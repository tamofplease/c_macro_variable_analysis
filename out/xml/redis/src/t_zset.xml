<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/t_zset.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * Copyright (c) 2009-2012, Pieter Noordhuis &lt;pcnoordhuis at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<comment type="block">/*-----------------------------------------------------------------------------
 * Sorted set API
 *----------------------------------------------------------------------------*/</comment>

<comment type="block">/* ZSETs are ordered sets using two data structures to hold the same elements
 * in order to get O(log(N)) INSERT and REMOVE operations into a sorted
 * data structure.
 *
 * The elements are added to a hash table mapping Redis objects to scores.
 * At the same time the elements are added to a skip list mapping scores
 * to Redis objects (so objects are sorted by scores in this "view").
 *
 * Note that the SDS string representing the element is the same in both
 * the hash table and skiplist in order to save memory. What we do in order
 * to manage the shared SDS string more easily is to free the SDS string
 * only in zslFreeNode(). The dictionary has no value free method set.
 * So we should always remove an element from the dictionary, and later from
 * the skiplist.
 *
 * This skiplist implementation is almost a C translation of the original
 * algorithm described by William Pugh in "Skip Lists: A Probabilistic
 * Alternative to Balanced Trees", modified in three ways:
 * a) this implementation allows for repeated scores.
 * b) the comparison is not just by key (our 'score') but by satellite data.
 * c) there is a back pointer, so it's a doubly linked list with the back
 * pointers being only at "level 1". This allows to traverse the list
 * from tail to head, useful for ZREVRANGE. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bzero</name><parameter_list>(<parameter><type><name>b</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memset((b), '\0', (len)), (void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*-----------------------------------------------------------------------------
 * Skiplist implementation of the low level API
 *----------------------------------------------------------------------------*/</comment>

<function_decl><type><name>int</name></type> <name>zslLexValueGteMin</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>zslLexValueLteMax</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Create a skiplist node with the specified number of levels.
 * The SDS string 'ele' is referenced by the node after the call. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslCreateNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name> <init>=
        <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zn</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>level</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>zskiplistLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>ele</name></expr>;</expr_stmt>
    <return>return <expr><name>zn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new skiplist. */</comment>
<function><type><name>zskiplist</name> <modifier>*</modifier></type><name>zslCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>zsl</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zsl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <call><name>zslCreateNode</name><argument_list>(<argument><expr><name>ZSKIPLIST_MAXLEVEL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ZSKIPLIST_MAXLEVEL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>zsl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free the specified skiplist node. The referenced SDS string representation
 * of the element is freed too, unless node-&gt;ele is set to NULL before calling
 * this function. */</comment>
<function><type><name>void</name></type> <name>zslFreeNode</name><parameter_list>(<parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a whole skiplist. */</comment>
<function><type><name>void</name></type> <name>zslFree</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns a random level for the new skiplist node we are going to create.
 * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
 * (both inclusive), with a powerlaw-alike distribution where higher
 * levels are less likely to be returned. */</comment>
<function><type><name>int</name></type> <name>zslRandomLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><call><name>random</name><argument_list>()</argument_list></call><operator>&amp;</operator><literal type="number">0xFFFF</literal><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>ZSKIPLIST_P</name> <operator>*</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>level</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>level</name><operator>&lt;</operator><name>ZSKIPLIST_MAXLEVEL</name><operator>)</operator></expr> ?</condition><then> <expr><name>level</name></expr> </then><else>: <expr><name>ZSKIPLIST_MAXLEVEL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a new node in the skiplist. Assumes the element does not already
 * exist (up to the caller to enforce that). The skiplist takes ownership
 * of the passed SDS string 'ele'. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslInsert</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>rank</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>level</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* store rank that is crossed to reach the insert position */</comment>
        <expr_stmt><expr><name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>rank</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>score</name> <operator>||</operator>
                    <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator>
                    <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside or not. */</comment>
    <expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>zslRandomLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>zslCreateNode</name><argument_list>(<argument><expr><name>level</name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

        <comment type="block">/* update span covered by update[i] as x is inserted here */</comment>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>-</operator> <operator>(</operator><name><name>rank</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <operator>(</operator><name><name>rank</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* increment span for untouched levels */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>level</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>update</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>update</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</comment>
<function><type><name>void</name></type> <name>zslDeleteNode</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>update</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>==</operator> <name>x</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <while>while<condition>(<expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>forward</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Delete an element with matching score/element from the skiplist.
 * The function returns 1 if the node was found and deleted, otherwise
 * 0 is returned.
 *
 * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise
 * it is not freed (but just unlinked) and *node is set to the node pointer,
 * so that it is possible for the caller to reuse the node (including the
 * referenced SDS string at node-&gt;ele). */</comment>
<function><type><name>int</name></type> <name>zslDelete</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>score</name> <operator>||</operator>
                    <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator>
                     <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>score</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>&amp;&amp;</operator> <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* not found */</comment>
</block_content>}</block></function>

<comment type="block">/* Update the score of an elmenent inside the sorted set skiplist.
 * Note that the element must exist and must match 'score'.
 * This function does not update the score in the hash table side, the
 * caller should take care of it.
 *
 * Note that this function attempts to just update the node, in case after
 * the score update, the node would be exactly at the same position.
 * Otherwise the skiplist is modified by removing and re-adding a new
 * element, which is more costly.
 *
 * The function returns the updated element skiplist node pointer. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslUpdateScore</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>curscore</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>newscore</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* We need to seek to element to update to start: this is useful anyway,
     * we'll have to update or remove it. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>curscore</name> <operator>||</operator>
                    <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>curscore</name> <operator>&amp;&amp;</operator>
                     <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Jump to our element: note that this function assumes that the
     * element with the matching score exists. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>&amp;&amp;</operator> <name>curscore</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>&amp;&amp;</operator> <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the node, after the score update, would be still exactly
     * at the same position, we can just update the score without
     * actually removing and re-inserting the element in the skiplist. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>backward</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>x</name><operator>-&gt;</operator><name>backward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>newscore</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&gt;</operator> <name>newscore</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>newscore</name></expr>;</expr_stmt>
        <return>return <expr><name>x</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No way to reuse the old node: we need to remove and insert a new
     * one at a different place. */</comment>
    <expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>zslInsert</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>newscore</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* We reused the old node x-&gt;ele SDS string, free the node now
     * since zslInsert created a new one. */</comment>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>newnode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zslValueGteMin</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>value</name> <operator>&gt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>min</name></name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>value</name> <operator>&gt;=</operator> <name><name>spec</name><operator>-&gt;</operator><name>min</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zslValueLteMax</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>max</name></name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>value</name> <operator>&lt;=</operator> <name><name>spec</name><operator>-&gt;</operator><name>max</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns if there is a part of the zset is in range. */</comment>
<function><type><name>int</name></type> <name>zslIsInRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>

    <comment type="block">/* Test for ranges that will always be empty. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>||</operator>
            <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the first node that is contained in the specified range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslFirstInRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Go forward while *OUT* of range. */</comment>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></for>

    <comment type="block">/* This is an inner range, so the next node cannot be NULL. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if score &lt;= max. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the last node that is contained in the specified range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslLastInRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Go forward while *IN* range. */</comment>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
            <call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></for>

    <comment type="block">/* This is an inner range, so this node cannot be NULL. */</comment>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if score &gt;= min. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete all the elements with score between min and max from the skiplist.
 * Min and max are inclusive, so a score &gt;= min || score &lt;= max is deleted.
 * Note that this function takes the reference to the hash table view of the
 * sorted set, in order to remove the elements from the hash table too. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>zslDeleteRangeByScore</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>range</name><operator>-&gt;</operator><name>minex</name></name></expr> ?</condition><then>
            <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;=</operator> <name><name>range</name><operator>-&gt;</operator><name>min</name></name></expr> </then><else>:
            <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name><name>range</name><operator>-&gt;</operator><name>min</name></name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Current node is the last with score &lt; or &lt;= min. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>

    <comment type="block">/* Delete nodes while in range. */</comment>
    <while>while <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator>
           <operator>(</operator><ternary><condition><expr><name><name>range</name><operator>-&gt;</operator><name>maxex</name></name></expr> ?</condition><then> <expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name></expr> </then><else>: <expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;=</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name></expr></else></ternary><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Here is where x-&gt;ele is actually released. */</comment>
        <expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PORT_ULONG</name></type> <name>zslDeleteRangeByLex</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Current node is the last with score &lt; or &lt;= min. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>

    <comment type="block">/* Delete nodes while in range. */</comment>
    <while>while <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Here is where x-&gt;ele is actually released. */</comment>
        <expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete all the elements with rank between start and end from the skiplist.
 * Start and end are inclusive. Note that start and end need to be 1-based */</comment>
<function><type><name>PORT_ULONG</name></type> <name>zslDeleteRangeByRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>traversed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>traversed</name> <operator>+</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name><operator>)</operator> <operator>&lt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>traversed</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>traversed</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>traversed</name> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>traversed</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the rank for an element by both score and key.
 * Returns 0 when the element cannot be found, rank otherwise.
 * Note that the rank is 1-based due to the span of zsl-&gt;header to the
 * first element. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>zslGetRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>rank</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>score</name> <operator>||</operator>
                <operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator>
                <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>rank</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name> <operator>&amp;&amp;</operator> <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>rank</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Finds an element by its rank. The rank argument needs to be 1-based. */</comment>
<function><type><name>zskiplistNode</name><modifier>*</modifier></type> <name>zslGetElementByRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name></type> <name>rank</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>traversed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>traversed</name> <operator>+</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name><operator>)</operator> <operator>&lt;=</operator> <name>rank</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>traversed</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>traversed</name> <operator>==</operator> <name>rank</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>x</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Populate the rangespec according to the objects min and max. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zslParseRange</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Parse the min-max interval. If one of the values is prefixed
     * by the "(" character, it's considered "open". For instance
     * ZRANGEBYSCORE zset (1.5 (2.5 will match min &lt; x &lt; max
     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min &lt;= x &lt;= max */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>min</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>max</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------ Lexicographic ranges ---------------------------- */</comment>

<comment type="block">/* Parse max or min argument of ZRANGEBYLEX.
  * (foo means foo (open interval)
  * [foo means foo (closed interval)
  * - means the min string possible
  * + means the max string possible
  *
  * If the string is valid the *dest pointer is set to the redis object
  * that will be used for the comparison, and ex will be set to 0 or 1
  * respectively if the item is exclusive or inclusive. C_OK will be
  * returned.
  *
  * If the string is not a valid range C_ERR is returned, and the value
  * of *dest and *ex is undefined. */</comment>
<function><type><name>int</name></type> <name>zslParseLexRangeItem</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>sds</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'+'</literal></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    <case>case <expr><literal type="char">'('</literal></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    <case>case <expr><literal type="char">'['</literal></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    <default>default:</default>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Free a lex range structure, must be called only after zelParseLexRange()
 * populated the structure with success (C_OK returned). */</comment>
<function><type><name>void</name></type> <name>zslFreeLexRange</name><parameter_list>(<parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name> <operator>&amp;&amp;</operator>
        <name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name> <operator>&amp;&amp;</operator>
        <name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Populate the lex rangespec according to the objects min and max.
 *
 * Return C_OK on success. On error C_ERR is returned.
 * When OK is returned the structure must be freed with zslFreeLexRange(),
 * otherwise no release is needed. */</comment>
<function><type><name>int</name></type> <name>zslParseLexRange</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* The range can't be valid if objects are integer encoded.
     * Every item must start with ( or [. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>min</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name> <operator>||</operator>
        <name><name>max</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>zslParseLexRangeItem</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name> <operator>||</operator>
        <call><name>zslParseLexRangeItem</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>C_OK</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This is just a wrapper to sdscmp() that is able to
 * handle shared.minstring and shared.maxstring as the equivalent of
 * -inf and +inf for strings */</comment>
<function><type><name>int</name></type> <name>sdscmplex</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name> <operator>||</operator> <name>b</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name> <operator>||</operator> <name>b</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>sdscmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zslLexValueGteMin</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name></expr> ?</condition><then>
        <expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>:
        <expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zslLexValueLteMax</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name></expr> ?</condition><then>
        <expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>:
        <expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns if there is a part of the zset is in the lex range. */</comment>
<function><type><name>int</name></type> <name>zslIsInLexRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>

    <comment type="block">/* Test for ranges that will always be empty. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>sdscmplex</name><argument_list>(<argument><expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name></expr></argument>,<argument><expr><name><name>range</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the first node that is contained in the specified lex range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslFirstInLexRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Go forward while *OUT* of range. */</comment>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></for>

    <comment type="block">/* This is an inner range, so the next node cannot be NULL. */</comment>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if score &lt;= max. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the last node that is contained in the specified range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslLastInLexRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Go forward while *IN* range. */</comment>
        <while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
            <call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></for>

    <comment type="block">/* This is an inner range, so this node cannot be NULL. */</comment>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if score &gt;= min. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Ziplist-backed sorted set API
 *----------------------------------------------------------------------------*/</comment>

<function><type><name>double</name></type> <name>zzlGetScore</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>vlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>vlong</name></expr>;</expr_stmt>                                                  <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (double) */</comment>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a ziplist element as an SDS string. */</comment>
<function><type><name>sds</name></type> <name>ziplistGetObject</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Compare element in sorted set with given element. */</comment>
<function><type><name>int</name></type> <name>zzlCompareElements</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>vbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>minlen</name></decl>, <decl><type ref="prev"/><name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Store string representation of long long in buf. */</comment>
        <expr_stmt><expr><name>vlen</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vbuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vstr</name> <operator>=</operator> <name>vbuf</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>minlen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vlen</name> <operator>&lt;</operator> <name>clen</name><operator>)</operator></expr> ?</condition><then> <expr><name>vlen</name></expr> </then><else>: <expr><name>clen</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>cstr</name></expr></argument>,<argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>vlen</name><operator>-</operator><name>clen</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name>zzlLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Move to next entry based on the values in eptr and sptr. Both are set to
 * NULL when there is no next entry. */</comment>
<function><type><name>void</name></type> <name>zzlNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>l_eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l_sptr</name></decl>;</decl_stmt>                                             <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* compiler error: _sptr -&gt; l_sptr */</comment>
    <name>serverAssert</name><argument_list>(<argument><expr><operator>*</operator><name>eptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><name>l_eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>*</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>l_eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>l_sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>l_eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>l_sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* No next entry. */</comment>
        <expr_stmt><expr><name>l_sptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>eptr</name> <operator>=</operator> <name>l_eptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>sptr</name> <operator>=</operator> <name>l_sptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Move to the previous entry based on the values in eptr and sptr. Both are
 * set to NULL when there is no next entry. */</comment>
<function><type><name>void</name></type> <name>zzlPrev</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>l_eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l_sptr</name></decl>;</decl_stmt>                                             <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* compiler error: _sptr -&gt; l_sptr */</comment>
    <name>serverAssert</name><argument_list>(<argument><expr><operator>*</operator><name>eptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><name>l_sptr</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>*</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>l_sptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>l_eptr</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>l_sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>l_eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* No previous entry. */</comment>
        <expr_stmt><expr><name>l_eptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>eptr</name> <operator>=</operator> <name>l_eptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>sptr</name> <operator>=</operator> <name>l_sptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns if there is a part of the zset is in range. Should only be used
 * internally by zzlFirstInRange and zzlLastInRange. */</comment>
<function><type><name>int</name></type> <name>zzlIsInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

    <comment type="block">/* Test for ranges that will always be empty. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>||</operator>
            <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Last score. */</comment>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Empty sorted set */</comment>
    <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* First score. */</comment>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find pointer to the first element contained in the specified range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFirstInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Check if score &lt;= max. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move to next element. */</comment>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find pointer to the last element contained in the specified range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlLastInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Check if score &gt;= min. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */</comment>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zzlLexValueGteMin</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>value</name> <init>= <expr><call><name>ziplistGetObject</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zzlLexValueLteMax</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>value</name> <init>= <expr><call><name>ziplistGetObject</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns if there is a part of the zset is in range. Should only be used
 * internally by zzlFirstInRange and zzlLastInRange. */</comment>
<function><type><name>int</name></type> <name>zzlIsInLexRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* Test for ranges that will always be empty. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>sdscmplex</name><argument_list>(<argument><expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name></expr></argument>,<argument><expr><name><name>range</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Last element. */</comment>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* First element. */</comment>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find pointer to the first element contained in the specified lex range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFirstInLexRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Check if score &lt;= max. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move to next element. */</comment>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* This element score. Skip it. */</comment>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Next element. */</comment>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find pointer to the last element contained in the specified lex range.
 * Returns NULL when no element is contained in the range. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlLastInLexRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

    <comment type="block">/* If everything is out of range, return early. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Check if score &gt;= min. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */</comment>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>     <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* unsigned int */</comment>
            <comment type="block">/* Matching element, pull out score. */</comment>
            <if_stmt><if>if <condition>(<expr><name>score</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>eptr</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move to next element. */</comment>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete (element,score) pair from ziplist. Use local copy of eptr because we
 * don't want to modify the one given as argument. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDelete</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>eptr</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* TODO: add function to ziplist API to delete N elements from offset. */</comment>
    <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlInsertAt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>scorebuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scorelen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scorelen</name> <operator>=</operator> <call><name>d2string</name><argument_list>(<argument><expr><name>scorebuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>scorebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* unsigned int */</comment>
        <name>zl</name> <init>= <expr><call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>scorebuf</name></expr></argument>,<argument><expr><name>scorelen</name></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Keep offset relative to zl, as it might be re-allocated. */</comment>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>eptr</name><operator>-</operator><name>zl</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* unsigned int */</comment>
        <name>eptr</name> <init>= <expr><name>zl</name><operator>+</operator><name>offset</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Insert score after the element. */</comment>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>scorebuf</name></expr></argument>,<argument><expr><name>scorelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert (element,score) pair in ziplist. This function assumes the element is
 * not yet present in the list. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlInsert</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* First element with score larger than score for element to be
             * inserted. This means we should take its spot in the list to
             * maintain ordering. */</comment>
            <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>score</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Ensure lexicographical ordering for elements. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>zzlCompareElements</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* unsigned int */</comment>
                <name>zl</name> <init>= <expr><call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move to next element. */</comment>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Push on tail of list when it was not yet inserted. */</comment>
    <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDeleteRangeByScore</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>zl</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* When the tail of the ziplist is deleted, eptr will point to the sentinel
     * byte and ziplistNext will return NULL. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Delete both the element and the score. */</comment>
            <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* No longer in range. */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDeleteRangeByLex</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>zl</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* When the tail of the ziplist is deleted, eptr will point to the sentinel
     * byte and ziplistNext will return NULL. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Delete both the element and the score. */</comment>
            <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* No longer in range. */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete all the elements with rank between start and end from the skiplist.
 * Start and end are inclusive. Note that start and end need to be 1-based */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDeleteRangeByRank</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name> <init>= <expr><operator>(</operator><name>end</name><operator>-</operator><name>start</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>start</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Common sorted set API
 *----------------------------------------------------------------------------*/</comment>

<function><type><name>PORT_ULONG</name></type> <name>zsetLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>zzlLength</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>zset</name><operator>*</operator><operator>)</operator><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>                         <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (PORT_ULONG) */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zsetConvert</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>encoding</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>!=</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown target encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>zs</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zsetDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name> <operator>=</operator> <call><name>zslCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>zs</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>!=</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown target encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Approach similar to zslFree(), since we want to free the skiplist at
         * the same time as creating the ziplist. */</comment>
        <expr_stmt><expr><name>zs</name> <operator>=</operator> <name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Convert the sorted set object into a ziplist if it is not already a ziplist
 * and if the number of elements and the maximum element size is within the
 * expected ranges. */</comment>
<function><type><name>void</name></type> <name>zsetConvertToZiplistIfNeeded</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxelelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zset</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zset</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>zset_max_ziplist_entries</name></name> <operator>&amp;&amp;</operator>
        <name>maxelelen</name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>zset_max_ziplist_value</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>zsetConvert</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ENCODING_ZIPLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return (by reference) the score of the specified member of the sorted set
 * storing it into *score. If the element does not exist C_ERR is returned
 * otherwise C_OK is returned and *score is correctly populated.
 * If 'zobj' or 'member' is NULL, C_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>zsetScore</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>member</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name> <operator>||</operator> <operator>!</operator><name>member</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zzlFind</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name>member</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new element or update the score of an existing element in a sorted
 * set, regardless of its encoding.
 *
 * The set of flags change the command behavior. They are passed with an integer
 * pointer since the function will clear the flags and populate them with
 * other flags to indicate different conditions.
 *
 * The input flags are the following:
 *
 * ZADD_INCR: Increment the current element score by 'score' instead of updating
 *            the current element score. If the element does not exist, we
 *            assume 0 as previous score.
 * ZADD_NX:   Perform the operation only if the element does not exist.
 * ZADD_XX:   Perform the operation only if the element already exist.
 *
 * When ZADD_INCR is used, the new score of the element is stored in
 * '*newscore' if 'newscore' is not NULL.
 *
 * The returned flags are the following:
 *
 * ZADD_NAN:     The resulting score is not a number.
 * ZADD_ADDED:   The element was added (not present before the call).
 * ZADD_UPDATED: The element score was updated.
 * ZADD_NOP:     No operation was performed because of NX or XX.
 *
 * Return value:
 *
 * The function returns 1 on success, and sets the appropriate flags
 * ADDED or UPDATED to signal what happened during the operation (note that
 * none could be set if we re-added an element using the same score it used
 * to have, or in the case a zero increment is used).
 *
 * The function returns 0 on erorr, currently only when the increment
 * produces a NAN condition, or when the 'score' value is NAN since the
 * start.
 *
 * The commad as a side effect of adding a new element may convert the sorted
 * set internal encoding from ziplist to hashtable+skiplist.
 *
 * Memory managemnet of 'ele':
 *
 * The function does not take ownership of the 'ele' SDS string, but copies
 * it if needed. */</comment>
<function><type><name>int</name></type> <name>zsetAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newscore</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Turn options into simple to check vars. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_INCR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_NX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>xx</name> <init>= <expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_XX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* We'll return our response flags. */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>curscore</name></decl>;</decl_stmt>

    <comment type="block">/* NaN as input is an error regardless of all the other parameters. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>ZADD_NAN</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update the sorted set according to its encoding. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>zzlFind</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>curscore</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* NX? Return, same element already exists. */</comment>
            <if_stmt><if>if <condition>(<expr><name>nx</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_NOP</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Prepare the score for the increment if needed. */</comment>
            <if_stmt><if>if <condition>(<expr><name>incr</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>score</name> <operator>+=</operator> <name>curscore</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_NAN</name></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Remove and re-insert when score changed. */</comment>
            <if_stmt><if>if <condition>(<expr><name>score</name> <operator>!=</operator> <name>curscore</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDelete</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlInsert</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_UPDATED</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>xx</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Optimize: check if the element is too large or the list
             * becomes too long *before* executing zzlInsert. */</comment>
            <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlInsert</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>zzlLength</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>zset_max_ziplist_entries</name></name> <operator>||</operator>
                <call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>zset_max_ziplist_value</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>zsetConvert</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ENCODING_SKIPLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_ADDED</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_NOP</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* NX? Return, same element already exists. */</comment>
            <if_stmt><if>if <condition>(<expr><name>nx</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_NOP</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>curscore</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Prepare the score for the increment if needed. */</comment>
            <if_stmt><if>if <condition>(<expr><name>incr</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>score</name> <operator>+=</operator> <name>curscore</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_NAN</name></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Remove and re-insert when score changes. */</comment>
            <if_stmt><if>if <condition>(<expr><name>score</name> <operator>!=</operator> <name>curscore</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslUpdateScore</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>curscore</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Note that we did not removed the original element from
                 * the hash table representing the sorted set, so we just
                 * update the score. */</comment>
                <expr_stmt><expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt> <comment type="block">/* Update score ptr. */</comment>
                <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_UPDATED</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>xx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_ADDED</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>ZADD_NOP</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Never reached. */</comment>
</block_content>}</block></function>

<comment type="block">/* Delete the element 'ele' from the sorted set, returning 1 if the element
 * existed and was deleted, 0 otherwise (the element was not there). */</comment>
<function><type><name>int</name></type> <name>zsetDel</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>zzlFind</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDelete</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictUnlink</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Get the score in order to delete from the skiplist later. */</comment>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Delete from the hash table and later from the skiplist.
             * Note that the order is important: deleting from the skiplist
             * actually releases the SDS string representing the element,
             * which is shared between the skiplist and the hash table, so
             * we need to delete from the skiplist as the final step. */</comment>
            <expr_stmt><expr><call><name>dictFreeUnlinkedEntry</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Delete from skiplist. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>zslDelete</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>htNeedsResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* No such element found. */</comment>
</block_content>}</block></function>

<comment type="block">/* Given a sorted set object returns the 0-based rank of the object or
 * -1 if the object does not exist.
 *
 * For rank we mean the position of the element in the sorted collection
 * of elements. So the first element has rank 0, the second rank 1, and so
 * forth up to length-1 elements.
 *
 * If 'reverse' is false, the rank is returned considering as first element
 * the one with the lowest score. Otherwise if 'reverse' is non-zero
 * the rank is computed considering as element with rank 0 the one with
 * the highest score. */</comment>
<function><type><name>PORT_LONG</name></type> <name>zsetRank</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>llen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>rank</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rank</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>rank</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>llen</name><operator>-</operator><name>rank</name></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>rank</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Existing elements always have a rank. */</comment>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>rank</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>llen</name><operator>-</operator><name>rank</name></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>rank</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Sorted set commands
 *----------------------------------------------------------------------------*/</comment>

<comment type="block">/* This generic command implements both ZADD and ZINCRBY. */</comment>
<function><type><name>void</name></type> <name>zaddGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>nanerr</name> <init>= <expr><literal type="string">"resulting score is not a number (NaN)"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>scores</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>elements</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scoreidx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* The following vars are used in order to track what the command actually
     * did during the execution, to reply to the client and to trigger the
     * notification of keyspace change. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Number of new elements added. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>updated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of elements with updated score. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of elements processed, may remain zero with
                           options like XX. */</comment>

    <comment type="block">/* Parse options. At the end 'scoreidx' is set to the argument position
     * of the score of the first score-element pair. */</comment>
    <expr_stmt><expr><name>scoreidx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>scoreidx</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"nx"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_NX</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"xx"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_XX</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"ch"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_CH</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"incr"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_INCR</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>scoreidx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Turn options into simple to check vars. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_INCR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_NX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>xx</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_XX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_CH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* After the options, we expect to have an even number of args, since
     * we expect any number of score-element pairs. */</comment>
    <expr_stmt><expr><name>elements</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>scoreidx</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>elements</name> <operator>%</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><name>elements</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>elements</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* Now this holds the number of score-element pairs. */</comment>

    <comment type="block">/* Check for incompatible options. */</comment>
    <if_stmt><if>if <condition>(<expr><name>nx</name> <operator>&amp;&amp;</operator> <name>xx</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><literal type="string">"XX and NX options at the same time are not compatible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>incr</name> <operator>&amp;&amp;</operator> <name>elements</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><literal type="string">"INCR option supports a single increment-element pair"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Start parsing all the scores, we need to emit any syntax error
     * before executing additions to the sorted set, as the command should
     * either execute fully or nothing at all. */</comment>
    <expr_stmt><expr><name>scores</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>elements</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name><operator>+</operator><name>j</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
            <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Lookup the key and create the sorted set if does not exist. */</comment>
    <expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>xx</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>reply_to_client</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* No key + XX option: nothing to do. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>zset_max_ziplist_entries</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <name><name>server</name><operator>.</operator><name>zset_max_ziplist_value</name></name> <operator>&lt;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createZsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createZsetZiplistObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>elements</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>newscore</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>retflags</name> <init>= <expr><name>flags</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>ele</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>j</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>zsetAdd</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>score</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newscore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>nanerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>retflags</name> <operator>&amp;</operator> <name>ZADD_ADDED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>added</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>retflags</name> <operator>&amp;</operator> <name>ZADD_UPDATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>retflags</name> <operator>&amp;</operator> <name>ZADD_NOP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <name>newscore</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <operator>(</operator><name>added</name><operator>+</operator><name>updated</name><operator>)</operator></expr>;</expr_stmt>

<label><name>reply_to_client</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>incr</name></expr>)</condition> <block>{<block_content> <comment type="block">/* ZINCRBY or INCR option. */</comment>
        <if_stmt><if>if <condition>(<expr><name>processed</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* ZADD. */</comment>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>ch</name></expr> ?</condition><then> <expr><name>added</name><operator>+</operator><name>updated</name></expr> </then><else>: <expr><name>added</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>scores</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>added</name> <operator>||</operator> <name>updated</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>incr</name></expr> ?</condition><then> <expr><literal type="string">"zincr"</literal></expr> </then><else>: <expr><literal type="string">"zadd"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zaddGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZADD_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zincrbyCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zaddGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZADD_INCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zremCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>keyremoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zsetDel</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><literal type="string">"zrem"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyremoved</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZRANGE_RANK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZRANGE_SCORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZRANGE_LEX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>zremrangeGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangetype</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keyremoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zlexrangespec</name></type> <name>lexrange</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>llen</name></decl>;</decl_stmt>

    <comment type="block">/* Step 1: Parse the range. */</comment>
    <if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_RANK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_SCORE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zslParseRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max is not a float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_LEX</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max not valid string range item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Step 2: Lookup &amp; range sanity checks if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_RANK</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Sanitize indexes. */</comment>
        <expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.
         * The range is empty when start &gt; end or start &gt;= length. */</comment>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name>start</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Step 3: Perform the range deletion operation. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <switch>switch<condition>(<expr><name>rangetype</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZRANGE_RANK</name></expr>:</case>
            <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDeleteRangeByRank</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>end</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int), cast (int) */</comment>
            <break>break;</break>
        <case>case <expr><name>ZRANGE_SCORE</name></expr>:</case>
            <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDeleteRangeByScore</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ZRANGE_LEX</name></expr>:</case>
            <expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDeleteRangeByLex</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><call><name>zzlLength</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name>rangetype</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ZRANGE_RANK</name></expr>:</case>
            <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>zslDeleteRangeByRank</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>end</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int), cast (int) */</comment>
            <break>break;</break>
        <case>case <expr><name>ZRANGE_SCORE</name></expr>:</case>
            <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>zslDeleteRangeByScore</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>,<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ZRANGE_LEX</name></expr>:</case>
            <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>zslDeleteRangeByLex</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>,<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><call><name>htNeedsResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Step 4: Notifications and reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>event</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"zremrangebyrank"</literal></expr>,<expr><literal type="string">"zremrangebyscore"</literal></expr>,<expr><literal type="string">"zremrangebylex"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><name><name>event</name><index>[<expr><name>rangetype</name></expr>]</index></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyremoved</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_LEX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zremrangebyrankCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zremrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZRANGE_RANK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zremrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zremrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZRANGE_SCORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zremrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zremrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZRANGE_LEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>subject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt> <comment type="block">/* Set, sorted set */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>weight</name></decl>;</decl_stmt>

    <union>union <block>{
        <comment type="block">/* Set iterators. */</comment>
        <union>union <name>_iterset</name> <block>{
            <struct>struct <block>{
                <decl_stmt><decl><type><name>intset</name> <modifier>*</modifier></type><name>is</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
            }</block> <decl><name>is</name></decl>;</struct>
            <struct>struct <block>{
                <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
            }</block> <decl><name>ht</name></decl>;</struct>
        }</block> <decl><name>set</name></decl>;</union>

        <comment type="block">/* Sorted set iterators. */</comment>
        <union>union <name>_iterzset</name> <block>{
            <struct>struct <block>{
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <modifier>*</modifier><name>sptr</name>;</decl_stmt>
            }</block> <decl><name>zl</name></decl>;</struct>
            <struct>struct <block>{
                <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
            }</block> <decl><name>sl</name></decl>;</struct>
        }</block> <decl><name>zset</name></decl>;</union>
    }</block> <decl><name>iter</name></decl>;</union>
}</block></struct></type> <name>zsetopsrc</name>;</typedef>


<comment type="block">/* Use dirty flags for pointers that need to be cleaned up in the next
 * iteration over the zsetopval. The dirty flag for the long long value is
 * special, since long long values don't need cleanup. Instead, it means that
 * we already checked that "ell" holds a long long, or tried to convert another
 * representation into a long long value. When this was successful,
 * OPVAL_VALID_LL is set as well. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPVAL_DIRTY_SDS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPVAL_DIRTY_LL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPVAL_VALID_LL</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/* Store value retrieved from the iterator. */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>_buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Private buffer. */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>estr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>elen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
}</block></struct></type> <name>zsetopval</name>;</typedef>

<typedef>typedef <type><name><name>union</name> <name>_iterset</name></name></type> <name>iterset</name>;</typedef>
<typedef>typedef <type><name><name>union</name> <name>_iterzset</name></name></type> <name>iterzset</name>;</typedef>

<function><type><name>void</name></type> <name>zuiInitIterator</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>iterset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>is</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>ii</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>dict</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>iterzset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>zset</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>zs</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zuiClearIterator</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>iterset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>iterzset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>zset</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>PORT_ULONG</name></type> <name>zuiLength</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>intsetLen</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>dictSize</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>zzlLength</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if the current value is valid. If so, store it in the passed structure
 * and move to the next element. If not valid, this means we have reached the
 * end of the structure and can abort. */</comment>
<function><type><name>int</name></type> <name>zuiNext</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_DIRTY_SDS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>iterset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>ell</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>intsetGet</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>is</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>ii</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ell</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name> <operator>=</operator> <name>ell</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

            <comment type="block">/* Move to next element. */</comment>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>ii</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

            <comment type="block">/* Move to next element. */</comment>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>iterzset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>zset</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* No need to check both, but better be explicit. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Move to next element. */</comment>
            <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt>

            <comment type="block">/* Move to next element. */</comment>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zuiLongLongFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_DIRTY_LL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_DIRTY_LL</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_VALID_LL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_VALID_LL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* The long long was already set, flag as valid. */</comment>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_VALID_LL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_VALID_LL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>sds</name></type> <name>zuiSdsFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_DIRTY_SDS</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is different from zuiSdsFromValue since returns a new SDS string
 * which is up to the caller to free. */</comment>
<function><type><name>sds</name></type> <name>zuiNewSdsFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_DIRTY_SDS</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We have already one to return! */</comment>
        <decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>OPVAL_DIRTY_SDS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><name>ele</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>sdsdup</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zuiBufferFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>_buf</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>_buf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>_buf</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find value pointed to by val in the source pointer to by op. When found,
 * return 1 and store its score in target. Return 0 otherwise. */</comment>
<function><type><name>int</name></type> <name>zuiFind</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>zuiLongLongFromValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>intsetFind</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>dictFind</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>zzlFind</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Score is already set by zzlFind. */</comment>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>zuiCompareByCardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>first</name> <init>= <expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>(</operator><name>zsetopsrc</name><operator>*</operator><operator>)</operator><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>second</name> <init>= <expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>(</operator><name>zsetopsrc</name><operator>*</operator><operator>)</operator><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>first</name> <operator>&gt;</operator> <name>second</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>first</name> <operator>&lt;</operator> <name>second</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_AGGR_SUM</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_AGGR_MIN</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_AGGR_MAX</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zunionInterDictValue</name><parameter_list>(<parameter><type><name>_e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))</cpp:value></cpp:define>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type> <name>zunionInterAggregate</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>aggregate</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>aggregate</name> <operator>==</operator> <name>REDIS_AGGR_SUM</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <operator>*</operator><name>target</name> <operator>+</operator> <name>val</name></expr>;</expr_stmt>
        <comment type="block">/* The result of adding two doubles is NaN when one variable
         * is +inf and the other is -inf. When these numbers are added,
         * we maintain the convention of the result being 0.0. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>aggregate</name> <operator>==</operator> <name>REDIS_AGGR_MIN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>&lt;</operator> <operator>*</operator><name>target</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><operator>*</operator><name>target</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>aggregate</name> <operator>==</operator> <name>REDIS_AGGR_MAX</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>&gt;</operator> <operator>*</operator><name>target</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><operator>*</operator><name>target</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* safety net */</comment>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown ZUNION/INTER aggregate type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><name>uint64_t</name></type> <name>dictSdsHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>dictSdsKeyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>dictType</name></type> <name>setAccumulatorDictType</name> <init>= <expr><block>{
    <expr><name>dictSdsHash</name></expr>,               <comment type="block">/* hash function */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key dup */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* val dup */</comment>
    <expr><name>dictSdsKeyCompare</name></expr>,         <comment type="block">/* key compare */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key destructor */</comment>
    <expr><name>NULL</name></expr>                       <comment type="block">/* val destructor */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>zunionInterGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>setnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>aggregate</name> <init>= <expr><name>REDIS_AGGR_SUM</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zsetopval</name></type> <name>zval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>maxelelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>dstzset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>touched</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* expect setnum input keys to be given */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>setnum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>setnum</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><literal type="string">"at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* test if the expected number of keys would overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>setnum</name> <operator>&gt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* read keys to be used for input */</comment>
    <expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopsrc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>setnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>encoding</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Default all weights to 1. */</comment>
        <expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* parse optional extra arguments */</comment>
    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <operator>(</operator><name>setnum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"weights"</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>remaining</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr></argument>,
                            <argument><expr><literal type="string">"weight value is not a float"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"aggregate"</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>aggregate</name> <operator>=</operator> <name>REDIS_AGGR_SUM</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>aggregate</name> <operator>=</operator> <name>REDIS_AGGR_MIN</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>aggregate</name> <operator>=</operator> <name>REDIS_AGGR_MAX</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* sort sets from the smallest to largest, this will improve our
     * algorithm's performance */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>src</name></expr></argument>,<argument><expr><name>setnum</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopsrc</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zuiCompareByCardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dstobj</name> <operator>=</operator> <call><name>createZsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstzset</name> <operator>=</operator> <name><name>dstobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_INTER</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Skip everything if the smallest input is empty. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Precondition: as src[0] is non-empty and the inputs are ordered
             * by size, all src[i &gt; 0] are non-empty too. */</comment>
            <expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>weight</name> <operator>*</operator> <name><name>zval</name><operator>.</operator><name>score</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <comment type="block">/* It is not safe to access the zset we are
                     * iterating, so explicitly check for equal object. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>==</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>subject</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>zval</name><operator>.</operator><name>score</name></name><operator>*</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>zunionInterAggregate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>zuiFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>value</name> <operator>*=</operator> <name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>zunionInterAggregate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>

                <comment type="block">/* Only continue when present in every input. */</comment>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>setnum</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxelelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxelelen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_UNION</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>accumulator</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>setAccumulatorDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>existing</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>setnum</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Our union is at least as large as the largest set.
             * Resize the dictionary ASAP to avoid useless rehashing. */</comment>
            <expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>,<argument><expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>setnum</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Step 1: Create a dictionary of elements -&gt; aggregated-scores
         * by iterating one sorted set after the other. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Initialize value */</comment>
                <expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>*</operator> <name><name>zval</name><operator>.</operator><name>score</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Search for this element in the accumulating dictionary. */</comment>
                <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictAddRaw</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>,<argument><expr><call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* If we don't have it, we need to create a new entry. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>existing</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Remember the longest single element encountered,
                     * to understand if it's possible to convert to ziplist
                     * at the end. */</comment>
                     <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxelelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxelelen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="block">/* Update the element with its initial score. */</comment>
                    <expr_stmt><expr><call><name>dictSetKey</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>, <argument><expr><name>de</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>dictSetDoubleVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* Update the score with the score of the new instance
                     * of the element found in the current sorted set.
                     *
                     * Here we access directly the dictEntry double
                     * value inside the union as it is a big speedup
                     * compared to using the getDouble/setDouble API. */</comment>
                    <expr_stmt><expr><call><name>zunionInterAggregate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>existing</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>d</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Step 2: convert the dictionary into the final sorted set. */</comment>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We now are aware of the final size of the resulting sorted set,
         * let's resize the dictionary embedded inside the sorted set to the
         * right size, in order to save rehashing time. */</comment>
        <expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>dictGetDoubleVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown operator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>touched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zsetConvertToZiplistIfNeeded</name><argument_list>(<argument><expr><name>dstobj</name></expr></argument>,<argument><expr><name>maxelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name>dstobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>dstobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>SET_OP_UNION</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"zunionstore"</literal></expr> </then><else>: <expr><literal type="string">"zinterstore"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>dstobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>touched</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zunionstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zunionInterGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>SET_OP_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zinterstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zunionInterGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>SET_OP_INTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrangeGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>withscores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>llen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>rangelen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"withscores"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>withscores</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
         <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Sanitize indexes. */</comment>
    <expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.
     * The range is empty when start &gt; end or start &gt;= length. */</comment>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name>start</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rangelen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end</name><operator>-</operator><name>start</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>                                              <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>

    <comment type="block">/* Return the result in form of a multi-bulk reply */</comment>
    <name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name>withscores</name></expr> ?</condition><then> <expr><operator>(</operator><name>rangelen</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr> </then><else>: <expr><name>rangelen</name></expr></else></ternary></expr></argument>)</argument_list></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>start</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                        <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
        <if_stmt><else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>                             <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>

        <name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>rangelen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>

        <comment type="block">/* Check if starting point is trivial, before doing log(N) lookup. */</comment>
        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslGetElementByRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>llen</name><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslGetElementByRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <while>while<condition>(<expr><name>rangelen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ele</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <ternary><condition><expr><name>reverse</name></expr> ?</condition><then> <expr><name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr> </then><else>: <expr><name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrevrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */</comment>
<function><type><name>void</name></type> <name>genericZrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>limit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>withscores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>rangelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>replylen</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>minidx</name></decl>, <decl><type ref="prev"/><name>maxidx</name></decl>;</decl_stmt>

    <comment type="block">/* Parse the range arguments. */</comment>
    <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Range is given as [max,min] */</comment>
        <expr_stmt><expr><name>maxidx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>minidx</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Range is given as [min,max] */</comment>
        <expr_stmt><expr><name>minidx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>maxidx</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>zslParseRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>minidx</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>maxidx</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max is not a float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse optional extra arguments. Note that ZCOUNT will exactly have
     * 4 arguments, so we'll never enter the following code path. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"withscores"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>withscores</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                        <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                        <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Ok, lookup the key and get the range */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

        <comment type="block">/* If reversed, get the last node in range as starting point. */</comment>
        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlLastInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* No "first" element in the specified interval. */</comment>
        <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Get score pointer for the first element. */</comment>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We don't know in advance how many matching elements there are in the
         * list, so we push this object that will represent the multi-bulk
         * length in the output buffer, and will "fix" it later */</comment>
        <expr_stmt><expr><name>replylen</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */</comment>
        <while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* We know the element exists, so ziplistGet should always succeed */</comment>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Move to next node */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <comment type="block">/* If reversed, get the last node in range as starting point. */</comment>
        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslLastInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslFirstInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* No "first" element in the specified interval. */</comment>
        <if_stmt><if>if <condition>(<expr><name>ln</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* We don't know in advance how many matching elements there are in the
         * list, so we push this object that will represent the multi-bulk
         * length in the output buffer, and will "fix" it later */</comment>
        <expr_stmt><expr><name>replylen</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */</comment>
        <while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Move to next node */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rangelen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>replylen</name></expr></argument>, <argument><expr><name>rangelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>genericZrangebyscoreCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrevrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>genericZrangebyscoreCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zcountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Parse the range arguments */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>zslParseRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max is not a float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Lookup the sorted set */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

        <comment type="block">/* Use the first element in range as the starting point */</comment>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No "first" element */</comment>
        <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* First element is in range */</comment>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Iterate over elements in range */</comment>
        <while>while <condition>(<expr><name>eptr</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>rank</name></decl>;</decl_stmt>

        <comment type="block">/* Find first element in range */</comment>
        <expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>zslFirstInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Use rank of first element, if any, to determine preliminary count */</comment>
        <if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>rank</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>                            <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>

            <comment type="block">/* Find last element in range */</comment>
            <name>zn</name> <init>= <expr><call><name>zslLastInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Use rank of last element, if any, to determine the actual count */</comment>
            <if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>rank</name><operator>)</operator></expr>;</expr_stmt>                             <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zlexcountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>zlexrangespec</name></type> <name>range</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Parse the range arguments */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max not valid string range item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Lookup the sorted set */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

        <comment type="block">/* Use the first element in range as the starting point */</comment>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No "first" element */</comment>
        <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* First element is in range */</comment>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Iterate over elements in range */</comment>
        <while>while <condition>(<expr><name>eptr</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>rank</name></decl>;</decl_stmt>

        <comment type="block">/* Find first element in range */</comment>
        <expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>zslFirstInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Use rank of first element, if any, to determine preliminary count */</comment>
        <if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>rank</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>                            <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>

            <comment type="block">/* Find last element in range */</comment>
            <name>zn</name> <init>= <expr><call><name>zslLastInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Use rank of last element, if any, to determine the actual count */</comment>
            <if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>rank</name><operator>)</operator></expr>;</expr_stmt>                             <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This command implements ZRANGEBYLEX, ZREVRANGEBYLEX. */</comment>
<function><type><name>void</name></type> <name>genericZrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zlexrangespec</name></type> <name>range</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>limit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>rangelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>replylen</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>minidx</name></decl>, <decl><type ref="prev"/><name>maxidx</name></decl>;</decl_stmt>

    <comment type="block">/* Parse the range arguments. */</comment>
    <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Range is given as [max,min] */</comment>
        <expr_stmt><expr><name>maxidx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>minidx</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Range is given as [min,max] */</comment>
        <expr_stmt><expr><name>minidx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>maxidx</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>minidx</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>maxidx</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max not valid string range item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse optional extra arguments. Note that ZCOUNT will exactly have
     * 4 arguments, so we'll never enter the following code path. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Ok, lookup the key and get the range */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>

        <comment type="block">/* If reversed, get the last node in range as starting point. */</comment>
        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlLastInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* No "first" element in the specified interval. */</comment>
        <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Get score pointer for the first element. */</comment>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We don't know in advance how many matching elements there are in the
         * list, so we push this object that will represent the multi-bulk
         * length in the output buffer, and will "fix" it later */</comment>
        <expr_stmt><expr><name>replylen</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */</comment>
        <while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* We know the element exists, so ziplistGet should always
             * succeed. */</comment>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Move to next node */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <comment type="block">/* If reversed, get the last node in range as starting point. */</comment>
        <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslLastInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslFirstInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* No "first" element in the specified interval. */</comment>
        <if_stmt><if>if <condition>(<expr><name>ln</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* We don't know in advance how many matching elements there are in the
         * list, so we push this object that will represent the multi-bulk
         * length in the output buffer, and will "fix" it later */</comment>
        <expr_stmt><expr><name>replylen</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */</comment>
        <while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Move to next node */</comment>
            <if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>replylen</name></expr></argument>, <argument><expr><name>rangelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>genericZrangebylexCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrevrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>genericZrangebylexCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zcardCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrankGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>rank</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zsetRank</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rank</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>rank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrankCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zrankGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zrevrankCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zrankGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zscanCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>cursor</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>parseScanCursorOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptyscan</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>scanGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This command implements the generic zpop operation, used by:
 * ZPOPMIN, ZPOPMAX, BZPOPMIN and BZPOPMAX. This function is also used
 * inside blocked.c in the unblocking stage of BZPOPMIN and BZPOPMAX.
 *
 * If 'emitkey' is true also the key name is emitted, useful for the blocking
 * behavior of BZPOP[MIN|MAX], since we can block into multiple keys.
 *
 * The synchronous version instead does not need to emit the key, but may
 * use the 'count' argument to return multiple items if available. */</comment>
<function><type><name>void</name></type> <name>genericZpopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keyc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emitkey</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>countarg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If a count argument as passed, parse it or return an error. */</comment>
    <if_stmt><if>if <condition>(<expr><name>countarg</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>countarg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check type and break on the first error, otherwise identify candidate. */</comment>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>keyc</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>keyv</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <break>break;</break>
    </block_content>}</block></while>

    <comment type="block">/* No candidate for zpopping, return empty. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We emit the key only for the blocking variant. */</comment>
    <if_stmt><if>if <condition>(<expr><name>emitkey</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Remove the element. */</comment>
    <do>do <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>

            <comment type="block">/* Get the first or last element in the sorted set. */</comment>
            <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><ternary><condition><expr><name>where</name> <operator>==</operator> <name>ZSET_MAX</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Get the score. */</comment>
            <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zln</name></decl>;</decl_stmt>

            <comment type="block">/* Get the first or last element in the sorted set. */</comment>
            <expr_stmt><expr><name>zln</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>where</name> <operator>==</operator> <name>ZSET_MAX</name></expr> ?</condition><then> <expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr> </then><else>:
                                       <expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

            <comment type="block">/* There must be an element in the sorted set. */</comment>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>zln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name><name>zln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>zln</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>zsetDel</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>arraylen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* Do this only for the first iteration. */</comment>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>events</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"zpopmin"</literal></expr>,<expr><literal type="string">"zpopmax"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><name><name>events</name><index>[<expr><name>where</name></expr>]</index></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arraylen</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <comment type="block">/* Remove the key, if indeed needed. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while<condition>(<expr><operator>--</operator><name>count</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name> <operator>+</operator> <operator>(</operator><name>emitkey</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZPOPMIN key [&lt;count&gt;] */</comment>
<function><type><name>void</name></type> <name>zpopminCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>genericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>ZSET_MIN</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ZMAXPOP key [&lt;count&gt;] */</comment>
<function><type><name>void</name></type> <name>zpopmaxCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>genericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>ZSET_MAX</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* BZPOPMIN / BZPOPMAX actual implementation. */</comment>
<function><type><name>void</name></type> <name>blockingGenericZpopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getTimeoutFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>,<argument><expr><name>UNIT_SECONDS</name></expr></argument>)</argument_list></call>
        <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>o</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */</comment>
                    <expr_stmt><expr><call><name>genericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>where</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Replicate it as an ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */</comment>
                    <expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>where</name> <operator>==</operator> <name>ZSET_MAX</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>zpopmax</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>zpopmin</name></name></expr></else></ternary></expr></argument>,
                        <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If we are inside a MULTI/EXEC and the zset is empty the only thing
     * we can do is treating it as a timeout (even with timeout 0). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the keys do not exist we must block */</comment>
    <expr_stmt><expr><call><name>blockForKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>BLOCKED_ZSET</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>,<argument><expr><name>timeout</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// BZPOPMIN key [key ...] timeout</comment>
<function><type><name>void</name></type> <name>bzpopminCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>blockingGenericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZSET_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// BZPOPMAX key [key ...] timeout</comment>
<function><type><name>void</name></type> <name>bzpopmaxCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>blockingGenericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZSET_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
