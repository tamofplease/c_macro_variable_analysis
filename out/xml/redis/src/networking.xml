<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/networking.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Error.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"atomicvar.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_QFork.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<macro><name>WIN32_ONLY</name><argument_list>(<argument>extern int WSIOCP_QueueAccept(int listenfd);</argument>)</argument_list></macro>
<macro><name>WIN32_ONLY</name><argument_list>(<argument>extern int WSIOCP_CloseSocketStateRFD(int listenfd);</argument>)</argument_list></macro>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setProtocolError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errstr</name></decl></parameter>, <parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return the size consumed from the allocator, for the specified SDS string,
 * including internal fragmentation. This function is used in order to compute
 * the client output buffer size. */</comment>
<function><type><name>size_t</name></type> <name>sdsZmallocSize</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sh</name> <init>= <expr><call><name>sdsAllocPtr</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the amount of memory used by the sds string at object-&gt;ptr
 * for a string object. */</comment>
<function><type><name>size_t</name></type> <name>getStringObjectSdsUsedMemory</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_ENCODING_RAW</name></expr>:</case> <return>return <expr><call><name>sdsZmallocSize</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_EMBSTR</name></expr>:</case> <return>return <expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name></expr></argument>)</argument_list></sizeof></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Just integer encoding for now. */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Client.reply list dup and free methods. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>dupClientReplyValue</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><name>o</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>old</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>old</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeClientReplyValue</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>listMatchObjects</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>equalStringObjects</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function links the client to the global linked list of clients.
 * unlinkClient() does the opposite, among other things. */</comment>
<function><type><name>void</name></type> <name>linkClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Note that we remember the linked list node where the client is stored,
     * this way removing the client in unlinkClient() will not require
     * a linear scan, but just a constant time operation. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>client_list_node</name></name> <operator>=</operator> <call><name>listLast</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name> <init>= <expr><call><name>htonu64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_index</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>client</name> <modifier>*</modifier></type><name>createClient</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* passing -1 as fd it is possible to create a non connected client.
     * This is useful since all the commands needs to be executed
     * in the context of a client. When commands are executed in other
     * contexts (for instance a Lua script) we need a non connected client. */</comment>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>anetEnableTcpNoDelay</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>tcpkeepalive</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>anetKeepAlive</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>tcpkeepalive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>,
            <argument><expr><name>readQueryFromClient</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>client_id</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>atomicGetIncr</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>next_client_id</name></name></expr></argument>,<argument><expr><name>client_id</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>client_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>pending_querybuf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf_peak</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>lastcmd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>ctime</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>lastinteraction</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>authenticated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>REPL_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reploff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>read_reploff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_ack_off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_ack_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slave_listening_port</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name> <operator>=</operator> <name>SLAVE_CAPA_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>obuf_soft_limit_reached_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name>freeClientReplyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetDupMethod</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name>dupClientReplyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>btype</name></name> <operator>=</operator> <name>BLOCKED_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>keys</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectKeyHeapPointerValueDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>target</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_consumer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group_noack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>numreplicas</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>reploffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>woff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>pubsub_channels</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectKeyPointerValueDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>pubsub_patterns</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>client_list_node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pubsub_patterns</name></name></expr></argument>,<argument><expr><name>decrRefCountVoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetMatchMethod</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pubsub_patterns</name></name></expr></argument>,<argument><expr><name>listMatchObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>linkClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>initClientMultiState</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This funciton puts the client in the queue of clients that should write
 * their output buffers to the socket. Note that it does not *yet* install
 * the write handler, to start clients are put in a queue of clients that need
 * to write, so we try to do that before returning in the event loop (see the
 * handleClientsWithPendingWrites() function).
 * If we fail and there is more data to write, compared to what the socket
 * buffers can hold, then we'll really install the handler. */</comment>
<function><type><name>void</name></type> <name>clientInstallWriteHandler</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Schedule the client to write the output buffers to the socket only
     * if not already done and, for slaves, if the slave can actually receive
     * writes at this stage. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PENDING_WRITE</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>REPL_STATE_NONE</name> <operator>||</operator>
         <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_ONLINE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Here instead of installing the write handler, we just flag the
         * client and put it into a list of clients that have something
         * to write to the socket. This way before re-entering the event
         * loop, we can try to directly write to the client sockets avoiding
         * a system call. We'll only really install the write handler if
         * we'll not be able to write the whole reply at once. */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_PENDING_WRITE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listAddNodeHead</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called every time we are going to transmit new data
 * to the client. The behavior is the following:
 *
 * If the client should receive new data (normal clients will) the function
 * returns C_OK, and make sure to install the write handler in our event
 * loop so that when the socket is writable new data gets written.
 *
 * If the client should not receive new data, because it is a fake client
 * (used to load AOF in memory), a master or because the setup of the write
 * handler failed, the function returns C_ERR.
 *
 * The function may return C_OK without actually installing the write
 * event handler in the following cases:
 *
 * 1) The event handler should already be installed since the output buffer
 *    already contains something.
 * 2) The client is a slave but not yet online, so we want to just accumulate
 *    writes in the buffer but not actually sending them yet.
 *
 * Typically gets called every time a reply is built, before adding more
 * data to the clients output buffers. If the function returns C_ERR no
 * data should be appended to the output buffers. */</comment>
<function><type><name>int</name></type> <name>prepareClientToWrite</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* If it's the Lua client we always return ok without installing any
     * handler since there is no socket at all. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_LUA</name><operator>|</operator><name>CLIENT_MODULE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* CLIENT REPLY OFF / SKIP handling: don't send replies. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_REPLY_OFF</name><operator>|</operator><name>CLIENT_REPLY_SKIP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
     * is set. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER_FORCE_REPLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Fake client for AOF loading. */</comment>

    <comment type="block">/* Schedule the client to write the output buffers to the socket, unless
     * it should already be setup to do so (it has already pending data). */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clientInstallWriteHandler</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Authorize the caller to queue in the output buffer of this client. */</comment>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Low level functions to add more data to output buffers.
 * -------------------------------------------------------------------------- */</comment>

<function><type><name>int</name></type> <name>_addReplyToBuffer</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>available</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If there already are entries in the reply list, we cannot
     * add anything more to the static buffer. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Check that the buffer has enough space available for this string. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>available</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>buf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name><operator>+=</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>                                                        <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_addReplyStringToList</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listLast</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><ternary><condition><expr><name>ln</name></expr>?</condition><then> <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Note that 'tail' may be NULL even if we have a tail node, becuase when
     * addDeferredMultiBulkLength() is used, it sets a dummy node to NULL just
     * fo fill it later, when the size of the bulk length is set. */</comment>

    <comment type="block">/* Append to tail string when possible. */</comment>
    <if_stmt><if>if <condition>(<expr><name>tail</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Copy the part we can fit into the tail, and leave the rest for a
         * new node */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name><name>tail</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>tail</name><operator>-&gt;</operator><name>used</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>copy</name> <init>= <expr><ternary><condition><expr><name>avail</name> <operator>&gt;=</operator> <name>len</name></expr>?</condition><then> <expr><name>len</name></expr></then><else>: <expr><name>avail</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tail</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>tail</name><operator>-&gt;</operator><name>used</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Create a new node, make sure it is allocated to at
         * least PROTO_REPLY_CHUNK_BYTES */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <name>PROTO_REPLY_CHUNK_BYTES</name></expr>?</condition><then> <expr><name>PROTO_REPLY_CHUNK_BYTES</name></expr></then><else>: <expr><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* take over the allocation's internal fragmentation */</comment>
        <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>zmalloc_usable</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tail</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>+=</operator> <name><name>tail</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>asyncCloseClientOnOutputBufferLimitReached</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Higher level functions to queue data on the client output buffer.
 * The following functions are the ones that commands implementations will call.
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Add the object 'obj' string representation to the client output buffer. */</comment>
<function><type><name>void</name></type> <name>addReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>prepareClientToWrite</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>_addReplyToBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_addReplyStringToList</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* For integer encoded strings we just convert it into a string
         * using our optimized function, and attach the resulting string
         * to the output buffer. */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>_addReplyToBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_addReplyStringToList</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Wrong obj-&gt;encoding in addReply()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Add the SDS 's' string to the client output buffer, as a side effect
 * the SDS string is freed. */</comment>
<function><type><name>void</name></type> <name>addReplySds</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>prepareClientToWrite</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* The caller expects the sds to be free'd. */</comment>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>_addReplyToBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_addReplyStringToList</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This low level function just adds whatever protocol you send it to the
 * client buffer, trying the static buffer initially, and using the string
 * of objects if not possible.
 *
 * It is efficient because does not create an SDS object nor an Redis object
 * if not needed. The object will only be created by calling
 * _addReplyStringToList() if we fail to extend the existing tail object
 * in the list of objects. */</comment>
<function><type><name>void</name></type> <name>addReplyString</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>prepareClientToWrite</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>_addReplyToBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_addReplyStringToList</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Low level function called by the addReplyError...() functions.
 * It emits the protocol for a Redis error, in the form:
 *
 * -ERRORCODE Error Message&lt;CR&gt;&lt;LF&gt;
 *
 * If the error code is already passed in the string 's', the error
 * code provided is used, otherwise the string "-ERR " for the generic
 * error code is automatically added. */</comment>
<function><type><name>void</name></type> <name>addReplyErrorLength</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* If the string already starts with "-..." then the error code
     * is provided by the caller. Otherwise we use "-ERR". */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"-ERR "</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sometimes it could be normal that a slave replies to a master with
     * an error and this function gets called. Actually the error will never
     * be sent because addReply*() against master clients has no effect...
     * A notable example is:
     *
     *    EVAL 'redis.call("incr",KEYS[1]); redis.call("nonexisting")' 1 x
     *
     * Where the master must propagate the first change even if the second
     * will produce an error. However it is useful to log such events since
     * they are rare and may hint at errors in a script or a bug in Redis. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_MASTER</name><operator>|</operator><name>CLIENT_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MONITOR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>to</name> <init>= <expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>?</condition><then> <expr><literal type="string">"master"</literal></expr></then><else>: <expr><literal type="string">"replica"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>from</name> <init>= <expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>?</condition><then> <expr><literal type="string">"replica"</literal></expr></then><else>: <expr><literal type="string">"master"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdname</name> <init>= <expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>lastcmd</name></name></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>lastcmd</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"&lt;unknown&gt;"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"== CRITICAL == This %s is sending an error "</literal>
                             <literal type="string">"to its %s: '%s' after processing the command "</literal>
                             <literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyError</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyErrorLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>err</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyErrorFormat</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><call><name>sdscatvprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Make sure there are no newlines in the string, otherwise invalid protocol
     * is emitted. */</comment>
    <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>addReplyErrorLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyStatusLength</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"+"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyStatus</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyStatusLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>status</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyStatusFormat</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><call><name>sdscatvprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyStatusLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Adds an empty object to the reply list that will contain the multi bulk
 * length, which is not known when this function is called. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>addDeferredMultiBulkLength</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Note that we install the write event here even if the object is not
     * ready to be sent, since we are sure that before returning to the
     * event loop setDeferredMultiBulkLength() will be called. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>prepareClientToWrite</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* NULL is our placeholder. */</comment>
    <return>return <expr><call><name>listLast</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Populate the length object and try gluing it to the next chunk. */</comment>
<function><type><name>void</name></type> <name>setDeferredMultiBulkLength</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><operator>(</operator><name>listNode</name><operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>lenstr</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lenstr_len</name> <init>= <expr><call><name>sprintf</name><argument_list>(<argument><expr><name>lenstr</name></expr></argument>, <argument><expr><literal type="string">"*%ld\r\n"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addDeferredMultiBulkLength() */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>!</operator><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Normally we fill this dummy NULL node, added by addDeferredMultiBulkLength(),
     * with a new buffer structure containing the protocol needed to specify
     * the length of the array following. However sometimes when there is
     * little memory to move, we may instead remove this NULL node, and prefix
     * our protocol in the node immediately after to it, in order to save a
     * write(2) syscall later. Conditions needed to do it:
     *
     * - The next node is non-NULL,
     * - It has enough room already allocated
     * - And not too large (avoid large memmove) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ln</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>next</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
        <name><name>next</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>next</name><operator>-&gt;</operator><name>used</name></name> <operator>&gt;=</operator> <name>lenstr_len</name> <operator>&amp;&amp;</operator>
        <name><name>next</name><operator>-&gt;</operator><name>used</name></name> <operator>&lt;</operator> <name>PROTO_REPLY_CHUNK_BYTES</name> <operator>*</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>lenstr_len</name></expr></argument>, <argument><expr><name><name>next</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>next</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>lenstr</name></expr></argument>, <argument><expr><name>lenstr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>lenstr_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Create a new node */</comment>
        <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>lenstr_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Take over the allocation's internal fragmentation */</comment>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>zmalloc_usable</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>lenstr_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>lenstr</name></expr></argument>, <argument><expr><name>lenstr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>+=</operator> <name><name>buf</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>asyncCloseClientOnOutputBufferLimitReached</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a double as a bulk reply */</comment>
<function><type><name>void</name></type> <name>addReplyDouble</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>dbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>sbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dlen</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */</comment>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name>d</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"inf"</literal></expr> </then><else>: <expr><literal type="string">"-inf"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>dlen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>dbuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%.17g"</literal></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"$%d\r\n%s\r\n"</literal></expr></argument>,<argument><expr><name>dlen</name></expr></argument>,<argument><expr><name>dbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sbuf</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a long double as a bulk reply, but uses a human readable formatting
 * of the double instead of exposing the crude behavior of doubles to the
 * dear user. */</comment>
<function><type><name>void</name></type> <name>addReplyHumanLongDouble</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGDOUBLE</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createStringObjectFromLongDouble</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a long long as integer reply or bulk len / multi bulk count.
 * Basically this is used to output &lt;prefix&gt;&lt;long long&gt;&lt;crlf&gt;. */</comment>
<function><type><name>void</name></type> <name>addReplyLongLongWithPrefix</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <comment type="block">/* Things like $3\r\n or *2\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */</comment>
    <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name>ll</name> <operator>&lt;</operator> <name>OBJ_SHARED_BULKHDR_LEN</name> <operator>&amp;&amp;</operator> <name>ll</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>mbulkhdr</name><index>[<expr><name>ll</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prefix</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name>ll</name> <operator>&lt;</operator> <name>OBJ_SHARED_BULKHDR_LEN</name> <operator>&amp;&amp;</operator> <name>ll</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>bulkhdr</name><index>[<expr><name>ll</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (size_t) */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyLongLong</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ll</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ll</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReplyLongLongWithPrefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ll</name></expr></argument>,<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addReplyMultiBulkLen</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <name>OBJ_SHARED_BULKHDR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>mbulkhdr</name><index>[<expr><name>length</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReplyLongLongWithPrefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>length</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Create the length prefix of a bulk reply, example: $2234 */</comment>
<function><type><name>void</name></type> <name>addReplyBulkLen</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Compute how many bytes will take this integer as a radix 10 string */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <name>n</name><operator>/</operator><literal type="number">10</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>OBJ_SHARED_BULKHDR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>bulkhdr</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReplyLongLongWithPrefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a Redis Object as a bulk reply */</comment>
<function><type><name>void</name></type> <name>addReplyBulk</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>crlf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a C buffer as bulk reply */</comment>
<function><type><name>void</name></type> <name>addReplyBulkCBuffer</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyLongLongWithPrefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>crlf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add sds to reply (takes ownership of sds and frees it) */</comment>
<function><type><name>void</name></type> <name>addReplyBulkSds</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>s</name></decl></parameter>)</parameter_list>  <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyLongLongWithPrefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>crlf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a C null term string as bulk reply */</comment>
<function><type><name>void</name></type> <name>addReplyBulkCString</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a long long as a bulk reply */</comment>
<function><type><name>void</name></type> <name>addReplyBulkLongLong</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">64</literal></expr></argument>,<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add an array of C strings as status replies with a heading.
 * This function is typically invoked by from commands that support
 * subcommands in response to the 'help' subcommand. The help array
 * is terminated by NULL sentinel. */</comment>
<function><type><name>void</name></type> <name>addReplyHelp</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>help</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>cmd</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>blenp</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>blen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sdstoupper</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyStatusFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
        <argument><expr><literal type="string">"%s &lt;subcommand&gt; arg arg ... arg. Subcommands are:"</literal></expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>help</name><index>[<expr><name>blen</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyStatus</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>help</name><index>[<expr><name>blen</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><name>blen</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Account for the header line(s). */</comment>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>blenp</name></expr></argument>,<argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a suggestive error reply.
 * This function is typically invoked by from commands that support
 * subcommands in response to an unknown subcommand or argument error. */</comment>
<function><type><name>void</name></type> <name>addReplySubcommandSyntaxError</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>cmd</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sdstoupper</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
        <argument><expr><literal type="string">"Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP."</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append 'src' client output buffers into 'dst' client output buffers. 
 * This function clears the output buffers of 'src' */</comment>
<function><type><name>void</name></type> <name>AddReplyFromClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>prepareClientToWrite</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name><name>src</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>bufpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>listJoin</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name><name>src</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>+=</operator> <name><name>src</name><operator>-&gt;</operator><name>reply_bytes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Copy 'src' client output buffers into 'dst' client output buffers.
 * The function takes care of freeing the old output buffers of the
 * destination client. */</comment>
<function><type><name>void</name></type> <name>copyClientOutputBuffer</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>listDup</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>src</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>src</name><operator>-&gt;</operator><name>bufpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>bufpos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>reply_bytes</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if the specified client has pending reply buffers to write to
 * the socket. */</comment>
<function><type><name>int</name></type> <name>clientHasPendingReplies</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>||</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ACCEPTS_PER_CALL</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>acceptCommonHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>createClient</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Error registering fd event for the new client: %s (fd=%d)"</literal></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* May be already closed, just ignore errors */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* If maxclient directive is set and this is one client more... close the
     * connection. Note that we create the client instead to check before
     * for this condition, since now the socket is already set in non-blocking
     * mode and we can send an error for free using the Kernel I/O */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>maxclients</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><literal type="string">"-ERR max number of clients reached\r\n"</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* That's a best effort error message, don't check write errors */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>err</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Nothing to do, Just to avoid the warning... */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_rejected_conn</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <comment type="line">//[tporadowski] freeClient was sometimes causing sent reply to be not delivered, so give it some</comment>
        <comment type="line">//  additional time via freeing asynchronously</comment>
        <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the server is running in protected mode (the default) and there
     * is no password set, nor a specific interface is bound, we don't accept
     * requests from non loopback interfaces. Instead we try to explain the
     * user what to do to fix it if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>protected_mode</name></name> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>bindaddr_count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>requirepass</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CLIENT_UNIX_SOCKET</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name>ip</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><literal type="string">"::1"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>=
                <expr><literal type="string">"-DENIED Redis is running in protected mode because protected "</literal>
                <literal type="string">"mode is enabled, no bind address was specified, no "</literal>
                <literal type="string">"authentication password is requested to clients. In this mode "</literal>
                <literal type="string">"connections are only accepted from the loopback interface. "</literal>
                <literal type="string">"If you want to connect from external computers to Redis you "</literal>
                <literal type="string">"may adopt one of the following solutions: "</literal>
                <literal type="string">"1) Just disable protected mode sending the command "</literal>
                <literal type="string">"'CONFIG SET protected-mode no' from the loopback interface "</literal>
                <literal type="string">"by connecting to Redis from the same host the server is "</literal>
                <literal type="string">"running, however MAKE SURE Redis is not publicly accessible "</literal>
                <literal type="string">"from internet if you do so. Use CONFIG REWRITE to make this "</literal>
                <literal type="string">"change permanent. "</literal>
                <literal type="string">"2) Alternatively you can just disable the protected mode by "</literal>
                <literal type="string">"editing the Redis configuration file, and setting the protected "</literal>
                <literal type="string">"mode option to 'no', and then restarting the server. "</literal>
                <literal type="string">"3) If you started the server manually just for testing, restart "</literal>
                <literal type="string">"it with the '--protected-mode no' option. "</literal>
                <literal type="string">"4) Setup a bind address or an authentication password. "</literal>
                <literal type="string">"NOTE: You only need to do one of the above things in order for "</literal>
                <literal type="string">"the server to start accepting connections from the outside.\r\n"</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>err</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Nothing to do, Just to avoid the warning... */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_rejected_conn</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_numconnections</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>acceptTcpHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cport</name></decl>, <decl><type ref="prev"/><name>cfd</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><name>MAX_ACCEPTS_PER_CALL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>max</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cfd</name> <operator>=</operator> <call><name>anetTcpAccept</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cip</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cip</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cfd</name> <operator>==</operator> <name>ANET_ERR</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"Accepting client connection: %s"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><call><name>WSIOCP_QueueAccept</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                        <argument><expr><literal type="string">"acceptTcpHandler: failed to queue another accept."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,<argument><expr><literal type="string">"Accepted %s:%d"</literal></expr></argument>, <argument><expr><name>cip</name></expr></argument>, <argument><expr><name>cport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>acceptCommonHandler</name><argument_list>(<argument><expr><name>cfd</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>cip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>acceptUnixHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cfd</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><name>MAX_ACCEPTS_PER_CALL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>max</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cfd</name> <operator>=</operator> <call><name>anetUnixAccept</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cfd</name> <operator>==</operator> <name>ANET_ERR</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"Accepting client connection: %s"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,<argument><expr><literal type="string">"Accepted connection to %s"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>unixsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>acceptCommonHandler</name><argument_list>(<argument><expr><name>cfd</name></expr></argument>,<argument><expr><name>CLIENT_UNIX_SOCKET</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeClientArgv</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Close all the slaves connections. This is useful in chained replication
 * when we resync with our own master and want to force all our slaves to
 * resync with us as well. */</comment>
<function><type><name>void</name></type> <name>disconnectSlaves</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <while>while <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><operator>(</operator><name>client</name><operator>*</operator><operator>)</operator><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Remove the specified client from global lists where the client could
 * be referenced, not including the Pub/Sub channels.
 * This is used by freeClient() and replicationCacheMaster(). */</comment>
<function><type><name>void</name></type> <name>unlinkClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <comment type="block">/* If this is marked as current client unset it. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Certain operations must be done only if the client has an active socket.
     * If the client was already unlinked or if it's a "fake client" the
     * fd is already set to -1. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Remove from the list of active clients. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>client_list_node</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name> <init>= <expr><call><name>htonu64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_index</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>client_list_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>client_list_node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* In the case of diskless replication the fork is writing to the
         * sockets and just closing the fd isn't enough, if we don't also
         * shutdown the socket the fork will continue to write to the slave
         * and the salve will only find out that it was disconnected when
         * it will finish reading the rdb. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_END</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
			<expr_stmt><expr><call><name>WSIOCP_CloseSocketStateRFD</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//TODO is this ok?</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SHUT_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Unregister async I/O handlers and close the socket. */</comment>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Remove from the list of pending writes if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PENDING_WRITE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_PENDING_WRITE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* When client was just unblocked because of a blocking operation,
     * remove it from the list of unblocked clients. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_UNBLOCKED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>unblocked_clients</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>unblocked_clients</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_UNBLOCKED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <comment type="block">/* If a client is protected, yet we need to free it right now, make sure
     * to at least use asynchronous freeing. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PROTECTED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If it is our master that's beging disconnected we should make sure
     * to cache the state to try a partial resynchronization later.
     *
     * Note that before doing this we make sure that the client is not in
     * some unexpected state, by checking its flags. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>master</name></name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Connection with master lost."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_CLOSE_AFTER_REPLY</name><operator>|</operator>
                          <name>CLIENT_CLOSE_ASAP</name><operator>|</operator>
                          <name>CLIENT_BLOCKED</name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>replicationCacheMaster</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Log link disconnection with slave */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MONITOR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Connection with replica %s lost."</literal></expr></argument>,
            <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Free the query buffer */</comment>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pending_querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Deallocate structures used to block on blocking ops. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>unblockClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* UNWATCH all the keys */</comment>
    <expr_stmt><expr><call><name>unwatchAllKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unsubscribe from all the pubsub channels */</comment>
    <expr_stmt><expr><call><name>pubsubUnsubscribeAllChannels</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pubsubUnsubscribeAllPatterns</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pubsub_channels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pubsub_patterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Free data structures. */</comment>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeClientArgv</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unlink the client: this will close the socket, remove the I/O
     * handlers, and remove references of the client from different
     * places where active clients may be referenced. */</comment>
    <expr_stmt><expr><call><name>unlinkClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Master/slave cleanup Case 1:
     * we lost the connection with a slave. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_SEND_BULK</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>DeleteFileA</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>replpreamble</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>replpreamble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MONITOR</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>server</name><operator>.</operator><name>monitors</name></name></expr> </then><else>: <expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listSearchKey</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We need to remember the time when we started to have zero
         * attached slaves, as after some time we'll free the replication
         * backlog. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>getClientType</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CLIENT_TYPE_SLAVE</name> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_no_slaves_since</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>refreshGoodSlavesCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Master/slave cleanup Case 2:
     * we lost the connection with the master. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>replicationHandleMasterDisconnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If this client was scheduled for async freeing we need to remove it
     * from the queue. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_ASAP</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_to_close</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_to_close</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Release other dynamically allocated client structure fields,
     * and finally release the client structure itself. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeClientMultiState</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Schedule a client to free it at a safe time in the serverCron() function.
 * This function is useful when we need to terminate a client but we are in
 * a context where calling freeClient() is not possible, because the client
 * should be valid for the continuation of the flow of the program. */</comment>
<function><type><name>void</name></type> <name>freeClientAsync</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_ASAP</name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_LUA</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_CLOSE_ASAP</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_to_close</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeClientsInAsyncFreeQueue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <while>while <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_to_close</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_to_close</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_CLOSE_ASAP</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_to_close</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Return a client by ID, or NULL if the client ID is not in the set
 * of registered clients. Note that "fake clients", created with -1 as FD,
 * are not registered clients. */</comment>
<function><type><name>client</name> <modifier>*</modifier></type><name>lookupClientByID</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_index</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <name>raxNotFound</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write data in output buffers to client. Return C_OK if the client
 * is still valid after the call, C_ERR if it was freed. */</comment>
<function><type><name>int</name></type> <name>writeToClient</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>handler_installed</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totwritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>objlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <while>while<condition>(<expr><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>-</operator> <name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr>;</expr_stmt>
            <comment type="line">//[tporadowski/#7] don't use "sendReplyBufferDone" callback, clean up and connection closing is done here and at the end now</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>WSIOCP_SocketSend</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr></argument>, <argument><expr><name>nwritten</name></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>WSA_IO_PENDING</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <comment type="line">//[tporadowski/#11] we might be bursting data too fast, so turn it into another try that will put back the client</comment>
                <comment type="line">//  in the sending queue</comment>
                <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <break>break;</break>
            </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>buf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>totwritten</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>

            <comment type="block">/* If the buffer was sent, set bufpos to zero to continue with
             * the remainder of the reply. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>==</operator> <name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>objlen</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>objlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>-=</operator> <name><name>o</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <comment type="line">//[tporadowski/#7] don't use "sendReplyListDone" callback, clean up and connection closing is at the end now</comment>
			<expr_stmt><expr><name>nwritten</name> <operator>=</operator> <name>objlen</name> <operator>-</operator> <name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>WSIOCP_SocketSend</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>buf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr></argument>, <argument><expr><name>nwritten</name></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>WSA_IO_PENDING</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <comment type="line">//[tporadowski/#11] we might be bursting data too fast, so turn it into another try that will put back the client</comment>
                <comment type="line">//  in the sending queue</comment>
                <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>totwritten</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr></argument>, <argument><expr><name>objlen</name> <operator>-</operator> <name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>totwritten</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* If we fully sent the object on head go to the next one */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>==</operator> <name>objlen</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>-=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <comment type="block">/* If there are no longer objects in the list, we expect
                 * the count of reply bytes to be exactly zero. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver.
         *
         * Moreover, we also send as much as possible if the client is
         * a slave or a monitor (otherwise, on high-speed traffic, the
         * replication/output buffer will grow indefinitely) */</comment>
        <if_stmt><if>if <condition>(<expr><name>totwritten</name> <operator>&gt;</operator> <name>NET_MAX_WRITES_PER_EVENT</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
             <call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>maxmemory</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_net_output_bytes</name></name> <operator>+=</operator> <name>totwritten</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
                <argument><expr><literal type="string">"Error writing to client: %s"</literal></expr></argument>, <argument><expr><call><call><name>IF_WIN32</name><argument_list>(<argument><expr><name>wsa_strerror</name></expr></argument>,<argument><expr><name>strerror</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>totwritten</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* For clients representing masters we don't count sending data
         * as an interaction, since we always send REPLCONF ACK commands
         * that take some time to just fill the socket output buffer.
         * We just rely on data / pings received for timeout detection. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>lastinteraction</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>handler_installed</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Close connection after entire reply has been sent. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <comment type="line">//[tporadowski] freeClient was sometimes causing sent reply to be not delivered, so give it some</comment>
            <comment type="line">//  additional time via freeing asynchronously</comment>
            <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_WIN32</name></expr></cpp:if>
    <comment type="block">/* [tporadowski/#11] too much data was sent in one run, schedule for next available sending slot again.
    * We are re-scheduling only when writeToClient was called from sendReplyToClient handler as normally
    * handleClientsWithPendingWrites() does this automatically after writeToClient() returns with pending
    * replies.
    */</comment>
    <if type="elseif">else if <condition>(<expr><name>handler_installed</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>,
            <argument><expr><name>sendReplyToClient</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"writeToClient: aeCreateFileEvent failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"writeToClient: re-scheduling sendReplyToClient() for pending client replies"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write event handler. Just send data to the client. */</comment>
<function><type><name>void</name></type> <name>sendReplyToClient</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writeToClient</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>privdata</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called just before entering the event loop, in the hope
 * we can just write the replies to the client output buffer without any
 * need to use a syscall in order to install the writable event handler,
 * get it called, and so forth. */</comment>
<function><type><name>int</name></type> <name>handleClientsWithPendingWrites</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>processed</name> <init>= <expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_PENDING_WRITE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If a client is protected, don't do anything,
         * that may trigger write error or recreate handler. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PROTECTED</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Try to write buffers to the client socket. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>writeToClient</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* If after the synchronous writes above we still have data to
         * output to the client, we need to install the writable handler. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>ae_flags</name> <init>= <expr><name>AE_WRITABLE</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* For the fsync=always policy, we want that a given FD is never
             * served for reading and writing in the same event loop iteration,
             * so that in the middle of receiving the query, and serving it
             * to the client, we'll call beforeSleep() that will do the
             * actual fsync of AOF to disk. AE_BARRIER ensures that. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>==</operator> <name>AOF_ON</name> <operator>&amp;&amp;</operator>
                <name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_ALWAYS</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ae_flags</name> <operator>|=</operator> <name>AE_BARRIER</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>ae_flags</name></expr></argument>,
                <argument><expr><name>sendReplyToClient</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition>
            <block>{<block_content>
                    <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* resetClient prepare the client to process the next command */</comment>
<function><type><name>void</name></type> <name>resetClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisCommandProc</name> <modifier>*</modifier></type><name>prevcmd</name> <init>= <expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>proc</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>freeClientArgv</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* We clear the ASKING flag as well if we are not inside a MULTI, and
     * if what we just executed is not the ASKING command itself. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>prevcmd</name> <operator>!=</operator> <name>askingCommand</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_ASKING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Remove the CLIENT_REPLY_SKIP flag if any so that the reply
     * to the next command will be sent, but set the flag if the command
     * we just processed was "CLIENT REPLY SKIP". */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_REPLY_SKIP</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_REPLY_SKIP_NEXT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_REPLY_SKIP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_REPLY_SKIP_NEXT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This funciton is used when we want to re-enter the event loop but there
 * is the risk that the client we are dealing with will be freed in some
 * way. This happens for instance in:
 *
 * * DEBUG RELOAD and similar.
 * * When a Lua script is in -BUSY state.
 *
 * So the function will protect the client by doing two things:
 *
 * 1) It removes the file events. This way it is not possible that an
 *    error is signaled on the socket, freeing the client.
 * 2) Moreover it makes sure that if the client is freed in a different code
 *    path, it is not really released, but only marked for later release. */</comment>
<function><type><name>void</name></type> <name>protectClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_PROTECTED</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This will undo the client protection done by protectClient() */</comment>
<function><type><name>void</name></type> <name>unprotectClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PROTECTED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_PROTECTED</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>,<argument><expr><name>readQueryFromClient</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clientInstallWriteHandler</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,
 * this function consumes the client query buffer and creates a command ready
 * to be executed inside the client structure. Returns C_OK if the command
 * is ready to be executed, or C_ERR if there is still protocol to read to
 * have a well formed command. The function also returns C_ERR when there is
 * a protocol error: in such a case the client structure is setup to reply
 * with the error and close the connection. */</comment>
<function><type><name>int</name></type> <name>processInlineBuffer</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>linefeed_chars</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name></decl>, <decl><type ref="prev"/><name>aux</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>querylen</name></decl>;</decl_stmt>

    <comment type="block">/* Search for end of line */</comment>
    <expr_stmt><expr><name>newline</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nothing to do without a \r\n */</comment>
    <if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&gt;</operator> <name>PROTO_INLINE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Protocol error: too big inline request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"too big inline request"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle the \r\n case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>newline</name> <operator>&amp;&amp;</operator> <name>newline</name> <operator>!=</operator> <name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>newline</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newline</name><operator>--</operator></expr><operator>,</operator> <expr><name>linefeed_chars</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Split the input buffer up to the \r\n */</comment>
    <expr_stmt><expr><name>querylen</name> <operator>=</operator> <name>newline</name><operator>-</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><name>querylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>sdssplitargs</name><argument_list>(<argument><expr><name>aux</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Protocol error: unbalanced quotes in request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"unbalanced quotes in inline request"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Newline from slaves can be used to refresh the last ACK time.
     * This is useful for a slave to ping back while loading a big
     * RDB file. */</comment>
    <if_stmt><if>if <condition>(<expr><name>querylen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>getClientType</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CLIENT_TYPE_SLAVE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_ack_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Move querybuffer position to the next query in the buffer. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>+=</operator> <name>querylen</name><operator>+</operator><name>linefeed_chars</name></expr>;</expr_stmt>

    <comment type="block">/* Setup argv array on client structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create redis objects for all arguments. */</comment>
    <for>for <control>(<init><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>]</index></name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function. Record protocol erro details in server log,
 * and set the client as CLIENT_CLOSE_AFTER_REPLY. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROTO_DUMP_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setProtocolError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errstr</name></decl></parameter>, <parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>verbosity</name></name> <operator>&lt;=</operator> <name>LL_VERBOSE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>client</name> <init>= <expr><call><name>catClientInfoString</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Sample some protocol to given an idea about what was inside. */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&lt;</operator> <name>PROTO_DUMP_LEN</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"Query buffer during protocol error: '%s'"</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"Query buffer during protocol error: '%.*s' (... more %Iu bytes ...) '%.*s'"</literal></expr></argument>, <argument><expr><name>PROTO_DUMP_LEN</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>-</operator><name>PROTO_DUMP_LEN</name></expr></argument>, <argument><expr><name>PROTO_DUMP_LEN</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name>PROTO_DUMP_LEN</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* %zu -&gt; %Iu */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Remove non printable chars. */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Log all the client and protocol info. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
            <argument><expr><literal type="string">"Protocol error (%s) from client: %s. %s"</literal></expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Process the query buffer for client 'c', setting up the client argument
 * vector for command execution. Returns C_OK if after running the function
 * the client has a well-formed ready to be processed command, otherwise
 * C_ERR if there is still to read more buffer to get the full command.
 * The function also returns C_ERR when there is a protocol error: in such a
 * case the client structure is setup to reply with the error and close
 * the connection.
 *
 * This function is called if processInputBuffer() detects that the next
 * command is in RESP format, so the first byte in the command is found
 * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */</comment>
<function><type><name>int</name></type> <name>processMultibulkBuffer</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newline</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* The client should have been reset */</comment>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Multi bulk length cannot be read without a \r\n */</comment>
        <expr_stmt><expr><name>newline</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&gt;</operator> <name>PROTO_INLINE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Protocol error: too big mbulk count string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"too big mbulk count string"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Buffer should also contain \n */</comment>
        <if_stmt><if>if <condition>(<expr><name>newline</name><operator>-</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* We know for sure there is a whole line since newline != NULL,
         * so go ahead and find out the multi bulk length. */</comment>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>string2ll</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><name>newline</name><operator>-</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>)</operator></expr></argument>,<argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>||</operator> <name>ll</name> <operator>&gt;</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Protocol error: invalid multibulk length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"invalid mbulk count"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>=</operator> <operator>(</operator><name>newline</name><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>)</operator><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ll</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ll</name></expr>;</expr_stmt>

        <comment type="block">/* Setup argv array on client structure */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Read bulk length if unknown */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>newline</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&gt;</operator> <name>PROTO_INLINE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                        <argument><expr><literal type="string">"Protocol error: too big bulk count string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"too big bulk count string"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>C_ERR</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Buffer should also contain \n */</comment>
            <if_stmt><if>if <condition>(<expr><name>newline</name><operator>-</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"Protocol error: expected '$', got '%c'"</literal></expr></argument>,
                    <argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"expected $ but got something else"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>C_ERR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>string2ll</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>newline</name><operator>-</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>||</operator> <name><name>ll</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ll</name></expr></argument> &gt;</argument_list></name> <name><name>server</name><operator>.</operator><name>proto_max_bulk_len</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Protocol error: invalid bulk length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setProtocolError</name><argument_list>(<argument><expr><literal type="string">"invalid bulk length"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>C_ERR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>=</operator> <name>newline</name><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ll</name> <operator>&gt;=</operator> <name>PROTO_MBULK_BIG_ARG</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If we are going to read a large object from network
                 * try to make it likely that it will start at c-&gt;querybuf
                 * boundary so that we can optimize object creation
                 * avoiding a large copy of data.
                 *
                 * But only when the data we have not parsed is less than
                 * or equal to ll+2. If the data length is greater than
                 * ll+2, trimming querybuf is just a waste of time, because
                 * at this time the querybuf contains not only our bulk. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>ll</name><operator>+</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <comment type="block">/* Hint the sds library about the amount of bytes this string is
                     * going to contain. */</comment>
                    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name> <operator>=</operator> <call><name>sdsMakeRoomFor</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>,<argument><expr><name>ll</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>ll</name></expr>;</expr_stmt>                                        <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (PORT_LONG) */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Read bulk argument */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Not enough data (+2 == trailing \r\n) */</comment>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Optimization: if the buffer contains JUST our bulk element
             * instead of creating a new object by *copying* the sds we
             * just use the current sds string. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>&gt;=</operator> <name>PROTO_MBULK_BIG_ARG</name> <operator>&amp;&amp;</operator>
                <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* remove CRLF */</comment>
                <comment type="block">/* Assume that if we saw a fat argument we'll see another one
                 * likely... */</comment>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>SDS_NOINIT</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sdsclear</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator>
                    <call><name>createStringObject</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>+=</operator> <name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* We're done when c-&gt;multibulk == 0 */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Still not ready to process the command */</comment>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called every time, in the client structure 'c', there is
 * more query buffer to process, because we read more data from the socket
 * or because a client was blocked and later reactivated, so there could be
 * pending query buffer, already representing a full command, to process. */</comment>
<function><type><name>void</name></type> <name>processInputBuffer</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

    <comment type="block">/* Keep processing while there is something in the input buffer */</comment>
    <while>while<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>&lt;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Return if clients are paused. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>clientsArePaused</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Immediately abort if the client is in the middle of something. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Don't process input from the master while there is a busy script
         * condition on the slave. We want just to accumulate the replication
         * stream (instead of replying -BUSY like we do with other clients) and
         * later resume the processing. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lua_timedout</name></name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
         * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_CLOSE_AFTER_REPLY</name><operator>|</operator><name>CLIENT_CLOSE_ASAP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Determine request type when unknown. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>=</operator> <name>PROTO_REQ_MULTIBULK</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>=</operator> <name>PROTO_REQ_INLINE</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>==</operator> <name>PROTO_REQ_INLINE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>processInlineBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>==</operator> <name>PROTO_REQ_MULTIBULK</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>processMultibulkBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown request type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Multibulk processing could see a &lt;= 0 length. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>resetClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Only reset the client when the command was executed. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>processCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Update the applied replication offset of our master. */</comment>
                    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reploff</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>read_reploff</name></name> <operator>-</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Don't reset the client structure for clients blocked in a
                 * module blocking command, so that the reply callback will
                 * still be able to access the client argv and argc field.
                 * The client will be reset in unblockClientFromModule(). */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name><operator>)</operator> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>btype</name></name> <operator>!=</operator> <name>BLOCKED_MODULE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>resetClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* freeMemoryIfNeeded may flush slave output buffers. This may
             * result into a slave, that may be the active client, to be
             * freed. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Trim to pos */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>qb_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is a wrapper for processInputBuffer that also cares about handling
 * the replication forwarding to the sub-slaves, in case the client 'c'
 * is flagged as master. Usually you want to call this instead of the
 * raw processInputBuffer(). */</comment>
<function><type><name>void</name></type> <name>processInputBufferAndReplicate</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>processInputBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>prev_offset</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>reploff</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>processInputBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>applied</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>reploff</name></name> <operator>-</operator> <name>prev_offset</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>applied</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>replicationFeedSlavesFromMasterStream</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,
                    <argument><expr><name><name>c</name><operator>-&gt;</operator><name>pending_querybuf</name></name></expr></argument>, <argument><expr><name>applied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pending_querybuf</name></name></expr></argument>,<argument><expr><name>applied</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>readQueryFromClient</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>client</name><operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nread</name></decl>, <decl><type ref="prev"/><name>readlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>qblen</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>readlen</name> <operator>=</operator> <name>PROTO_IOBUF_LEN</name></expr>;</expr_stmt>
    <comment type="block">/* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>reqtype</name></name> <operator>==</operator> <name>PROTO_REQ_MULTIBULK</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>multibulklen</name></name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal>
        <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name> <operator>&gt;=</operator> <name>PROTO_MBULK_BIG_ARG</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>remaining</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>bulklen</name></name><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>-</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Note that the 'remaining' variable may be zero in some edge case,
         * for example once we resume a blocked client after CLIENT PAUSE. */</comment>
        <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>remaining</name> <operator>&lt;</operator> <name>readlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>readlen</name> <operator>=</operator> <name>remaining</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>qblen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>querybuf_peak</name></name> <operator>&lt;</operator> <name>qblen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf_peak</name></name> <operator>=</operator> <name>qblen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name> <operator>=</operator> <call><name>sdsMakeRoomFor</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>, <argument><expr><name>readlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nread</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name>qblen</name></expr></argument>, <argument><expr><name>readlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                          <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"Reading from client: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"Client closed connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Append the query buffer to the pending (not applied) buffer
         * of the master. We'll use this buffer later in order to have a
         * copy of the string applied by the last command executed. */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>pending_querybuf</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pending_querybuf</name></name></expr></argument>,
                                        <argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name><operator>+</operator><name>qblen</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
    <expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>lastinteraction</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>read_reploff</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_net_input_bytes</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>client_max_querybuf_len</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>ci</name> <init>= <expr><call><name>catClientInfoString</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>bytes</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>sdscatrepr</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>,<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</literal></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Time to process the buffer. If the client is a master we need to
     * compute the difference between the applied offset before and after
     * processing the buffer, to understand how much of the replication stream
     * was actually applied to the master state: this quantity, and its
     * corresponding part of the replication stream, will be propagated to
     * the sub-slaves and to the replication backlog. */</comment>
    <expr_stmt><expr><call><name>processInputBufferAndReplicate</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>getClientsMaxBuffers</name><parameter_list>(<parameter><decl><type><name>PORT_ULONG</name> <modifier>*</modifier></type><name>longest_output_list</name></decl></parameter>,
                          <parameter><decl><type><name>PORT_ULONG</name> <modifier>*</modifier></type><name>biggest_input_buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>lol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bib</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>lol</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lol</name> <operator>=</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bib</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bib</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (PORT_ULONG) */</comment>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>longest_output_list</name> <operator>=</operator> <name>lol</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>biggest_input_buffer</name> <operator>=</operator> <name>bib</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* A Redis "Peer ID" is a colon separated ip:port pair.
 * For IPv4 it's in the form x.y.z.k:port, example: "127.0.0.1:1234".
 * For IPv6 addresses we use [] around the IP part, like in "[::1]:1234".
 * For Unix sockets we use path:0, like in "/tmp/redis:0".
 *
 * A Peer ID always fits inside a buffer of NET_PEER_ID_LEN bytes, including
 * the null term.
 *
 * On failure the function still populates 'peerid' with the "?:0" string
 * in case you want to relax error checking or need to display something
 * anyway (see anetPeerToString implementation for more info). */</comment>
<function><type><name>void</name></type> <name>genClientPeerId</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>peerid</name></decl></parameter>,
                            <parameter><decl><type><name>size_t</name></type> <name>peerid_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_UNIX_SOCKET</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Unix socket client. */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>peerid</name></expr></argument>,<argument><expr><name>peerid_len</name></expr></argument>,<argument><expr><literal type="string">"%s:0"</literal></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>unixsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* TCP client. */</comment>
        <expr_stmt><expr><call><name>anetFormatPeer</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>peerid</name></expr></argument>,<argument><expr><name>peerid_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function returns the client peer id, by creating and caching it
 * if client-&gt;peerid is NULL, otherwise returning the cached value.
 * The Peer ID never changes during the life of the client, however it
 * is expensive to compute. */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>getClientPeerId</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>peerid</name><index>[<expr><name>NET_PEER_ID_LEN</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>genClientPeerId</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>peerid</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>peerid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>peerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Concatenate a string representing the state of a client in an human
 * readable format, into the sds string 's'. */</comment>
<function><type><name>sds</name></type> <name>catClientInfoString</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>flags</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>events</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>emask</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MONITOR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'O'</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'M'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PUBSUB</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'P'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_DIRTY_CAS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_UNBLOCKED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_ASAP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_UNIX_SOCKET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'U'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_READONLY</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>flags</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>emask</name> <operator>=</operator> <ternary><condition><expr><name><name>client</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>aeGetFileEvents</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>client</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>events</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>emask</name> <operator>&amp;</operator> <name>AE_READABLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>emask</name> <operator>&amp;</operator> <name>AE_WRITABLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'w'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
        <argument><expr><literal type="string">"id=%U addr=%s fd=%i name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U obl=%U oll=%U omem=%U events=%s cmd=%s"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>client</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
        <argument><expr><call><name>getClientPeerId</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name><name>client</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>client</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>ptr</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>client</name><operator>-&gt;</operator><name>ctime</name></name><operator>)</operator></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>client</name><operator>-&gt;</operator><name>lastinteraction</name></name><operator>)</operator></expr></argument>,
        <argument><expr><name>flags</name></expr></argument>,
        <argument><expr><name><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pubsub_channels</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pubsub_patterns</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>client</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <call><name>sdsavail</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>client</name><operator>-&gt;</operator><name>bufpos</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <call><name>getClientOutputBufferMemoryUsage</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>events</name></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>client</name><operator>-&gt;</operator><name>lastcmd</name></name></expr> ?</condition><then> <expr><name><name>client</name><operator>-&gt;</operator><name>lastcmd</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>sds</name></type> <name>getAllClientsInfoString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>o</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>SDS_NOINIT</name></expr></argument>,<argument><expr><literal type="number">200</literal><operator>*</operator><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sdsclear</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>client</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>getClientType</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>catClientInfoString</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clientCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"id                     -- Return the ID of the current connection."</literal></expr>,
<expr><literal type="string">"getname                -- Return the name of the current connection."</literal></expr>,
<expr><literal type="string">"kill &lt;ip:port&gt;         -- Kill connection made from &lt;ip:port&gt;."</literal></expr>,
<expr><literal type="string">"kill &lt;option&gt; &lt;value&gt; [option value ...] -- Kill connections. Options are:"</literal></expr>,
<expr><literal type="string">"     addr &lt;ip:port&gt;                      -- Kill connection made from &lt;ip:port&gt;"</literal></expr>,
<expr><literal type="string">"     type (normal|master|replica|pubsub) -- Kill connections by type."</literal></expr>,
<expr><literal type="string">"     skipme (yes|no)   -- Skip killing current connection (default: yes)."</literal></expr>,
<expr><literal type="string">"list [options ...]     -- Return information about client connections. Options:"</literal></expr>,
<expr><literal type="string">"     type (normal|master|replica|pubsub) -- Return clients of specified type."</literal></expr>,
<expr><literal type="string">"pause &lt;timeout&gt;        -- Suspend all Redis clients for &lt;timout&gt; milliseconds."</literal></expr>,
<expr><literal type="string">"reply (on|off|skip)    -- Control the replies sent to the current connection."</literal></expr>,
<expr><literal type="string">"setname &lt;name&gt;         -- Assign the name &lt;name&gt; to the current connection."</literal></expr>,
<expr><literal type="string">"unblock &lt;clientid&gt; [TIMEOUT|ERROR] -- Unblock the specified blocked client."</literal></expr>,
<expr><name>NULL</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLIENT ID */</comment>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLIENT LIST */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>getClientTypeByName</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown client type '%s'"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
             </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>o</name> <init>= <expr><call><name>getAllClientsInfoString</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"reply"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLIENT REPLY ON|OFF|SKIP */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CLIENT_REPLY_SKIP</name><operator>|</operator><name>CLIENT_REPLY_OFF</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_REPLY_OFF</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"skip"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_REPLY_OFF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_REPLY_SKIP_NEXT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"kill"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLIENT KILL &lt;ip:port&gt;
         * CLIENT KILL &lt;option&gt; [value] ... &lt;option&gt; [value] */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>skipme</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>killed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>close_this_client</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Old style syntax: CLIENT KILL &lt;addr&gt; */</comment>
            <expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>skipme</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* With the old form, you can kill yourself. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Next option index. */</comment>

            <comment type="block">/* New style syntax: parse options. */</comment>
            <while>while<condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>tmp</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                        <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>id</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>getClientTypeByName</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown client type '%s'"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"addr"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"skipme"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>skipme</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>skipme</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Iterate clients killing all the matching clients. */</comment>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>client</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>getClientPeerId</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>getClientType</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>client</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>client</name> <operator>&amp;&amp;</operator> <name>skipme</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Kill it. */</comment>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>client</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>close_this_client</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>killed</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Reply according to old/new format. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>killed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"No such client"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* If this client has to be closed, flag it as CLOSE_AFTER_REPLY
         * only after we queued the reply to its output buffers. */</comment>
        <if_stmt><if>if <condition>(<expr><name>close_this_client</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"unblock"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>||</operator>
                                                          <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLIENT UNBLOCK &lt;id&gt; [timeout|error] */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>unblock_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"timeout"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>unblock_error</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>unblock_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"CLIENT UNBLOCK reason should be TIMEOUT or ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
            <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>client</name></name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>lookupClientByID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>target</name> <operator>&amp;&amp;</operator> <name><name>target</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>unblock_error</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
                    <argument><expr><literal type="string">"-UNBLOCKED client unblocked via CLIENT UNBLOCK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>replyToBlockedClientTimedOut</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>unblockClient</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"setname"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                              <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
        <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Setting the client name to an empty string actually removes
         * the current name. */</comment>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Otherwise check if the charset is ok. We need to do this otherwise
         * CLIENT LIST format will break. You should always be able to
         * split by space to get the different fields. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'!'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* ASCII is assumed. */</comment>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"Client names cannot contain spaces, "</literal>
                    <literal type="string">"newlines or special characters."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"getname"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"pause"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>duration</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getTimeoutFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>duration</name></expr></argument>,<argument><expr><name>UNIT_MILLISECONDS</name></expr></argument>)</argument_list></call>
                                        <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pauseClients</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This callback is bound to POST and "Host:" command names. Those are not
 * really commands, but are used in security attacks in order to talk to
 * Redis instances via HTTP, with a technique called "cross protocol scripting"
 * which exploits the fact that services like Redis will discard invalid
 * HTTP headers and will process what follows.
 *
 * As a protection against this attack, Redis will terminate the connection
 * when a POST or "Host:" header is seen, and will log the event from
 * time to time (to avoid creating a DOS as a result of too many logs). */</comment>
<function><type><name>void</name></type> <name>securityWarningCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>logged_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>labs</name><argument_list>(<argument><expr><name>now</name><operator>-</operator><name>logged_time</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">60</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>logged_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Rewrite the command vector of the client. All the new objects ref count
 * is incremented. The old command vector is freed, and the old objects
 * ref count is decremented. */</comment>
<function><type><name>void</name></type> <name>rewriteClientCommandVector</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt> <comment type="block">/* The new argument vector */</comment>

    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* We free the objects in the original vector at the end, so we are
     * sure that if the same objects are reused in the new vector the
     * refcount gets incremented before it gets decremented. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Replace argv and argc with our new versions. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <call><name>lookupCommandOrOriginal</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Completely replace the client command vector with the provided one. */</comment>
<function><type><name>void</name></type> <name>replaceClientCommandVector</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>freeClientArgv</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <call><name>lookupCommandOrOriginal</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Rewrite a single item in the command vector.
 * The new val ref count is incremented, and the old decremented.
 *
 * It is possible to specify an argument over the current size of the
 * argument vector: in this case the array of objects gets reallocated
 * and c-&gt;argc set to the max value. However it's up to the caller to
 *
 * 1. Make sure there are no "holes" and all the arguments are set.
 * 2. If the original argument vector was longer than the one we
 *    want to end with, it's up to the caller to set c-&gt;argc and
 *    free the no longer used objects on c-&gt;argv. */</comment>
<function><type><name>void</name></type> <name>rewriteClientCommandArgument</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>oldval</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_ULONG) */</comment>
        <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <init>= <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>oldval</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>oldval</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If this is the command name make sure to fix c-&gt;cmd. */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <call><name>lookupCommandOrOriginal</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function returns the number of bytes that Redis is
 * using to store the reply still not read by the client.
 *
 * Note: this function is very fast so can be called as many time as
 * the caller wishes. The main usage of this function currently is
 * enforcing the client output length limits. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>getClientOutputBufferMemoryUsage</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>list_item_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>listNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clientReplyBlock</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>+</operator> <operator>(</operator><name>list_item_size</name><operator>*</operator><call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the class of a client, used in order to enforce limits to different
 * classes of clients.
 *
 * The function will return one of the following:
 * CLIENT_TYPE_NORMAL -&gt; Normal client
 * CLIENT_TYPE_SLAVE  -&gt; Slave
 * CLIENT_TYPE_PUBSUB -&gt; Client subscribed to Pub/Sub channels
 * CLIENT_TYPE_MASTER -&gt; The client representing our replication master.
 */</comment>
<function><type><name>int</name></type> <name>getClientType</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_MASTER</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Even though MONITOR clients are marked as replicas, we
     * want the expose them as normal clients. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MONITOR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>CLIENT_TYPE_SLAVE</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PUBSUB</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_PUBSUB</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>CLIENT_TYPE_NORMAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getClientTypeByName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"normal"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_NORMAL</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"slave"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_SLAVE</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"replica"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_SLAVE</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"pubsub"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_PUBSUB</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"master"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CLIENT_TYPE_MASTER</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>getClientTypeName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch<condition>(<expr><name>class</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CLIENT_TYPE_NORMAL</name></expr>:</case> <return>return <expr><literal type="string">"normal"</literal></expr>;</return>
    <case>case <expr><name>CLIENT_TYPE_SLAVE</name></expr>:</case>  <return>return <expr><literal type="string">"slave"</literal></expr>;</return>
    <case>case <expr><name>CLIENT_TYPE_PUBSUB</name></expr>:</case> <return>return <expr><literal type="string">"pubsub"</literal></expr>;</return>
    <case>case <expr><name>CLIENT_TYPE_MASTER</name></expr>:</case> <return>return <expr><literal type="string">"master"</literal></expr>;</return>
    <default>default:</default>                       <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* The function checks if the client reached output buffer soft or hard
 * limit, and also update the state needed to check the soft limit as
 * a side effect.
 *
 * Return value: non-zero if the client reached the soft or the hard limit.
 *               Otherwise zero is returned. */</comment>
<function><type><name>int</name></type> <name>checkClientOutputBufferLimits</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>soft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>hard</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>used_mem</name> <init>= <expr><call><name>getClientOutputBufferMemoryUsage</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>class</name> <operator>=</operator> <call><name>getClientType</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* For the purpose of output buffer limiting, masters are handled
     * like normal clients. */</comment>
    <if_stmt><if>if <condition>(<expr><name>class</name> <operator>==</operator> <name>CLIENT_TYPE_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>class</name> <operator>=</operator> <name>CLIENT_TYPE_NORMAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>client_obuf_limits</name><index>[<expr><name>class</name></expr>]</index></name><operator>.</operator><name>hard_limit_bytes</name> <operator>&amp;&amp;</operator>
        <name>used_mem</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>client_obuf_limits</name><index>[<expr><name>class</name></expr>]</index></name><operator>.</operator><name>hard_limit_bytes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hard</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>client_obuf_limits</name><index>[<expr><name>class</name></expr>]</index></name><operator>.</operator><name>soft_limit_bytes</name> <operator>&amp;&amp;</operator>
        <name>used_mem</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>client_obuf_limits</name><index>[<expr><name>class</name></expr>]</index></name><operator>.</operator><name>soft_limit_bytes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>soft</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need to check if the soft limit is reached continuously for the
     * specified amount of seconds. */</comment>
    <if_stmt><if>if <condition>(<expr><name>soft</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>obuf_soft_limit_reached_time</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>obuf_soft_limit_reached_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>soft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* First time we see the soft limit reached */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>time_t</name></type> <name>elapsed</name> <init>= <expr><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>c</name><operator>-&gt;</operator><name>obuf_soft_limit_reached_time</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&lt;=</operator>
                <name><name>server</name><operator>.</operator><name>client_obuf_limits</name><index>[<expr><name>class</name></expr>]</index></name><operator>.</operator><name>soft_limit_seconds</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>soft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* The client still did not reached the max number of
                             seconds for the soft limit to be considered
                             reached. */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>obuf_soft_limit_reached_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>soft</name> <operator>||</operator> <name>hard</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Asynchronously close a client if soft or hard limit is reached on the
 * output buffer size. The caller can check if the client will be closed
 * checking if the client CLIENT_CLOSE_ASAP flag is set.
 *
 * Note: we need to close the client asynchronously because this function is
 * called from contexts where the client can't be freed safely, i.e. from the
 * lower level functions pushing data inside the client output buffers. */</comment>
<function><type><name>void</name></type> <name>asyncCloseClientOnOutputBufferLimitReached</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* It is unsafe to free fake clients. */</comment>
    <macro><name>POSIX_ONLY</name><argument_list>(<argument>serverAssert(c-&gt;reply_bytes &lt; PORT_ULONG_MAX-(<literal type="number">1024</literal>*<literal type="number">64</literal>));</argument>)</argument_list></macro>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_CLOSE_ASAP</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>checkClientOutputBufferLimits</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>client</name> <init>= <expr><call><name>catClientInfoString</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Client %s scheduled to be closed ASAP for overcoming of output buffer limits."</literal></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function used by freeMemoryIfNeeded() in order to flush slaves
 * output buffers without returning control to the event loop.
 * This is also called by SHUTDOWN for a best-effort attempt to send
 * slaves the latest writes. */</comment>
<function><type><name>void</name></type> <name>flushSlavesOutputBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>events</name> <init>= <expr><call><name>aeGetFileEvents</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>can_receive_writes</name> <init>= <expr><operator>(</operator><name>events</name> <operator>&amp;</operator> <name>AE_WRITABLE</name><operator>)</operator> <operator>||</operator>
                                 <operator>(</operator><name><name>slave</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PENDING_WRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We don't want to send the pending data to the replica in a few
         * cases:
         *
         * 1. For some reason there is neither the write handler installed
         *    nor the client is flagged as to have pending writes: for some
         *    reason this replica may not be set to receive data. This is
         *    just for the sake of defensive programming.
         *
         * 2. The put_online_on_ack flag is true. To know why we don't want
         *    to send data to the replica in this case, please grep for the
         *    flag for this flag.
         *
         * 3. Obviously if the slave is not ONLINE.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_ONLINE</name> <operator>&amp;&amp;</operator>
            <name>can_receive_writes</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name><name>slave</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name> <operator>&amp;&amp;</operator>
            <call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>writeToClient</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>slave</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Pause clients up to the specified unixtime (in ms). While clients
 * are paused no command is processed from clients, so the data set can't
 * change during that time.
 *
 * However while this function pauses normal and Pub/Sub clients, slaves are
 * still served, so this function can be used on server upgrades where it is
 * required that slaves process the latest bytes from the replication stream
 * before being turned to masters.
 *
 * This function is also internally used by Redis Cluster for the manual
 * failover procedure implemented by CLUSTER FAILOVER.
 *
 * The function always succeed, even if there is already a pause in progress.
 * In such a case, the pause is extended if the duration is more than the
 * time left for the previous duration. However if the duration is smaller
 * than the time left for the previous pause, no change is made to the
 * left duration. */</comment>
<function><type><name>void</name></type> <name>pauseClients</name><parameter_list>(<parameter><decl><type><name>mstime_t</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>clients_paused</name></name> <operator>||</operator> <name>end</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>clients_pause_end_time</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>clients_pause_end_time</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>clients_paused</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if clients are currently paused. As a side effect the
 * function checks if the pause time was reached and clear it. */</comment>
<function><type><name>int</name></type> <name>clientsArePaused</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>clients_paused</name></name> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>clients_pause_end_time</name></name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>mstime</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>clients_paused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Put all the clients in the unblocked clients queue in order to
         * force the re-processing of the input buffer if any. */</comment>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Don't touch slaves and blocked clients.
             * The latter pending requests will be processed when unblocked. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_SLAVE</name><operator>|</operator><name>CLIENT_BLOCKED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>queueClientForReprocessing</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>server</name><operator>.</operator><name>clients_paused</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called by Redis in order to process a few events from
 * time to time while blocked into some not interruptible operation.
 * This allows to reply to clients with the -LOADING error while loading the
 * data set at startup or after a full resynchronization with the master
 * and so forth.
 *
 * It calls the event loop in order to process a few events. Specifically we
 * try to call the event loop 4 times as long as we receive acknowledge that
 * some event was processed, in order to go forward with the accept, read,
 * write, close sequence needed to serve a client.
 *
 * The function returns the total number of events processed. */</comment>
<function><type><name>int</name></type> <name>processEventsWhileBlocked</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iterations</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* See the function top-comment. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>iterations</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>events</name> <operator>+=</operator> <call><name>aeProcessEvents</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name>AE_FILE_EVENTS</name><operator>|</operator><name>AE_DONT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>events</name> <operator>+=</operator> <call><name>handleClientsWithPendingWrites</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>events</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>events</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>
</unit>
