<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/dict.c"><comment type="block">/* Hash Tables Implementation.
 *
 * This file implements in memory hash tables with insert/del/replace/find/
 * get-random-element operations. Hash tables will auto resize if needed
 * tables of power of two in size are used, collisions are handled by
 * chaining. See the source code for more information... :)
 *
 * Copyright (c) 2006-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32fixes.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>extern</specifier> <name>BOOL</name></type> <name>g_IsForkedProcess</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmacros.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DICT_BENCHMARK_MAIN</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"redisassert.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Using dictEnableResize() / dictDisableResize() we make possible to
 * enable/disable resizing of the hash table as needed. This is very important
 * for Redis, as we use copy-on-write and don't want to move too much memory
 * around when there is a child performing saving operations.
 *
 * Note that even when dict_can_resize is set to 0, not all resizes are
 * prevented: a hash table is still allowed to grow if the ratio between
 * the number of elements and the buckets &gt; dict_force_resize_ratio. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dict_can_resize</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>dict_force_resize_ratio</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* -------------------------- private prototypes ---------------------------- */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_dictExpandIfNeeded</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PORT_ULONG</name></type> <name>_dictNextPower</name><parameter_list>(<parameter><decl><type><name>PORT_ULONG</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PORT_LONG</name></type> <name>_dictKeyIndex</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>dictEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>existing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_dictInit</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>dictType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privDataPtr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* -------------------------- hash functions -------------------------------- */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name><name>dict_hash_function_seed</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>dictSetHashFunctionSeed</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dict_hash_function_seed</name></expr></argument>,<argument><expr><name>seed</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dict_hash_function_seed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint8_t</name> <modifier>*</modifier></type><name>dictGetHashFunctionSeed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name>dict_hash_function_seed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The default hashing function uses SipHash implementation
 * in siphash.c. */</comment>

<function_decl><type><name>uint64_t</name></type> <name>siphash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>inlen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uint64_t</name></type> <name>siphash_nocase</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>inlen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>uint64_t</name></type> <name>dictGenHashFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>siphash</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>dict_hash_function_seed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>dictGenCaseHashFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>siphash_nocase</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>dict_hash_function_seed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------- API implementation ------------------------- */</comment>

<comment type="block">/* Reset a hash table already initialized with ht_init().
 * NOTE: This function should only be called by ht_destroy(). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_dictReset</name><parameter_list>(<parameter><decl><type><name>dictht</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>sizemask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a new hash table */</comment>
<function><type><name>dict</name> <modifier>*</modifier></type><name>dictCreate</name><parameter_list>(<parameter><decl><type><name>dictType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
        <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privDataPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>_dictInit</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>type</name></expr></argument>,<argument><expr><name>privDataPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize the hash table */</comment>
<function><type><name>int</name></type> <name>_dictInit</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>dictType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
        <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privDataPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>_dictReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_dictReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>privdata</name></name> <operator>=</operator> <name>privDataPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iterators</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>DICT_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Resize the table to the minimal size that contains all the elements,
 * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</comment>
<function><type><name>int</name></type> <name>dictResize</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>minimal</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dict_can_resize</name> <operator>||</operator> <call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>DICT_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>minimal</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name></expr>;</expr_stmt>                                               <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <if_stmt><if>if <condition>(<expr><name>minimal</name> <operator>&lt;</operator> <name>DICT_HT_INITIAL_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>minimal</name> <operator>=</operator> <name>DICT_HT_INITIAL_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>minimal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Expand or create the hash table */</comment>
<function><type><name>int</name></type> <name>dictExpand</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>DICT_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>dictht</name></type> <name>n</name></decl>;</decl_stmt> <comment type="block">/* the new hash table */</comment>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>realsize</name> <init>= <expr><call><name>_dictNextPower</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Rehashing to the same table size is not useful. */</comment>
    <if_stmt><if>if <condition>(<expr><name>realsize</name> <operator>==</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>DICT_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Allocate the new hash table and initialize all pointers to NULL */</comment>
    <expr_stmt><expr><name><name>n</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>realsize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>.</operator><name>sizemask</name></name> <operator>=</operator> <name>realsize</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>.</operator><name>table</name></name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><name>realsize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>.</operator><name>used</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>                                                        <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (size_t) */</comment>

    <comment type="block">/* Is this the first initialization? If so it's not really a rehashing
     * we just set the first hash table so that it can accept keys. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>table</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        <return>return <expr><name>DICT_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Prepare a second hash table for incremental rehashing */</comment>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>DICT_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */</comment>
<function><type><name>int</name></type> <name>dictRehash</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <comment type="line">// On Windows we choose not to execute the dict rehash since it's not</comment>
    <comment type="line">// necessary and it may have a performance impact.</comment>
    <macro><name>WIN32_ONLY</name><argument_list>(<argument>if (g_IsForkedProcess) return <literal type="number">0</literal>;</argument>)</argument_list></macro>

    <decl_stmt><decl><type><name>int</name></type> <name>empty_visits</name> <init>= <expr><name>n</name><operator>*</operator><literal type="number">10</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Max number of empty buckets to visit. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <while>while<condition>(<expr><name>n</name><operator>--</operator> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextde</name></decl>;</decl_stmt>

        <comment type="block">/* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name> <operator>&gt;</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>empty_visits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>de</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="block">/* Move all the keys in this bucket from the old to the new hash HT */</comment>
        <while>while<condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>nextde</name> <operator>=</operator> <name><name>de</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <comment type="block">/* Get the index in the new hash table */</comment>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>dictHashKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>de</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>de</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>used</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>de</name> <operator>=</operator> <name>nextde</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Check if we already rehashed the whole table... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_dictReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* More to rehash... */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>PORT_LONGLONG</name></type> <name>timeInMilliseconds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <return>return <expr><call><name>GetHighResRelativeTime</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator><operator>*</operator><literal type="number">1000</literal><operator>)</operator><operator>+</operator><operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name><operator>/</operator><literal type="number">1000</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</comment>
<function><type><name>int</name></type> <name>dictRehashMilliseconds</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name> <init>= <expr><call><name>timeInMilliseconds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rehashes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><call><name>dictRehash</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rehashes</name> <operator>+=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>timeInMilliseconds</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name> <operator>&gt;</operator> <name>ms</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>rehashes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function performs just a step of rehashing, and only if there are
 * no safe iterators bound to our hash table. When we have iterators in the
 * middle of a rehashing we can't mess with the two hash tables otherwise
 * some element can be missed or duplicated.
 *
 * This function is called by common lookup or update operations in the
 * dictionary so that the hash table automatically migrates from H1 to H2
 * while it is actively used. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>_dictRehashStep</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>iterators</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictRehash</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Add an element to the target hash table */</comment>
<function><type><name>int</name></type> <name>dictAdd</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>dictAddRaw</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>DICT_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>dictSetVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>DICT_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Low level add or find:
 * This function adds the entry but instead of setting a value returns the
 * dictEntry structure to the user, that will make sure to fill the value
 * field as he wishes.
 *
 * This function is also directly exposed to the user API to be called
 * mainly in order to store non-pointers inside the hash value, example:
 *
 * entry = dictAddRaw(dict,mykey,NULL);
 * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
 *
 * Return values:
 *
 * If key already exists NULL is returned, and "*existing" is populated
 * with the existing entry if existing is not NULL.
 *
 * If key was added, the hash entry is returned to be manipulated by the caller.
 */</comment>
<function><type><name>dictEntry</name> <modifier>*</modifier></type><name>dictAddRaw</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>dictEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictht</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_dictRehashStep</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get the index of the new element, or -1 if
     * the element already exists. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>index</name> <operator>=</operator> <call><name>_dictKeyIndex</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>dictHashKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Allocate the memory and store the new entry.
     * Insert the element in top, with the assumption that in a database
     * system it is more likely that recently added entries are accessed
     * more frequently. */</comment>
    <expr_stmt><expr><name>ht</name> <operator>=</operator> <ternary><condition><expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>used</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Set the hash entry fields. */</comment>
    <expr_stmt><expr><call><name>dictSetKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add or Overwrite:
 * Add an element, discarding the old value if the key already exists.
 * Return 1 if the key was added from scratch, 0 if there was already an
 * element with such key and dictReplace() just performed a value update
 * operation. */</comment>
<function><type><name>int</name></type> <name>dictReplace</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>existing</name></decl>, <decl><type ref="prev"/><name>auxentry</name></decl>;</decl_stmt>

    <comment type="block">/* Try to add the element. If the key
     * does not exists dictAdd will succeed. */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>dictAddRaw</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dictSetVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set the new value and free the old one. Note that it is important
     * to do that in this order, as the value may just be exactly the same
     * as the previous one. In this context, think to reference counting,
     * you want to increment (set), and then decrement (free), and not the
     * reverse. */</comment>
    <expr_stmt><expr><name>auxentry</name> <operator>=</operator> <operator>*</operator><name>existing</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictSetVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictFreeVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auxentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add or Find:
 * dictAddOrFind() is simply a version of dictAddRaw() that always
 * returns the hash entry of the specified key, even if the key already
 * exists and can't be added (in that case the entry of the already
 * existing key is returned.)
 *
 * See dictAddRaw() for more information. */</comment>
<function><type><name>dictEntry</name> <modifier>*</modifier></type><name>dictAddOrFind</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>existing</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>dictAddRaw</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>entry</name></expr> ?</condition><then> <expr><name>entry</name></expr> </then><else>: <expr><name>existing</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search and remove an element. This is an helper function for
 * dictDelete() and dictUnlink(), please check the top comment
 * of those functions. */</comment>
<function><type><specifier>static</specifier> <name>dictEntry</name> <modifier>*</modifier></type><name>dictGenericDelete</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nofree</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prevHe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>table</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_dictRehashStep</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>dictHashKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>table</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>table</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>h</name> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prevHe</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>key</name><operator>==</operator><name><name>he</name><operator>-&gt;</operator><name>key</name></name> <operator>||</operator> <call><name>dictCompareKeys</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>he</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Unlink the element from the list */</comment>
                <if_stmt><if>if <condition>(<expr><name>prevHe</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>prevHe</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nofree</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>dictFreeKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>dictFreeVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>used</name><operator>--</operator></expr>;</expr_stmt>
                <return>return <expr><name>he</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>prevHe</name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* not found */</comment>
</block_content>}</block></function>

<comment type="block">/* Remove an element, returning DICT_OK on success or DICT_ERR if the
 * element was not found. */</comment>
<function><type><name>int</name></type> <name>dictDelete</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><call><name>dictGenericDelete</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DICT_OK</name></expr> </then><else>: <expr><name>DICT_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove an element from the table, but without actually releasing
 * the key, value and dictionary entry. The dictionary entry is returned
 * if the element was found (and unlinked from the table), and the user
 * should later call `dictFreeUnlinkedEntry()` with it in order to release it.
 * Otherwise if the key is not found, NULL is returned.
 *
 * This function is useful when we want to remove something from the hash
 * table but want to use its value before actually deleting the entry.
 * Without this function the pattern would require two lookups:
 *
 *  entry = dictFind(...);
 *  // Do something with entry
 *  dictDelete(dictionary,entry);
 *
 * Thanks to this function it is possible to avoid this, and use
 * instead:
 *
 * entry = dictUnlink(dictionary,entry);
 * // Do something with entry
 * dictFreeUnlinkedEntry(entry); // &lt;- This does not need to lookup again.
 */</comment>
<function><type><name>dictEntry</name> <modifier>*</modifier></type><name>dictUnlink</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictGenericDelete</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* You need to call this function to really free the entry after a call
 * to dictUnlink(). It's safe to call this function with 'he' = NULL. */</comment>
<function><type><name>void</name></type> <name>dictFreeUnlinkedEntry</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>he</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>dictFreeKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictFreeVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Destroy an entire dictionary */</comment>
<function><type><name>int</name></type> <name>_dictClear</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>dictht</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type>(<name>callback</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Free all the elements */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>ht</name><operator>-&gt;</operator><name>used</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextHe</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>callback</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">65535</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>privdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>he</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nextHe</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictFreeKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictFreeVal</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>used</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <name>nextHe</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>
    <comment type="block">/* Free the table and the allocated cache structure */</comment>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Re-initialize the table */</comment>
    <expr_stmt><expr><call><name>_dictReset</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>DICT_OK</name></expr>;</return> <comment type="block">/* never fails */</comment>
</block_content>}</block></function>

<comment type="block">/* Clear &amp; Release the hash table */</comment>
<function><type><name>void</name></type> <name>dictRelease</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>_dictClear</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_dictClear</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>dictEntry</name> <modifier>*</modifier></type><name>dictFind</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* dict is empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_dictRehashStep</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>dictHashKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>table</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>table</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>h</name> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>key</name><operator>==</operator><name><name>he</name><operator>-&gt;</operator><name>key</name></name> <operator>||</operator> <call><name>dictCompareKeys</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>he</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>he</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>dictFetchValue</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>he</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>he</name></expr> ?</condition><then> <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* A fingerprint is a 64 bit number that represents the state of the dictionary
 * at a given time, it's just a few dict properties xored together.
 * When an unsafe iterator is initialized, we get the dict fingerprint, and check
 * the fingerprint again when the iterator is released.
 * If the two fingerprints are different it means that the user of the iterator
 * performed forbidden operations against the dictionary while iterating. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>dictFingerprint</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name><name>integers</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>integers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>table</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>integers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>integers</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>integers</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>table</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>integers</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>integers</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>used</name></expr>;</expr_stmt>

    <comment type="block">/* We hash N integers by summing every successive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result = hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in a different order will (likely) hash
     * to a different number. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>hash</name> <operator>+=</operator> <name><name>integers</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="block">/* For the hashing step we use Tomas Wang's 64 bit integer hash. */</comment>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><operator>~</operator><name>hash</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">21</literal><operator>)</operator></expr>;</expr_stmt> <comment type="line">// hash = (hash &lt;&lt; 21) - hash - 1;</comment>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><name>hash</name> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt> <comment type="line">// hash * 265</comment>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><name>hash</name> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt> <comment type="line">// hash * 21</comment>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name> <operator>^</operator> <operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">28</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name> <operator>+</operator> <operator>(</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>dictIterator</name> <modifier>*</modifier></type><name>dictGetIterator</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>safe</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>nextEntry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>dictIterator</name> <modifier>*</modifier></type><name>dictGetSafeIterator</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>safe</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>dictEntry</name> <modifier>*</modifier></type><name>dictNext</name><parameter_list>(<parameter><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>entry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>dictht</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name><name>iter</name><operator>-&gt;</operator><name>table</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>iter</name><operator>-&gt;</operator><name>table</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>d</name><operator>-&gt;</operator><name>iterators</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>fingerprint</name></name> <operator>=</operator> <call><name>dictFingerprint</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>index</name></name> <operator>&gt;=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>d</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>iter</name><operator>-&gt;</operator><name>table</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>table</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ht</name> <operator>=</operator> <operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name><name>iter</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>nextEntry</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>entry</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We need to save the 'next' here, the iterator user
             * may delete the entry we are returning. */</comment>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>nextEntry</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>entry</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dictReleaseIterator</name><parameter_list>(<parameter><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>iter</name><operator>-&gt;</operator><name>table</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>safe</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>d</name><operator>-&gt;</operator><name>iterators</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>fingerprint</name></name> <operator>==</operator> <call><name>dictFingerprint</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>d</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return a random entry from the hash table. Useful to
 * implement randomized algorithms */</comment>
<function><type><name>dictEntry</name> <modifier>*</modifier></type><name>dictGetRandomKey</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>orighe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>h</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>listlen</name></decl>, <decl><type ref="prev"/><name>listele</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>_dictRehashStep</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <do>do <block>{<block_content>
            <comment type="block">/* We are sure there are no elements in indexes from 0
             * to rehashidx-1 */</comment>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name> <operator>+</operator> <operator>(</operator><call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name> <operator>+</operator>     <name>WIN_PORT_FIX</name> <comment type="block">/* cast (PORT_ULONG) */</comment>
                                            <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>size</name> <operator>-</operator>
                                            <name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>h</name> <operator>&gt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>h</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name></expr>]</index></name></expr> </then><else>:
                                      <expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>h</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block> while<condition>(<expr><name>he</name> <operator>==</operator> <name>NULL</name></expr>)</condition>;</do>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <do>do <block>{<block_content>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block> while<condition>(<expr><name>he</name> <operator>==</operator> <name>NULL</name></expr>)</condition>;</do>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Now we found a non empty bucket, but it is a linked
     * list and we need to get a random element from the list.
     * The only sane way to do so is counting the elements and
     * select a random index. */</comment>
    <expr_stmt><expr><name>listlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>orighe</name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>listlen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>listele</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <name>listlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>he</name> <operator>=</operator> <name>orighe</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>listele</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
    <return>return <expr><name>he</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function samples the dictionary to return a few keys from random
 * locations.
 *
 * It does not guarantee to return all the keys specified in 'count', nor
 * it does guarantee to return non-duplicated elements, however it will make
 * some effort to do both things.
 *
 * Returned pointers to hash table entries are stored into 'des' that
 * points to an array of dictEntry pointers. The array must have room for
 * at least 'count' elements, that is the argument we pass to the function
 * to tell how many random elements we need.
 *
 * The function returns the number of items stored into 'des', that may
 * be less than 'count' if the hash table has less than 'count' elements
 * inside, or if not enough elements were found in a reasonable amount of
 * steps.
 *
 * Note that this function is not suitable when you need a good distribution
 * of the returned items, but only when you need to "sample" a given number
 * of continuous elements to run some kind of algorithm or to produce
 * statistics. However the function is much faster than dictGetRandomKey()
 * at producing N elements. */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>dictGetSomeKeys</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>dictEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>des</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>j</name></decl>;</decl_stmt> <comment type="block">/* internal hash table id, 0 or 1. */</comment>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>tables</name></decl>;</decl_stmt> <comment type="block">/* 1 or 2 tables? */</comment>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>stored</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxsizemask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>maxsteps</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                 <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (unsigned int) */</comment>
    <name>maxsteps</name> <init>= <expr><name>count</name><operator>*</operator><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Try to do a rehashing work proportional to 'count'. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_dictRehashStep</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>tables</name> <operator>=</operator> <ternary><condition><expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>maxsizemask</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>                             <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (unsigned int) */</comment>
    <if_stmt><if>if <condition>(<expr><name>tables</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>maxsizemask</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>maxsizemask</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>                         <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (unsigned int) */</comment>

    <comment type="block">/* Pick a random point inside the larger table. */</comment>
    <name>PORT_ULONG</name></type> <name>i</name> <init>= <expr><call><name>random</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>maxsizemask</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>emptylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Continuous empty entries so far. */</comment>
    <while>while<condition>(<expr><name>stored</name> <operator>&lt;</operator> <name>count</name> <operator>&amp;&amp;</operator> <name>maxsteps</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>tables</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* Invariant of the dict.c rehashing: up to the indexes already
             * visited in ht[0] during the rehashing, there are no populated
             * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */</comment>
            <if_stmt><if>if <condition>(<expr><name>tables</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Moreover, if we are currently out of range in the second
                 * table, there will be no elements in both tables up to
                 * the current rehashing index, so we jump if possible.
                 * (this happens when going from big to small table). */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>        <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (unsigned long) */</comment>
                <if_stmt><else>else<block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Out of range for this table. */</comment>
            <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Count contiguous empty buckets, and jump to other
             * locations if they reach 'count' (with a minimum of 5). */</comment>
            <if_stmt><if>if <condition>(<expr><name>he</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>emptylen</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>emptylen</name> <operator>&gt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name>emptylen</name> <operator>&gt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>maxsizemask</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>emptylen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>emptylen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Collect all the elements of the buckets found non
                     * empty while iterating. */</comment>
                    <expr_stmt><expr><operator>*</operator><name>des</name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>des</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>stored</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>stored</name> <operator>==</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>stored</name></expr>;</return></block_content></block></if></if_stmt>           <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (unsigned int) */</comment>
                </block_content>}</block></while>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>maxsizemask</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>stored</name></expr>;</return>                                                <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (unsigned int) */</comment>
</block_content>}</block></function>

<comment type="block">/* Function to reverse bits. Algorithm from:
 * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</comment>
<function><type><specifier>static</specifier> <name>PORT_ULONG</name></type> <name>rev</name><parameter_list>(<parameter><decl><type><name>PORT_ULONG</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>s</name> <init>= <expr><literal type="number">8</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt> <comment type="line">// bit size; must be power of 2</comment>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>mask</name> <init>= <expr><operator>~</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>^=</operator> <operator>(</operator><name>mask</name> <operator>&lt;&lt;</operator> <name>s</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <name>s</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <name>s</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>mask</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* dictScan() is used to iterate over the elements of a dictionary.
 *
 * Iterating works the following way:
 *
 * 1) Initially you call the function using a cursor (v) value of 0.
 * 2) The function performs one step of the iteration, and returns the
 *    new cursor value you must use in the next call.
 * 3) When the returned cursor is 0, the iteration is complete.
 *
 * The function guarantees all elements present in the
 * dictionary get returned between the start and end of the iteration.
 * However it is possible some elements get returned multiple times.
 *
 * For every element returned, the callback argument 'fn' is
 * called with 'privdata' as first argument and the dictionary entry
 * 'de' as second argument.
 *
 * HOW IT WORKS.
 *
 * The iteration algorithm was designed by Pieter Noordhuis.
 * The main idea is to increment a cursor starting from the higher order
 * bits. That is, instead of incrementing the cursor normally, the bits
 * of the cursor are reversed, then the cursor is incremented, and finally
 * the bits are reversed again.
 *
 * This strategy is needed because the hash table may be resized between
 * iteration calls.
 *
 * dict.c hash tables are always power of two in size, and they
 * use chaining, so the position of an element in a given table is given
 * by computing the bitwise AND between Hash(key) and SIZE-1
 * (where SIZE-1 is always the mask that is equivalent to taking the rest
 *  of the division between the Hash of the key and SIZE).
 *
 * For example if the current hash table size is 16, the mask is
 * (in binary) 1111. The position of a key in the hash table will always be
 * the last four bits of the hash output, and so forth.
 *
 * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?
 *
 * If the hash table grows, elements can go anywhere in one multiple of
 * the old bucket: for example let's say we already iterated with
 * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).
 *
 * If the hash table will be resized to 64 elements, then the new mask will
 * be 111111. The new buckets you obtain by substituting in ??1100
 * with either 0 or 1 can be targeted only by keys we already visited
 * when scanning the bucket 1100 in the smaller hash table.
 *
 * By iterating the higher bits first, because of the inverted counter, the
 * cursor does not need to restart if the table size gets bigger. It will
 * continue iterating using cursors without '1100' at the end, and also
 * without any other combination of the final 4 bits already explored.
 *
 * Similarly when the table size shrinks over time, for example going from
 * 16 to 8, if a combination of the lower three bits (the mask for size 8
 * is 111) were already completely explored, it would not be visited again
 * because we are sure we tried, for example, both 0111 and 1111 (all the
 * variations of the higher bit) so we don't need to test it again.
 *
 * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!
 *
 * Yes, this is true, but we always iterate the smaller table first, then
 * we test all the expansions of the current cursor into the larger
 * table. For example if the current cursor is 101 and we also have a
 * larger table of size 16, we also test (0)101 and (1)101 inside the larger
 * table. This reduces the problem back to having only one table, where
 * the larger one, if it exists, is just an expansion of the smaller one.
 *
 * LIMITATIONS
 *
 * This iterator is completely stateless, and this is a huge advantage,
 * including no additional memory used.
 *
 * The disadvantages resulting from this design are:
 *
 * 1) It is possible we return elements more than once. However this is usually
 *    easy to deal with in the application level.
 * 2) The iterator must return multiple elements per call, as it needs to always
 *    return all the keys chained in a given bucket, and all the expansions, so
 *    we are sure we don't miss keys moving during rehashing.
 * 3) The reverse cursor is somewhat hard to understand at first, but this
 *    comment is supposed to help.
 */</comment>
<function><type><name>PORT_ULONG</name></type> <name>dictScan</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
                       <parameter><decl><type><name>PORT_ULONG</name></type> <name>v</name></decl></parameter>,
                       <parameter><decl><type><name>dictScanFunction</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>,
                       <parameter><decl><type><name>dictScanBucketFunction</name><modifier>*</modifier></type> <name>bucketfn</name></decl></parameter>,
                       <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dictht</name> <modifier>*</modifier></type><name>t0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>m0</name></decl>, <decl><type ref="prev"/><name>m1</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>m0</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>t0</name><operator>-&gt;</operator><name>sizemask</name></name></expr>;</expr_stmt>                                          <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_ULONG) */</comment>

        <comment type="block">/* Emit entries at cursor */</comment>
        <if_stmt><if>if <condition>(<expr><name>bucketfn</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bucketfn</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t0</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>v</name> <operator>&amp;</operator> <name>m0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>de</name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>v</name> <operator>&amp;</operator> <name>m0</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>de</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fn</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>de</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Set unmasked bits so incrementing the reversed cursor
         * operates on the masked bits */</comment>
        <expr_stmt><expr><name>v</name> <operator>|=</operator> <operator>~</operator><name>m0</name></expr>;</expr_stmt>

        <comment type="block">/* Increment the reverse cursor */</comment>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rev</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rev</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Make sure t0 is the smaller and t1 is the bigger table */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>t0</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>t1</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>m0</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>t0</name><operator>-&gt;</operator><name>sizemask</name></name></expr>;</expr_stmt>                                          <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_ULONG) */</comment>
        <name>m1</name> <init>= <expr><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>t1</name><operator>-&gt;</operator><name>sizemask</name></name></expr></init></decl>;</decl_stmt>                                          <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_ULONG) */</comment>

        <comment type="block">/* Emit entries at cursor */</comment>
        <if_stmt><if>if <condition>(<expr><name>bucketfn</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bucketfn</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t0</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>v</name> <operator>&amp;</operator> <name>m0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>de</name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>v</name> <operator>&amp;</operator> <name>m0</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>de</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fn</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>de</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Iterate over indices in larger table that are the expansion
         * of the index pointed to by the cursor in the smaller table */</comment>
        <do>do <block>{<block_content>
            <comment type="block">/* Emit entries at cursor */</comment>
            <if_stmt><if>if <condition>(<expr><name>bucketfn</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bucketfn</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t1</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>v</name> <operator>&amp;</operator> <name>m1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>de</name> <operator>=</operator> <name><name>t1</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>v</name> <operator>&amp;</operator> <name>m1</name></expr>]</index></name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>de</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fn</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>, <argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>de</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* Increment the reverse cursor not covered by the smaller mask.*/</comment>
            <expr_stmt><expr><name>v</name> <operator>|=</operator> <operator>~</operator><name>m1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rev</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rev</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Continue while bits covered by mask difference is non-zero */</comment>
        </block_content>}</block> while <condition>(<expr><name>v</name> <operator>&amp;</operator> <operator>(</operator><name>m0</name> <operator>^</operator> <name>m1</name><operator>)</operator></expr>)</condition>;</do>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------- private functions ------------------------------ */</comment>

<comment type="block">/* Expand the hash table if needed */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_dictExpandIfNeeded</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Incremental rehashing already in progress. Return. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>DICT_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If the hash table is empty expand it to the initial size. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>DICT_HT_INITIAL_SIZE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>&gt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>dict_can_resize</name> <operator>||</operator>
         <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name><operator>/</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>size</name> <operator>&gt;</operator> <name>dict_force_resize_ratio</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>DICT_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Our hash table capability is a power of two */</comment>
<function><type><specifier>static</specifier> <name>PORT_ULONG</name></type> <name>_dictNextPower</name><parameter_list>(<parameter><decl><type><name>PORT_ULONG</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>i</name> <init>= <expr><name>DICT_HT_INITIAL_SIZE</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <name>PORT_LONG_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PORT_LONG_MAX</name> <operator>+</operator> <literal type="number">1LU</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>i</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Returns the index of a free slot that can be populated with
 * a hash entry for the given 'key'.
 * If the key already exists, -1 is returned
 * and the optional output parameter may be filled.
 *
 * Note that if we are in the process of rehashing the hash table, the
 * index is always returned in the context of the second (new) hash table. */</comment>
<function><type><specifier>static</specifier> <name>PORT_LONG</name></type> <name>_dictKeyIndex</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>dictEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>existing</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Expand the hash table if needed */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>_dictExpandIfNeeded</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_ERR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>table</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>table</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>hash</name> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>
        <comment type="block">/* Search if this slot does not already contain the given key */</comment>
        <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>key</name><operator>==</operator><name><name>he</name><operator>-&gt;</operator><name>key</name></name> <operator>||</operator> <call><name>dictCompareKeys</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>he</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>existing</name> <operator>=</operator> <name>he</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dictEmpty</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type>(<name>callback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>_dictClear</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_dictClear</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rehashidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iterators</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dictEnableResize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>dict_can_resize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dictDisableResize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>dict_can_resize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>dictGetHash</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictHashKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Finds the dictEntry reference by using pointer and pre-calculated hash.
 * oldkey is a dead pointer and should not be accessed.
 * the hash value should be provided using dictGetHash.
 * no string / key comparison is performed.
 * return value is the reference to the dictEntry if found, or NULL if not found. */</comment>
<function><type><name>dictEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>dictFindEntryRefByPtrAndHash</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>oldptr</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>hash</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>heref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* dict is empty */</comment>
    <for>for <control>(<init><expr><name>table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>table</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>table</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>hash</name> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>sizemask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>heref</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name><name>table</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>he</name> <operator>=</operator> <operator>*</operator><name>heref</name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>oldptr</name><operator>==</operator><name><name>he</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>heref</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>heref</name> <operator>=</operator> <operator>&amp;</operator><name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <operator>*</operator><name>heref</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------- Debugging ---------------------------------*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICT_STATS_VECTLEN</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<function><type><name>size_t</name></type> <name>_dictGetStatsHt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>dictht</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>chainlen</name></decl>, <decl><type ref="prev"/><name>maxchainlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>totchainlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name><name>clvector</name><index>[<expr><name>DICT_STATS_VECTLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>used</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>bufsize</name></expr></argument>,
            <argument><expr><literal type="string">"No stats available for empty dictionaries\n"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute stats. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DICT_STATS_VECTLEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>clvector</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>clvector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>slots</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* For each hash entry on this slot... */</comment>
        <expr_stmt><expr><name>chainlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>he</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>chainlen</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>he</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>clvector</name><index>[<expr><ternary><condition><expr><operator>(</operator><name>chainlen</name> <operator>&lt;</operator> <name>DICT_STATS_VECTLEN</name><operator>)</operator></expr> ?</condition><then> <expr><name>chainlen</name></expr> </then><else>: <expr><operator>(</operator><name>DICT_STATS_VECTLEN</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>chainlen</name> <operator>&gt;</operator> <name>maxchainlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxchainlen</name> <operator>=</operator> <name>chainlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>totchainlen</name> <operator>+=</operator> <name>chainlen</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Generate human readable stats. */</comment>
    <expr_stmt><expr><name>l</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>l</name></expr></argument>,<argument><expr><name>bufsize</name><operator>-</operator><name>l</name></expr></argument>,
        <argument><expr><literal type="string">"Hash table %d stats (%s):\n"</literal>
        <literal type="string">" table size: %Id\n"</literal>                                                      <name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
        <literal type="string">" number of elements: %Id\n"</literal>                                              <name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
        <literal type="string">" different slots: %Id\n"</literal>                                                 <name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
        <literal type="string">" max chain length: %Id\n"</literal>                                                <name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
        <literal type="string">" avg chain length (counted): %.02f\n"</literal>
        <literal type="string">" avg chain length (computed): %.02f\n"</literal>
        <literal type="string">" Chain length distribution:\n"</literal></expr></argument>,
        <argument><expr><name>tableid</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>tableid</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"main hash table"</literal></expr> </then><else>: <expr><literal type="string">"rehashing target"</literal></expr></else></ternary></expr></argument>,
        <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>used</name></name></expr></argument>, <argument><expr><name>slots</name></expr></argument>, <argument><expr><name>maxchainlen</name></expr></argument>,
        <argument><expr><operator>(</operator><name>float</name><operator>)</operator><name>totchainlen</name><operator>/</operator><name>slots</name></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>used</name></name><operator>/</operator><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DICT_STATS_VECTLEN</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>clvector</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>bufsize</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>l</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>l</name></expr></argument>,<argument><expr><name>bufsize</name><operator>-</operator><name>l</name></expr></argument>,
            <argument><expr><literal type="string">"   %s%Id: %Id (%.02f%%)\n"</literal></expr></argument>,                                          <argument><expr><ternary><condition><expr><call><name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
            <argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>DICT_STATS_VECTLEN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="string">"&gt;= "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>clvector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name><name>clvector</name><index>[<expr><name>i</name></expr>]</index></name><operator>/</operator><name><name>ht</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator><operator>*</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Unlike snprintf(), teturn the number of characters actually written. */</comment>
    <if_stmt><if>if <condition>(<expr><name>bufsize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buf</name><index>[<expr><name>bufsize</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dictGetStats</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>orig_buf</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>orig_bufsize</name> <init>= <expr><name>bufsize</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>_dictGetStatsHt</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>bufsize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufsize</name> <operator>-=</operator> <name>l</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>_dictGetStatsHt</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>bufsize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ht</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Make sure there is a NULL term at the end. */</comment>
    <if_stmt><if>if <condition>(<expr><name>orig_bufsize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>orig_buf</name><index>[<expr><name>orig_bufsize</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------- Benchmark ---------------------------------*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DICT_BENCHMARK_MAIN</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sds.h"</cpp:file></cpp:include>

<function><type><name>uint64_t</name></type> <name>hashCallback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictGenHashFunction</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>key</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>compareCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>,<decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DICT_NOTUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>key1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>l1</name> <operator>!=</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>DICT_NOTUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>dictType</name></type> <name>BenchmarkDictType</name> <init>= <expr><block>{
    <expr><name>hashCallback</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>compareCallback</name></expr>,
    <expr><name>freeCallback</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>start_benchmark</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>start = timeInMilliseconds()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>end_benchmark</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    elapsed = timeInMilliseconds()-start; \
    printf(msg ": %ld items in %lld ms\n", count, elapsed); \
} while(0);</cpp:value></cpp:define>

<comment type="block">/* dict-benchmark [count] */</comment>
<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>elapsed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BenchmarkDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">5000000</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>start_benchmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>end_benchmark</name><argument_list>(<argument><expr><literal type="string">"Inserting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><call><name>dictSize</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait for rehashing. */</comment>
    <while>while <condition>(<expr><call><name>dictIsRehashing</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dictRehashMilliseconds</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>start_benchmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>end_benchmark</name><argument_list>(<argument><expr><literal type="string">"Linear access of existing elements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>start_benchmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>end_benchmark</name><argument_list>(<argument><expr><literal type="string">"Linear access of existing elements (2nd round)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>start_benchmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>end_benchmark</name><argument_list>(<argument><expr><literal type="string">"Random access of existing elements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>start_benchmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'X'</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>de</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>end_benchmark</name><argument_list>(<argument><expr><literal type="string">"Accessing missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>start_benchmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">17</literal></expr>;</expr_stmt> <comment type="block">/* Change first number to letter. */</comment>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictAdd</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>end_benchmark</name><argument_list>(<argument><expr><literal type="string">"Removing and adding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
