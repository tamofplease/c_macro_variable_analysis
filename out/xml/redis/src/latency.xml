<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/latency.c"><comment type="block">/* The latency monitor allows to easily observe the sources of latency
 * in a Redis instance using the LATENCY command. Different latency
 * sources are monitored, like disk I/O, execution of commands, fork
 * system call, and so forth.
 *
 * ----------------------------------------------------------------------------
 *
 * Copyright (c) 2014, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<comment type="block">/* Dictionary type for latency events. */</comment>
<function><type><name>int</name></type> <name>dictStringKeyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key1</name></expr></argument>,<argument><expr><name>key2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>dictStringHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictGenHashFunction</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>                          <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>dictVanillaFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>dictType</name></type> <name>latencyTimeSeriesDictType</name> <init>= <expr><block>{
    <expr><name>dictStringHash</name></expr>,             <comment type="block">/* hash function */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* key dup */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* val dup */</comment>
    <expr><name>dictStringKeyCompare</name></expr>,       <comment type="block">/* key compare */</comment>
    <expr><name>dictVanillaFree</name></expr>,            <comment type="block">/* key destructor */</comment>
    <expr><name>dictVanillaFree</name></expr>             <comment type="block">/* val destructor */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ------------------------- Utility functions ------------------------------ */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<comment type="block">/* Returns 1 if Transparent Huge Pages support is enabled in the kernel.
 * Otherwise (or if we are unable to check) 0 is returned. */</comment>
<function><type><name>int</name></type> <name>THPIsEnabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/sys/kernel/mm/transparent_hugepage/enabled"</literal></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"[never]"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Report the amount of AnonHugePages in smap, in bytes. If the return
 * value of the function is non-zero, the process is being targeted by
 * THP support, and is likely to have memory usage / latency issues. */</comment>
<function><type><name>int</name></type> <name>THPGetAnonHugePagesSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>zmalloc_get_smap_bytes_by_field</name><argument_list>(<argument><expr><literal type="string">"AnonHugePages:"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>              <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
</block_content>}</block></function>

<comment type="block">/* ---------------------------- Latency API --------------------------------- */</comment>

<comment type="block">/* Latency monitor initialization. We just need to create the dictionary
 * of time series, each time serie is craeted on demand in order to avoid
 * having a fixed list to maintain. */</comment>
<function><type><name>void</name></type> <name>latencyMonitorInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>latencyTimeSeriesDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add the specified sample to the specified time series "event".
 * This function is usually called via latencyAddSampleIfNeeded(), that
 * is a macro that only adds the sample if the latency is higher than
 * server.latency_monitor_threshold. */</comment>
<function><type><name>void</name></type> <name>latencyAddSample</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name>mstime_t</name></type> <name>latency</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>;</decl_stmt>

    <comment type="block">/* Create the time series if it does not exist. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ts</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>,<argument><expr><call><name>zstrdup</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>latency</name> <operator>&gt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If the previous sample is in the same second, we update our old sample
     * if this latency is &gt; of the old one, or just return. */</comment>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>(</operator><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>+</operator> <name>LATENCY_TS_LEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>LATENCY_TS_LEN</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>prev</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>==</operator> <name>now</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>latency</name> <operator>&gt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>prev</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>prev</name></expr>]</index></name><operator>.</operator><name>latency</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>                       <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int32_t) */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name></expr>]</index></name><operator>.</operator><name>time</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                            <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int32_t) */</comment>
    <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name></expr>]</index></name><operator>.</operator><name>latency</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>latency</name></expr>;</expr_stmt>                            <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int32_t) */</comment>

    <name><name>ts</name><operator>-&gt;</operator><name>idx</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <name>LATENCY_TS_LEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reset data for the specified event, or all the events data if 'event' is
 * NULL.
 *
 * Note: this is O(N) even when event_to_reset is not NULL because makes
 * the code simpler and we have a small fixed max number of events. */</comment>
<function><type><name>int</name></type> <name>latencyResetEvent</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>event_to_reset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>event_to_reset</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><name>event_to_reset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>resets</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>resets</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------ Latency reporting (doctor) ---------------------- */</comment>

<comment type="block">/* Analyze the samples available for a given event and return a structure
 * populate with different metrics, average, MAD, min, max, and so forth.
 * Check latency.h definition of struct latenctStat for more info.
 * If the specified event has no elements the structure is populate with
 * zero values. */</comment>
<function><type><name>void</name></type> <name>analyzeLatencyForEvent</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>latencyStats</name></name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>sum</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>all_time_high</name></name> <operator>=</operator> <ternary><condition><expr><name>ts</name></expr> ?</condition><then> <expr><name><name>ts</name><operator>-&gt;</operator><name>max</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>avg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>mad</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>samples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>period</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* First pass, populate everything but the MAD. */</comment>
    <expr_stmt><expr><name>sum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LATENCY_TS_LEN</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>samples</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>samples</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>max</name></name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt>

        <comment type="block">/* Track the oldest event time in ls-&gt;period. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>period</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>&lt;</operator> <name><name>ls</name><operator>-&gt;</operator><name>period</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>period</name></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* So far avg is actually the sum of the latencies, and period is
     * the oldest event time. We need to make the first an average and
     * the second a range of seconds. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>samples</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>avg</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>sum</name> <operator>/</operator> <name><name>ls</name><operator>-&gt;</operator><name>samples</name></name><operator>)</operator></expr>;</expr_stmt>                                 <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int32_t) */</comment>
        <name><name>ls</name><operator>-&gt;</operator><name>period</name></name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>period</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>period</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>period</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Second pass, compute MAD. */</comment>
    <expr_stmt><expr><name>sum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LATENCY_TS_LEN</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>delta</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>ls</name><operator>-&gt;</operator><name>avg</name></name> <operator>-</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>sum</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>samples</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>mad</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>sum</name> <operator>/</operator> <name><name>ls</name><operator>-&gt;</operator><name>samples</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>                    <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int32_t) */</comment>
</block_content>}</block></function>

<comment type="block">/* Create a human readable report of latency events for this Redis instance. */</comment>
<function><type><name>sds</name></type> <name>createLatencyReport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>report</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_better_vm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Better virtual machines. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_slowlog_enabled</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Enable slowlog. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_slowlog_tuning</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Reconfigure slowlog. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_slowlog_inspect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Check your slowlog. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_disk_contention</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Try to lower disk contention. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_scheduler</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Intrinsic latency. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_data_writeback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* data=writeback. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_no_appendfsync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* don't fsync during rewrites. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_local_disk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Avoid remote disks. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_ssd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Use an SSD drive. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_write_load_info</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Print info about AOF and write load. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_hz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Use higher HZ. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_large_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Deletion of large objects. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_mass_eviction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Avoid mass eviction of keys. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_relax_fsync_policy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* appendfsync always is slow. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advise_disable_thp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* AnonHugePages detected. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>advices</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Return ASAP if the latency engine is disabled and it looks like it
     * was never enabled so far. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>latency_monitor_threshold</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"I'm sorry, Dave, I can't do that. Latency monitoring is disabled in this Redis instance. You may use \"CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;.\" in order to enable it. If we weren't in a deep space mission I'd suggest to take a look at http://redis.io/topics/latency-monitor.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>report</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Show all the events stats and add for each event some event-related
     * comment depending on the values. */</comment>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eventnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>latencyStats</name></name></type> <name>ls</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>ts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>eventnum</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>eventnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"Dave, I have observed latency spikes in this Redis instance. You don't mind talking about it, do you Dave?\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>analyzeLatencyForEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>report</name> <operator>=</operator> <macro><name>sdscatprintf</name><argument_list>(<argument>report</argument>,
            <argument><literal type="string">"%d. %s: %d latency spikes (average %Iums, mean deviation %Iums, period %.2f sec). Worst all time event %Iums."</literal></argument>,            <argument>WIN_PORT_FIX <comment type="block">/* %lu -&gt; %Iu */</comment>
            eventnum</argument>, <argument>event</argument>,
            <argument>ls.samples</argument>,
            <argument>(PORT_ULONG) ls.avg</argument>,
            <argument>(PORT_ULONG) ls.mad</argument>,
            <argument>(double) ls.period/ls.samples</argument>,
            <argument>(PORT_ULONG) ts-&gt;max</argument>)</argument_list></macro></expr>;</expr_stmt>

        <comment type="block">/* Fork */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"fork"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fork_quality</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>stat_fork_rate</name></name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>fork_quality</name> <operator>=</operator> <literal type="string">"terrible"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>advise_better_vm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>stat_fork_rate</name></name> <operator>&lt;</operator> <literal type="number">25</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>fork_quality</name> <operator>=</operator> <literal type="string">"poor"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>advise_better_vm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>stat_fork_rate</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>fork_quality</name> <operator>=</operator> <literal type="string">"good"</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>fork_quality</name> <operator>=</operator> <literal type="string">"excellent"</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>report</name></expr></argument>,
                <argument><expr><literal type="string">" Fork rate is %.2f GB/sec (%s)."</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>stat_fork_rate</name></name></expr></argument>,
                <argument><expr><name>fork_quality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Potentially commands. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>slowlog_log_slower_than</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>advise_slowlog_enabled</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>slowlog_log_slower_than</name></name><operator>/</operator><literal type="number">1000</literal> <operator>&gt;</operator>
                       <name><name>server</name><operator>.</operator><name>latency_monitor_threshold</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>advise_slowlog_tuning</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>advise_slowlog_inspect</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_large_objects</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* fast-command. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"fast-command"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_scheduler</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* AOF and I/O. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-write-pending-fsync"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_local_disk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_disk_contention</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_ssd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_data_writeback</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-write-active-child"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_no_appendfsync</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_data_writeback</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_ssd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-write-alone"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_local_disk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_data_writeback</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_ssd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-fsync-always"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_relax_fsync_policy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-fstat"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"rdb-unlik-temp-file"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_disk_contention</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_local_disk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-rewrite-diff-write"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"aof-rename"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_write_load_info</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_data_writeback</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_ssd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_local_disk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Expire cycle. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"expire-cycle"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_hz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advise_large_objects</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Eviction cycle. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"eviction-del"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_large_objects</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><literal type="string">"eviction-cycle"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>advise_mass_eviction</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add non event based advices. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>THPGetAnonHugePagesSize</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>advise_disable_thp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>advices</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>eventnum</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>advices</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"Dave, no latency spike was observed during the lifetime of this Redis instance, not in the slightest bit. I honestly think you ought to sit down calmly, take a stress pill, and think things over.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eventnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>advices</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"\nWhile there are latency events logged, I'm not able to suggest any easy fix. Please use the Redis community to get some help, providing this report in your help request.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Add all the suggestions accumulated so far. */</comment>

        <comment type="block">/* Better VM. */</comment>
        <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"\nI have a few advices for you:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>advise_better_vm</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- If you are using a virtual machine, consider upgrading it with a faster one using an hypervisior that provides less latency during fork() calls. Xen is known to have poor fork() performance. Even in the context of the same VM provider, certain kinds of instances can execute fork faster than others.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Slow log. */</comment>
        <if_stmt><if>if <condition>(<expr><name>advise_slowlog_enabled</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- There are latency issues with potentially slow commands you are using. Try to enable the Slow Log Redis feature using the command 'CONFIG SET slowlog-log-slower-than %llu'. If the Slow log is disabled Redis is not able to log slow commands execution for you.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator><name><name>server</name><operator>.</operator><name>latency_monitor_threshold</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_slowlog_tuning</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Your current Slow Log configuration only logs events that are slower than your configured latency monitor threshold. Please use 'CONFIG SET slowlog-log-slower-than %llu'.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator><name><name>server</name><operator>.</operator><name>latency_monitor_threshold</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_slowlog_inspect</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Check your Slow Log to understand what are the commands you are running which are too slow to execute. Please check http://redis.io/commands/slowlog for more information.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Intrinsic latency. */</comment>
        <if_stmt><if>if <condition>(<expr><name>advise_scheduler</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- The system is slow to execute Redis code paths not containing system calls. This usually means the system does not provide Redis CPU time to run for long periods. You should try to:\n"</literal>
            <literal type="string">"  1) Lower the system load.\n"</literal>
            <literal type="string">"  2) Use a computer / VM just for Redis if you are running other softawre in the same system.\n"</literal>
            <literal type="string">"  3) Check if you have a \"noisy neighbour\" problem.\n"</literal>
            <literal type="string">"  4) Check with 'redis-cli --intrinsic-latency 100' what is the intrinsic latency in your system.\n"</literal>
            <literal type="string">"  5) Check if the problem is allocator-related by recompiling Redis with MALLOC=libc, if you are using Jemalloc. However this may create fragmentation problems.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* AOF / Disk latency. */</comment>
        <if_stmt><if>if <condition>(<expr><name>advise_local_disk</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- It is strongly advised to use local disks for persistence, especially if you are using AOF. Remote disks provided by platform-as-a-service providers are known to be slow.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_ssd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- SSD disks are able to reduce fsync latency, and total time needed for snapshotting and AOF log rewriting (resulting in smaller memory usage and smaller final AOF rewrite buffer flushes). With extremely high write load SSD disks can be a good option. However Redis should perform reasonably with high load using normal disks. Use this advice as a last resort.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_data_writeback</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Mounting ext3/4 filesystems with data=writeback can provide a performance boost compared to data=ordered, however this mode of operation provides less guarantees, and sometimes it can happen that after a hard crash the AOF file will have an half-written command at the end and will require to be repaired before Redis restarts.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_disk_contention</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Try to lower the disk contention. This is often caused by other disk intensive processes running in the same computer (including other Redis instances).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_no_appendfsync</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Assuming from the point of view of data safety this is viable in your environment, you could try to enable the 'no-appendfsync-on-rewrite' option, so that fsync will not be performed while there is a child rewriting the AOF file or producing an RDB file (the moment where there is high disk contention).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_relax_fsync_policy</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_ALWAYS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Your fsync policy is set to 'always'. It is very hard to get good performances with such a setup, if possible try to relax the fsync policy to 'onesec'.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_write_load_info</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Latency during the AOF atomic rename operation or when the final difference is flushed to the AOF file at the end of the rewrite, sometimes is caused by very high write load, causing the AOF buffer to get very large. If possible try to send less commands to accomplish the same work, or use Lua scripts to group multiple operations into a single EVALSHA call.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_hz</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>hz</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- In order to make the Redis keys expiring process more incremental, try to set the 'hz' configuration parameter to 100 using 'CONFIG SET hz 100'.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_large_objects</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Deleting, expiring or evicting (because of maxmemory policy) large objects is a blocking operation. If you have very large objects that are often deleted, expired, or evicted, try to fragment those objects into multiple smaller objects.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_mass_eviction</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- Sudden changes to the 'maxmemory' setting via 'CONFIG SET', or allocation of large objects via sets or sorted sets intersections, STORE option of SORT, Redis Cluster large keys migrations (RESTORE command), may create sudden memory pressure forcing the server to block trying to evict keys. \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>advise_disable_thp</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>report</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>report</name></expr></argument>,<argument><expr><literal type="string">"- I detected a non zero amount of anonymous huge pages used by your process. This creates very serious latency events in different conditions, especially when Redis is persisting on disk. To disable THP support use the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled', make sure to also add it into /etc/rc.local so that the command will be executed again after a reboot. Note that even if you have already disabled THP, you still need to restart the Redis process to get rid of the huge pages already created.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>report</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------- Latency command implementation -------------------- */</comment>

<comment type="block">/* latencyCommand() helper to produce a time-delay reply for all the samples
 * in memory for the specified time series. */</comment>
<function><type><name>void</name></type> <name>latencyCommandReplyWithSamples</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>replylen</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>samples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LATENCY_TS_LEN</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>%</operator> <name>LATENCY_TS_LEN</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>samples</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>replylen</name></expr></argument>,<argument><expr><name>samples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* latencyCommand() helper to produce the reply for the LATEST subcommand,
 * listing the last latency sample for every event type registered so far. */</comment>
<function><type><name>void</name></type> <name>latencyCommandReplyWithLatestEvents</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><operator>(</operator><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>+</operator> <name>LATENCY_TS_LEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>LATENCY_TS_LEN</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>last</name></expr>]</index></name><operator>.</operator><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>last</name></expr>]</index></name><operator>.</operator><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LATENCY_GRAPH_COLS</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>
<function><type><name>sds</name></type> <name>latencyCommandGenSparkeline</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sequence</name></name> <modifier>*</modifier></type><name>seq</name> <init>= <expr><call><name>createSparklineSequence</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>graph</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LATENCY_TS_LEN</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name><name>ts</name><operator>-&gt;</operator><name>idx</name></name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>%</operator> <name>LATENCY_TS_LEN</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>elapsed</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Update min and max. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>min</name> <operator>=</operator> <name>max</name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Use as label the number of seconds / minutes / hours / days
         * ago the event happened. */</comment>
        <expr_stmt><expr><name>elapsed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time</name><operator>)</operator></expr>;</expr_stmt>                      <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
        <if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&lt;</operator> <literal type="number">60</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%ds"</literal></expr></argument>,<argument><expr><name>elapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>elapsed</name> <operator>&lt;</operator> <literal type="number">3600</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%dm"</literal></expr></argument>,<argument><expr><name>elapsed</name><operator>/</operator><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>elapsed</name> <operator>&lt;</operator> <literal type="number">3600</literal><operator>*</operator><literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%dh"</literal></expr></argument>,<argument><expr><name>elapsed</name><operator>/</operator><literal type="number">3600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%dd"</literal></expr></argument>,<argument><expr><name>elapsed</name><operator>/</operator><operator>(</operator><literal type="number">3600</literal><operator>*</operator><literal type="number">24</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>sparklineSequenceAddSample</name><argument_list>(<argument><expr><name>seq</name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>samples</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>latency</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>graph</name></expr></argument>,
        <argument><expr><literal type="string">"%s - high %Iu ms, low %Iu ms (all time high %Iu ms)\n"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>,         <argument><expr><macro><name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id, %lu -&gt; %Iu */</comment>
        <argument_list>(<argument>PORT_ULONG</argument>)</argument_list></macro> <name>max</name></expr></argument>, <argument><expr><operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name>min</name></expr></argument>, <argument><expr><operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name><name>ts</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LATENCY_GRAPH_COLS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>graph</name></expr></argument>,<argument><expr><literal type="string">"-"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>graph</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>sparklineRender</name><argument_list>(<argument><expr><name>graph</name></expr></argument>,<argument><expr><name>seq</name></expr></argument>,<argument><expr><name>LATENCY_GRAPH_COLS</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><name>SPARKLINE_FILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeSparklineSequence</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>graph</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* LATENCY command implementations.
 *
 * LATENCY HISTORY: return time-latency samples for the specified event.
 * LATENCY LATEST: return the latest latency for all the events classes.
 * LATENCY DOCTOR: returns a human readable analysis of instance latency.
 * LATENCY GRAPH: provide an ASCII graph of the latency of the specified event.
 * LATENCY RESET: reset data of a specified event or all the data if no event provided.
 */</comment>
<function><type><name>void</name></type> <name>latencyCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"DOCTOR              -- Returns a human readable latency analysis report."</literal></expr>,
<expr><literal type="string">"GRAPH   &lt;event&gt;     -- Returns an ASCII latency graph for the event class."</literal></expr>,
<expr><literal type="string">"HISTORY &lt;event&gt;     -- Returns time-latency samples for the event class."</literal></expr>,
<expr><literal type="string">"LATEST              -- Returns the latest latency samples for all events."</literal></expr>,
<expr><literal type="string">"RESET   [event ...] -- Resets latency data of one or more event classes."</literal></expr>,
<expr><literal type="string">"                       (default: reset all data for all event classes)"</literal></expr>,
<expr><literal type="string">"HELP                -- Prints this help."</literal></expr>,
<expr><name>NULL</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>latencyTimeSeries</name></name> <modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"history"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* LATENCY HISTORY &lt;event&gt; */</comment>
        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ts</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>latencyCommandReplyWithSamples</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"graph"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* LATENCY GRAPH &lt;event&gt; */</comment>
        <decl_stmt><decl><type><name>sds</name></type> <name>graph</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>latency_events</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>nodataerr</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>event</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>latencyCommandGenSparkeline</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"latest"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* LATENCY LATEST */</comment>
        <expr_stmt><expr><call><name>latencyCommandReplyWithLatestEvents</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"doctor"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* LATENCY DOCTOR */</comment>
        <decl_stmt><decl><type><name>sds</name></type> <name>report</name> <init>= <expr><call><name>createLatencyReport</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>report</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* LATENCY RESET */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>latencyResetEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>resets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>resets</name> <operator>+=</operator> <call><name>latencyResetEvent</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>resets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return;</return>

<label><name>nodataerr</name>:</label>
    <comment type="block">/* Common error when the user asks for an event we have no latency
     * information about. */</comment>
    <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
        <argument><expr><literal type="string">"No samples available for event '%s'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
