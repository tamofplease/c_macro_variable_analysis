<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/quicklist.c"><comment type="block">/* quicklist.c - A doubly linked list of ziplists
 *
 * Copyright (c) 2014, Matt Stancliff &lt;matt@genges.com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must start the above copyright notice,
 *     this quicklist of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this quicklist of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include> <comment type="block">/* for memcpy */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quicklist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ziplist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util.h"</cpp:file></cpp:include> <comment type="block">/* for ll2string */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lzf.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST_VERBOSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> <comment type="block">/* for printf (debug printing), snprintf (genstr) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REDIS_STATIC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_STATIC</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Optimization levels for size-based filling */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name><name>optimization_level</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">4096</literal></expr>, <expr><literal type="number">8192</literal></expr>, <expr><literal type="number">16384</literal></expr>, <expr><literal type="number">32768</literal></expr>, <expr><literal type="number">65536</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Maximum size in bytes of any multi-element ziplist.
 * Larger values will live in their own isolated ziplists. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_SAFETY_LIMIT</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/* Minimum ziplist size in bytes for attempting compression. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_COMPRESS_BYTES</name></cpp:macro> <cpp:value>48</cpp:value></cpp:define>

<comment type="block">/* Minimum size reduction in bytes to store compressed quicklistNode data.
 * This also prevents us from storing compression if the compression
 * resulted in a larger size than the original data. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_COMPRESS_IMPROVE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* If not verbose testing, remove all debug printing. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REDIS_TEST_VERBOSE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                 \
    <cpp:value>do {                                                                       \
        printf("%s:%s:%d:\t", __FILE__, __FUNCTION__, __LINE__);               \
        printf(__VA_ARGS__);                                                   \
        printf("\n");                                                          \
    } while (0);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Simple way to give quicklistEntry structs default values with one call. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>initEntry</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>                                                           \
    <cpp:value>do {                                                                       \
        (e)-&gt;zi = (e)-&gt;value = NULL;                                           \
        (e)-&gt;longval = -123456789;                                             \
        (e)-&gt;quicklist = NULL;                                                 \
        (e)-&gt;node = NULL;                                                      \
        (e)-&gt;offset = 123456789;                                               \
        (e)-&gt;sz = 0;                                                           \
    } while (0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>likely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_expect(!!(x), 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlikely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_expect(!!(x), 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>likely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlikely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Create a new quicklist.
 * Free with quicklistRelease(). */</comment>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>quicklist</name></name> <modifier>*</modifier></type><name>quicklist</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>quicklist</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>quicklist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <return>return <expr><name>quicklist</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESS_MAX</name></cpp:macro> <cpp:value>(1 &lt;&lt; 16)</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>quicklistSetCompressDepth</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compress</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>compress</name> <operator>&gt;</operator> <name>COMPRESS_MAX</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>compress</name> <operator>=</operator> <name>COMPRESS_MAX</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>compress</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>compress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>compress</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILL_MAX</name></cpp:macro> <cpp:value>(1 &lt;&lt; 15)</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>quicklistSetFill</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>fill</name> <operator>&gt;</operator> <name>FILL_MAX</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fill</name> <operator>=</operator> <name>FILL_MAX</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fill</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fill</name> <operator>=</operator> <operator>-</operator><literal type="number">5</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name> <operator>=</operator> <name>fill</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>quicklistSetOptions</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quicklistSetCompressDepth</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a new quicklist with some default parameters. */</comment>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compress</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name> <init>= <expr><call><name>quicklistCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>quicklistSetOptions</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>compress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>quicklist</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>REDIS_STATIC</name> <name>quicklistNode</name> <modifier>*</modifier></type><name>quicklistCreateNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name>QUICKLIST_NODE_CONTAINER_ZIPLIST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return cached quicklist count */</comment>
<function><type><name>PORT_ULONG</name></type> <name>quicklistCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><operator>(</operator><name><name>ql</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator></expr>;</return> </block_content>}</block></function> <function><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (unsigned int) */</comment>

<comment type="block">/* Free entire quicklist. */</comment>
<name>void</name></type> <name>quicklistRelease</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name><name>current</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compress the ziplist in 'node' and update encoding details.
 * Returns 1 if ziplist compressed successfully.
 * Returns 0 if compression failed or if ziplist too small to compress. */</comment>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>__quicklistCompressNode</name><parameter_list>(<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REDIS_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Don't bother compressing small values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>&lt;</operator> <name>MIN_COMPRESS_BYTES</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lzf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Cancel if compression fails or doesn't compress small enough */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <call><name>lzf_compress</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>lzf</name><operator>-&gt;</operator><name>compressed</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name> <operator>+</operator> <name>MIN_COMPRESS_IMPROVE</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* lzf_compress aborts/rejects compression if value not compressable. */</comment>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lzf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>lzf</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>lzf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lzf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>lzf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compress only uncompressed nodes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistCompressNode</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro>                                           \
    <cpp:value>do {                                                                       \
        if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) {     \
            __quicklistCompressNode((_node));                                  \
        }                                                                      \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Uncompress the ziplist in 'node' and update encoding details.
 * Returns 1 on successful decode, 0 on failure to decode. */</comment>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>__quicklistDecompressNode</name><parameter_list>(<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REDIS_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>decompressed</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><operator>(</operator><name>quicklistLZF</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lzf_decompress</name><argument_list>(<argument><expr><name><name>lzf</name><operator>-&gt;</operator><name>compressed</name></name></expr></argument>, <argument><expr><name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><name>decompressed</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Someone requested decompress, but we can't decompress.  Not good. */</comment>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>decompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lzf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <name>decompressed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decompress only compressed nodes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistDecompressNode</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro>                                         \
    <cpp:value>do {                                                                       \
        if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
            __quicklistDecompressNode((_node));                                \
        }                                                                      \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Force node to not be immediately re-compresable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistDecompressNodeForUse</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro>                                   \
    <cpp:value>do {                                                                       \
        if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
            __quicklistDecompressNode((_node));                                \
            (_node)-&gt;recompress = 1;                                           \
        }                                                                      \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Extract the raw LZF data from this quicklistNode.
 * Pointer to LZF data is assigned to '*data'.
 * Return value is the length of compressed LZF data. */</comment>
<function><type><name>size_t</name></type> <name>quicklistGetLzf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><operator>(</operator><name>quicklistLZF</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name><name>lzf</name><operator>-&gt;</operator><name>compressed</name></name></expr>;</expr_stmt>
    <return>return <expr><name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistAllowsCompression</name><parameter_list>(<parameter><type><name>_ql</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_ql)-&gt;compress != 0)</cpp:value></cpp:define>

<comment type="block">/* Force 'quicklist' to meet compression guidelines set by compress depth.
 * The only way to guarantee interior nodes get compressed is to iterate
 * to our "interior" compress depth then compress the next node we find.
 * If compress depth is larger than the entire list, we return immediately. */</comment>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>__quicklistCompress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                      <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* If length is less than our compress depth (from both sides),
     * we can't compress anything. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>quicklistAllowsCompression</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* Optimized cases for small depth counts */</comment>
    if (quicklist-&gt;compress == 1) {
        quicklistNode *h = quicklist-&gt;head, *t = quicklist-&gt;tail;
        quicklistDecompressNode(h);
        quicklistDecompressNode(t);
        if (h != node &amp;&amp; t != node)
            quicklistCompressNode(node);
        return;
    } else if (quicklist-&gt;compress == 2) {
        quicklistNode *h = quicklist-&gt;head, *hn = h-&gt;next, *hnn = hn-&gt;next;
        quicklistNode *t = quicklist-&gt;tail, *tp = t-&gt;prev, *tpp = tp-&gt;prev;
        quicklistDecompressNode(h);
        quicklistDecompressNode(hn);
        quicklistDecompressNode(t);
        quicklistDecompressNode(tp);
        if (h != node &amp;&amp; hn != node &amp;&amp; t != node &amp;&amp; tp != node) {
            quicklistCompressNode(node);
        }
        if (hnn != t) {
            quicklistCompressNode(hnn);
        }
        if (tpp != h) {
            quicklistCompressNode(tpp);
        }
        return;
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Iterate until we reach compress depth for both sides of the list.a
     * Note: because we do length checks at the *top* of this function,
     *       we can skip explicit null checks below. Everything exists. */</comment>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>forward</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>reverse</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>in_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>depth</name><operator>++</operator> <operator>&lt;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>forward</name> <operator>==</operator> <name>node</name> <operator>||</operator> <name>reverse</name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>in_depth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>forward</name> <operator>==</operator> <name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>forward</name> <operator>=</operator> <name><name>forward</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reverse</name> <operator>=</operator> <name><name>reverse</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_depth</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>quicklistCompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* At this point, forward and reverse are one node beyond depth */</comment>
        <expr_stmt><expr><call><name>quicklistCompressNode</name><argument_list>(<argument><expr><name>forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistCompressNode</name><argument_list>(<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistCompress</name><parameter_list>(<parameter><type><name>_ql</name></type></parameter>, <parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro>                                          \
    <cpp:value>do {                                                                       \
        if ((_node)-&gt;recompress)                                               \
            quicklistCompressNode((_node));                                    \
        else                                                                   \
            __quicklistCompress((_ql), (_node));                               \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* If we previously used quicklistDecompressNodeForUse(), just recompress. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistRecompressOnly</name><parameter_list>(<parameter><type><name>_ql</name></type></parameter>, <parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro>                                    \
    <cpp:value>do {                                                                       \
        if ((_node)-&gt;recompress)                                               \
            quicklistCompressNode((_node));                                    \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Insert 'new_node' after 'old_node' if 'after' is 1.
 * Insert 'new_node' before 'old_node' if 'after' is 0.
 * Note: 'new_node' is *always* uncompressed, so if we assign it to
 *       head or tail, we do not need to uncompress it. */</comment>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>__quicklistInsertNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                        <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
                                        <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>after</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>old_node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>old_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>old_node</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>old_node</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>old_node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>old_node</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* If this insert creates the only element so far, initialize head/tail. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>old_node</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Wrappers for node inserting around existing node. */</comment>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistInsertNodeBefore</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                             <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
                                             <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistInsertNodeAfter</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                            <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
                                            <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>REDIS_STATIC</name> <name>int</name></type>
<name>_quicklistNodeSizeMeetsOptimizationRequirement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>,
                                               <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>fill</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>fill</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><operator>(</operator><operator>-</operator><name>fill</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>optimization_level</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>optimization_level</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <name><name>optimization_level</name><index>[<expr><name>offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizeMeetsSafetyLimit</name><parameter_list>(<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sz) &lt;= SIZE_SAFETY_LIMIT)</cpp:value></cpp:define>

<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>_quicklistNodeAllowInsert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                           <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>ziplist_overhead</name></decl>;</decl_stmt>
    <comment type="block">/* size of previous offset */</comment>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">254</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ziplist_overhead</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ziplist_overhead</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* size of forward offset */</comment>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ziplist_overhead</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>sz</name> <operator>&lt;</operator> <literal type="number">16384</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ziplist_overhead</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ziplist_overhead</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* new_sz overestimates if 'sz' encodes to an integer type */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>new_sz</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>+</operator> <name>sz</name> <operator>+</operator> <name>ziplist_overhead</name><operator>)</operator></expr></init></decl>;</decl_stmt>     <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (unsigned int) */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>_quicklistNodeSizeMeetsOptimizationRequirement</name><argument_list>(<argument><expr><name>new_sz</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>sizeMeetsSafetyLimit</name><argument_list>(<argument><expr><name>new_sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <name>fill</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>_quicklistNodeAllowMerge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
                                          <parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
                                          <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>fill</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* approximate merged ziplist size (- 11 to remove one ziplist
     * header/trailer) */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>merge_sz</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>sz</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>sz</name></name> <operator>-</operator> <literal type="number">11</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>_quicklistNodeSizeMeetsOptimizationRequirement</name><argument_list>(<argument><expr><name>merge_sz</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>sizeMeetsSafetyLimit</name><argument_list>(<argument><expr><name>merge_sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>count</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator> <operator>&lt;=</operator> <name>fill</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistNodeUpdateSz</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro>                                            \
    <cpp:value>do {                                                                       \
        (node)-&gt;sz = ziplistBlobLen((node)-&gt;zl);                               \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Add new entry to head node of quicklist.
 *
 * Returns 0 if used existing head.
 * Returns 1 if new head created. */</comment>
<function><type><name>int</name></type> <name>quicklistPushHead</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>orig_head</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(
            <argument><expr><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator>
            <call><name>ziplistPush</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_quicklistInsertNodeBefore</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>orig_head</name> <operator>!=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add new entry to tail node of quicklist.
 *
 * Returns 0 if used existing tail.
 * Returns 1 if new tail created. */</comment>
<function><type><name>int</name></type> <name>quicklistPushTail</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>orig_tail</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(
            <argument><expr><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator>
            <call><name>ziplistPush</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>orig_tail</name> <operator>!=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create new node consisting of a pre-formed ziplist.
 * Used for loading RDBs where entire ziplists have been stored
 * to be retrieved later. */</comment>
<function><type><name>void</name></type> <name>quicklistAppendZiplist</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append all values of ziplist 'zl' individually into 'quicklist'.
 *
 * This allows us to restore old RDB ziplists into new quicklists
 * with smaller ziplist sizes than the saved RDB ziplist.
 *
 * Returns 'quicklist' argument. Frees passed-in ziplist 'zl' */</comment>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistAppendValuesFromZiplist</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                            <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>longval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>longstr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>longval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Write the longval as a string so we can re-add it */</comment>
            <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>longstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>longstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>longval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>longstr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>quicklist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create new (potentially multi-node) quicklist from a single existing ziplist.
 *
 * Returns new quicklist.  Frees passed-in ziplist 'zl'. */</comment>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistCreateFromZiplist</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compress</name></decl></parameter>,
                                      <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>quicklistAppendValuesFromZiplist</name><argument_list>(<argument><expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>fill</name></expr></argument>, <argument><expr><name>compress</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistDeleteIfEmpty</name><parameter_list>(<parameter><type><name>ql</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>                                          \
    <cpp:value>do {                                                                       \
        if ((n)-&gt;count == 0) {                                                 \
            __quicklistDelNode((ql), (n));                                     \
            (n) = NULL;                                                        \
        }                                                                      \
    } while (0)</cpp:value></cpp:define>

<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>__quicklistDelNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                     <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we deleted a node within our compress depth, we
     * now have compressed nodes needing to be decompressed. */</comment>
    <expr_stmt><expr><call><name>__quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Delete one entry from list given the node for the entry and a pointer
 * to the entry in the node.
 *
 * Note: quicklistDelIndex() *requires* uncompressed nodes because you
 *       already had to get *p from an uncompressed node somewhere.
 *
 * Returns 1 if the entire node was deleted, 0 if node still exists.
 * Also updates in/out param 'p' with the next offset in the ziplist. */</comment>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>quicklistDelIndex</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                   <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>gone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>gone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
    <comment type="block">/* If we deleted the node, the original node is no longer valid */</comment>
    <return>return <expr><ternary><condition><expr><name>gone</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete one element represented by 'entry'
 *
 * 'entry' stores enough metadata to delete the proper position in
 * the correct ziplist in the correct quicklist node. */</comment>
<function><type><name>void</name></type> <name>quicklistDelEntry</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>deleted_node</name> <init>= <expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><operator>(</operator><name>quicklist</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>quicklist</name></name></expr></argument>,
                                         <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* after delete, the zi is now invalid for any future usage. */</comment>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* If current node is deleted, we must update iterator node and offset. */</comment>
    <if_stmt><if>if <condition>(<expr><name>deleted_node</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* else if (!deleted_node), no changes needed.
     * we already reset iter-&gt;zi above, and the existing iter-&gt;offset
     * doesn't move again because:
     *   - [1, 2, 3] =&gt; delete offset 1 =&gt; [1, 3]: next element still offset 1
     *   - [1, 2, 3] =&gt; delete offset 0 =&gt; [2, 3]: next element still offset 0
     *  if we deleted the last element at offet N and now
     *  length of this ziplist is N-1, the next call into
     *  quicklistNext() will jump to the next node. */</comment>
</block_content>}</block></function>

<comment type="block">/* Replace quicklist entry at offset 'index' by 'data' with length 'sz'.
 *
 * Returns 1 if replace happened.
 * Returns 0 if replace failed and no changes happened. */</comment>
<function><type><name>int</name></type> <name>quicklistReplaceAtIndex</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* quicklistIndex provides an uncompressed node */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>zi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>zi</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Given two nodes, try to merge their ziplists.
 *
 * This helps us not have a quicklist with 3 element ziplists if
 * our fill factor can handle much higher levels.
 *
 * Note: 'a' must be to the LEFT of 'b'.
 *
 * After calling this function, both 'a' and 'b' should be considered
 * unusable.  The return value from this function must be used
 * instead of re-using any of the quicklistNode input arguments.
 *
 * Returns the input node picked to merge against or NULL if
 * merging was not possible. */</comment>
<function><type><name>REDIS_STATIC</name> <name>quicklistNode</name> <modifier>*</modifier></type><name>_quicklistZiplistMerge</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                                   <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
                                                   <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Requested merge (a,b) (%u, %u)"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ziplistMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We merged ziplists! Now remove the unused quicklistNode. */</comment>
        <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>keep</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nokeep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>zl</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nokeep</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>keep</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>zl</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nokeep</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>keep</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>keep</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>keep</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>nokeep</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>nokeep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>keep</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* else, the merge returned NULL and nothing changed. */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Attempt to merge ziplists within two nodes on either side of 'center'.
 *
 * We attempt to merge:
 *   - (center-&gt;prev-&gt;prev, center-&gt;prev)
 *   - (center-&gt;next, center-&gt;next-&gt;next)
 *   - (center-&gt;prev, center)
 *   - (center, center-&gt;next)
 */</comment>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistMergeNodes</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                       <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>center</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fill</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>prev_prev</name> <operator>=</operator> <name>next</name> <operator>=</operator> <name>next_next</name> <operator>=</operator> <name>target</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>prev_prev</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>next_next</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Try to merge prev_prev and prev */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>prev_prev</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>_quicklistZiplistMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>prev_prev</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_prev</name> <operator>=</operator> <name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* they could have moved, invalidate them. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Try to merge next and next_next */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>_quicklistZiplistMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name>next_next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* they could have moved, invalidate them. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Try to merge center node and previous node */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>_quicklistZiplistMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>center</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>center</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* center could have been deleted, invalidate it. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* else, we didn't merge here, but target needs to be valid below. */</comment>
        <expr_stmt><expr><name>target</name> <operator>=</operator> <name>center</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Use result of center merge (or original) to merge with next node. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>_quicklistZiplistMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Split 'node' into two parts, parameterized by 'offset' and 'after'.
 *
 * The 'after' argument controls which quicklistNode gets returned.
 * If 'after'==1, returned node has elements after 'offset'.
 *                input node keeps elements up to 'offset', including 'offset'.
 * If 'after'==0, returned node has elements up to 'offset', including 'offset'.
 *                input node keeps elements after 'offset'.
 *
 * If 'after'==1, returned node will have elements _after_ 'offset'.
 *                The returned node will have elements [OFFSET+1, END].
 *                The input node keeps elements [0, OFFSET].
 *
 * If 'after'==0, returned node will keep elements up to and including 'offset'.
 *                The returned node will have elements [0, OFFSET].
 *                The input node keeps elements [OFFSET+1, END].
 *
 * The input node keeps all elements not taken by the returned node.
 *
 * Returns newly created node or NULL if split not possible. */</comment>
<function><type><name>REDIS_STATIC</name> <name>quicklistNode</name> <modifier>*</modifier></type><name>_quicklistSplitNode</name><parameter_list>(<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>,
                                                <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>zl_sz</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>zl_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy original ziplist so we can split it */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>zl_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* -1 here means "continue deleting until the list ends" */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>orig_start</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>orig_extent</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>offset</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_start</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>offset</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_extent</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"After %d (%d); ranges: [%d, %d], [%d, %d]"</literal></expr></argument>, <argument><expr><name>after</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>orig_start</name></expr></argument>,
      <argument><expr><name>orig_extent</name></expr></argument>, <argument><expr><name>new_start</name></expr></argument>, <argument><expr><name>new_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>orig_start</name></expr></argument>, <argument><expr><name>orig_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>new_start</name></expr></argument>, <argument><expr><name>new_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"After split lengths: orig (%d), new (%d)"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>new_node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a new entry before or after existing entry 'entry'.
 *
 * If after==1, the new value is inserted after 'entry', otherwise
 * the new value is inserted before 'entry'. */</comment>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistInsert</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>full</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>at_tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>at_head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>full_next</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>full_prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fill</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* we have no reference node, so let's create only node in the list */</comment>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"No node given!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Populate accounting flags for easier boolean checks later */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <macro><name>D</name><argument_list>(<argument><literal type="string">"Current node is full with count %d with requested fill %Iu"</literal></argument>,                    <argument>WIN_PORT_FIX <comment type="block">/* %lu -&gt; %Iu */</comment>
          node-&gt;count</argument>, <argument>fill</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name>full</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>after</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"At Tail of current ziplist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>at_tail</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Next node is full too."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>full_next</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>after</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"At Head"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>at_head</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Prev node is full too."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>full_prev</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now determine where and how to insert the new element */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>full</name> <operator>&amp;&amp;</operator> <name>after</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Not full, inserting after current position."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>ziplistNext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>full</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Not full, inserting before current position."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name> <operator>&amp;&amp;</operator> <name>at_tail</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>full_next</name> <operator>&amp;&amp;</operator> <name>after</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we are: at tail, next has free space, and inserting after:
         *   - insert entry at head of next node. */</comment>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Full and tail, but next isn't full; inserting next node head"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name> <operator>&amp;&amp;</operator> <name>at_head</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>full_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we are: at head, previous has free space, and inserting before:
         *   - insert entry at tail of previous node. */</comment>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Full and head, but prev isn't full, inserting prev node tail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>at_tail</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>&amp;&amp;</operator> <name>full_next</name> <operator>&amp;&amp;</operator> <name>after</name><operator>)</operator> <operator>||</operator>
                        <operator>(</operator><name>at_head</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>&amp;&amp;</operator> <name>full_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we are: full, and our prev/next is full, then:
         *   - create new node and attach to quicklist */</comment>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"\tprovisioning new node..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* else, node is full we need to split it. */</comment>
        <comment type="block">/* covers both after and !after cases */</comment>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"\tsplitting node..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>_quicklistSplitNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
                                   <argument><expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><name>ZIPLIST_HEAD</name></expr> </then><else>: <expr><name>ZIPLIST_TAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_quicklistMergeNodes</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>quicklistInsertBefore</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
                           <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>_quicklistInsert</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>quicklistInsertAfter</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
                          <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>_quicklistInsert</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Delete a range of elements from the quicklist.
 *
 * elements may span across multiple quicklistNodes, so we
 * have to be careful about tracking where we start and end.
 *
 * Returns 1 if entries were deleted, 0 if nothing was deleted. */</comment>
<function><type><name>int</name></type> <name>quicklistDelRange</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PORT_LONG</name></type> <name>start</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>PORT_LONG</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>extent</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt> <comment type="block">/* range is inclusive of start position */</comment>

    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>&gt;</operator> <operator>(</operator><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>start</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* if requesting delete more elements than exist, limit to list size. */</comment>
        <expr_stmt><expr><name>extent</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><call><name><name>start</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name>PORT_ULONG</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* else, if at negative offset, limit max size to rest of list. */</comment>
        <expr_stmt><expr><name>extent</name> <operator>=</operator> <operator>-</operator><name>start</name></expr>;</expr_stmt> <comment type="block">/* c.f. LREM -29 29; just delete until end. */</comment>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <macro><name>D</name><argument_list>(<argument><literal type="string">"Quicklist delete request for start %Id, count %Id, extent: %Id"</literal></argument>, <argument>start</argument>,                 <argument>WIN_PORT_FIX <comment type="block">/* %ld -&gt; %Id */</comment>
      count</argument>, <argument>extent</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* iterate over next nodes until everything is deleted. */</comment>
    <while>while <condition>(<expr><name>extent</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>del</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>delete_entire_node</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If we are deleting more than the count of this node, we
             * can just delete the entire node without ziplist math. */</comment>
            <expr_stmt><expr><name>delete_entire_node</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>del</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>.</operator><name>offset</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If deleting more nodes after this one, calculate delete based
             * on size of current node. */</comment>
            <expr_stmt><expr><name>del</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name><name>entry</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>.</operator><name>offset</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If offset is negative, we are in the first run of this loop
             * and we are deleting the entire range
             * from this start offset to end of list.  Since the Negative
             * offset is the number of elements until the tail of the list,
             * just use it directly as the deletion count. */</comment>
            <expr_stmt><expr><name>del</name> <operator>=</operator> <operator>-</operator><name><name>entry</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>

            <comment type="block">/* If the positive offset is greater than the remaining extent,
             * we only delete the remaining extent, not the entire offset.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>del</name> <operator>&gt;</operator> <name>extent</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>del</name> <operator>=</operator> <name>extent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* else, we are deleting less than the extent of this node, so
             * use extent directly. */</comment>
            <expr_stmt><expr><name>del</name> <operator>=</operator> <name>extent</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"[%Id]: asking to del: %Id because offset: %d; (ENTIRE NODE: %d), "</literal>                             <name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
          <literal type="string">"node count: %u"</literal></expr></argument>,
          <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>del</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>delete_entire_node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>delete_entire_node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDeleteIfEmpty</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>extent</name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>node</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Passthrough to ziplistCompare() */</comment>
<function><type><name>int</name></type> <name>quicklistCompare</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p2_len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns a quicklist iterator 'iter'. After the initialization every
 * call to quicklistNext() will return the next element of the quicklist. */</comment>
<function><type><name>quicklistIter</name> <modifier>*</modifier></type><name>quicklistGetIterator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>direction</name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name> <operator>=</operator> <name>quicklist</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize an iterator at a specific offset 'idx' and make the iterator
 * return nodes in 'direction' direction. */</comment>
<function><type><name>quicklistIter</name> <modifier>*</modifier></type><name>quicklistGetIteratorAtIdx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>direction</name></decl></parameter>,
                                         <parameter><decl><type><specifier>const</specifier> <name>PORT_LONGLONG</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
        <return>return <expr><name>base</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Release iterator.
 * If we still have a valid current node, then re-encode current node. */</comment>
<function><type><name>void</name></type> <name>quicklistReleaseIterator</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Get next element in iterator.
 *
 * Note: You must NOT insert into the list while iterating over it.
 * You *may* delete from the list while iterating using the
 * quicklistDelEntry() function.
 * If you insert into the quicklist while iterating, you should
 * re-create the iterator after your addition.
 *
 * iter = quicklistGetIterator(quicklist,&lt;direction&gt;);
 * quicklistEntry entry;
 * while (quicklistNext(iter, &amp;entry)) {
 *     if (entry.value)
 *          [[ use entry.value with entry.sz ]]
 *     else
 *          [[ use entry.longval ]]
 * }
 *
 * Populates 'entry' with values for this iteration.
 * Returns 0 when iteration is complete or if iteration not possible.
 * If return value is 0, the contents of 'entry' are not valid.
 */</comment>
<function><type><name>int</name></type> <name>quicklistNext</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>initEntry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>iter</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Returning because no iter!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>quicklist</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition> <block>{<block_content>
        <macro><name>D</name><argument_list>(<argument><literal type="string">"Returning because current node is NULL"</literal></argument>)</argument_list></macro>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <function_decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>nextFn</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
    <decl_stmt><decl><type><name>int</name></type> <name>offset_update</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If !zi, use current index. */</comment>
        <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* else, use existing iterator offset and get prev/next as necessary. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nextFn</name> <operator>=</operator> <name>ziplistNext</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset_update</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nextFn</name> <operator>=</operator> <name>ziplistPrev</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset_update</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <call><name>nextFn</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name>offset_update</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Populate value from existing ziplist position */</comment>
        <expr_stmt><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* We ran out of ziplist entries.
         * Pick next node, update offset, then re-run retrieval. */</comment>
        <expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Forward traversal */</comment>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Jumping to start of next node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Reverse traversal */</comment>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Jumping to end of previous node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Duplicate the quicklist.
 * On success a copy of the original quicklist is returned.
 *
 * The original quicklist both on success or error is never modified.
 *
 * Returns newly allocated quicklist. */</comment>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistDup</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>current</name> <init>= <expr><name><name>orig</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</init> <condition><expr><name>current</name></expr>;</condition>
         <incr><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><operator>(</operator><name>quicklistLZF</name> <operator>*</operator><operator>)</operator><name><name>current</name><operator>-&gt;</operator><name>zl</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>lzf_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lzf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>lzf_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>lzf_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>sz</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name><name>copy</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* copy-&gt;count must equal orig-&gt;count here */</comment>
    <return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Populate 'entry' with the element at the specified zero-based index
 * where 0 is the head, 1 is the element next to head
 * and so on. Negative integers are used in order to count
 * from the tail, -1 is the last element, -2 the penultimate
 * and so on. If the index is out of range 0 is returned.
 *
 * Returns 1 if element found
 * Returns 0 if element not found */</comment>
<function><type><name>int</name></type> <name>quicklistIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PORT_LONGLONG</name></type> <name>idx</name></decl></parameter>,
                   <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>accum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>forward</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="block">/* &lt; 0 -&gt; reverse, 0+ -&gt; forward */</comment>

    <expr_stmt><expr><call><name>initEntry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>quicklist</name></name> <operator>=</operator> <name>quicklist</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>forward</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>idx</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>accum</name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator> <operator>&gt;</operator> <name>index</name></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Skipping over (%p) %u at accum %lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>count</name></name></expr></argument>,
              <argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>accum</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>prev</name></name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>,
      <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>-</operator> <name>accum</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>index</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* forward = normal head-to-tail offset. */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>index</name> <operator>-</operator> <name>accum</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* reverse = need negative offset for tail-to-head, so undo
         * the result of the original if (index &lt; 0) above. */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>index</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>accum</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The caller will use our result, so we don't re-compress here.
     * The caller can recompress or delete the node as needed. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Rotate quicklist by moving the tail element to the head. */</comment>
<function><type><name>void</name></type> <name>quicklistRotate</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* First, get the tail entry */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>longval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>longstr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>longval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If value found is NULL, then ziplistGet populated longval instead */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Write the longval as a string so we can re-add it */</comment>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>longstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>longstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>longval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>longstr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add tail entry to head (must happen before tail is deleted). */</comment>
    <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If quicklist has only one node, the head ziplist is also the
     * tail ziplist and PushHead() could have reallocated our single ziplist,
     * which would make our pre-existing 'p' unusable. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Remove tail entry. */</comment>
    <expr_stmt><expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* pop from quicklist and return result in 'data' ptr.  Value of 'data'
 * is the return value of 'saver' function pointer if the data is NOT a number.
 *
 * If the quicklist element is a long long, then the return value is returned in
 * 'sval'.
 *
 * Return value of 0 means no elements available.
 * Return value of 1 means check 'data' and 'sval' for values.
 * If 'data' is set, use 'data' and 'sz'.  Otherwise, use 'sval'. */</comment>
<function><type><name>int</name></type> <name>quicklistPopCustom</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>sz</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>sval</name></decl></parameter>,
                       <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>saver</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>QUICKLIST_HEAD</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>sval</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sval</name> <operator>=</operator> <operator>-</operator><literal type="number">123456789</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_HEAD</name> <operator>&amp;&amp;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_TAIL</name> <operator>&amp;&amp;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <call><name>saver</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <name>vlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>sval</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>sval</name> <operator>=</operator> <name>vlong</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a malloc'd copy of data passed in */</comment>
<function><type><name>REDIS_STATIC</name> <name>void</name> <modifier>*</modifier></type><name>_quicklistSaver</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>vstr</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Default pop function
 *
 * Returns malloc'd value from quicklist */</comment>
<function><type><name>int</name></type> <name>quicklistPop</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>,
                 <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>sz</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>slong</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>quicklistPopCustom</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>,
                                 <argument><expr><name>_quicklistSaver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>vstr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>slong</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>slong</name> <operator>=</operator> <name>vlong</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <name>vlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper to allow argument-based switching between HEAD/TAIL pop */</comment>
<function><type><name>void</name></type> <name>quicklistPush</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_HEAD</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_TAIL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* The rest of this file is test cases and test helpers. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REDIS_TEST</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>_e</name></type></parameter>)</parameter_list></cpp:macro>                                                             \
    <cpp:value>do {                                                                       \
        if (!(_e)) {                                                           \
            printf("\n\n=== ASSERTION FAILED ===\n");                          \
            printf("==&gt; %s:%d '%s' is not true\n", __FILE__, __LINE__, #_e);   \
            err++;                                                             \
        }                                                                      \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yell</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("ERROR! " str "\n\n", __VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OK</name></cpp:macro> <cpp:value>printf("\tOK\n")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR</name></cpp:macro>                                                                  \
    <cpp:value>do {                                                                       \
        printf("\tERROR!\n");                                                  \
        err++;                                                                 \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                            \
    <cpp:value>do {                                                                       \
        printf("%s:%s:%d:\t", __FILE__, __FUNCTION__, __LINE__);               \
        printf("ERROR! " x "\n", __VA_ARGS__);                                 \
        err++;                                                                 \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("test  %s\n", name);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_DESC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("test  " name "\n", __VA_ARGS__);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QL_TEST_VERBOSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ql_info</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>QL_TEST_VERBOSE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Container length: %lu\n"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Container size: %lu\n"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(zsize head: %d)\n"</literal></expr></argument>, <argument><expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(zsize tail: %d)\n"</literal></expr></argument>, <argument><expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Return the UNIX time in microseconds */</comment>
<function><type><specifier>static</specifier> <name>PORT_LONGLONG</name></type> <name>ustime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ust</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ust</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ust</name> <operator>+=</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
    <return>return <expr><name>ust</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the UNIX time in milliseconds */</comment>
<function><type><specifier>static</specifier> <name>PORT_LONGLONG</name></type> <name>mstime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>ustime</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">1000</literal></expr>;</return> </block_content>}</block></function>

<comment type="block">/* Iterate over an entire quicklist.
 * Print the list if 'print' == 1.
 *
 * Returns physical count of elements found by iterating over the list. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_itrprintr</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forward</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>=
        <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>AL_START_HEAD</name></expr> </then><else>: <expr><name>AL_START_TAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>node</name></name> <operator>!=</operator> <name>prev</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Count the number of list nodes too */</comment>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>print</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%3d (%2d)]: [%.*s] (%lld)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>itrprintr</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>_itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>print</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>itrprintr_rev</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>_itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>print</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ql_verify</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>                                               \
    <cpp:value>do {                                                                       \
        err += _ql_verify((a), (b), (c), (d), (e));                            \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Verify list metadata matches physical list contents. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_ql_verify</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>count</name></decl></parameter>,
                      <parameter><decl><type><name>uint32_t</name></type> <name>head_count</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>tail_count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist length wrong: expected %d, got %u"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist count wrong: expected %d, got %lu"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>loopr</name> <init>= <expr><call><name>itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>loopr</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist cached count not match actual count: expected %lu, got "</literal>
             <literal type="string">"%d"</literal></expr></argument>,
             <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>loopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>rloopr</name> <init>= <expr><call><name>itrprintr_rev</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>loopr</name> <operator>!=</operator> <name>rloopr</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist has different forward count than reverse count!  "</literal>
             <literal type="string">"Forward count is %d, reverse count is %d."</literal></expr></argument>,
             <argument><expr><name>loopr</name></expr></argument>, <argument><expr><name>rloopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>errors</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>OK</name></expr>;</expr_stmt>
        <return>return <expr><name>errors</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name>head_count</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>count</name></name> <operator>&amp;&amp;</operator>
        <name>head_count</name> <operator>!=</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist head count wrong: expected %d, "</literal>
             <literal type="string">"got cached %d vs. actual %d"</literal></expr></argument>,
             <argument><expr><name>head_count</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name></name> <operator>&amp;&amp;</operator> <name>tail_count</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>count</name></name> <operator>&amp;&amp;</operator>
        <name>tail_count</name> <operator>!=</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist tail count wrong: expected %d, "</literal>
             <literal type="string">"got cached %u vs. actual %d"</literal></expr></argument>,
             <argument><expr><name>tail_count</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>quicklistAllowsCompression</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>low_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>high_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>at</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>at</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>at</name> <operator>&lt;</operator> <name>low_raw</name> <operator>||</operator> <name>at</name> <operator>&gt;=</operator> <name>high_raw</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"Incorrect compression: node %d is "</literal>
                         <literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
                         <literal type="string">"nodes: %u; size: %u; recompress: %d)"</literal></expr></argument>,
                         <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name> <operator>&amp;&amp;</operator>
                    <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"Incorrect non-compression: node %d is NOT "</literal>
                         <literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
                         <literal type="string">"nodes: %u; size: %u; recompress: %d; attempted: %d)"</literal></expr></argument>,
                         <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>errors</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>errors</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate new string concatenating integer i against string 'prefix' */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>genstr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>result</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* main test, but callable from other files */</comment>
<function><type><name>int</name></type> <name>quicklistTest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>optimize_start</name> <init>=
        <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>optimization_level</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>optimization_level</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Starting optimization offset at: %d\n"</literal></expr></argument>, <argument><expr><name>optimize_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>option_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>options</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>runtime</name><index>[<expr><name>option_count</name></expr>]</index></name></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>_i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>option_count</name></expr>;</condition> <incr><expr><name>_i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Testing Option %d\n"</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"create list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"add to tail of empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 1 for head and 1 for tail because 1 node = head = tail */</comment>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"add to head of empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 1 for head and 1 for tail because 1 node = head = tail */</comment>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to tail 5x at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to head 5x at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to tail 500x at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to head 500x at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"rotate empty"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST</name><argument_list>(<argument><literal type="string">"rotate one val once"</literal></argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Ignore compression verify because ziplist is
                 * too small to compress. */</comment>
                <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"rotate 500 val 5000 times at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"900"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"7000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"-1200"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"42"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">252</literal></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop empty"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop 1 string from 1"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>populate</name> <init>= <expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">331</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>populate</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>lv</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>populate</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Pop'd value (%.*s) didn't equal original value (%s)"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
                    <argument><expr><name>data</name></expr></argument>, <argument><expr><name>populate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop head 1 number from 1"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"55513"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>lv</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lv</name> <operator>==</operator> <literal type="number">55513</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop head 500 from 500"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>lv</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Pop'd value (%.*s) didn't equal original value (%s)"</literal></expr></argument>,
                        <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop head 5000 from 500"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>lv</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Pop'd value (%.*s) didn't equal original value "</literal>
                            <literal type="string">"(%s)"</literal></expr></argument>,
                            <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"iterate forward over 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">499</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"value [%s] didn't match [%s] at position %d"</literal></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't iterate over exactly 500 elements (%d)"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"iterate reverse over 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"value [%s] didn't match [%s] at position %d"</literal></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't iterate over exactly 500 elements (%d)"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert before with 0 elements"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert after with 0 elements"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert after 1 element"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert before 1 element"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"insert once in elements while iterating at fill %d at "</literal>
                      <literal type="string">"compress %d\n"</literal></argument>,
                      <argument>f</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* force to unique node */</comment>
                <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"bob"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* force to reset for +3 */</comment>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"zoo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* insert "bar" before "bob" while iterating over list. */</comment>
                <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bob"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* Insert as fill = 1 so it spills into new node. */</comment>
                        <expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break> <comment type="block">/* didn't we fix insert-while-iterating? */</comment>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* verify results */</comment>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 0 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 1 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 2 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bob"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 3 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 4 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"zoo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 5 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(
                <argument><literal type="string">"insert [before] 250 new in middle of 500 elements at fill"</literal>
                <literal type="string">" %d at compress %d"</literal></argument>,
                <argument>f</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">250</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">250</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">750</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"insert [after] 250 new in middle of 500 elements at "</literal>
                      <literal type="string">"fill %d at compress %d"</literal></argument>,
                      <argument>f</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">250</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">250</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">750</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"List size not 750, but rather %ld"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">26</literal></expr></argument>, <argument><expr><literal type="number">750</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"duplicate empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>quicklistDup</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"duplicate list of 1 element"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>quicklistDup</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"duplicate list of 500"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>quicklistDup</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index 1,200 from 500 list at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello2"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello201"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index -1,-2 from 500 list at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello500"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello499"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index -100 from 500 list at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello401"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index too big +1 from 50 list at fill %d at compress %d"</literal></argument>,
                      <argument>f</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Index found at 50 with 50 list: %.*s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete range empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete range of entire node in list of one node"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete range of entire node with overflow counts"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete middle 100 of 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete negative 1 from 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">499</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete negative 1 from 500 list with overflow counts"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">499</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete negative 100 from 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete -10 count 5 from 50 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"numbers only list read"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"1111"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"2222"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"3333"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"4444"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">1111</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 1111, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">2222</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 2222, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">3333</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 3333, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">4444</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 4444, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Index past elements: %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">4444</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 4444 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">3333</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 3333 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">2222</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 2222 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">1111</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 1111 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Index past elements (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"numbers larger list read"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"xxxxxxxxxxxxxxxxxxxx"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"[%d] Not longval %lld but rather %lld"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>=</operator> <literal type="number">0xdeadbeef</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"xxxxxxxxxxxxxxxxxxxx"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"String val not match: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">157</literal></expr></argument>, <argument><expr><literal type="number">5001</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <macro><name>TEST</name><argument_list>(<argument><literal type="string">"numbers larger list read B"</literal></argument>)</argument_list></macro> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"99"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"98"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"xxxxxxxxxxxxxxxxxxxx"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"96"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"95"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistReplaceAtIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistReplaceAtIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>OK</name></expr>;</expr_stmt>
        </block_content>}</block>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"lrem test at fill %d at compress %d"</literal></argument>, <argument>f</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>words</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"bar"</literal></expr>,  <expr><literal type="string">"foobar"</literal></expr>, <expr><literal type="string">"foobared"</literal></expr>,
                                 <expr><literal type="string">"zap"</literal></expr>, <expr><literal type="string">"bar"</literal></expr>, <expr><literal type="string">"test"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>result</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>,  <expr><literal type="string">"foobar"</literal></expr>, <expr><literal type="string">"foobared"</literal></expr>,
                                  <expr><literal type="string">"zap"</literal></expr>, <expr><literal type="string">"test"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>resultB</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>,      <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"foobar"</literal></expr>,
                                   <expr><literal type="string">"foobared"</literal></expr>, <expr><literal type="string">"zap"</literal></expr>, <expr><literal type="string">"test"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="block">/* lrem 0 bar */</comment>
                <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>quicklistCompare</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>quicklistDelEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* check result of lrem 0 bar */</comment>
                <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Result must be: abc, foo, foobar, foobared, zap, test,
                     * foo */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"No match at position %d, got %.*s instead of %s"</literal></expr></argument>,
                            <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* lrem -2 foo */</comment>
                <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>del</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>quicklistCompare</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>quicklistDelEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>del</name><operator>--</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>del</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* check result of lrem -2 foo */</comment>
                <comment type="block">/* (we're ignoring the '2' part and still deleting all foo
                 * because
                 * we only have two foo) */</comment>
                <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>resB</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>resultB</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>resultB</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Result must be: abc, foo, foobar, foobared, zap, test,
                     * foo */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>resultB</name><index>[<expr><name>resB</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>,
                                <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"No match at position %d, got %.*s instead of %s"</literal></expr></argument>,
                            <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>resultB</name><index>[<expr><name>resB</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>

                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* final result of all tests */</comment>
                <if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"iterate reverse + delete at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hij"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"jkl"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"oop"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>quicklistCompare</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"hij"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>quicklistDelEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't iterate 5 times, iterated %d times."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Check results after deletion of "hij" */</comment>
                <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>vals</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"def"</literal></expr>, <expr><literal type="string">"jkl"</literal></expr>, <expr><literal type="string">"oop"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>quicklistCompare</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value at %d didn't match %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">800</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"iterator at index test at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">760</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>=
                    <expr><call><name>quicklistGetIteratorAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>, <argument><expr><literal type="number">437</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">437</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Expected %lld, but got %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>,
                            <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test A at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* ltrim 25 53 (keep [25,32] inclusive = 7 remaining) */</comment>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><literal type="number">25</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Deleted invalid range!  Expected %lld but got "</literal>
                            <literal type="string">"%lld"</literal></expr></argument>,
                            <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><literal type="number">25</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test B at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <comment type="block">/* Force-disable compression because our 33 sequential
                 * integers don't compress and the check always fails. */</comment>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>QUICKLIST_NOCOMPRESS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* ltrim 5 16 (keep [5,16] inclusive = 12 remaining) */</comment>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"A: longval not 5, but %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"B! got instead: %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"bobobob"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bobobob"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Tail doesn't match bobobob, it's %.*s instead"</literal></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Deleted invalid range!  Expected %lld but got "</literal>
                            <literal type="string">"%lld"</literal></expr></argument>,
                            <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test C at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* ltrim 3 3 (keep [3,3] inclusive = 1 remaining) */</comment>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">29</literal></expr></argument>,
                                  <argument><expr><literal type="number">4000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* make sure not loop forever */</comment>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>quicklistIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">5157318210846258173</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test D at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
                      <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">30</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't delete exactly three elements!  Count is: %lu"</literal></expr></argument>,
                        <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">72</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"create quicklist from ziplist at fill %d at compress %d"</literal></argument>,
                      <argument>f</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name><name>nums</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>zl</name> <operator>=</operator>
                        <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistCreateFromZiplist</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">66</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>stop</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>runtime</name><index>[<expr><name>_i</name></expr>]</index></name> <operator>=</operator> <name>stop</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Run a longer test of compression depth outside of primary test loop. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name><name>list_sizes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">250</literal></expr>, <expr><literal type="number">251</literal></expr>, <expr><literal type="number">500</literal></expr>, <expr><literal type="number">999</literal></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>list</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>list</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>list_sizes</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>list_sizes</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition>
         <incr><expr><name>list</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>optimize_start</name></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>depth</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <comment type="block">/* skip over many redundant test cases */</comment>
                <macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"verify specific compression of interior nodes with "</literal>
                          <literal type="string">"%d list "</literal>
                          <literal type="string">"at fill %d at compress %d"</literal></argument>,
                          <argument>list_sizes[list]</argument>, <argument>f</argument>, <argument>depth</argument>)</argument_list></macro> <block>{<block_content>
                    <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list_sizes</name><index>[<expr><name>list</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello TAIL"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello HEAD"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>

                    <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>low_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>high_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>at</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition>
                         <incr><expr><name>at</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>at</name> <operator>&lt;</operator> <name>low_raw</name> <operator>||</operator> <name>at</name> <operator>&gt;=</operator> <name>high_raw</name></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Incorrect compression: node %d is "</literal>
                                    <literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
                                    <literal type="string">"nodes: %u; size: %u)"</literal></expr></argument>,
                                    <argument><expr><name>at</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
                                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Incorrect non-compression: node %d is NOT "</literal>
                                    <literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
                                    <literal type="string">"nodes: %u; size: %u; attempted: %d)"</literal></expr></argument>,
                                    <argument><expr><name>at</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
                                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>stop</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>option_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Test Loop %02d: %0.2f seconds.\n"</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
               <argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>runtime</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compressions: %0.2f seconds.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name>stop</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ALL TESTS PASSED!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Sorry, not all tests passed!  In fact, %d tests failed."</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
