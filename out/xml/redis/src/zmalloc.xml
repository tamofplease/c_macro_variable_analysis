<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/zmalloc.c"><comment type="block">/* zmalloc - total amount of allocated memory aware version of malloc()
 *
 * Copyright (c) 2009-2010, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32fixes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_QFork.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_PThread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<comment type="block">/* This function provide us access to the original libc free(). This is useful
 * for instance to free results obtained by backtrace_symbols(). We need
 * to define this function before including zmalloc.h that may shadow the
 * free implementation if we use jemalloc or another non standard allocator. */</comment>
<function><type><name>void</name></type> <name>zlibc_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;pthread.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"atomicvar.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX_SIZE</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX_SIZE</name></cpp:macro> <cpp:value>(sizeof(PORT_LONGLONG))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX_SIZE</name></cpp:macro> <cpp:value>(sizeof(size_t))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Explicitly override malloc/free etc when using tcmalloc. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TCMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tc_malloc(size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc</name><parameter_list>(<parameter><type><name>count</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tc_calloc(count,size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>realloc</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tc_realloc(ptr,size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tc_free(ptr)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_JEMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>je_malloc(size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc</name><parameter_list>(<parameter><type><name>count</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>je_calloc(count,size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>realloc</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>je_realloc(ptr,size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>je_free(ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mallocx</name><parameter_list>(<parameter><type><name>size</name></type></parameter>,<parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>je_mallocx(size,flags)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dallocx</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>,<parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>je_dallocx(ptr,flags)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>update_zmalloc_stat_alloc</name><parameter_list>(<parameter><type><name>__n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    size_t _n = (__n); \
    if (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \
    atomicIncr(used_memory,__n); \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>update_zmalloc_stat_free</name><parameter_list>(<parameter><type><name>__n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    size_t _n = (__n); \
    if (_n&amp;(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&amp;(sizeof(PORT_LONG)-1)); \
    atomicDecr(used_memory,__n); \
} while(0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>used_memory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>used_memory_mutex</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>used_memory_mutex</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>zmalloc_default_oom</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>stderr</argument>, <argument><literal type="string">"zmalloc: Out of memory trying to allocate %Iu bytes\n"</literal></argument>,    <argument>WIN_PORT_FIX <comment type="block">/* %zu -&gt; %Iu */</comment>
        size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>zmalloc_oom_handler</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>zmalloc_default_oom</name></expr></init>;</function_decl>

<function><type><name>void</name> <modifier>*</modifier></type><name>zmalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zmalloc_oom_handler</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ptr</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>+</operator><name>PREFIX_SIZE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Allocation and free functions that bypass the thread cache
 * and go straight to the allocator arena bins.
 * Currently implemented only for jemalloc. Used for online defragmentation. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DEFRAG</name></cpp:ifdef>
<function><type><name>void</name> <modifier>*</modifier></type><name>zmalloc_no_tcache</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>mallocx</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>, <argument><expr><name>MALLOCX_TCACHE_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zmalloc_oom_handler</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zfree_no_tcache</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_free</name><argument_list>(<argument><expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dallocx</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>MALLOCX_TCACHE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <modifier>*</modifier></type><name>zcalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zmalloc_oom_handler</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ptr</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>+</operator><name>PREFIX_SIZE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>zrealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>realptr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>newptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifdef>
    <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>newptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zmalloc_oom_handler</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>update_zmalloc_stat_free</name><argument_list>(<argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>newptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>newptr</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>realptr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>-</operator><name>PREFIX_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>realptr</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>realptr</name></expr></argument>,<argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>newptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zmalloc_oom_handler</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>newptr</name><operator>)</operator> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_free</name><argument_list>(<argument><expr><name>oldsize</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_alloc</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>newptr</name><operator>+</operator><name>PREFIX_SIZE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Provide zmalloc_size() for systems where this function is not provided by
 * malloc itself, given that in that case we store a header with this
 * information as the first bytes of every allocation. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifndef>
<function><type><name>size_t</name></type> <name>zmalloc_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>realptr</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>-</operator><name>PREFIX_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>realptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>size</name><operator>+</operator><name>PREFIX_SIZE</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>size_t</name></type> <name>zmalloc_usable</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>-</operator><name>PREFIX_SIZE</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>zfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>realptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_SIZE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>update_zmalloc_stat_free</name><argument_list>(<argument><expr><call><name>zmalloc_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>realptr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name><operator>-</operator><name>PREFIX_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>realptr</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_zmalloc_stat_free</name><argument_list>(<argument><expr><name>oldsize</name><operator>+</operator><name>PREFIX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>realptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>zstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>zmalloc_used_memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>um</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>atomicGet</name><argument_list>(<argument><expr><name>used_memory</name></expr></argument>,<argument><expr><name>um</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>um</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>zmalloc_set_oom_handler</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>oom_handler</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>zmalloc_oom_handler</name> <operator>=</operator> <name>oom_handler</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Get the RSS information in an OS-specific way.
 *
 * WARNING: the function zmalloc_get_rss() is not designed to be fast
 * and may not be called in the busy loops where Redis tries to release
 * memory expiring or swapping out objects.
 *
 * For this kind of "fast RSS reporting" usages use instead the
 * function RedisEstimateRSS() that is a much faster (and less precise)
 * version of the function. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PROC_STAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<function><type><name>size_t</name></type> <name>zmalloc_get_rss</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>page</name> <init>= <expr><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>rss</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,<argument><expr><literal type="string">"/proc/%d/stat"</literal></expr></argument>,<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt> <comment type="block">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</comment>
    <while>while<condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name>count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>x</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>rss</name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rss</name> <operator>*=</operator> <name>page</name></expr>;</expr_stmt>
    <return>return <expr><name>rss</name></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TASKINFO</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/task.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach_init.h&gt;</cpp:file></cpp:include>

<function><type><name>size_t</name></type> <name>zmalloc_get_rss</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><name>MACH_PORT_NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>task_basic_info</name></name></type> <name>t_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>t_info_count</name> <init>= <expr><name>TASK_BASIC_INFO_COUNT</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>task_for_pid</name><argument_list>(<argument><expr><call><name>current_task</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>task</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>task_info</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>TASK_BASIC_INFO</name></expr></argument>, <argument><expr><operator>(</operator><name>task_info_t</name><operator>)</operator><operator>&amp;</operator><name>t_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_info_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>t_info</name><operator>.</operator><name>resident_size</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>size_t</name></type> <name>zmalloc_get_rss</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* If we can't get the RSS in an OS-specific way for this system just
     * return the memory usage we estimated in zmalloc()..
     *
     * Fragmentation will appear to be always 1 (no fragmentation)
     * of course... */</comment>
    <return>return <expr><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_JEMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type> <name>zmalloc_get_allocator_info</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>,
                               <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>active</name></decl></parameter>,
                               <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>resident</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>epoch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <operator>*</operator><name>resident</name> <operator>=</operator> <operator>*</operator><name>active</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Update the statistics cached by mallctl. */</comment>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>epoch</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"epoch"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>epoch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epoch</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/* Unlike RSS, this does not include RSS from shared libraries and other non
     * heap mappings. */</comment>
    <expr_stmt><expr><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"stats.resident"</literal></expr></argument>, <argument><expr><name>resident</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Unlike resident, this doesn't not include the pages jemalloc reserves
     * for re-use (purge will clean that). */</comment>
    <expr_stmt><expr><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"stats.active"</literal></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Unlike zmalloc_used_memory, this matches the stats.resident by taking
     * into account all allocations done by this process (not only zmalloc). */</comment>
    <expr_stmt><expr><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"stats.allocated"</literal></expr></argument>, <argument><expr><name>allocated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_jemalloc_bg_thread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>enable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* let jemalloc do purging asynchronously, required when there's no traffic 
     * after flushdb */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>val</name> <init>= <expr><operator>!</operator><operator>!</operator><name>enable</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"background_thread"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>int</name></type> <name>zmalloc_get_allocator_info</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>,
                               <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>active</name></decl></parameter>,
                               <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>resident</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>allocated</name> <operator>=</operator> <operator>*</operator><name>resident</name> <operator>=</operator> <operator>*</operator><name>active</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Get the sum of the specified field (converted form kb to bytes) in
 * /proc/self/smaps. The field must be specified with trailing ":" as it
 * apperas in the smaps output.
 *
 * If a pid is specified, the information is extracted for such a pid,
 * otherwise if pid is -1 the information is reported is about the
 * current process.
 *
 * Example: zmalloc_get_smap_bytes_by_field("Rss:",-1);
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PROC_SMAPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>size_t</name></type> <name>zmalloc_get_smap_bytes_by_field</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/proc/self/smaps"</literal></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"/proc/%ld/smaps"</literal></expr></argument>,<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>field</name></expr></argument>,<argument><expr><name>flen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><literal type="char">'k'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>bytes</name> <operator>+=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>line</name><operator>+</operator><name>flen</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>size_t</name></type> <name>zmalloc_get_smap_bytes_by_field</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>field</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>pid</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type> <name>zmalloc_get_private_dirty</name><parameter_list>(<parameter><decl><type><name>PORT_LONG</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zmalloc_get_smap_bytes_by_field</name><argument_list>(<argument><expr><literal type="string">"Private_Dirty:"</literal></expr></argument>,<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the size of physical memory (RAM) in bytes.
 * It looks ugly, but this is the cleanest way to achieve cross platform results.
 * Cleaned up from:
 *
 * http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system
 *
 * Note that this function:
 * 1) Was released under the following CC attribution license:
 *    http://creativecommons.org/licenses/by/3.0/deed.en_US.
 * 2) Was originally implemented by David Robert Nadeau.
 * 3) Was modified for Redis by Matt Stancliff.
 * 4) This note exists in order to comply with the original license.
 */</comment>
<function><type><name>size_t</name></type> <name>zmalloc_get_memory_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__unix</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>unix</name></expr></argument>)</argument_list></call> <operator>||</operator> \
    <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MACH__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CTL_HW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HW_MEMSIZE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HW_PHYSMEM64</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CTL_HW</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HW_MEMSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>HW_MEMSIZE</name></expr>;</expr_stmt>            <comment type="block">/* OSX. --------------------- */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HW_PHYSMEM64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>HW_PHYSMEM64</name></expr>;</expr_stmt>          <comment type="block">/* NetBSD, OpenBSD. --------- */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* 64-bit */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sysctl</name><argument_list>( <argument><expr><name>mib</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>size</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0L</literal></expr>;</return>          <comment type="block">/* Failed? */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PHYS_PAGES</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="block">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</comment>
    <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PHYS_PAGES</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CTL_HW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HW_PHYSMEM</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HW_REALMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
    <comment type="block">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CTL_HW</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HW_REALMEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>HW_REALMEM</name></expr>;</expr_stmt>        <comment type="block">/* FreeBSD. ----------------- */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HW_PHYSMEM</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>HW_PHYSMEM</name></expr>;</expr_stmt>        <comment type="block">/* Others. ------------------ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* 32-bit */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sysctl</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>size</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0L</literal></expr>;</return>          <comment type="block">/* Failed? */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><literal type="number">0L</literal></expr>;</return>          <comment type="block">/* Unknown method to get the data. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><literal type="number">0L</literal></expr>;</return>          <comment type="block">/* Unknown OS. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REDIS_TEST</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)(x))</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>zmalloc_test</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Initial used memory: %zu\n"</literal></expr></argument>, <argument><expr><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Allocated 123 bytes; used: %zu\n"</literal></expr></argument>, <argument><expr><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Reallocated to 456 bytes; used: %zu\n"</literal></expr></argument>, <argument><expr><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Freed pointer; used: %zu\n"</literal></expr></argument>, <argument><expr><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
