<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/hyperloglog.c"><comment type="block">/* hyperloglog.c - Redis HyperLogLog probabilistic cardinality approximation.
 * This file implements the algorithm and the exported Redis commands.
 *
 * Copyright (c) 2014, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<comment type="block">/* The Redis HyperLogLog implementation is based on the following ideas:
 *
 * * The use of a 64 bit hash function as proposed in [1], in order to don't
 *   limited to cardinalities up to 10^9, at the cost of just 1 additional
 *   bit per register.
 * * The use of 16384 6-bit registers for a great level of accuracy, using
 *   a total of 12k per key.
 * * The use of the Redis string data type. No new type is introduced.
 * * No attempt is made to compress the data structure as in [1]. Also the
 *   algorithm used is the original HyperLogLog Algorithm as in [2], with
 *   the only difference that a 64 bit hash function is used, so no correction
 *   is performed for values near 2^32 as in [1].
 *
 * [1] Heule, Nunkesser, Hall: HyperLogLog in Practice: Algorithmic
 *     Engineering of a State of The Art Cardinality Estimation Algorithm.
 *
 * [2] P. Flajolet, Ãric Fusy, O. Gandouet, and F. Meunier. Hyperloglog: The
 *     analysis of a near-optimal cardinality estimation algorithm.
 *
 * Redis uses two representations:
 *
 * 1) A "dense" representation where every entry is represented by
 *    a 6-bit integer.
 * 2) A "sparse" representation using run length compression suitable
 *    for representing HyperLogLogs with many registers set to 0 in
 *    a memory efficient way.
 *
 *
 * HLL header
 * ===
 *
 * Both the dense and sparse representation have a 16 byte header as follows:
 *
 * +------+---+-----+----------+
 * | HYLL | E | N/U | Cardin.  |
 * +------+---+-----+----------+
 *
 * The first 4 bytes are a magic string set to the bytes "HYLL".
 * "E" is one byte encoding, currently set to HLL_DENSE or
 * HLL_SPARSE. N/U are three not used bytes.
 *
 * The "Cardin." field is a 64 bit integer stored in little endian format
 * with the latest cardinality computed that can be reused if the data
 * structure was not modified since the last computation (this is useful
 * because there are high probabilities that HLLADD operations don't
 * modify the actual data structure and hence the approximated cardinality).
 *
 * When the most significant bit in the most significant byte of the cached
 * cardinality is set, it means that the data structure was modified and
 * we can't reuse the cached value that must be recomputed.
 *
 * Dense representation
 * ===
 *
 * The dense representation used by Redis is the following:
 *
 * +--------+--------+--------+------//      //--+
 * |11000000|22221111|33333322|55444444 ....     |
 * +--------+--------+--------+------//      //--+
 *
 * The 6 bits counters are encoded one after the other starting from the
 * LSB to the MSB, and using the next bytes as needed.
 *
 * Sparse representation
 * ===
 *
 * The sparse representation encodes registers using a run length
 * encoding composed of three opcodes, two using one byte, and one using
 * of two bytes. The opcodes are called ZERO, XZERO and VAL.
 *
 * ZERO opcode is represented as 00xxxxxx. The 6-bit integer represented
 * by the six bits 'xxxxxx', plus 1, means that there are N registers set
 * to 0. This opcode can represent from 1 to 64 contiguous registers set
 * to the value of 0.
 *
 * XZERO opcode is represented by two bytes 01xxxxxx yyyyyyyy. The 14-bit
 * integer represented by the bits 'xxxxxx' as most significant bits and
 * 'yyyyyyyy' as least significant bits, plus 1, means that there are N
 * registers set to 0. This opcode can represent from 0 to 16384 contiguous
 * registers set to the value of 0.
 *
 * VAL opcode is represented as 1vvvvvxx. It contains a 5-bit integer
 * representing the value of a register, and a 2-bit integer representing
 * the number of contiguous registers set to that value 'vvvvv'.
 * To obtain the value and run length, the integers vvvvv and xx must be
 * incremented by one. This opcode can represent values from 1 to 32,
 * repeated from 1 to 4 times.
 *
 * The sparse representation can't represent registers with a value greater
 * than 32, however it is very unlikely that we find such a register in an
 * HLL with a cardinality where the sparse representation is still more
 * memory efficient than the dense representation. When this happens the
 * HLL is converted to the dense representation.
 *
 * The sparse representation is purely positional. For example a sparse
 * representation of an empty HLL is just: XZERO:16384.
 *
 * An HLL having only 3 non-zero registers at position 1000, 1020, 1021
 * respectively set to 2, 3, 3, is represented by the following three
 * opcodes:
 *
 * XZERO:1000 (Registers 0-999 are set to 0)
 * VAL:2,1    (1 register set to value 2, that is register 1000)
 * ZERO:19    (Registers 1001-1019 set to 0)
 * VAL:3,2    (2 registers set to value 3, that is registers 1020,1021)
 * XZERO:15362 (Registers 1022-16383 set to 0)
 *
 * In the example the sparse representation used just 7 bytes instead
 * of 12k in order to represent the HLL registers. In general for low
 * cardinality there is a big win in terms of space efficiency, traded
 * with CPU time since the sparse representation is slower to access:
 *
 * The following table shows average cardinality vs bytes used, 100
 * samples per cardinality (when the set was not representable because
 * of registers with too big value, the dense representation size was used
 * as a sample).
 *
 * 100 267
 * 200 485
 * 300 678
 * 400 859
 * 500 1033
 * 600 1205
 * 700 1375
 * 800 1544
 * 900 1713
 * 1000 1882
 * 2000 3480
 * 3000 4879
 * 4000 6089
 * 5000 7138
 * 6000 8042
 * 7000 8823
 * 8000 9500
 * 9000 10088
 * 10000 10591
 *
 * The dense representation uses 12288 bytes, so there is a big win up to
 * a cardinality of ~2000-3000. For bigger cardinalities the constant times
 * involved in updating the sparse representation is not justified by the
 * memory savings. The exact maximum length of the sparse representation
 * when this implementation switches to the dense representation is
 * configured via the define server.hll_sparse_max_bytes.
 */</comment>

<struct>struct <name>hllhdr</name> <block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* "HYLL" */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>encoding</name></decl>;</decl_stmt>   <comment type="block">/* HLL_DENSE or HLL_SPARSE. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>notused</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Reserved for future use, must be zero. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>card</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Cached cardinality, little endian. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>registers</name><index>[]</index></name></decl>;</decl_stmt> <comment type="block">/* Data bytes. */</comment>
}</block>;</struct>

<comment type="block">/* The cached cardinality MSB is used to signal validity of the cached value. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_INVALIDATE_CACHE</name><parameter_list>(<parameter><type><name>hdr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_VALID_CACHE</name><parameter_list>(<parameter><type><name>hdr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_P</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> <comment type="block">/* The greater is P, the smaller the error. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_Q</name></cpp:macro> <cpp:value>(64-HLL_P)</cpp:value></cpp:define> <comment type="block">/* The number of bits of the hash value used for
                            determining the number of leading zeros. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_REGISTERS</name></cpp:macro> <cpp:value>(1&lt;&lt;HLL_P)</cpp:value></cpp:define> <comment type="block">/* With P=14, 16384 registers. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_P_MASK</name></cpp:macro> <cpp:value>(HLL_REGISTERS-1)</cpp:value></cpp:define> <comment type="block">/* Mask to index register. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_BITS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define> <comment type="block">/* Enough to count up to 63 leading zeroes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_REGISTER_MAX</name></cpp:macro> <cpp:value>((1&lt;&lt;HLL_BITS)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_HDR_SIZE</name></cpp:macro> <cpp:value>sizeof(struct hllhdr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_SIZE</name></cpp:macro> <cpp:value>(HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> <comment type="block">/* Dense encoding. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Sparse encoding. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_RAW</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define> <comment type="block">/* Only used internally, never exposed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_MAX_ENCODING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>invalid_hll_err</name> <init>= <expr><literal type="string">"-INVALIDOBJ Corrupted HLL object detected\r\n"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* =========================== Low level bit macros ========================= */</comment>

<comment type="block">/* Macros to access the dense representation.
 *
 * We need to get and set 6 bit counters in an array of 8 bit bytes.
 * We use macros to make sure the code is inlined since speed is critical
 * especially in order to compute the approximated cardinality in
 * HLLCOUNT where we need to access all the registers at once.
 * For the same reason we also want to avoid conditionals in this code path.
 *
 * +--------+--------+--------+------//
 * |11000000|22221111|33333322|55444444
 * +--------+--------+--------+------//
 *
 * Note: in the above representation the most significant bit (MSB)
 * of every byte is on the left. We start using bits from the LSB to MSB,
 * and so forth passing to the next byte.
 *
 * Example, we want to access to counter at pos = 1 ("111111" in the
 * illustration above).
 *
 * The index of the first byte b0 containing our data is:
 *
 *  b0 = 6 * pos / 8 = 0
 *
 *   +--------+
 *   |11000000|  &lt;- Our byte at b0
 *   +--------+
 *
 * The position of the first bit (counting from the LSB = 0) in the byte
 * is given by:
 *
 *  fb = 6 * pos % 8 -&gt; 6
 *
 * Right shift b0 of 'fb' bits.
 *
 *   +--------+
 *   |11000000|  &lt;- Initial value of b0
 *   |00000011|  &lt;- After right shift of 6 pos.
 *   +--------+
 *
 * Left shift b1 of bits 8-fb bits (2 bits)
 *
 *   +--------+
 *   |22221111|  &lt;- Initial value of b1
 *   |22111100|  &lt;- After left shift of 2 bits.
 *   +--------+
 *
 * OR the two bits, and finally AND with 111111 (63 in decimal) to
 * clean the higher order bits we are not interested in:
 *
 *   +--------+
 *   |00000011|  &lt;- b0 right shifted
 *   |22111100|  &lt;- b1 left shifted
 *   |22111111|  &lt;- b0 OR b1
 *   |  111111|  &lt;- (b0 OR b1) AND 63, our value.
 *   +--------+
 *
 * We can try with a different example, like pos = 0. In this case
 * the 6-bit counter is actually contained in a single byte.
 *
 *  b0 = 6 * pos / 8 = 0
 *
 *   +--------+
 *   |11000000|  &lt;- Our byte at b0
 *   +--------+
 *
 *  fb = 6 * pos % 8 = 0
 *
 *  So we right shift of 0 bits (no shift in practice) and
 *  left shift the next byte of 8 bits, even if we don't use it,
 *  but this has the effect of clearing the bits so the result
 *  will not be affacted after the OR.
 *
 * -------------------------------------------------------------------------
 *
 * Setting the register is a bit more complex, let's assume that 'val'
 * is the value we want to set, already in the right range.
 *
 * We need two steps, in one we need to clear the bits, and in the other
 * we need to bitwise-OR the new bits.
 *
 * Let's try with 'pos' = 1, so our first byte at 'b' is 0,
 *
 * "fb" is 6 in this case.
 *
 *   +--------+
 *   |11000000|  &lt;- Our byte at b0
 *   +--------+
 *
 * To create a AND-mask to clear the bits about this position, we just
 * initialize the mask with the value 63, left shift it of "fs" bits,
 * and finally invert the result.
 *
 *   +--------+
 *   |00111111|  &lt;- "mask" starts at 63
 *   |11000000|  &lt;- "mask" after left shift of "ls" bits.
 *   |00111111|  &lt;- "mask" after invert.
 *   +--------+
 *
 * Now we can bitwise-AND the byte at "b" with the mask, and bitwise-OR
 * it with "val" left-shifted of "ls" bits to set the new bits.
 *
 * Now let's focus on the next byte b1:
 *
 *   +--------+
 *   |22221111|  &lt;- Initial value of b1
 *   +--------+
 *
 * To build the AND mask we start again with the 63 value, right shift
 * it by 8-fb bits, and invert it.
 *
 *   +--------+
 *   |00111111|  &lt;- "mask" set at 2&amp;6-1
 *   |00001111|  &lt;- "mask" after the right shift by 8-fb = 2 bits
 *   |11110000|  &lt;- "mask" after bitwise not.
 *   +--------+
 *
 * Now we can mask it with b+1 to clear the old bits, and bitwise-OR
 * with "val" left-shifted by "rs" bits to set the new value.
 */</comment>

<comment type="block">/* Note: if we access the last counter, we will also access the b+1 byte
 * that is out of the array, but sds strings always have an implicit null
 * term, so the byte exists, and we can skip the conditional (or the need
 * to allocate 1 byte more explicitly). */</comment>

<comment type="block">/* Store the value of the register at position 'regnum' into variable 'target'.
 * 'p' is an array of unsigned bytes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_GET_REGISTER</name><parameter_list>(<parameter><type><name>target</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>regnum</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    uint8_t *_p = (uint8_t*) p; \
    PORT_ULONG _byte = regnum*HLL_BITS/8; \
    PORT_ULONG _fb = regnum*HLL_BITS&amp;7; \
    PORT_ULONG _fb8 = 8 - _fb; \
    PORT_ULONG b0 = _p[_byte]; \
    PORT_ULONG b1 = _p[_byte+1]; \
    target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* Set the value of the register at position 'regnum' to 'val'.
 * 'p' is an array of unsigned bytes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_SET_REGISTER</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>regnum</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    uint8_t *_p = (uint8_t*) p; \
    PORT_ULONG _byte = regnum*HLL_BITS/8; \
    PORT_ULONG _fb = regnum*HLL_BITS&amp;7; \
    PORT_ULONG _fb8 = 8 - _fb; \
    PORT_ULONG _v = val; \
    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \
    _p[_byte] |= _v &lt;&lt; _fb; \
    _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \
    _p[_byte+1] |= _v &gt;&gt; _fb8; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* Macros to access the sparse representation.
 * The macros parameter is expected to be an uint8_t pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_BIT</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define> <comment type="block">/* 01xxxxxx */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_BIT</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define> <comment type="block">/* 1vvvvvxx */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_ZERO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0xc0) == 0)</cpp:value></cpp:define> <comment type="block">/* 00xxxxxx */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_XZERO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_VAL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(p)) &amp; HLL_SPARSE_VAL_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0x3f)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_VALUE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0x3)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_MAX_VALUE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_MAX_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_MAX_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_MAX_LEN</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>val</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    *(p) = (((val)-1)&lt;&lt;2|((len)-1))|HLL_SPARSE_VAL_BIT; \
} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    *(p) = (len)-1; \
} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    int _l = (len)-1; \
    *(p) = (_l&gt;&gt;8) | HLL_SPARSE_XZERO_BIT; \
    *((p)+1) = (_l&amp;0xff); \
} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_ALPHA_INF</name></cpp:macro> <cpp:value>0.721347520444481703680</cpp:value></cpp:define> <comment type="block">/* constant for 0.5/ln(2) */</comment>

<comment type="block">/* ========================= HyperLogLog algorithm  ========================= */</comment>

<comment type="block">/* Our hash function is MurmurHash2, 64 bit version.
 * It was modified for Redis in order to provide the same result in
 * big and little endian archs (endian neutral). */</comment>
<function><type><name>uint64_t</name></type> <name>MurmurHash64A</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>m</name> <init>= <expr><literal type="number">0xc6a4a7935bd1e995</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">47</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name> <init>= <expr><name>seed</name> <operator>^</operator> <operator>(</operator><name>len</name> <operator>*</operator> <name>m</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>data</name> <operator>+</operator> <operator>(</operator><name>len</name><operator>-</operator><operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>data</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>BYTE_ORDER</name> <operator>==</operator> <name>LITTLE_ENDIAN</name><operator>)</operator></expr></cpp:if>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ALIGNED_ACCESS</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>^=</operator> <name>k</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <switch>switch<condition>(<expr><name>len</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt> <comment type="block">/* fall-thru */</comment>
    </block_content>}</block></switch><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
    <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Given a string element to add to the HyperLogLog, returns the length
 * of the pattern 000..1 of the element hash. As a side effect 'regp' is
 * set to the register index this element hashes to. */</comment>
<function><type><name>int</name></type> <name>hllPatLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name> <modifier>*</modifier></type><name>regp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>bit</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* Count the number of zeroes starting from bit HLL_REGISTERS
     * (that is a power of two corresponding to the first bit we don't use
     * as index). The max run can be 64-P+1 = Q+1 bits.
     *
     * Note that the final "1" ending the sequence of zeroes must be
     * included in the count, so if we find "001" the count is 3, and
     * the smallest count possible is no zeroes at all, just a 1 bit
     * at the first position, that is a count of 1.
     *
     * This may sound like inefficient, but actually in the average case
     * there are high probabilities to find a 1 after a few iterations. */</comment>
    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>MurmurHash64A</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>elesize</name></expr></argument>,<argument><expr><literal type="number">0xadc83b19ULL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                       <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
    <name>index</name> <init>= <expr><name>hash</name> <operator>&amp;</operator> <name>HLL_P_MASK</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Register index. */</comment>
    <expr_stmt><expr><name>hash</name> <operator>&gt;&gt;=</operator> <name>HLL_P</name></expr>;</expr_stmt> <comment type="block">/* Remove bits used to address the register. */</comment>
    <expr_stmt><expr><name>hash</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>HLL_Q</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Make sure the loop terminates
                                     and count will be &lt;= Q+1. */</comment>
    <expr_stmt><expr><name>bit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Initialized to 1 since we count the "00000...1" pattern. */</comment>
    <while>while<condition>(<expr><operator>(</operator><name>hash</name> <operator>&amp;</operator> <name>bit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>bit</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>regp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>index</name></expr>;</expr_stmt>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ================== Dense representation implementation  ================== */</comment>

<comment type="block">/* Low level function to set the dense HLL register at 'index' to the
 * specified value if the current value is smaller than 'count'.
 *
 * 'registers' is expected to have room for HLL_REGISTERS plus an
 * additional byte on the right. This requirement is met by sds strings
 * automatically since they are implicitly null terminated.
 *
 * The function always succeed, however if as a result of the operation
 * the approximated cardinality changed, 1 is returned. Otherwise 0
 * is returned. */</comment>
<function><type><name>int</name></type> <name>hllDenseSet</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>oldcount</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>oldcount</name></expr></argument>,<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>oldcount</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* "Add" the element in the dense hyperloglog data structure.
 * Actually nothing is added, but the max 0 pattern counter of the subset
 * the element belongs to is incremented if needed.
 *
 * This is just a wrapper to hllDenseSet(), performing the hashing of the
 * element in order to retrieve the index and zero-run count. */</comment>
<function><type><name>int</name></type> <name>hllDenseAdd</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>count</name> <init>= <expr><call><name>hllPatLen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Update the register if this element produced a longer run of zeroes. */</comment>
    <return>return <expr><call><name>hllDenseSet</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute the register histogram in the dense representation. */</comment>
<function><type><name>void</name></type> <name>hllDenseRegHisto</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>reghisto</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Redis default is to use 16384 registers 6 bits each. The code works
     * with other values by modifying the defines, but for our target value
     * we take a faster path with unrolled loops. */</comment>
    <if_stmt><if>if <condition>(<expr><name>HLL_REGISTERS</name> <operator>==</operator> <literal type="number">16384</literal> <operator>&amp;&amp;</operator> <name>HLL_BITS</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>registers</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>r0</name></decl>, <decl><type ref="prev"/><name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>r3</name></decl>, <decl><type ref="prev"/><name>r4</name></decl>, <decl><type ref="prev"/><name>r5</name></decl>, <decl><type ref="prev"/><name>r6</name></decl>, <decl><type ref="prev"/><name>r7</name></decl>, <decl><type ref="prev"/><name>r8</name></decl>, <decl><type ref="prev"/><name>r9</name></decl>,
                      <decl><type ref="prev"/><name>r10</name></decl>, <decl><type ref="prev"/><name>r11</name></decl>, <decl><type ref="prev"/><name>r12</name></decl>, <decl><type ref="prev"/><name>r13</name></decl>, <decl><type ref="prev"/><name>r14</name></decl>, <decl><type ref="prev"/><name>r15</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* Handle 16 registers per iteration. */</comment>
            <expr_stmt><expr><name>r0</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r1</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r3</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r4</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r5</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r6</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r7</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r8</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r9</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r10</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r11</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r12</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r13</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r14</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>r15</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r1</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r2</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r3</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r4</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r5</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r6</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r7</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r8</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r9</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r10</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r11</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r12</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r13</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r14</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r15</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>reg</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>reg</name></expr></argument>,<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>reg</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ================== Sparse representation implementation  ================= */</comment>

<comment type="block">/* Convert the HLL with sparse representation given as input in its dense
 * representation. Both representations are represented by SDS strings, and
 * the input representation is freed as a side effect.
 *
 * The function returns C_OK if the sparse representation was valid,
 * otherwise C_ERR is returned if the representation was corrupted. */</comment>
<function><type><name>int</name></type> <name>hllSparseToDense</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>sparse</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>dense</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oldhdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator><name>sparse</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>sparse</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name><operator>+</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>sparse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the representation is already the right one return ASAP. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>sparse</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Create a string of the right size filled with zero bytes.
     * Note that the cached cardinality is set to 0 as a side effect
     * that is exactly the cardinality of an empty HLL. */</comment>
    <expr_stmt><expr><name>dense</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>dense</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>hdr</name> <operator>=</operator> <operator>*</operator><name>oldhdr</name></expr>;</expr_stmt> <comment type="block">/* This will copy the magic and cached cardinality. */</comment>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_DENSE</name></expr>;</expr_stmt>

    <comment type="block">/* Now read the sparse representation and set non-zero registers
     * accordingly. */</comment>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>runlen</name> <operator>+</operator> <name>idx</name><operator>)</operator> <operator>&gt;</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Overflow. */</comment>
            <while>while<condition>(<expr><name>runlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name>regval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* If the sparse representation was valid, we expect to find idx
     * set to HLL_REGISTERS. */</comment>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>HLL_REGISTERS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Free the old representation and set the new one. */</comment>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>dense</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Low level function to set the sparse HLL register at 'index' to the
 * specified value if the current value is smaller than 'count'.
 *
 * The object 'o' is the String object holding the HLL. The function requires
 * a reference to the object in order to be able to enlarge the string if
 * needed.
 *
 * On success, the function returns 1 if the cardinality changed, or 0
 * if the register for this element was not updated.
 * On error (if the representation is invalid) -1 is returned.
 *
 * As a side effect the function may promote the HLL representation from
 * sparse to dense: this happens when a register requires to be set to a value
 * not representable with the sparse representation, or when the resulting
 * size would be greater than server.hll_sparse_max_bytes. */</comment>
<function><type><name>int</name></type> <name>hllSparseSet</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>oldcount</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sparse</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>span</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>is_zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_xzero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the count is too big to be representable by the sparse representation
     * switch to dense representation. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>HLL_SPARSE_VAL_MAX_VALUE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* When updating a sparse representation, sometimes we may need to
     * enlarge the buffer for up to 3 bytes in the worst case (XZERO split
     * into XZERO-VAL-XZERO). Make sure there is enough space right now
     * so that the pointers we take during the execution of the function
     * will be valid all the time. */</comment>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsMakeRoomFor</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Step 1: we need to locate the opcode we need to modify to check
     * if a value update is actually needed. */</comment>
    <expr_stmt><expr><name>sparse</name> <operator>=</operator> <name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Points to previous opcode at the end of the loop. */</comment>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Points to the next opcode at the end of the loop. */</comment>
    <expr_stmt><expr><name>span</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>oplen</name></decl>;</decl_stmt>

        <comment type="block">/* Set span to the number of registers covered by this opcode.
         *
         * This is the most performance critical loop of the sparse
         * representation. Sorting the conditionals from the most to the
         * least frequent opcode in many-bytes sparse HLLs is faster. */</comment>
        <expr_stmt><expr><name>oplen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_VAL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* XZERO. */</comment>
            <expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>oplen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Break if this opcode covers the register as 'index'. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;=</operator> <name>first</name><operator>+</operator><name>span</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>oplen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>first</name> <operator>+=</operator> <name>span</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>span</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>p</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Invalid format. */</comment>

    <expr_stmt><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr> </then><else>: <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>next</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Cache current opcode type to avoid using the macro again and
     * again for something that will not change.
     * Also cache the run-length of the opcode. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_zero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_xzero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>is_val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Step 2: After the loop:
     *
     * 'first' stores to the index of the first register covered
     *  by the current opcode, which is pointed by 'p'.
     *
     * 'next' ad 'prev' store respectively the next and previous opcode,
     *  or NULL if the opcode at 'p' is respectively the last or first.
     *
     * 'span' is set to the number of registers covered by the current
     *  opcode.
     *
     * There are different cases in order to update the data structure
     * in place without generating it from scratch:
     *
     * A) If it is a VAL opcode already set to a value &gt;= our 'count'
     *    no update is needed, regardless of the VAL run-length field.
     *    In this case PFADD returns 0 since no changes are performed.
     *
     * B) If it is a VAL opcode with len = 1 (representing only our
     *    register) and the value is less than 'count', we just update it
     *    since this is a trivial case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_val</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>oldcount</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Case A. */</comment>
        <if_stmt><if>if <condition>(<expr><name>oldcount</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Case B. */</comment>
        <if_stmt><if>if <condition>(<expr><name>runlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>updated</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* C) Another trivial to handle case is a ZERO opcode with a len of 1.
     * We can just replace it with a VAL opcode with our value and len of 1. */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>&amp;&amp;</operator> <name>runlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>updated</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* D) General case.
     *
     * The other cases are more complex: our register requires to be updated
     * and is either currently represented by a VAL opcode with len &gt; 1,
     * by a ZERO opcode with len &gt; 1, or by an XZERO opcode.
     *
     * In those cases the original opcode must be split into multiple
     * opcodes. The worst case is an XZERO split in the middle resuling into
     * XZERO - VAL - XZERO, so the resulting sequence max length is
     * 5 bytes.
     *
     * We perform the split writing the new sequence into the 'new' buffer
     * with 'newlen' as length. Later the new sequence is inserted in place
     * of the old one, possibly moving what is on the right a few bytes
     * if the new sequence is longer than the older one. */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>seq</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name> <init>= <expr><name>seq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>first</name><operator>+</operator><name>span</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* Last register covered by the sequence. */</comment>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
    <name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>||</operator> <name>is_xzero</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Handle splitting of ZERO / XZERO. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>first</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>index</name><operator>-</operator><name>first</name><operator>)</operator></expr>;</expr_stmt>                                           <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>HLL_SPARSE_ZERO_MAX_LEN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_ZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>last</name><operator>-</operator><name>index</name><operator>)</operator></expr>;</expr_stmt>                                            <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>HLL_SPARSE_ZERO_MAX_LEN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>HLL_SPARSE_ZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Handle splitting of VAL. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>curval</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>first</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>index</name><operator>-</operator><name>first</name><operator>)</operator></expr>;</expr_stmt>                                           <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
            <name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curval</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>last</name><operator>-</operator><name>index</name><operator>)</operator></expr>;</expr_stmt>                                            <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
            <name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curval</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Step 3: substitute the new sequence with the old one.
     *
     * Note that we already allocated space on the sds string
     * calling sdsMakeRoomFor(). */</comment>
     <decl_stmt><decl><type><name>int</name></type> <name>seqlen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>n</name><operator>-</operator><name>seq</name><operator>)</operator></expr></init></decl>;</decl_stmt>                                                 <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
     <name>int</name></type> <name>oldlen</name> <init>= <expr><ternary><condition><expr><name>is_xzero</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>deltalen</name> <init>= <expr><name>seqlen</name><operator>-</operator><name>oldlen</name></expr></init></decl>;</decl_stmt>

     <if_stmt><if>if <condition>(<expr><name>deltalen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
         <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>deltalen</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>hll_sparse_max_bytes</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>
     <if_stmt><if>if <condition>(<expr><name>deltalen</name> <operator>&amp;&amp;</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>next</name><operator>+</operator><name>deltalen</name></expr></argument>,<argument><expr><name>next</name></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
     <expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>deltalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>seq</name></expr></argument>,<argument><expr><name>seqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>end</name> <operator>+=</operator> <name>deltalen</name></expr>;</expr_stmt>

<label><name>updated</name>:</label>
    <comment type="block">/* Step 4: Merge adjacent values if possible.
     *
     * The representation was updated, however the resulting representation
     * may not be optimal: adjacent VAL opcodes can sometimes be merged into
     * a single one. */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>prev</name></expr> ?</condition><then> <expr><name>prev</name></expr> </then><else>: <expr><name>sparse</name></expr></else></ternary></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scanlen</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Scan up to 5 upcodes starting from prev. */</comment>
    <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>scanlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* We need two adjacent VAL opcodes to try a merge, having
         * the same value, and a len that fits the VAL opcode max len. */</comment>
        <if_stmt><if>if <condition>(<expr><name>p</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>HLL_SPARSE_IS_VAL</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>v1</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>HLL_SPARSE_VAL_MAX_LEN</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>
                    <comment type="block">/* After a merge we reiterate without incrementing 'p'
                     * in order to try to merge the just merged value with
                     * a value on its right. */</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Invalidate the cached cardinality. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>promote</name>:</label> <comment type="block">/* Promote to dense representation. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Corrupted HLL. */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <comment type="block">/* We need to call hllDenseAdd() to perform the operation after the
     * conversion. However the result must be 1, since if we need to
     * convert from sparse to dense a register requires to be updated.
     *
     * Note that this in turn means that PFADD will make sure the command
     * is propagated to slaves / AOF, so if there is a sparse -&gt; dense
     * conversion, it will be performed in all the slaves as well. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dense_retval</name> <init>= <expr><call><name>hllDenseSet</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>dense_retval</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>dense_retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* "Add" the element in the sparse hyperloglog data structure.
 * Actually nothing is added, but the max 0 pattern counter of the subset
 * the element belongs to is incremented if needed.
 *
 * This function is actually a wrapper for hllSparseSet(), it only performs
 * the hashshing of the elmenet to obtain the index and zeros run length. */</comment>
<function><type><name>int</name></type> <name>hllSparseAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>count</name> <init>= <expr><call><name>hllPatLen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Update the register if this element produced a longer run of zeroes. */</comment>
    <return>return <expr><call><name>hllSparseSet</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute the register histogram in the sparse representation. */</comment>
<function><type><name>void</name></type> <name>hllSparseRegHisto</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sparse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sparselen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>invalid</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>reghisto</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>sparse</name><operator>+</operator><name>sparselen</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>sparse</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>regval</name></expr>]</index></name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>HLL_REGISTERS</name> <operator>&amp;&amp;</operator> <name>invalid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>invalid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ========================= HyperLogLog Count ==============================
 * This is the core of the algorithm where the approximated count is computed.
 * The function uses the lower level hllDenseRegHisto() and hllSparseRegHisto()
 * functions as helpers to compute histogram of register values part of the
 * computation, which is representation-specific, while all the rest is common. */</comment>

<comment type="block">/* Implements the register histogram calculation for uint8_t data type
 * which is only used internally as speedup for PFCOUNT with multiple keys. */</comment>
<function><type><name>void</name></type> <name>hllRawRegHisto</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>reghisto</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>word</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator> <name>registers</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name><operator>/</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <name>word</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>word</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Helper function sigma as defined in
 * "New cardinality estimation algorithms for HyperLogLog sketches"
 * Otmar Ertl, arXiv:1702.01284 */</comment>
<function><type><name>double</name></type> <name>hllSigma</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">1.</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>INFINITY</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>zPrime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>z</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zPrime</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>x</name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>+=</operator> <name>y</name></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><name>zPrime</name> <operator>!=</operator> <name>z</name></expr>)</condition>;</do>
    <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function tau as defined in
 * "New cardinality estimation algorithms for HyperLogLog sketches"
 * Otmar Ertl, arXiv:1702.01284 */</comment>
<function><type><name>double</name></type> <name>hllTau</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0.</literal> <operator>||</operator> <name>x</name> <operator>==</operator> <literal type="number">1.</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0.</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>zPrime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>z</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <name>x</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zPrime</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>-=</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>-</operator> <name>x</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>*</operator><name>y</name></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><name>zPrime</name> <operator>!=</operator> <name>z</name></expr>)</condition>;</do>
    <return>return <expr><name>z</name> <operator>/</operator> <literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the approximated cardinality of the set based on the harmonic
 * mean of the registers values. 'hdr' points to the start of the SDS
 * representing the String object holding the HLL representation.
 *
 * If the sparse representation of the HLL object is not valid, the integer
 * pointed by 'invalid' is set to non-zero, otherwise it is left untouched.
 *
 * hllCount() supports a special internal-only encoding of HLL_RAW, that
 * is, hdr-&gt;registers will point to an uint8_t array of HLL_REGISTERS element.
 * This is useful in order to speedup PFCOUNT when called against multiple
 * keys (no need to work with 6-bit integers encoding). */</comment>
<function><type><name>uint64_t</name></type> <name>hllCount</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>invalid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>m</name> <init>= <expr><name>HLL_REGISTERS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>E</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <comment type="block">/* Note that reghisto size could be just HLL_Q+2, becuase HLL_Q+1 is
     * the maximum frequency of the "000...1" sequence the hash function is
     * able to return. However it is slow to check for sanity of the
     * input: instead we history array at a safe size: overflows will
     * just write data to wrong, but correctly allocated, places. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name><name>reghisto</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Compute register histogram */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>hllDenseRegHisto</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>reghisto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>hllSparseRegHisto</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,
                         <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>hdr</name></expr></argument>)</argument_list></call><operator>-</operator><name>HLL_HDR_SIZE</name></expr></argument>,<argument><expr><name>invalid</name></expr></argument>,<argument><expr><name>reghisto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_RAW</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>hllRawRegHisto</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>reghisto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown HyperLogLog encoding in hllCount()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Estimate cardinality form register histogram. See:
     * "New cardinality estimation algorithms for HyperLogLog sketches"
     * Otmar Ertl, arXiv:1702.01284 */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>z</name> <init>= <expr><name>m</name> <operator>*</operator> <call><name>hllTau</name><argument_list>(<argument><expr><operator>(</operator><name>m</name><operator>-</operator><name><name>reghisto</name><index>[<expr><name>HLL_Q</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>HLL_Q</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>z</name> <operator>+=</operator> <name><name>reghisto</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>m</name> <operator>*</operator> <call><name>hllSigma</name><argument_list>(<argument><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>llroundl</name><argument_list>(<argument><expr><name>HLL_ALPHA_INF</name><operator>*</operator><name>m</name><operator>*</operator><name>m</name><operator>/</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>E</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */</comment>
<function><type><name>int</name></type> <name>hllAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>HLL_DENSE</name></expr>:</case> <return>return <expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>HLL_SPARSE</name></expr>:</case> <return>return <expr><call><name>hllSparseAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> <comment type="block">/* Invalid representation. */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Merge by computing MAX(registers[i],hll[i]) the HyperLogLog 'hll'
 * with an array of uint8_t HLL_REGISTERS registers pointed by 'max'.
 *
 * The hll object must be already validated via isHLLObjectOrReply()
 * or in some other way.
 *
 * If the HyperLogLog is sparse and is found to be invalid, C_ERR
 * is returned, otherwise the function always succeeds. */</comment>
<function><type><name>int</name></type> <name>hllMerge</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>hll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><name><name>hll</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>val</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <name><name>max</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>max</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>hll</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name> <operator>+</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>hll</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>runlen</name></expr>;</expr_stmt>                                               <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
                <name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>runlen</name></expr>;</expr_stmt>                                               <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
                <name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>runlen</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>&gt;</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Overflow. */</comment>
                <while>while<condition>(<expr><name>runlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>regval</name> <operator>&gt;</operator> <name><name>max</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>max</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>regval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>              <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (uint8_t) */</comment>
                    <name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ========================== HyperLogLog commands ========================== */</comment>

<comment type="block">/* Create an HLL object. We always create the HLL using sparse encoding.
 * This will be upgraded to the dense representation as needed. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createHLLObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sparselen</name> <init>= <expr><name>HLL_HDR_SIZE</name> <operator>+</operator>
                    <operator>(</operator><operator>(</operator><operator>(</operator><name>HLL_REGISTERS</name><operator>+</operator><operator>(</operator><name>HLL_SPARSE_XZERO_MAX_LEN</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator>
                     <name>HLL_SPARSE_XZERO_MAX_LEN</name><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>aux</name></decl>;</decl_stmt>

    <comment type="block">/* Populate the sparse representation with as many XZERO opcodes as
     * needed to represent all the registers. */</comment>
    <expr_stmt><expr><name>aux</name> <operator>=</operator> <name>HLL_REGISTERS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>sparselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>aux</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>xzero</name> <init>= <expr><name>HLL_SPARSE_XZERO_MAX_LEN</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>xzero</name> <operator>&gt;</operator> <name>aux</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xzero</name> <operator>=</operator> <name>aux</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>xzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>aux</name> <operator>-=</operator> <name>xzero</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name><operator>-</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>s</name><operator>)</operator> <operator>==</operator> <name>sparselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the actual object. */</comment>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>,<argument><expr><literal type="string">"HYLL"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_SPARSE</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check if the object is a String with a valid HLL representation.
 * Return C_OK if this is true, otherwise reply to the client
 * with an error and return C_ERR. */</comment>
<function><type><name>int</name></type> <name>isHLLObjectOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

    <comment type="block">/* Key exists, check type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Error already sent. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>stringObjectLen</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Magic should be "HYLL". */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'H'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'Y'</literal> <operator>||</operator>
        <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>&gt;</operator> <name>HLL_MAX_ENCODING</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Dense representation string length should match exactly. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name> <operator>&amp;&amp;</operator>
        <call><name>stringObjectLen</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HLL_DENSE_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* All tests passed. */</comment>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>invalid</name>:</label>
    <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
        <argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-WRONGTYPE Key is not a valid "</literal>
               <literal type="string">"HyperLogLog string value.\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PFADD var ele ele ele ... ele =&gt; :0 or :1 */</comment>
<function><type><name>void</name></type> <name>pfaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>updated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Create the key with a string value of the exact length to
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */</comment>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createHLLObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Perform the low level ADD operation for every element. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>hllAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
                               <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STRING</name></expr></argument>,<argument><expr><literal type="string">"pfadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name>updated</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PFCOUNT var -&gt; approximated cardinality of set. */</comment>
<function><type><name>void</name></type> <name>pfcountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>card</name></decl>;</decl_stmt>

    <comment type="block">/* Case 1: multi-key keys, cardinality of the union.
     *
     * When multiple keys are specified, PFCOUNT actually computes
     * the cardinality of the merge of the N HLLs specified. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>max</name><index>[<expr><name>HLL_HDR_SIZE</name><operator>+</operator><name>HLL_REGISTERS</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>registers</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Compute an HLL with M[i] = MAX(M[i]_j). */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>max</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_RAW</name></expr>;</expr_stmt> <comment type="block">/* Special internal-only encoding. */</comment>
        <expr_stmt><expr><name>registers</name> <operator>=</operator> <name>max</name> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* Check type and size. */</comment>
            <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Assume empty HLL for non existing var.*/</comment>
            <if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

            <comment type="block">/* Merge with this HLL with our 'max' HHL by setting max[i]
             * to MAX(max[i],hll[i]). */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>hllMerge</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Compute cardinality of the resulting set. */</comment>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Case 2: cardinality of the single HLL.
     *
     * The user specified a single key. Either return the cached value
     * or compute one and update the cache. */</comment>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No key? Cardinality is zero since no element was added, otherwise
         * we would have a key as HLLADD creates it as a side effect. */</comment>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check if the cached cardinality is valid. */</comment>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HLL_VALID_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Just return the cached value. */</comment>
            <expr_stmt><expr><name>card</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>invalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Recompute it and update the cached value. */</comment>
            <expr_stmt><expr><name>card</name> <operator>=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>invalid</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>card</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">40</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">56</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
            <comment type="block">/* This is not considered a read-only command even if the
             * data structure is not modified, since the cached value
             * may be modified and given that the HLL is a Redis string
             * we need to propagate the change. */</comment>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>card</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* PFMERGE dest src1 src2 src3 ... srcN =&gt; OK */</comment>
<function><type><name>void</name></type> <name>pfmergeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>max</name><index>[<expr><name>HLL_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>use_dense</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Use dense representation as target? */</comment>

    <comment type="block">/* Compute an HLL with M[i] = MAX(M[i]_j).
     * We store the maximum into the max array of registers. We'll write
     * it to the target variable later. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Check type and size. */</comment>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Assume empty HLL for non existing var. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/* If at least one involved HLL is dense, use the dense representation
         * as target ASAP to save time and avoid the conversion step. */</comment>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>use_dense</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Merge with this HLL with our 'max' HHL by setting max[i]
         * to MAX(max[i],hll[i]). */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>hllMerge</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Create / unshare the destination key's value if needed. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Create the key with a string value of the exact length to
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */</comment>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createHLLObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If key exists we are sure it's of the right type/size
         * since we checked when merging the different HLLs, so we
         * don't check again. */</comment>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Convert the destination object to dense representation if at least
     * one of the inputs was dense. */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_dense</name> <operator>&amp;&amp;</operator> <call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Write the resulting HLL to the destination HLL registers and
     * invalidate the cached value. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>HLL_DENSE</name></expr>:</case> <expr_stmt><expr><call><name>hllDenseSet</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>HLL_SPARSE</name></expr>:</case> <expr_stmt><expr><call><name>hllSparseSet</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt> <comment type="block">/* o-&gt;ptr may be different now, as a side effect of
                     last hllSparseSet() call. */</comment>
    <expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We generate a PFADD event for PFMERGE for semantical simplicity
     * since in theory this is a mass-add of elements. */</comment>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STRING</name></expr></argument>,<argument><expr><literal type="string">"pfadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ========================== Testing / Debugging  ========================== */</comment>

<comment type="block">/* PFSELFTEST
 * This command performs a self-test of the HLL registers implementation.
 * Something that is not easy to test from within the outside. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_TEST_CYCLES</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>pfselftestCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>bitcounters</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>bitcounters</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hdr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>bytecounters</name><index>[<expr><name>HLL_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Test 1: access registers.
     * The test is conceived to test that the different counters of our data
     * structure are accessible and that setting their values both result in
     * the correct value to be retained and not affect adjacent values. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_TEST_CYCLES</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Set the HLL counters and an array of unsigned byes of the
         * same size to the same set of random values. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name> <init>= <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>HLL_REGISTER_MAX</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* Check that we are able to retrieve the same values. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"TESTFAILED Register %d should be %d but is %d"</literal></expr></argument>,
                    <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* Test 2: approximation error.
     * The test adds unique elements and check that the estimated value
     * is always reasonable bounds.
     *
     * We check that the error is smaller than a few times than the expected
     * standard error, to make it very unlikely for the test to fail because
     * of a "bad" run.
     *
     * The test is performed with both dense and sparse HLLs at the same
     * time also verifying that the computed cardinality is the same. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name><operator>-</operator><name>HLL_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createHLLObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>relerr</name> <init>= <expr><literal type="number">1.04</literal><operator>/</operator><call><name>sqrt</name><argument_list>(<argument><expr><name>HLL_REGISTERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>checkpoint</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>seed</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>|</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>ele</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <literal type="number">10000000</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>ele</name> <operator>=</operator> <name>j</name> <operator>^</operator> <name>seed</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hllAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure that for small cardinalities we use sparse
         * encoding. */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>hll_sparse_max_bytes</name></name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hdr2</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>hdr2</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"TESTFAILED sparse encoding not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check that dense and sparse representations agree. */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name> <operator>&amp;&amp;</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"TESTFAILED dense/sparse disagree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check error. */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>abserr</name> <init>= <expr><name>checkpoint</name> <operator>-</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>maxerr</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><name>relerr</name><operator>*</operator><literal type="number">6</literal><operator>*</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>              <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (uint64_t) */</comment>

            <comment type="block">/* Adjust the max error we expect for cardinality 10
             * since from time to time it is statistically likely to get
             * much higher error due to collision, resulting into a false
             * positive. */</comment>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxerr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>abserr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>abserr</name> <operator>=</operator> <operator>-</operator><name>abserr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>abserr</name> <operator>&gt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>maxerr</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"TESTFAILED Too big error. card:%llu abserr:%llu"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name>checkpoint</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name>abserr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>checkpoint</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Success! */</comment>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>bitcounters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* PFDEBUG &lt;subcommand&gt; &lt;key&gt; ... args ...
 * Different debugging related operations about the HLL implementation. */</comment>
<function><type><name>void</name></type> <name>pfdebugCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The specified key does not exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <comment type="block">/* PFDEBUG GETREG &lt;key&gt; */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"getreg"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Force propagation on encoding change. */</comment>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>HLL_REGISTERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>uint8_t</name></type> <name>val</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <comment type="block">/* PFDEBUG DECODE &lt;key&gt; */</comment>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"decode"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name><operator>+</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>decoded</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"HLL encoding is not sparse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">"z:%d "</literal></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">"Z:%d "</literal></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">"v:%d,%d "</literal></expr></argument>,<argument><expr><name>regval</name></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdstrim</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>decoded</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* PFDEBUG ENCODING &lt;key&gt; */</comment>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>encodingstr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"dense"</literal></expr>,<expr><literal type="string">"sparse"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>addReplyStatus</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>encodingstr</name><index>[<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* PFDEBUG TODENSE &lt;key&gt; */</comment>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"todense"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>conv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>conv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Force propagation on encoding change. */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>conv</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown PFDEBUG subcommand '%s'"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return;</return>

<label><name>arityerr</name>:</label>
    <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
        <argument><expr><literal type="string">"Wrong number of arguments for the '%s' subcommand"</literal></expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
