<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/listpack.c"><comment type="block">/* Listpack -- A lists of strings serialization format
 *
 * This file implements the specification you can find at:
 *
 *  https://github.com/antirez/listpack
 *
 * Copyright (c) 2017, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"listpack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"listpack_malloc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_HDR_SIZE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>       <comment type="block">/* 32 bit total len + 16 bit number of elements. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_HDR_NUMELE_UNKNOWN</name></cpp:macro> <cpp:value>UINT16_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MAX_INT_ENCODING_LEN</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MAX_BACKLEN_SIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MAX_ENTRY_BACKLEN</name></cpp:macro> <cpp:value>34359738367ULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_INT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_STRING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_7BIT_UINT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_7BIT_UINT_MASK</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_7BIT_UINT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_7BIT_UINT_MASK)==LP_ENCODING_7BIT_UINT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_6BIT_STR</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_6BIT_STR_MASK</name></cpp:macro> <cpp:value>0xC0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_6BIT_STR</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_6BIT_STR_MASK)==LP_ENCODING_6BIT_STR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_13BIT_INT</name></cpp:macro> <cpp:value>0xC0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_13BIT_INT_MASK</name></cpp:macro> <cpp:value>0xE0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_13BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_12BIT_STR</name></cpp:macro> <cpp:value>0xE0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_12BIT_STR_MASK</name></cpp:macro> <cpp:value>0xF0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_12BIT_STR</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_16BIT_INT</name></cpp:macro> <cpp:value>0xF1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_16BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_16BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_24BIT_INT</name></cpp:macro> <cpp:value>0xF2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_24BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_24BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_24BIT_INT_MASK)==LP_ENCODING_24BIT_INT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_INT</name></cpp:macro> <cpp:value>0xF3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_32BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_32BIT_INT_MASK)==LP_ENCODING_32BIT_INT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_64BIT_INT</name></cpp:macro> <cpp:value>0xF4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_64BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_64BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_64BIT_INT_MASK)==LP_ENCODING_64BIT_INT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_STR</name></cpp:macro> <cpp:value>0xF0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_STR_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_32BIT_STR</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_32BIT_STR_MASK)==LP_ENCODING_32BIT_STR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_EOF</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_6BIT_STR_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[0] &amp; 0x3F)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_12BIT_STR_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((p)[0] &amp; 0xF) &lt;&lt; 8) | (p)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_STR_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint32_t)(p)[1]&lt;&lt;0) | \
                                      ((uint32_t)(p)[2]&lt;&lt;8) | \
                                      ((uint32_t)(p)[3]&lt;&lt;16) | \
                                      ((uint32_t)(p)[4]&lt;&lt;24))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpGetTotalBytes</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>           <cpp:value>(((uint32_t)(p)[0]&lt;&lt;0) | \
                                      ((uint32_t)(p)[1]&lt;&lt;8) | \
                                      ((uint32_t)(p)[2]&lt;&lt;16) | \
                                      ((uint32_t)(p)[3]&lt;&lt;24))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpGetNumElements</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>(((uint32_t)(p)[4]&lt;&lt;0) | \
                                      ((uint32_t)(p)[5]&lt;&lt;8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpSetTotalBytes</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    (p)[0] = (v)&amp;0xff; \
    (p)[1] = ((v)&gt;&gt;8)&amp;0xff; \
    (p)[2] = ((v)&gt;&gt;16)&amp;0xff; \
    (p)[3] = ((v)&gt;&gt;24)&amp;0xff; \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpSetNumElements</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    (p)[4] = (v)&amp;0xff; \
    (p)[5] = ((v)&gt;&gt;8)&amp;0xff; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* Convert a string into a signed 64 bit integer.
 * The function returns 1 if the string could be parsed into a (non-overflowing)
 * signed 64 bit int, 0 otherwise. The 'value' will be set to the parsed value
 * when the function returns success.
 *
 * Note that this function demands that the string strictly represents
 * a int64 value: no spaces or other characters before or after the string
 * representing the number are accepted, nor zeroes at the start if not
 * for the string "0" representing the zero number.
 *
 * Because of its strictness, it is safe to use this function to check if
 * you can convert a string into a long long, and obtain back the string
 * from the number without any loss in the string representation. *
 *
 * -----------------------------------------------------------------------------
 *
 * Credits: this function was adapted from the Redis source code, file
 * "utils.c", function string2ll(), and is copyright:
 *
 * Copyright(C) 2011, Pieter Noordhuis
 * Copyright(C) 2011, Salvatore Sanfilippo
 *
 * The function is released under the BSD 3-clause license.
 */</comment>
<function><type><name>int</name></type> <name>lpStringToInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>plen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>v</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>plen</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Special case: first and only digit is 0. */</comment>
    <if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>negative</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>plen</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Abort on only a negative sign. */</comment>
        <if_stmt><if>if <condition>(<expr><name>plen</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* First digit should be 1-9, otherwise the string should just be 0. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>plen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>slen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <while>while <condition>(<expr><name>plen</name> <operator>&lt;</operator> <name>slen</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <operator>(</operator><name>UINT64_MAX</name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* Overflow. */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>v</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <operator>(</operator><name>UINT64_MAX</name> <operator>-</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* Overflow. */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>v</name> <operator>+=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>plen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Return if not all bytes were used. */</comment>
    <if_stmt><if>if <condition>(<expr><name>plen</name> <operator>&lt;</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>negative</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>INT64_MIN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* Overflow. */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name>INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* Overflow. */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new, empty listpack.
 * On success the new listpack is returned, otherwise an error is returned. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lp_malloc</name><argument_list>(<argument><expr><name>LP_HDR_SIZE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>LP_HDR_SIZE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lp</name><index>[<expr><name>LP_HDR_SIZE</name></expr>]</index></name> <operator>=</operator> <name>LP_EOF</name></expr>;</expr_stmt>
    <return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free the specified listpack. */</comment>
<function><type><name>void</name></type> <name>lpFree</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>lp_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Given an element 'ele' of size 'size', determine if the element can be
 * represented inside the listpack encoded as integer, and returns
 * LP_ENCODING_INT if so. Otherwise returns LP_ENCODING_STR if no integer
 * encoding is possible.
 *
 * If the LP_ENCODING_INT is returned, the function stores the integer encoded
 * representation of the element in the 'intenc' buffer.
 *
 * Regardless of the returned encoding, 'enclen' is populated by reference to
 * the number of bytes that the string or integer encoded element will require
 * in order to be represented. */</comment>
<function><type><name>int</name></type> <name>lpEncodeGetType</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>intenc</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>enclen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>v</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lpStringToInt64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Single byte 0-127 integer. */</comment>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">4096</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">4095</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* 13 bit integer. */</comment>
            <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">13</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>|</operator><name>LP_ENCODING_13BIT_INT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">32768</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">32767</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* 16 bit integer. */</comment>
            <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_16BIT_INT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">8388608</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">8388607</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* 24 bit integer. */</comment>
            <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_24BIT_INT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">2147483648</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">2147483647</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* 32 bit integer. */</comment>
            <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_32BIT_INT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* 64 bit integer. */</comment>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>uv</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_64BIT_INT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>uv</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">40</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">48</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>uv</name><operator>&gt;&gt;</operator><literal type="number">56</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>LP_ENCODING_INT</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>size</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">2</literal><operator>+</operator><name>size</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">5</literal><operator>+</operator><name>size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><name>LP_ENCODING_STRING</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Store a reverse-encoded variable length field, representing the length
 * of the previous element of size 'l', in the target buffer 'buf'.
 * The function returns the number of bytes used to encode it, from
 * 1 to 5. If 'buf' is NULL the function just returns the number of bytes
 * needed in order to encode the backlen. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>lpEncodeBacklen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">16383</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">2097151</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">268435455</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">21</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">14</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">28</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">21</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">14</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">5</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Decode the backlen and returns it. If the encoding looks invalid (more than
 * 5 bytes are used), UINT64_MAX is returned to report the problem. */</comment>
<function><type><name>uint64_t</name></type> <name>lpDecodeBacklen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>shift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">128</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>shift</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&gt;</operator> <literal type="number">28</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>UINT64_MAX</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block> while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
    <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Encode the string element pointed by 's' of size 'len' in the target
 * buffer 's'. The function should be called with 'buf' having always enough
 * space for encoding the string. This is done by calling lpEncodeGetType()
 * before calling this function. */</comment>
<function><type><name>void</name></type> <name>lpEncodeString</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>|</operator> <name>LP_ENCODING_6BIT_STR</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>LP_ENCODING_12BIT_STR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_32BIT_STR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">5</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the encoded length of the listpack element pointed by 'p'. If the
 * element encoding is wrong then 0 is returned. */</comment>
<function><type><name>uint32_t</name></type> <name>lpCurrentEncodedSize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_6BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal><operator>+</operator><call><name>LP_ENCODING_6BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">9</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_12BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal><operator>+</operator><call><name>LP_ENCODING_12BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">5</literal><operator>+</operator><call><name>LP_ENCODING_32BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Skip the current entry returning the next. It is invalid to call this
 * function if the current element is the EOF element at the end of the
 * listpack, however, while this function is used to implement lpNext(),
 * it does not return NULL when the EOF element is encountered. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpSkip</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>entrylen</name> <init>= <expr><call><name>lpCurrentEncodedSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>entrylen</name> <operator>+=</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>entrylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>entrylen</name></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If 'p' points to an element of the listpack, calling lpNext() will return
 * the pointer to the next element (the one on the right), or NULL if 'p'
 * already pointed to the last element of the listpack. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>lp</name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* lp is not used for now. However lpPrev() uses it. */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSkip</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If 'p' points to an element of the listpack, calling lpPrev() will return
 * the pointer to the preivous element (the one on the left), or NULL if 'p'
 * already pointed to the first element of the listpack. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpPrev</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>p</name><operator>-</operator><name>lp</name> <operator>==</operator> <name>LP_HDR_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* Seek the first backlen byte of the last element. */</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>prevlen</name> <init>= <expr><call><name>lpDecodeBacklen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>prevlen</name> <operator>+=</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>p</name><operator>-</operator><name>prevlen</name><operator>+</operator><literal type="number">1</literal></expr>;</return> <comment type="block">/* Seek the first byte of the previous entry. */</comment>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to the first element of the listpack, or NULL if the
 * listpack has no elements. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpFirst</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>lp</name> <operator>+=</operator> <name>LP_HDR_SIZE</name></expr>;</expr_stmt> <comment type="block">/* Skip the header. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to the last element of the listpack, or NULL if the
 * listpack has no elements. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpLast</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>lp</name><operator>+</operator><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Seek EOF element. */</comment>
    <return>return <expr><call><name>lpPrev</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* Will return NULL if EOF is the only element. */</comment>
</block_content>}</block></function>

<comment type="block">/* Return the number of elements inside the listpack. This function attempts
 * to use the cached value when within range, otherwise a full scan is
 * needed. As a side effect of calling this function, the listpack header
 * could be modified, because if the count is found to be already within
 * the 'numele' header field range, the new value is set. */</comment>
<function><type><name>uint32_t</name></type> <name>lpLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>numele</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Too many elements inside the listpack. We need to scan in order
     * to get the total number. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* If the count is again within range of the header numele field,
     * set it. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the listpack element pointed by 'p'.
 *
 * The function changes behavior depending on the passed 'intbuf' value.
 * Specifically, if 'intbuf' is NULL:
 *
 * If the element is internally encoded as an integer, the function returns
 * NULL and populates the integer value by reference in 'count'. Otherwise if
 * the element is encoded as a string a pointer to the string (pointing inside
 * the listpack itself) is returned, and 'count' is set to the length of the
 * string.
 *
 * If instead 'intbuf' points to a buffer passed by the caller, that must be
 * at least LP_INTBUF_SIZE bytes, the function always returns the element as
 * it was a string (returning the pointer to the string and setting the
 * 'count' argument to the string length by reference). However if the element
 * is encoded as an integer, the 'intbuf' buffer is used in order to store
 * the string representation.
 *
 * The user should use one or the other form depending on what the value will
 * be used for. If there is immediate usage for an integer value returned
 * by the function, than to pass a buffer (and convert it back to a number)
 * is of course useless.
 *
 * If the function is called against a badly encoded ziplist, so that there
 * is no valid way to parse it, the function returns like if there was an
 * integer encoded with value 12345678900000000 + &lt;unrecognized byte&gt;, this may
 * be an hint to understand that something is wrong. To crash in this case is
 * not sensible because of the different requirements of the application using
 * this lib.
 *
 * Similarly, there is no error returned since the listpack normally can be
 * assumed to be valid, so that would be a very high API cost. However a function
 * in order to check the integrity of the listpack at load time is provided,
 * check lpIsValid(). */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpGet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>intbuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>uval</name></decl>, <decl><type ref="prev"/><name>negstart</name></decl>, <decl><type ref="prev"/><name>negmax</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt> <comment type="block">/* 7 bit ints are always positive. */</comment>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_6BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>LP_ENCODING_6BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x1f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">12</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <literal type="number">8191</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">23</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT32_MAX</name><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">31</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">40</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">48</literal> <operator>|</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">56</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">63</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_12BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>LP_ENCODING_12BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>LP_ENCODING_32BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name><operator>+</operator><literal type="number">5</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <literal type="number">12345678900000000ULL</literal> <operator>+</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>negstart</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>negmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* We reach this code path only for integer encodings.
     * Convert the unsigned value to the signed one using two's complement
     * rule. */</comment>
    <if_stmt><if>if <condition>(<expr><name>uval</name> <operator>&gt;=</operator> <name>negstart</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* This three steps conversion should avoid undefined behaviors
         * in the unsigned -&gt; signed conversion. */</comment>
        <expr_stmt><expr><name>uval</name> <operator>=</operator> <name>negmax</name><operator>-</operator><name>uval</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <name>uval</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><name>val</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <name>uval</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Return the string representation of the integer or the value itself
     * depending on intbuf being NULL or not. */</comment>
    <if_stmt><if>if <condition>(<expr><name>intbuf</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>intbuf</name></expr></argument>,<argument><expr><name>LP_INTBUF_SIZE</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>intbuf</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Insert, delete or replace the specified element 'ele' of length 'len' at
 * the specified position 'p', with 'p' being a listpack element pointer
 * obtained with lpFirst(), lpLast(), lpIndex(), lpNext(), lpPrev() or
 * lpSeek().
 *
 * The element is inserted before, after, or replaces the element pointed
 * by 'p' depending on the 'where' argument, that can be LP_BEFORE, LP_AFTER
 * or LP_REPLACE.
 *
 * If 'ele' is set to NULL, the function removes the element pointed by 'p'
 * instead of inserting one.
 *
 * Returns NULL on out of memory or when the listpack total length would exceed
 * the max allowed size of 2^32-1, otherwise the new pointer to the listpack
 * holding the new element is returned (and the old pointer passed is no longer
 * considered valid)
 *
 * If 'newp' is not NULL, at the end of a successful call '*newp' will be set
 * to the address of the element just added, so that it will be possible to
 * continue an interation with lpNext() and lpPrev().
 *
 * For deletion operations ('ele' set to NULL) 'newp' is set to the next
 * element, on the right of the deleted one, or to NULL if the deleted element
 * was the last one. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpInsert</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>intenc</name><index>[<expr><name>LP_MAX_INT_ENCODING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>backlen</name><index>[<expr><name>LP_MAX_BACKLEN_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>enclen</name></decl>;</decl_stmt> <comment type="block">/* The length of the encoded element. */</comment>

    <comment type="block">/* An element pointer set to NULL means deletion, which is conceptually
     * replacing the element with a zero-length element. So whatever we
     * get passed as 'where', set it to LP_REPLACE. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ele</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>where</name> <operator>=</operator> <name>LP_REPLACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If we need to insert after the current element, we just jump to the
     * next element (that could be the EOF one) and handle the case of
     * inserting before. So the function will actually deal with just two
     * cases: LP_BEFORE and LP_REPLACE. */</comment>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>LP_AFTER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSkip</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>where</name> <operator>=</operator> <name>LP_BEFORE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Store the offset of the element 'p', so that we can obtain its
     * address again after a reallocation. */</comment>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>poff</name> <init>= <expr><name>p</name><operator>-</operator><name>lp</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Calling lpEncodeGetType() results into the encoded version of the
     * element to be stored into 'intenc' in case it is representable as
     * an integer: in that case, the function returns LP_ENCODING_INT.
     * Otherwise if LP_ENCODING_STR is returned, we'll have to call
     * lpEncodeString() to actually write the encoded string on place later.
     *
     * Whatever the returned encoding is, 'enclen' is populated with the
     * length of the encoded element. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>enctype</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ele</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>enctype</name> <operator>=</operator> <call><name>lpEncodeGetType</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name>intenc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>enctype</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* We need to also encode the backward-parsable length of the element
     * and append it to the end: this allows to traverse the listpack from
     * the end to the start. */</comment>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>backlen_size</name> <init>= <expr><ternary><condition><expr><name>ele</name></expr> ?</condition><then> <expr><call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>backlen</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>old_listpack_bytes</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>replaced_len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>LP_REPLACE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>replaced_len</name> <operator>=</operator> <call><name>lpCurrentEncodedSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>replaced_len</name> <operator>+=</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>replaced_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>new_listpack_bytes</name> <init>= <expr><name>old_listpack_bytes</name> <operator>+</operator> <name>enclen</name> <operator>+</operator> <name>backlen_size</name>
                                  <operator>-</operator> <name>replaced_len</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>new_listpack_bytes</name> <operator>&gt;</operator> <name>UINT32_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* We now need to reallocate in order to make space or shrink the
     * allocation (in case 'when' value is LP_REPLACE and the new element is
     * smaller). However we do that before memmoving the memory to
     * make room for the new element if the final allocation will get
     * larger, or we do it after if the final allocation will get smaller. */</comment>

    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>poff</name></expr></init></decl>;</decl_stmt> <comment type="block">/* May be updated after reallocation. */</comment>

    <comment type="block">/* Realloc before: we need more room. */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_listpack_bytes</name> <operator>&gt;</operator> <name>old_listpack_bytes</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>lp_realloc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>new_listpack_bytes</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <name>lp</name> <operator>+</operator> <name>poff</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Setup the listpack relocating the elements to make the exact room
     * we need to store the new one. */</comment>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>LP_BEFORE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name><operator>+</operator><name>enclen</name><operator>+</operator><name>backlen_size</name></expr></argument>,<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>old_listpack_bytes</name><operator>-</operator><name>poff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* LP_REPLACE. */</comment>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>lendiff</name> <init>= <expr><operator>(</operator><name>enclen</name><operator>+</operator><name>backlen_size</name><operator>)</operator><operator>-</operator><name>replaced_len</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name><operator>+</operator><name>replaced_len</name><operator>+</operator><name>lendiff</name></expr></argument>,
                <argument><expr><name>dst</name><operator>+</operator><name>replaced_len</name></expr></argument>,
                <argument><expr><name>old_listpack_bytes</name><operator>-</operator><name>poff</name><operator>-</operator><name>replaced_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Realloc after: we need to free space. */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_listpack_bytes</name> <operator>&lt;</operator> <name>old_listpack_bytes</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>lp_realloc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>new_listpack_bytes</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <name>lp</name> <operator>+</operator> <name>poff</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Store the entry. */</comment>
    <if_stmt><if>if <condition>(<expr><name>newp</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>newp</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
        <comment type="block">/* In case of deletion, set 'newp' to NULL if the next element is
         * the EOF element. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ele</name> <operator>&amp;&amp;</operator> <name><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ele</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>enctype</name> <operator>==</operator> <name>LP_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>intenc</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>lpEncodeString</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>enclen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>backlen</name></expr></argument>,<argument><expr><name>backlen_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>backlen_size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update header. */</comment>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>!=</operator> <name>LP_REPLACE</name> <operator>||</operator> <name>ele</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_elements</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>num_elements</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ele</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>num_elements</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>num_elements</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>new_listpack_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* This code path is normally disabled: what it does is to force listpack
     * to return *always* a new pointer after performing some modification to
     * the listpack, even if the previous allocation was enough. This is useful
     * in order to spot bugs in code using listpacks: by doing so we can find
     * if the caller forgets to set the new pointer where the listpack reference
     * is stored, after an update. */</comment>
    unsigned char *oldlp = lp;
    lp = lp_malloc(new_listpack_bytes);
    memcpy(lp,oldlp,new_listpack_bytes);
    if (newp) {
        unsigned long offset = (*newp)-oldlp;
        *newp = lp + offset;
    }
    <comment type="block">/* Make sure the old allocation contains garbage. */</comment>
    memset(oldlp,'A',new_listpack_bytes);
    lp_free(oldlp);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append the specified element 'ele' of length 'len' at the end of the
 * listpack. It is implemented in terms of lpInsert(), so the return value is
 * the same as lpInsert(). */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpAppend</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>listpack_bytes</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eofptr</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>listpack_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name>eofptr</name></expr></argument>,<argument><expr><name>LP_BEFORE</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the element pointed by 'p', and return the resulting listpack.
 * If 'newp' is not NULL, the next element pointer (to the right of the
 * deleted one) is returned by reference. If the deleted element was the
 * last one, '*newp' is set to NULL. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpDelete</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>LP_REPLACE</name></expr></argument>,<argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the total number of bytes the listpack is composed of. */</comment>
<function><type><name>uint32_t</name></type> <name>lpBytes</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Seek the specified element and returns the pointer to the seeked element.
 * Positive indexes specify the zero-based element to seek from the head to
 * the tail, negative indexes specify elements starting from the tail, where
 * -1 means the last element, -2 the penultimate and so forth. If the index
 * is out of range, NULL is returned. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpSeek</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>forward</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Seek forward by default. */</comment>

    <comment type="block">/* We want to seek from left to right or the other way around
     * depending on the listpack length and the element position.
     * However if the listpack length cannot be obtained in constant time,
     * we always seek from left to right. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>numele</name><operator>+</operator><name>index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Index still &lt; 0 means out of range. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>numele</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Out of range the other side. */</comment>
        <comment type="block">/* We want to scan right-to-left if the element we are looking for
         * is past the half of the listpack. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name>numele</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>forward</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* Left to right scanning always expects a negative index. Convert
             * our index to negative form. */</comment>
            <expr_stmt><expr><name>index</name> <operator>-=</operator> <name>numele</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If the listpack length is unspecified, for negative indexes we
         * want to always scan left-to-right. */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>forward</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Forward and backward scanning is trivially based on lpNext()/lpPrev(). */</comment>
    <if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>index</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ele</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <return>return <expr><name>ele</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>index</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ele</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <return>return <expr><name>ele</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

</unit>
