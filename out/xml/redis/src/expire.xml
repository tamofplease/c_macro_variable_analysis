<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/expire.c"><comment type="block">/* Implementation of EXPIRE (keys with fixed time to live).
 *
 * ----------------------------------------------------------------------------
 *
 * Copyright (c) 2009-2016, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<comment type="block">/*-----------------------------------------------------------------------------
 * Incremental collection of expired keys.
 *
 * When keys are accessed they are expired on-access. However we need a
 * mechanism in order to ensure keys are eventually removed when expired even
 * if no access is performed on them.
 *----------------------------------------------------------------------------*/</comment>

<comment type="block">/* Helper function for the activeExpireCycle() function.
 * This function will try to expire the key that is stored in the hash table
 * entry 'de' of the 'expires' hash table of a Redis database.
 *
 * If the key is found to be expired, it is removed from the database and
 * 1 is returned. Otherwise no operation is performed and 0 is returned.
 *
 * When a key is expired, server.stat_expiredkeys is incremented.
 *
 * The parameter 'now' is the current time in milliseconds as is passed
 * to the function to avoid too many gettimeofday() syscalls. */</comment>
<function><type><name>int</name></type> <name>activeExpireCycleTryExpire</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>now</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>t</name> <init>= <expr><call><name>dictGetSignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>keyobj</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>propagateExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_expire</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_expire</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dbSyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_EXPIRED</name></expr></argument>,
            <argument><expr><literal type="string">"expired"</literal></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>,<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_expiredkeys</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Try to expire a few timed out keys. The algorithm used is adaptive and
 * will use few CPU cycles if there are few expiring keys, otherwise
 * it will get more aggressive to avoid that too much memory is used by
 * keys that can be removed from the keyspace.
 *
 * No more than CRON_DBS_PER_CALL databases are tested at every
 * iteration.
 *
 * This kind of call is used when Redis detects that timelimit_exit is
 * true, so there is more work to do, and we do it more incrementally from
 * the beforeSleep() function of the event loop.
 *
 * Expire cycle type:
 *
 * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a
 * "fast" expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION
 * microseconds, and is not repeated again before the same amount of time.
 *
 * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is
 * executed, where the time limit is a percentage of the REDIS_HZ period
 * as specified by the ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC define. */</comment>

<function><type><name>void</name></type> <name>activeExpireCycle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* This function has some global state in order to continue the work
     * incrementally across calls. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>current_db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Last DB tested. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>timelimit_exit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Time limit hit in previous call? */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PORT_LONGLONG</name></type> <name>last_fast_cycle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* When last fast cycle ran. */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>iteration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dbs_per_call</name> <init>= <expr><name>CRON_DBS_PER_CALL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name> <init>= <expr><call><name>ustime</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>timelimit</name></decl>, <decl><type ref="prev"/><name>elapsed</name></decl>;</decl_stmt>

    <comment type="block">/* When clients are paused the dataset should be static not just from the
     * POV of clients not being able to write, but also from the POV of
     * expires and evictions of keys not being performed. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clientsArePaused</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ACTIVE_EXPIRE_CYCLE_FAST</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Don't start a fast cycle if the previous cycle did not exit
         * for time limit. Also don't repeat a fast cycle for the same period
         * as the fast cycle total duration itself. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>timelimit_exit</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>last_fast_cycle</name> <operator>+</operator> <name>ACTIVE_EXPIRE_CYCLE_FAST_DURATION</name><operator>*</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>last_fast_cycle</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We usually should test CRON_DBS_PER_CALL per iteration, with
     * two exceptions:
     *
     * 1) Don't test more DBs than we have.
     * 2) If last time we hit the time limit, we want to scan all DBs
     * in this iteration, as there is work to do in some DB and we don't want
     * expired keys to use memory for too much time. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dbs_per_call</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name> <operator>||</operator> <name>timelimit_exit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dbs_per_call</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time
     * per iteration. Since this function gets called with a frequency of
     * server.hz times per second, the following is the max amount of
     * microseconds we can spend in this function. */</comment>
    <expr_stmt><expr><name>timelimit</name> <operator>=</operator> <literal type="number">1000000</literal><operator>*</operator><name>ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC</name><operator>/</operator><name><name>server</name><operator>.</operator><name>hz</name></name><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>timelimit_exit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>timelimit</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>timelimit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ACTIVE_EXPIRE_CYCLE_FAST</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>timelimit</name> <operator>=</operator> <name>ACTIVE_EXPIRE_CYCLE_FAST_DURATION</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* in microseconds. */</comment>

    <comment type="block">/* Accumulate some global stats as we expire keys, to have some idea
     * about the number of keys that are already logically expired, but still
     * existing inside the database. */</comment>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>total_sampled</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PORT_LONG</name></type> <name>total_expired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dbs_per_call</name> <operator>&amp;&amp;</operator> <name>timelimit_exit</name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>expired</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><operator>(</operator><name>current_db</name> <operator>%</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Increment the DB now so we are sure if we run out of time
         * in the current DB we'll restart from the next. This allows to
         * distribute the time evenly across DBs. */</comment>
        <expr_stmt><expr><name>current_db</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Continue to expire if at the end of the cycle more than 25%
         * of the keys were expired. */</comment>
        <do>do <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>slots</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>now</name></decl>, <decl><type ref="prev"/><name>ttl_sum</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>ttl_samples</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>iteration</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* If there is nothing to expire try next DB ASAP. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>num</name> <operator>=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>avg_ttl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>dictSlots</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* When there are less than 1% filled slots getting random
             * keys is expensive, so stop here waiting for better times...
             * The dictionary will be resized asap. */</comment>
            <if_stmt><if>if <condition>(<expr><name>num</name> <operator>&amp;&amp;</operator> <name>slots</name> <operator>&gt;</operator> <name>DICT_HT_INITIAL_SIZE</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>num</name><operator>*</operator><literal type="number">100</literal><operator>/</operator><name>slots</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* The main collection cycle. Sample random keys among keys
             * with an expire set, checking for expired ones. */</comment>
            <expr_stmt><expr><name>expired</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ttl_sum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ttl_samples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>num</name> <operator>=</operator> <name>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <while>while <condition>(<expr><name>num</name><operator>--</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ttl</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>ttl</name> <operator>=</operator> <call><name>dictGetSignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call><operator>-</operator><name>now</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>activeExpireCycleTryExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>de</name></expr></argument>,<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>expired</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* We want the average TTL of keys yet not expired. */</comment>
                    <expr_stmt><expr><name>ttl_sum</name> <operator>+=</operator> <name>ttl</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ttl_samples</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>total_sampled</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>total_expired</name> <operator>+=</operator> <name>expired</name></expr>;</expr_stmt>

            <comment type="block">/* Update the average TTL stats for this database. */</comment>
            <if_stmt><if>if <condition>(<expr><name>ttl_samples</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>avg_ttl</name> <init>= <expr><name>ttl_sum</name><operator>/</operator><name>ttl_samples</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Do a simple running average with a few samples.
                 * We just use the current estimate with a weight of 2%
                 * and the previous estimate with a weight of 98%. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>db</name><operator>-&gt;</operator><name>avg_ttl</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>avg_ttl</name></name> <operator>=</operator> <name>avg_ttl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>avg_ttl</name></name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>avg_ttl</name></name><operator>/</operator><literal type="number">50</literal><operator>)</operator><operator>*</operator><literal type="number">49</literal> <operator>+</operator> <operator>(</operator><name>avg_ttl</name><operator>/</operator><literal type="number">50</literal><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* We can't block forever here even if there are many keys to
             * expire. So after a given amount of milliseconds return to the
             * caller waiting for the other active expire cycle. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>iteration</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* check once every 16 iterations. */</comment>
                <expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&gt;</operator> <name>timelimit</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>timelimit_exit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_expired_time_cap_reached_count</name></name><operator>++</operator></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* We don't repeat the cycle if there are less than 25% of keys
             * found expired in the current DB. */</comment>
        </block_content>}</block> while <condition>(<expr><name>expired</name> <operator>&gt;</operator> <name>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</name><operator>/</operator><literal type="number">4</literal></expr>)</condition>;</do>
    </block_content>}</block></for>

    <expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"expire-cycle"</literal></expr></argument>,<argument><expr><name>elapsed</name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update our estimate of keys existing but yet to be expired.
     * Running average with this sample accounting for 5%. */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>current_perc</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_sampled</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>current_perc</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>total_expired</name><operator>/</operator><name>total_sampled</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>current_perc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_expired_stale_perc</name></name> <operator>=</operator> <operator>(</operator><name>current_perc</name><operator>*</operator><literal type="number">0.05</literal><operator>)</operator><operator>+</operator>
                                     <operator>(</operator><name><name>server</name><operator>.</operator><name>stat_expired_stale_perc</name></name><operator>*</operator><literal type="number">0.95</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Expires of keys created in writable slaves
 *
 * Normally slaves do not process expires: they wait the masters to synthesize
 * DEL operations in order to retain consistency. However writable slaves are
 * an exception: if a key is created in the slave and an expire is assigned
 * to it, we need a way to expire such a key, since the master does not know
 * anything about such a key.
 *
 * In order to do so, we track keys created in the slave side with an expire
 * set, and call the expireSlaveKeys() function from time to time in order to
 * reclaim the keys if they already expired.
 *
 * Note that the use case we are trying to cover here, is a popular one where
 * slaves are put in writable mode in order to compute slow operations in
 * the slave side that are mostly useful to actually read data in a more
 * processed way. Think at sets intersections in a tmp key, with an expire so
 * that it is also used as a cache to avoid intersecting every time.
 *
 * This implementation is currently not perfect but a lot better than leaking
 * the keys as implemented in 3.2.
 *----------------------------------------------------------------------------*/</comment>

<comment type="block">/* The dictionary where we remember key names and database ID of keys we may
 * want to expire from the slave. Since this function is not often used we
 * don't even care to initialize the database at startup. We'll do it once
 * the feature is used the first time, that is, when rememberSlaveKeyWithExpire()
 * is called.
 *
 * The dictionary has an SDS string representing the key as the hash table
 * key, while the value is a 64 bit unsigned integer with the bits corresponding
 * to the DB where the keys may exist set to 1. Currently the keys created
 * with a DB id &gt; 63 are not expired, but a trivial fix is to set the bitmap
 * to the max 64 bit unsigned value when we know there is a key with a DB
 * ID greater than 63, and check all the configured DBs in such a case. */</comment>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>slaveKeysWithExpire</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Check the set of keys created by the master with an expire set in order to
 * check if they should be evicted. */</comment>
<function><type><name>void</name></type> <name>expireSlaveKeys</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>slaveKeysWithExpire</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>dictSize</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>cycles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>noexpire</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>keyname</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>dbids</name> <init>= <expr><call><name>dictGetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>new_dbids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Check the key against every database corresponding to the
         * bits set in the value bitmap. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>dbid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><name>dbids</name> <operator>&amp;&amp;</operator> <name>dbid</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dbids</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>dbid</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>expire</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>,<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>expired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>&amp;&amp;</operator>
                    <call><name>activeExpireCycleTryExpire</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>dbid</name></expr></argument>,<argument><expr><name>expire</name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>expired</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* If the key was not expired in this DB, we need to set the
                 * corresponding bit in the new bitmap we set as value.
                 * At the end of the loop if the bitmap is zero, it means we
                 * no longer need to keep track of this key. */</comment>
                <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>expired</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>noexpire</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>new_dbids</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>dbid</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>dbid</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>dbids</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Set the new bitmap as value of the key, in the dictionary
         * of keys with an expire set directly in the writable slave. Otherwise
         * if the bitmap is zero, we no longer need to keep track of it. */</comment>
        <if_stmt><if>if <condition>(<expr><name>new_dbids</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dictSetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><name>new_dbids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>,<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Stop conditions: found 3 keys we cna't expire in a row or
         * time limit was reached. */</comment>
        <expr_stmt><expr><name>cycles</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>noexpire</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cycles</name> <operator>%</operator> <literal type="number">64</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Track keys that received an EXPIRE or similar command in the context
 * of a writable slave. */</comment>
<function><type><name>void</name></type> <name>rememberSlaveKeyWithExpire</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>slaveKeysWithExpire</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>static</specifier> <name>dictType</name></type> <name>dt</name> <init>= <expr><block>{
            <expr><name>dictSdsHash</name></expr>,                <comment type="block">/* hash function */</comment>
            <expr><name>NULL</name></expr>,                       <comment type="block">/* key dup */</comment>
            <expr><name>NULL</name></expr>,                       <comment type="block">/* val dup */</comment>
            <expr><name>dictSdsKeyCompare</name></expr>,          <comment type="block">/* key compare */</comment>
            <expr><name>dictSdsDestructor</name></expr>,          <comment type="block">/* key destructor */</comment>
            <expr><name>NULL</name></expr>                        <comment type="block">/* val destructor */</comment>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>slaveKeysWithExpire</name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dt</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictAddOrFind</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* If the entry was just created, set it to a copy of the SDS string
     * representing the key: we don't want to need to take those keys
     * in sync with the main DB. The keys will be removed by expireSlaveKeys()
     * as it scans to find keys to remove. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>de</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>de</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictSetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>dbids</name> <init>= <expr><call><name>dictGetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>dbids</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictSetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><name>dbids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the number of keys we are tracking. */</comment>
<function><type><name>size_t</name></type> <name>getSlaveKeyWithExpireCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>slaveKeysWithExpire</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>dictSize</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the keys in the hash table. We need to do that when data is
 * flushed from the server. We may receive new keys from the master with
 * the same name/db and it is no longer a good idea to expire them.
 *
 * Note: technically we should handle the case of a single DB being flushed
 * but it is not worth it since anyway race conditions using the same set
 * of key names in a wriatable slave and in its master will lead to
 * inconsistencies. This is just a best-effort thing we do. */</comment>
<function><type><name>void</name></type> <name>flushSlaveKeysWithExpireList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>slaveKeysWithExpire</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>slaveKeysWithExpire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>slaveKeysWithExpire</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>checkAlreadyExpired</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>when</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past
     * should never be executed as a DEL when load the AOF or in the context
     * of a slave instance.
     *
     * Instead we add the already expired key to the database with expire time
     * (possibly in the past) and wait for an explicit DEL from the master. */</comment>
    <return>return <expr><operator>(</operator><name>when</name> <operator>&lt;=</operator> <call><name>mstime</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>server</name><operator>.</operator><name>loading</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>server</name><operator>.</operator><name>masterhost</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Expires Commands
 *----------------------------------------------------------------------------*/</comment>

<comment type="block">/* This is the generic command implementation for EXPIRE, PEXPIRE, EXPIREAT
 * and PEXPIREAT. Because the commad second argument may be relative or absolute
 * the "basetime" argument is used to signal what the base time is (either 0
 * for *AT variants of the command, or the current time for relative expires).
 *
 * unit is either UNIT_SECONDS or UNIT_MILLISECONDS, and is only used for
 * the argv[2] parameter. The basetime is always specified in milliseconds. */</comment>
<function><type><name>void</name></type> <name>expireGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>basetime</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unit</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>param</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>when</name></decl>;</decl_stmt> <comment type="block">/* unix time in milliseconds when the key will expire. */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>when</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <name>UNIT_SECONDS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>when</name> <operator>*=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>when</name> <operator>+=</operator> <name>basetime</name></expr>;</expr_stmt>

    <comment type="block">/* No key, return zero. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>checkAlreadyExpired</name><argument_list>(<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>aux</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_expire</name></name></expr> ?</condition><then> <expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                                    <expr><call><name>dbSyncDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Replicate/AOF this as an explicit DEL or UNLINK. */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <ternary><condition><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_expire</name></name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>unlink</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>del</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>setExpire</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"expire"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* EXPIRE key seconds */</comment>
<function><type><name>void</name></type> <name>expireCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>expireGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>UNIT_SECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* EXPIREAT key time */</comment>
<function><type><name>void</name></type> <name>expireatCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>expireGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>UNIT_SECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PEXPIRE key milliseconds */</comment>
<function><type><name>void</name></type> <name>pexpireCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>expireGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>UNIT_MILLISECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PEXPIREAT key ms_time */</comment>
<function><type><name>void</name></type> <name>pexpireatCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>expireGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>UNIT_MILLISECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Implements TTL and PTTL */</comment>
<function><type><name>void</name></type> <name>ttlGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>output_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>expire</name></decl>, <decl><type ref="prev"/><name>ttl</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the key does not exist at all, return -2 */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lookupKeyReadWithFlags</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>LOOKUP_NOTOUCH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* The key exists. Return -1 if it has no expire, or the actual
     * TTL value otherwise. */</comment>
    <expr_stmt><expr><name>expire</name> <operator>=</operator> <call><name>getExpire</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ttl</name> <operator>=</operator> <name>expire</name><operator>-</operator><call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ttl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>output_ms</name></expr> ?</condition><then> <expr><name>ttl</name></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>ttl</name><operator>+</operator><literal type="number">500</literal><operator>)</operator><operator>/</operator><literal type="number">1000</literal><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* TTL key */</comment>
<function><type><name>void</name></type> <name>ttlCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>ttlGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PTTL key */</comment>
<function><type><name>void</name></type> <name>pttlCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>ttlGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PERSIST key */</comment>
<function><type><name>void</name></type> <name>persistCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>removeExpire</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* TOUCH key1 [key2 key3 ... keyN] */</comment>
<function><type><name>void</name></type> <name>touchCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>touched</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>touched</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>touched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
