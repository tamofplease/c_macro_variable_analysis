<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/t_set.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<comment type="block">/*-----------------------------------------------------------------------------
 * Set Commands
 *----------------------------------------------------------------------------*/</comment>

<function_decl><type><name>void</name></type> <name>sunionDiffGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>setkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setnum</name></decl></parameter>,
                              <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Factory method to return a set that *can* hold "value". When the object has
 * an integer-encodable value, an intset will be returned. Otherwise a regular
 * hash table. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>setTypeCreate</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>isSdsRepresentableAsLongLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>createIntsetObject</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>createSetObject</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add the specified value into a set.
 *
 * If the value was already member of the set, nothing is done and 0 is
 * returned, otherwise the new element is added and 1 is returned. */</comment>
<function><type><name>int</name></type> <name>setTypeAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>llval</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictAddRaw</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dictSetKey</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name>de</name></expr></argument>,<argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictSetVal</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name>de</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isSdsRepresentableAsLongLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llval</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uint8_t</name></type> <name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>intsetAdd</name><argument_list>(<argument><expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>llval</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Convert to regular set when the intset contains
                 * too many entries. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>intsetLen</name><argument_list>(<argument><expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>set_max_intset_entries</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>setTypeConvert</name><argument_list>(<argument><expr><name>subject</name></expr></argument>,<argument><expr><name>OBJ_ENCODING_HT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Failed to get integer from object, convert to regular set. */</comment>
            <expr_stmt><expr><call><name>setTypeConvert</name><argument_list>(<argument><expr><name>subject</name></expr></argument>,<argument><expr><name>OBJ_ENCODING_HT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* The set *was* an intset and this value is not integer
             * encodable, so dictAdd should always work. */</comment>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>setTypeRemove</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>setobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>llval</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>htNeedsResize</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictResize</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isSdsRepresentableAsLongLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llval</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>success</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>intsetRemove</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>llval</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>setTypeIsMember</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>llval</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>dictFind</name><argument_list>(<argument><expr><operator>(</operator><name>dict</name><operator>*</operator><operator>)</operator><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isSdsRepresentableAsLongLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llval</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>intsetFind</name><argument_list>(<argument><expr><operator>(</operator><name>intset</name><operator>*</operator><operator>)</operator><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>llval</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>setTypeInitIterator</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>setTypeIterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>di</name></name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>ii</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>si</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setTypeReleaseIterator</name><parameter_list>(<parameter><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Move to the next entry in the set. Returns the object at the current
 * position.
 *
 * Since set elements can be internally be stored as SDS strings or
 * simple arrays of integers, setTypeNext returns the encoding of the
 * set object you are iterating, and will populate the appropriate pointer
 * (sdsele) or (llele) accordingly.
 *
 * Note that both the sdsele and llele pointers should be passed and cannot
 * be NULL since the function will try to defensively populate the non
 * used field with values which are easy to trap if misused.
 *
 * When there are no longer elements -1 is returned. */</comment>
<function><type><name>int</name></type> <name>setTypeNext</name><parameter_list>(<parameter><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>sds</name> <modifier>*</modifier></type><name>sdsele</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>llele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>di</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>sdsele</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>llele</name> <operator>=</operator> <operator>-</operator><literal type="number">123456789</literal></expr>;</expr_stmt> <comment type="block">/* Not needed. Defensive. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>intsetGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ii</name></name><operator>++</operator></expr></argument>,<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>sdsele</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Not needed. Defensive. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Wrong set encoding in setTypeNext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name><name>si</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The not copy on write friendly version but easy to use version
 * of setTypeNext() is setTypeNextObject(), returning new SDS
 * strings. So if you don't retain a pointer to this object you should call
 * sdsfree() against it.
 *
 * This function is the way to go for write operations where COW is not
 * an issue. */</comment>
<function><type><name>sds</name></type> <name>setTypeNextObject</name><parameter_list>(<parameter><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>intele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>sdsele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeNext</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sdsele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>intele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>encoding</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>    <return>return <expr><name>NULL</name></expr>;</return>
        <case>case <expr><name>OBJ_ENCODING_INTSET</name></expr>:</case>
            <return>return <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>intele</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>OBJ_ENCODING_HT</name></expr>:</case>
            <return>return <expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* just to suppress warnings */</comment>
</block_content>}</block></function>

<comment type="block">/* Return random element from a non empty set.
 * The returned element can be a int64_t value if the set is encoded
 * as an "intset" blob of integers, or an SDS string if the set
 * is a regular set.
 *
 * The caller provides both pointers to be populated with the right
 * object. The return value of the function is the object-&gt;encoding
 * field of the object and is used by the caller to check if the
 * int64_t pointer or the redis object pointer was populated.
 *
 * Note that both the sdsele and llele pointers should be passed and cannot
 * be NULL since the function will try to defensively populate the non
 * used field with values which are easy to trap if misused. */</comment>
<function><type><name>int</name></type> <name>setTypeRandomElement</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>setobj</name></decl></parameter>, <parameter><decl><type><name>sds</name> <modifier>*</modifier></type><name>sdsele</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>llele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>sdsele</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>llele</name> <operator>=</operator> <operator>-</operator><literal type="number">123456789</literal></expr>;</expr_stmt> <comment type="block">/* Not needed. Defensive. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>llele</name> <operator>=</operator> <call><name>intsetRandom</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>sdsele</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Not needed. Defensive. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PORT_ULONG</name></type> <name>setTypeSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <call><name>dictSize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>dict</name><operator>*</operator><operator>)</operator><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>                     <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (PORT_ULONG) */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>subject</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>intsetLen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>intset</name><operator>*</operator><operator>)</operator><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Convert the set to specified encoding. The resulting dict (when converting
 * to a hash table) is presized to hold the number of elements in the original
 * set. */</comment>
<function><type><name>void</name></type> <name>setTypeConvert</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>setobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>setobj</name></expr></argument>,<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name> <operator>&amp;&amp;</operator>
                             <name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>intele</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>setDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>element</name></decl>;</decl_stmt>

        <comment type="block">/* Presize the dict to avoid rehashing */</comment>
        <expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><call><name>intsetLen</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* To add the elements we extract integers and create redis objects */</comment>
        <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name>setobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>setTypeNext</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>element</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>intele</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>element</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>intele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>element</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>setobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_HT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>setobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported set conversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>saddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>set</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>setTypeCreate</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>set</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>added</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>added</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"sadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>added</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>added</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sremCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>keyremoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>setTypeRemove</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"srem"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyremoved</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>smoveCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>srcset</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dstset</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>srcset</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstset</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ele</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* If the source key does not exist return 0 */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcset</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the source key has the wrong type, or the destination key
     * is set and has the wrong type, return with an error. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>srcset</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name>dstset</name> <operator>&amp;&amp;</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If srcset and dstset are equal, SMOVE is a no-op */</comment>
    <if_stmt><if>if <condition>(<expr><name>srcset</name> <operator>==</operator> <name>dstset</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><call><name>setTypeIsMember</name><argument_list>(<argument><expr><name>srcset</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
            <expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the element cannot be removed from the src set, return 0. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setTypeRemove</name><argument_list>(<argument><expr><name>srcset</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"srem"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove the src set from the database when empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>srcset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create the destination set when it doesn't exist */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstset</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dstset</name> <operator>=</operator> <call><name>setTypeCreate</name><argument_list>(<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* An extra key has changed when ele was successfully added to dstset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"sadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sismemberCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>setTypeIsMember</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>scardCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Handle the "SPOP key &lt;count&gt;" variant. The normal version of the
 * command is handled by the spopCommand() function itself. */</comment>

<comment type="block">/* How many times bigger should be the set compared to the remaining size
 * for us to use the "create new set" strategy? Read later in the
 * implementation for more info. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPOP_MOVE_STRATEGY_MUL</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>spopWithCountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>

    <comment type="block">/* Get the count argument */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name>l</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>outofrangeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set. Otherwise, return nil */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
        <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If count is zero, serve an empty multibulk ASAP to avoid special
     * cases later. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate an SPOP keyspace notification */</comment>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"spop"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>

    <comment type="block">/* CASE 1:
     * The number of requested elements is greater than or equal to
     * the number of elements inside the set: simply return the whole set. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We just return the entire set */</comment>
        <expr_stmt><expr><call><name>sunionDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>SET_OP_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Delete the set as it is now empty */</comment>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Propagate this command as an DEL operation */</comment>
        <expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>del</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Case 2 and 3 require to replicate SPOP as a set of SREM commands.
     * Prepare our replication argument vector. Also send the array length
     * which is common to both the code paths. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>propargv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>propargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"SREM"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>propargv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Common iteration vars. */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>sdsele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>objele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>llele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>remaining</name> <init>= <expr><name>size</name><operator>-</operator><name>count</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Elements left after SPOP. */</comment>

    <comment type="block">/* If we are here, the number of requested elements is less than the
     * number of elements inside the set. Also we are sure that count &lt; size.
     * Use two different strategies.
     *
     * CASE 2: The number of elements to return is small compared to the
     * set size. We can just extract random elements and return them to
     * the set. */</comment>
    <if_stmt><if>if <condition>(<expr><name>remaining</name><operator>*</operator><name>SPOP_MOVE_STRATEGY_MUL</name> <operator>&gt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
        <while>while<condition>(<expr><name>count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Emit and remove. */</comment>
            <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeRandomElement</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sdsele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>objele</name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>intsetRemove</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>llele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>objele</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setTypeRemove</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Replicate/AOF this command as an SREM operation */</comment>
            <expr_stmt><expr><name><name>propargv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>objele</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>sremCommand</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>propargv</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,
                <argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>objele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* CASE 3: The number of elements to return is very big, approaching
     * the size of the set itself. After some time extracting random elements
     * from such a set becomes computationally expensive, so we use
     * a different strategy, we extract random elements that we don't
     * want to return (the elements that will remain part of the set),
     * creating a new set as we do this (that will be stored as the original
     * set). Then we return the elements left in the original set and
     * release it. */</comment>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>newset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Create a new set with just the remaining elements. */</comment>
        <while>while<condition>(<expr><name>remaining</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeRandomElement</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sdsele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>sdsele</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>sdsele</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>newset</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newset</name> <operator>=</operator> <call><name>setTypeCreate</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>newset</name></expr></argument>,<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setTypeRemove</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Transfer the old set to the client. */</comment>
        <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>encoding</name> <operator>=</operator> <call><name>setTypeNext</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sdsele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>objele</name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>objele</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Replicate/AOF this command as an SREM operation */</comment>
            <expr_stmt><expr><name><name>propargv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>objele</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>sremCommand</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>propargv</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,
                <argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>objele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Assign the new set as the key value. */</comment>
        <expr_stmt><expr><call><name>dbOverwrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>newset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Don't propagate the command itself even if we incremented the
     * dirty counter. We don't want to propagate an SPOP command since
     * we propagated the command as a set of SREMs operations using
     * the alsoPropagate() API. */</comment>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>propargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>preventCommandPropagation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>spopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ele</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aux</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>sdsele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>llele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>spopWithCountCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get a random element from the set */</comment>
    <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeRandomElement</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sdsele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove the element from the set */</comment>
    <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>intsetRemove</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>llele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setTypeRemove</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"spop"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replicate/AOF this command as an SREM operation */</comment>
    <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"SREM"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the element to the reply */</comment>
    <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Delete the set if it's empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set has been modified */</comment>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* handle the "SRANDMEMBER key &lt;count&gt;" variant. The normal version of the
 * command is handled by the srandmemberCommand() function itself. */</comment>

<comment type="block">/* How many times bigger should be the set compared to the requested size
 * for us to don't use the "remove elements" strategy? Read later in the
 * implementation for more info. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SRANDMEMBER_SUB_STRATEGY_MUL</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>srandmemberWithCountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>uniq</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>llele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name>l</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* A negative count means: return the same elements multiple times
         * (i.e. don't remove the extracted element after every extraction). */</comment>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>uniq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
        <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If count is zero, serve it ASAP to avoid special cases later. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* CASE 1: The count was negative, so the extraction method is just:
     * "return N random elements" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>uniq</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeRandomElement</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* CASE 2:
     * The number of requested elements is greater than the number of
     * elements inside the set: simply return the whole set. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sunionDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>SET_OP_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* For CASE 3 and CASE 4 we need an auxiliary dictionary. */</comment>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectKeyPointerValueDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* CASE 3:
     * The number of elements inside the set is not greater than
     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.
     * In this case we create a set from scratch with all the elements, and
     * subtract random elements to reach the requested number of elements.
     *
     * This is done because if the number of requsted elements is just
     * a bit less than the number of elements in the set, the natural approach
     * used into CASE 3 is highly inefficient. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name><operator>*</operator><name>SRANDMEMBER_SUB_STRATEGY_MUL</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

        <comment type="block">/* Add all the elements into the temporary dictionary. */</comment>
        <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>encoding</name> <operator>=</operator> <call><name>setTypeNext</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>DICT_ERR</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictAdd</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictAdd</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Remove random elements to reach the right count. */</comment>
        <while>while<condition>(<expr><name>size</name> <operator>&gt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>

    <comment type="block">/* CASE 4: We have a big set compared to the requested number of elements.
     * In this case we can simply get random elements from the set and add
     * to the temporary set, trying to eventually get enough unique elements
     * to reach the specified count. */</comment>
    <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>objele</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><name>added</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeRandomElement</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>objele</name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>objele</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* Try to add the object to the dictionary. If it already exists
             * free it, otherwise increment the number of objects we have
             * in the result dictionary. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>objele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>added</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>objele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* CASE 3 &amp; 4: send the result to the user. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>srandmemberCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>llele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>srandmemberWithCountCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>setTypeRandomElement</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>llele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>qsortCompareSetsByCardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>robj</name><operator>*</operator><operator>*</operator><operator>)</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>robj</name><operator>*</operator><operator>*</operator><operator>)</operator><name>s2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>robj</name><operator>*</operator><operator>*</operator><operator>)</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>robj</name><operator>*</operator><operator>*</operator><operator>)</operator><name>s2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is used by SDIFF and in this case we can receive NULL that should
 * be handled as empty sets. */</comment>
<function><type><name>int</name></type> <name>qsortCompareSetsByRevCardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>robj</name><operator>*</operator><operator>*</operator><operator>)</operator><name>s1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>robj</name><operator>*</operator><operator>*</operator><operator>)</operator><name>s2</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>first</name> <init>= <expr><ternary><condition><expr><name>o1</name></expr> ?</condition><then> <expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>second</name> <init>= <expr><ternary><condition><expr><name>o2</name></expr> ?</condition><then> <expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>first</name> <operator>&lt;</operator> <name>second</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>first</name> <operator>&gt;</operator> <name>second</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sinterGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>setkeys</name></decl></parameter>,
                          <parameter><decl><type><name>PORT_ULONG</name></type> <name>setnum</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>sets</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>setnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>elesds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>intobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>replylen</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>cardinality</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>setobj</name> <init>= <expr><ternary><condition><expr><name>dstkey</name></expr> ?</condition><then>
            <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>setkeys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
            <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>setkeys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setobj</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dstkey</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>setobj</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>setobj</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Sort sets from the smallest to largest, this will improve our
     * algorithm's performance */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sets</name></expr></argument>,<argument><expr><name>setnum</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>qsortCompareSetsByCardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The first thing we should output is the total number of elements...
     * since this is a multi-bulk write, but at this stage we don't know
     * the intersection set size, so we use a trick, append an empty object
     * to the output list and save the pointer to later modify it with the
     * right length */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstkey</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>replylen</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If we have a target key where to store the resulting set
         * create this key with an empty set inside */</comment>
        <expr_stmt><expr><name>dstset</name> <operator>=</operator> <call><name>createIntsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Iterate all the elements of the first (smallest) set, and test
     * the element against all the other sets, if at least one set does
     * not include the element it is discarded */</comment>
    <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>encoding</name> <operator>=</operator> <call><name>setTypeNext</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>elesds</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>intobj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* intset with intset is simple... and fast */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>intsetFind</name><argument_list>(<argument><expr><operator>(</operator><name>intset</name><operator>*</operator><operator>)</operator><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                <comment type="block">/* in order to compare an integer with an object we
                 * have to use the generic function, creating an object
                 * for this */</comment>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>elesds</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setTypeIsMember</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setTypeIsMember</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Only take action when all sets contain the member */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>setnum</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstkey</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>elesds</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name>cardinality</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>elesds</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>elesds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dstkey</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Store the resulting set into the target, if the intersection
         * is not an empty set. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,<argument><expr><literal type="string">"sinterstore"</literal></expr></argument>,
                <argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,
                    <argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>replylen</name></expr></argument>,<argument><expr><name>cardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sinterCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sinterGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sinterstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sinterGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_OP_UNION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_OP_DIFF</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_OP_INTER</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>sunionDiffGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>setkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setnum</name></decl></parameter>,
                              <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>sets</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>setnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>cardinality</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>diff_algo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>setobj</name> <init>= <expr><ternary><condition><expr><name>dstkey</name></expr> ?</condition><then>
            <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>setkeys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
            <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>setkeys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setobj</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>setobj</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>setobj</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M) where N is the size of the element first set
     * and M the total number of sets.
     *
     * Algorithm 2 is O(N) where N is the total number of elements in all
     * the sets.
     *
     * We compute what is the best bet with the current input here. */</comment>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_DIFF</name> <operator>&amp;&amp;</operator> <name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>algo_one_work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>algo_two_work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>algo_one_work</name> <operator>+=</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>algo_two_work</name> <operator>+=</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Algorithm 1 has better constant times and performs less operations
         * if there are elements in common. Give it some advantage. */</comment>
        <expr_stmt><expr><name>algo_one_work</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>diff_algo</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>algo_one_work</name> <operator>&lt;=</operator> <name>algo_two_work</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>diff_algo</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>setnum</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* With algorithm 1 it is better to order the sets to subtract
             * by decreasing size, so that we are more likely to find
             * duplicated elements ASAP. */</comment>
            <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sets</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>setnum</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>qsortCompareSetsByRevCardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We need a temp set object to store our union. If the dstkey
     * is not NULL (that is, we are inside an SUNIONSTORE operation) then
     * this set object will be the resulting object to set into the target key*/</comment>
    <expr_stmt><expr><name>dstset</name> <operator>=</operator> <call><name>createIntsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_UNION</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Union is trivial, just add every element of every set to the
         * temporary set. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* non existing keys are like empty sets */</comment>

            <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>setTypeNextObject</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cardinality</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_DIFF</name> <operator>&amp;&amp;</operator> <name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>diff_algo</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* DIFF Algorithm 1:
         *
         * We perform the diff by iterating all the elements of the first set,
         * and only adding it to the target set if the element does not exist
         * into all the other sets.
         *
         * This way we perform at max N*M operations, where N is the size of
         * the first set, and M the number of sets. */</comment>
        <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>setTypeNextObject</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* no key is an empty set. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* same set! */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>setTypeIsMember</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>setnum</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* There is no other set with this element. Add it. */</comment>
                <expr_stmt><expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>cardinality</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_DIFF</name> <operator>&amp;&amp;</operator> <name><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>diff_algo</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* DIFF Algorithm 2:
         *
         * Add all the elements of the first set to the auxiliary set.
         * Then remove all the elements of all the next sets from it.
         *
         * This is O(N) where N is the sum of all the elements in every
         * set. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* non existing keys are like empty sets */</comment>

            <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name><name>sets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>setTypeNextObject</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>setTypeAdd</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cardinality</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>setTypeRemove</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cardinality</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Exit if result set is empty as any additional removal
             * of elements will have no effect. */</comment>
            <if_stmt><if>if <condition>(<expr><name>cardinality</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Output the content of the resulting set, if not in STORE mode */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstkey</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>cardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>setTypeNextObject</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If we have a target key where to store the resulting set
         * create this key with the result set inside */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_SET</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>op</name> <operator>==</operator> <name>SET_OP_UNION</name></expr> ?</condition><then> <expr><literal type="string">"sunionstore"</literal></expr> </then><else>: <expr><literal type="string">"sdiffstore"</literal></expr></else></ternary></expr></argument>,
                <argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>dstset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,
                    <argument><expr><name>dstkey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sunionCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sunionDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>SET_OP_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sunionstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sunionDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>SET_OP_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sdiffCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sunionDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>SET_OP_DIFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sdiffstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sunionDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>SET_OP_DIFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sscanCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>cursor</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>parseScanCursorOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptyscan</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>OBJ_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>scanGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>set</name></expr></argument>,<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
