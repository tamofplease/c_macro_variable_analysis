<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/rax.c"><comment type="block">/* Rax -- A radix tree implementation.
 *
 * Copyright (c) 2017-2018, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rax.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RAX_MALLOC_INCLUDE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAX_MALLOC_INCLUDE</name></cpp:macro> <cpp:value>"rax_malloc.h"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> RAX_MALLOC_INCLUDE</cpp:include>

<comment type="block">/* This is a special pointer that is guaranteed to never have the same value
 * of a radix tree node. It's used in order to report "not found" error without
 * requiring the function to have multiple return values. */</comment>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>raxNotFound</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="string">"rax-not-found-pointer"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* -------------------------------- Debugging ------------------------------ */</comment>

<function_decl><type><name>void</name></type> <name>raxDebugShowNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Turn debugging messages on/off by compiling with RAX_DEBUG_MSG macro on.
 * When RAX_DEBUG_MSG is defined by default Rax operations will emit a lot
 * of debugging info to the standard output, however you can still turn
 * debugging on/off in order to enable it only when you suspect there is an
 * operation causing a bug using the function raxSetDebugMsg(). */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAX_DEBUG_MSG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugf</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                            \
    <cpp:value>if (raxDebugMsg) {                                                         \
        printf("%s:%s:%d:\t", __FILE__, __FUNCTION__, __LINE__);               \
        printf(__VA_ARGS__);                                                   \
        fflush(stdout);                                                        \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugnode</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>raxDebugShowNode(msg,n)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugf</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugnode</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* By default log debug info if RAX_DEBUG_MSG is defined. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>raxDebugMsg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* When debug messages are enabled, turn them on/off dynamically. By
 * default they are enabled. Set the state to 0 to disable, and 1 to
 * re-enable. */</comment>
<function><type><name>void</name></type> <name>raxSetDebugMsg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>onoff</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>raxDebugMsg</name> <operator>=</operator> <name>onoff</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------- raxStack functions --------------------------
 * The raxStack is a simple stack of pointers that is capable of switching
 * from using a stack-allocated array to dynamic heap once a given number of
 * items are reached. It is used in order to retain the list of parent nodes
 * while walking the radix tree in order to implement certain operations that
 * need to navigate the tree upward.
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* Initialize the stack. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>raxStackInit</name><parameter_list>(<parameter><decl><type><name>raxStack</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>static_items</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>maxitems</name></name> <operator>=</operator> <name>RAX_STACK_STATIC_ITEMS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Push an item into the stack, returns 1 on success, 0 on out of memory. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>raxStackPush</name><parameter_list>(<parameter><decl><type><name>raxStack</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name> <operator>==</operator> <name><name>ts</name><operator>-&gt;</operator><name>maxitems</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name><name>ts</name><operator>-&gt;</operator><name>static_items</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <call><name>rax_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>ts</name><operator>-&gt;</operator><name>maxitems</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>static_items</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>static_items</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>ts</name><operator>-&gt;</operator><name>maxitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>newalloc</name> <init>= <expr><call><name>rax_realloc</name><argument_list>(<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>ts</name><operator>-&gt;</operator><name>maxitems</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>newalloc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>newalloc</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>maxitems</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pop an item from the stack, the function returns NULL if there are no
 * items to pop. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>raxStackPop</name><parameter_list>(<parameter><decl><type><name>raxStack</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name><operator>--</operator></expr>;</expr_stmt>
    <return>return <expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the stack item at the top of the stack without actually consuming
 * it. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>raxStackPeek</name><parameter_list>(<parameter><decl><type><name>raxStack</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>ts</name><operator>-&gt;</operator><name>items</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free the stack in case we used heap allocation. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>raxStackFree</name><parameter_list>(<parameter><decl><type><name>raxStack</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name> <operator>!=</operator> <name><name>ts</name><operator>-&gt;</operator><name>static_items</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * Radix tree implementation
 * --------------------------------------------------------------------------*/</comment>

<comment type="block">/* Return the padding needed in the characters section of a node having size
 * 'nodesize'. The padding is needed to store the child pointers to aligned
 * addresses. Note that we add 4 to the node size because the node has a four
 * bytes header. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>raxPadding</name><parameter_list>(<parameter><type><name>nodesize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1))</cpp:value></cpp:define>

<comment type="block">/* Return the pointer to the last child pointer in a node. For the compressed
 * nodes this is the only child pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>raxNodeLastChildPtr</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((raxNode**) ( \
    ((char*)(n)) + \
    raxNodeCurrentLength(n) - \
    sizeof(raxNode*) - \
    (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \
))</cpp:value></cpp:define>

<comment type="block">/* Return the pointer to the first child pointer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>raxNodeFirstChildPtr</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((raxNode**) ( \
    (n)-&gt;data + \
    (n)-&gt;size + \
    raxPadding((n)-&gt;size)))</cpp:value></cpp:define>

<comment type="block">/* Return the current total size of the node. Note that the second line
 * computes the padding after the string of characters, needed in order to
 * save pointers to aligned addresses. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>raxNodeCurrentLength</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
    sizeof(raxNode)+(n)-&gt;size+ \
    raxPadding((n)-&gt;size)+ \
    ((n)-&gt;iscompr ? sizeof(raxNode*) : sizeof(raxNode*)*(n)-&gt;size)+ \
    (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull)*sizeof(void*)) \
)</cpp:value></cpp:define>

<comment type="block">/* Allocate a new non compressed node with the specified number of children.
 * If datafiled is true, the allocation is made large enough to hold the
 * associated data pointer.
 * Returns the new node pointer. On out of memory NULL is returned. */</comment>
<function><type><name>raxNode</name> <modifier>*</modifier></type><name>raxNewNode</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>children</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datafield</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nodesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>children</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call><operator>+</operator>
                      <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>children</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>datafield</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nodesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>rax_malloc</name><argument_list>(<argument><expr><name>nodesize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>children</name></expr>;</expr_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate a new rax and return its pointer. On out of memory the function
 * returns NULL. */</comment>
<function><type><name>rax</name> <modifier>*</modifier></type><name>raxNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name> <init>= <expr><call><name>rax_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>rax</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rax</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <call><name>raxNewNode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rax</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>rax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>rax</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* realloc the node to make room for auxiliary data in order
 * to store an item in that node. On out of memory NULL is returned. */</comment>
<function><type><name>raxNode</name> <modifier>*</modifier></type><name>raxReallocForData</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* No reallocation needed, setting isnull=1 */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>curlen</name> <init>= <expr><call><name>raxNodeCurrentLength</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>rax_realloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curlen</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set the node auxiliary data to the specified pointer. */</comment>
<function><type><name>void</name></type> <name>raxSetData</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ndata</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator>
            <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>n</name><operator>+</operator><call><name>raxNodeCurrentLength</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ndata</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Get the node auxiliary data. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>raxGetData</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ndata</name> <init>=<expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>n</name><operator>+</operator><call><name>raxNodeCurrentLength</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,<argument><expr><name>ndata</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new child to the node 'n' representing the character 'c' and return
 * its new pointer, as well as the child pointer by reference. Additionally
 * '***parentlink' is populated with the raxNode pointer-to-pointer of where
 * the new child was stored, which is useful for the caller to replace the
 * child pointer if it gets reallocated.
 *
 * On success the new parent node pointer is returned (it may change because
 * of the realloc, so the caller should discard 'n' and use the new value).
 * On out of memory NULL is returned, and the old node is still valid. */</comment>
<function><type><name>raxNode</name> <modifier>*</modifier></type><name>raxAddChild</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>childptr</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>parentlink</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>curlen</name> <init>= <expr><call><name>raxNodeCurrentLength</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newlen</name> <init>= <expr><call><name>raxNodeCurrentLength</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* For now restore the orignal size. We'll update it only on
                  success at the end. */</comment>

    <comment type="block">/* Alloc the new child we will link to 'n'. */</comment>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>raxNewNode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Make space in the original node. */</comment>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>newn</name> <init>= <expr><call><name>rax_realloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newn</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>newn</name></expr>;</expr_stmt>

    <comment type="block">/* After the reallocation, we have up to 8/16 (depending on the system
     * pointer size, and the required node padding) bytes at the end, that is,
     * the additional char in the 'data' section, plus one pointer to the new
     * child, plus the padding needed in order to store addresses into aligned
     * locations.
     *
     * So if we start with the following node, having "abde" edges.
     *
     * Note:
     * - We assume 4 bytes pointer for simplicity.
     * - Each space below corresponds to one byte
     *
     * [HDR*][abde][Aptr][Bptr][Dptr][Eptr]|AUXP|
     *
     * After the reallocation we need: 1 byte for the new edge character
     * plus 4 bytes for a new child pointer (assuming 32 bit machine).
     * However after adding 1 byte to the edge char, the header + the edge
     * characters are no longer aligned, so we also need 3 bytes of padding.
     * In total the reallocation will add 1+4+3 bytes = 8 bytes:
     *
     * (Blank bytes are represented by ".")
     *
     * [HDR*][abde][Aptr][Bptr][Dptr][Eptr]|AUXP|[....][....]
     *
     * Let's find where to insert the new child in order to make sure
     * it is inserted in-place lexicographically. Assuming we are adding
     * a child "c" in our case pos will be = 2 after the end of the following
     * loop. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Now, if present, move auxiliary data pointer at the end
     * so that we can mess with the other data without overwriting it.
     * We will obtain something like that:
     *
     * [HDR*][abde][Aptr][Bptr][Dptr][Eptr][....][....]|AUXP|
     */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>n</name><operator>+</operator><name>curlen</name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>n</name><operator>+</operator><name>newlen</name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute the "shift", that is, how many bytes we need to move the
     * pointers section forward because of the addition of the new child
     * byte in the string section. Note that if we had no padding, that
     * would be always "1", since we are adding a single byte in the string
     * section of the node (where now there is "abde" basically).
     *
     * However we have padding, so it could be zero, or up to 8.
     *
     * Another way to think at the shift is, how many bytes we need to
     * move child pointers forward *other than* the obvious sizeof(void*)
     * needed for the additional pointer itself. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>shift</name> <init>= <expr><name>newlen</name> <operator>-</operator> <name>curlen</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We said we are adding a node with edge 'c'. The insertion
     * point is between 'b' and 'd', so the 'pos' variable value is
     * the index of the first child pointer that we need to move forward
     * to make space for our new pointer.
     *
     * To start, move all the child pointers after the insertion point
     * of shift+sizeof(pointer) bytes on the right, to obtain:
     *
     * [HDR*][abde][Aptr][Bptr][....][....][Dptr][Eptr]|AUXP|
     */</comment>
    <expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name><name>n</name><operator>-&gt;</operator><name>size</name></name><operator>+</operator>
          <call><name>raxPadding</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>+</operator>
          <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>src</name><operator>+</operator><name>shift</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><name>pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Move the pointers to the left of the insertion position as well. Often
     * we don't need to do anything if there was already some padding to use. In
     * that case the final destination of the pointers will be the same, however
     * in our example there was no pre-existing padding, so we added one byte
     * plus thre bytes of padding. After the next memmove() things will look
     * like thata:
     *
     * [HDR*][abde][....][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>src</name><operator>+</operator><name>shift</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now make the space for the additional char in the data section,
     * but also move the pointers before the insertion point to the right
     * by shift bytes, in order to obtain the following:
     *
     * [HDR*][ab.d][e...][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
     */</comment>
    <expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>src</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We can now set the character and its child node pointer to get:
     *
     * [HDR*][abcd][e...][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
     * [HDR*][abcd][e...][Aptr][Bptr][Cptr][Dptr][Eptr]|AUXP|
     */</comment>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>childfield</name> <init>= <expr><operator>(</operator><name>raxNode</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>pos</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>childfield</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>childptr</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>parentlink</name> <operator>=</operator> <name>childfield</name></expr>;</expr_stmt>
    <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Turn the node 'n', that must be a node without any children, into a
 * compressed node representing a set of nodes linked one after the other
 * and having exactly one child each. The node can be a key or not: this
 * property and the associated value if any will be preserved.
 *
 * The function also returns a child node, since the last node of the
 * compressed chain cannot be part of the chain: it has zero children while
 * we can only compress inner nodes with exactly one child each. */</comment>
<function><type><name>raxNode</name> <modifier>*</modifier></type><name>raxCompressNode</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Initialized only to avoid warnings. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Compress node: %.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate the child to link to this node. */</comment>
    <expr_stmt><expr><operator>*</operator><name>child</name> <operator>=</operator> <call><name>raxNewNode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>child</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Make space in the parent node. */</comment>
    <expr_stmt><expr><name>newsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>len</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* To restore it later. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newsize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>newn</name> <init>= <expr><call><name>rax_realloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newn</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><operator>*</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>newn</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>childfield</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>childfield</name></expr></argument>,<argument><expr><name>child</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Low level function that walks the tree looking for the string
 * 's' of 'len' bytes. The function returns the number of characters
 * of the key that was possible to process: if the returned integer
 * is the same as 'len', then it means that the node corresponding to the
 * string was found (however it may not be a key in case the node-&gt;iskey is
 * zero or if simply we stopped in the middle of a compressed node, so that
 * 'splitpos' is non zero).
 *
 * Otherwise if the returned integer is not the same as 'len', there was an
 * early stop during the tree walk because of a character mismatch.
 *
 * The node where the search ended (because the full string was processed
 * or because there was an early stop) is returned by reference as
 * '*stopnode' if the passed pointer is not NULL. This node link in the
 * parent's node is returned as '*plink' if not NULL. Finally, if the
 * search stopped in a compressed node, '*splitpos' returns the index
 * inside the compressed node where the search ended. This is useful to
 * know where to split the node for insertion.
 *
 * Note that when we stop in the middle of a compressed node with
 * a perfect match, this function will return a length equal to the
 * 'len' argument (all the key matched), and will return a *splitpos which is
 * always positive (that will represent the index of the character immediately
 * *after* the last match in the current compressed node).
 *
 * When instead we stop at a compressed node and *splitpos is zero, it
 * means that the current node represents the key (that is, none of the
 * compressed node characters are needed to represent the key, just all
 * its parents nodes). */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>raxLowWalk</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>stopnode</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>plink</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>splitpos</name></decl></parameter>, <parameter><decl><type><name>raxStack</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>rax</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>parentlink</name> <init>= <expr><operator>&amp;</operator><name><name>rax</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Position in the string. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Position in the node children (or bytes if compressed).*/</comment>
    <while>while<condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"Lookup current node"</literal></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>v</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Even when h-&gt;size is large, linear scan provides good
             * performances compared to other approaches that are in theory
             * more sounding, like performing a binary search. */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>v</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ts</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxStackPush</name><argument_list>(<argument><expr><name>ts</name></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Save stack of parent nodes. */</comment>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>children</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Compressed node only child is at index 0. */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><name>children</name><operator>+</operator><name>j</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>parentlink</name> <operator>=</operator> <name>children</name><operator>+</operator><name>j</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* If the new node is compressed and we do not
                  iterate again (since i == l) set the split
                  position to 0 to signal this node represents
                  the searched key. */</comment>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"Lookup stop node is"</literal></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>stopnode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>stopnode</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>plink</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>plink</name> <operator>=</operator> <name>parentlink</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>splitpos</name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>splitpos</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert the element 's' of size 'len', setting as auxiliary data
 * the pointer 'data'. If the element is already present, the associated
 * data is updated (only if 'overwrite' is set to 1), and 0 is returned,
 * otherwise the element is inserted and 1 is returned. On out of memory the
 * function returns 0 as well but sets errno to ENOMEM, otherwise errno will
 * be set to 0.
 */</comment>
<function><type><name>int</name></type> <name>raxGenericInsert</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>overwrite</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Split position. If raxLowWalk() stops in a compressed
                  node, the index 'j' represents the char we stopped within the
                  compressed node, that is, the position where to split the
                  node for insertion. */</comment>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>h</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>parentlink</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"### Insert %.*s with value %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>raxLowWalk</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>j</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If i == len we walked following the whole string. If we are not
     * in the middle of a compressed node, the string is either already
     * inserted or this middle node is currently not a key, but can represent
     * our key. We have just to reallocate the node and make space for the
     * data pointer. */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>||</operator> <name>j</name> <operator>==</operator> <literal type="number">0</literal> <comment type="block">/* not in the middle if j is 0 */</comment><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"### Insert: node representing key exists\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Make space for the value pointer if needed. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>||</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <name>overwrite</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>raxReallocForData</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>h</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update the existing key if there is already one. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>old</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>old</name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>overwrite</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Element already exists. */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Otherwise set the node as a key. Note that raxSetData()
         * will set h-&gt;iskey. */</comment>
        <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* Element inserted. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the node we stopped at is a compressed node, we need to
     * split it before to continue.
     *
     * Splitting a compressed node have a few possible cases.
     * Imagine that the node 'h' we are currently at is a compressed
     * node contaning the string "ANNIBALE" (it means that it represents
     * nodes A -&gt; N -&gt; N -&gt; I -&gt; B -&gt; A -&gt; L -&gt; E with the only child
     * pointer of this node pointing at the 'E' node, because remember that
     * we have characters at the edges of the graph, not inside the nodes
     * themselves.
     *
     * In order to show a real case imagine our node to also point to
     * another compressed node, that finally points at the node without
     * children, representing 'O':
     *
     *     "ANNIBALE" -&gt; "SCO" -&gt; []
     *
     * When inserting we may face the following cases. Note that all the cases
     * require the insertion of a non compressed node with exactly two
     * children, except for the last case which just requires splitting a
     * compressed node.
     *
     * 1) Inserting "ANNIENTARE"
     *
     *               |B| -&gt; "ALE" -&gt; "SCO" -&gt; []
     *     "ANNI" -&gt; |-|
     *               |E| -&gt; (... continue algo ...) "NTARE" -&gt; []
     *
     * 2) Inserting "ANNIBALI"
     *
     *                  |E| -&gt; "SCO" -&gt; []
     *     "ANNIBAL" -&gt; |-|
     *                  |I| -&gt; (... continue algo ...) []
     *
     * 3) Inserting "AGO" (Like case 1, but set iscompr = 0 into original node)
     *
     *            |N| -&gt; "NIBALE" -&gt; "SCO" -&gt; []
     *     |A| -&gt; |-|
     *            |G| -&gt; (... continue algo ...) |O| -&gt; []
     *
     * 4) Inserting "CIAO"
     *
     *     |A| -&gt; "NNIBALE" -&gt; "SCO" -&gt; []
     *     |-|
     *     |C| -&gt; (... continue algo ...) "IAO" -&gt; []
     *
     * 5) Inserting "ANNI"
     *
     *     "ANNI" -&gt; "BALE" -&gt; "SCO" -&gt; []
     *
     * The final algorithm for insertion covering all the above cases is as
     * follows.
     *
     * ============================= ALGO 1 =============================
     *
     * For the above cases 1 to 4, that is, all cases where we stopped in
     * the middle of a compressed node for a character mismatch, do:
     *
     * Let $SPLITPOS be the zero-based index at which, in the
     * compressed node array of characters, we found the mismatching
     * character. For example if the node contains "ANNIBALE" and we add
     * "ANNIENTARE" the $SPLITPOS is 4, that is, the index at which the
     * mismatching character is found.
     *
     * 1. Save the current compressed node $NEXT pointer (the pointer to the
     *    child element, that is always present in compressed nodes).
     *
     * 2. Create "split node" having as child the non common letter
     *    at the compressed node. The other non common letter (at the key)
     *    will be added later as we continue the normal insertion algorithm
     *    at step "6".
     *
     * 3a. IF $SPLITPOS == 0:
     *     Replace the old node with the split node, by copying the auxiliary
     *     data if any. Fix parent's reference. Free old node eventually
     *     (we still need its data for the next steps of the algorithm).
     *
     * 3b. IF $SPLITPOS != 0:
     *     Trim the compressed node (reallocating it as well) in order to
     *     contain $splitpos characters. Change chilid pointer in order to link
     *     to the split node. If new compressed node len is just 1, set
     *     iscompr to 0 (layout is the same). Fix parent's reference.
     *
     * 4a. IF the postfix len (the length of the remaining string of the
     *     original compressed node after the split character) is non zero,
     *     create a "postfix node". If the postfix node has just one character
     *     set iscompr to 0, otherwise iscompr to 1. Set the postfix node
     *     child pointer to $NEXT.
     *
     * 4b. IF the postfix len is zero, just use $NEXT as postfix pointer.
     *
     * 5. Set child[0] of split node to postfix node.
     *
     * 6. Set the split node as the current node, set current index at child[1]
     *    and continue insertion algorithm as usually.
     *
     * ============================= ALGO 2 =============================
     *
     * For case 5, that is, if we stopped in the middle of a compressed
     * node but no mismatch was found, do:
     *
     * Let $SPLITPOS be the zero-based index at which, in the
     * compressed node array of characters, we stopped iterating because
     * there were no more keys character to match. So in the example of
     * the node "ANNIBALE", addig the string "ANNI", the $SPLITPOS is 4.
     *
     * 1. Save the current compressed node $NEXT pointer (the pointer to the
     *    child element, that is always present in compressed nodes).
     *
     * 2. Create a "postfix node" containing all the characters from $SPLITPOS
     *    to the end. Use $NEXT as the postfix node child pointer.
     *    If the postfix node length is 1, set iscompr to 0.
     *    Set the node as a key with the associated value of the new
     *    inserted key.
     *
     * 3. Trim the current node to contain the first $SPLITPOS characters.
     *    As usually if the new node length is just 1, set iscompr to 0.
     *    Take the iskey / associated value as it was in the orignal node.
     *    Fix the parent's reference.
     *
     * 4. Set the postfix node as the only child pointer of the trimmed
     *    node created at step 1.
     */</comment>

    <comment type="block">/* ------------------------- ALGORITHM 1 --------------------------- */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"ALGO 1: Stopped at compressed node %.*s (%p)\n"</literal></expr></argument>,
            <argument><expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Still to insert: %.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>len</name><operator>-</operator><name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>s</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Splitting at %d: '%c'\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>h</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><index>[<expr><name>j</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Other (key) letter is '%c'\n"</literal></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 1: Save next pointer. */</comment>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>childfield</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next</name></expr></argument>,<argument><expr><name>childfield</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Next is %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"iskey %d\n"</literal></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"key value is %p\n"</literal></expr></argument>, <argument><expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Set the length of the additional nodes we will need. */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>trimmedlen</name> <init>= <expr><name>j</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>postfixlen</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>split_node_is_key</name> <init>= <expr><operator>!</operator><name>trimmedlen</name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>isnull</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nodesize</name></decl>;</decl_stmt>

        <comment type="block">/* 2: Create the split node. Also allocate the other nodes we'll need
         *    ASAP, so that it will be simpler to handle OOM. */</comment>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>splitnode</name> <init>= <expr><call><name>raxNewNode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>split_node_is_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>trimmed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>postfix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>trimmedlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nodesize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>trimmedlen</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>trimmedlen</name></expr></argument>)</argument_list></call><operator>+</operator>
                       <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nodesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>trimmed</name> <operator>=</operator> <call><name>rax_malloc</name><argument_list>(<argument><expr><name>nodesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>postfixlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nodesize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>postfixlen</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>postfixlen</name></expr></argument>)</argument_list></call><operator>+</operator>
                       <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name>postfix</name> <operator>=</operator> <call><name>rax_malloc</name><argument_list>(<argument><expr><name>nodesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* OOM? Abort now that the tree is untouched. */</comment>
        <if_stmt><if>if <condition>(<expr><name>splitnode</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <operator>(</operator><name>trimmedlen</name> <operator>&amp;&amp;</operator> <name>trimmed</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>postfixlen</name> <operator>&amp;&amp;</operator> <name>postfix</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>splitnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>splitnode</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* 3a: Replace the old node with the split node. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ndata</name> <init>= <expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>splitnode</name></expr></argument>,<argument><expr><name>ndata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>splitnode</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>splitnode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* 3b: Trim the compressed node. */</comment>
            <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>trimmed</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <ternary><condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ndata</name> <init>= <expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>,<argument><expr><name>ndata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>splitnode</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>splitnode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>trimmed</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parentlink</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt> <comment type="block">/* Set parentlink to splitnode parent. */</comment>
            <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* 4: Create the postfix node: what remains of the original
         * compressed node after the split. */</comment>
        <if_stmt><if>if <condition>(<expr><name>postfixlen</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* 4a: create a postfix node. */</comment>
            <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>postfixlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <name>postfixlen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>postfix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>postfixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>postfix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>next</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* 4b: just use next as postfix node. */</comment>
            <expr_stmt><expr><name>postfix</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* 5: Set splitnode first child as the postfix node. */</comment>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>splitchild</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>splitnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>splitchild</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>postfix</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>postfix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 6. Continue insertion: this will cause the splitnode to
         * get a new child (the non common character at the currently
         * inserted key). */</comment>
        <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <name>splitnode</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>len</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* ------------------------- ALGORITHM 2 --------------------------- */</comment>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"ALGO 2: Stopped at compressed node %.*s (%p) j = %d\n"</literal></expr></argument>,
            <argument><expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>h</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Allocate postfix &amp; trimmed nodes ASAP to fail for OOM gracefully. */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>postfixlen</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nodesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>postfixlen</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>postfixlen</name></expr></argument>)</argument_list></call><operator>+</operator>
                          <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nodesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>postfix</name> <init>= <expr><call><name>rax_malloc</name><argument_list>(<argument><expr><name>nodesize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>nodesize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>j</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nodesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>trimmed</name> <init>= <expr><call><name>rax_malloc</name><argument_list>(<argument><expr><name>nodesize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>postfix</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>trimmed</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* 1: Save next pointer. */</comment>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>childfield</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next</name></expr></argument>,<argument><expr><name>childfield</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 2: Create the postfix node. */</comment>
        <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>postfixlen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <name>postfixlen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>postfix</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>postfix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>j</name></expr></argument>,<argument><expr><name>postfixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>postfix</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>postfix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>next</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* 3: Trim the compressed node. */</comment>
        <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <name>j</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trimmed</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>trimmed</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>trimmed</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>aux</name> <init>= <expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>,<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Fix the trimmed node child pointer to point to
         * the postfix node. */</comment>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>postfix</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>postfix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Finish! We don't need to continue with the insertion
         * algorithm for ALGO 2. The key is already inserted. */</comment>
        <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* Key inserted. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We walked the radix tree as far as we could, but still there are left
     * chars in our string. We need to insert the missing nodes. */</comment>
    <while>while<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

        <comment type="block">/* If this node is going to have a single child, and there
         * are other characters, so that that would result in a chain
         * of single-childed nodes, turn it into a compressed node. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name><operator>-</operator><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Inserting compressed node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>comprsize</name> <init>= <expr><name>len</name><operator>-</operator><name>i</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>comprsize</name> <operator>&gt;</operator> <name>RAX_NODE_MAX_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>comprsize</name> <operator>=</operator> <name>RAX_NODE_MAX_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>newh</name> <init>= <expr><call><name>raxCompressNode</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>s</name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><name>comprsize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>newh</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>oom</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <name>newh</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parentlink</name> <operator>=</operator> <call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>comprsize</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Inserting normal node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_parentlink</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>newh</name> <init>= <expr><call><name>raxAddChild</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>new_parentlink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>newh</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>oom</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <name>newh</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parentlink</name> <operator>=</operator> <name>new_parentlink</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>newh</name> <init>= <expr><call><name>raxReallocForData</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newh</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>oom</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <name>newh</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* Element inserted. */</comment>

<label><name>oom</name>:</label>
    <comment type="block">/* This code path handles out of memory after part of the sub-tree was
     * already modified. Set the node as a key, and then remove it. However we
     * do that only if the node is a terminal node, otherwise if the OOM
     * happened reallocating a node in the middle, we don't need to free
     * anything. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Compensate the next remove. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Overwriting insert. Just a wrapper for raxGenericInsert() that will
 * update the element if there is already one for the same key. */</comment>
<function><type><name>int</name></type> <name>raxInsert</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>raxGenericInsert</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><name>old</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Non overwriting insert function: this if an element with the same key
 * exists, the value is not updated and the function returns 0.
 * This is a just a wrapper for raxGenericInsert(). */</comment>
<function><type><name>int</name></type> <name>raxTryInsert</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>raxGenericInsert</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><name>old</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find a key in the rax, returns raxNotFound special void pointer value
 * if the item was not found, otherwise the value associated with the
 * item is returned. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>raxFind</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"### Lookup: %.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>splitpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>raxLowWalk</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>splitpos</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>len</name> <operator>||</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name>splitpos</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>raxNotFound</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the memory address where the 'parent' node stores the specified
 * 'child' pointer, so that the caller can update the pointer with another
 * one if needed. The function assumes it will find a match, otherwise the
 * operation is an undefined behavior (it will continue scanning the
 * memory without any bound checking). */</comment>
<function><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>raxFindParentLink</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>child</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>cp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Low level child removal from node. The new node pointer (after the child
 * removal) is returned. Note that this function does not fix the pointer
 * of the parent node in its parent, so this task is up to the caller.
 * The function never fails for out of memory. */</comment>
<function><type><name>raxNode</name> <modifier>*</modifier></type><name>raxRemoveChild</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"raxRemoveChild before"</literal></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If parent is a compressed node (having a single child, as for definition
     * of the data structure), the removal of the child consists into turning
     * it into a normal node without children. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSetData</name><argument_list>(<argument><expr><name>parent</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"raxRemoveChild after"</literal></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>parent</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise we need to scan for the child pointer and memmove()
     * accordingly.
     *
     * 1. To start we seek the first element in both the children
     *    pointers and edge bytes in the node. */</comment>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>c</name> <init>= <expr><name>cp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* 2. Search the child pointer to remove inside the array of children
     *    pointers. */</comment>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>aux</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux</name></expr></argument>,<argument><expr><name>c</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aux</name> <operator>==</operator> <name>child</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* 3. Remove the edge and the pointer by memmoving the remaining children
     *    pointer and edge bytes one position before. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>taillen</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <operator>(</operator><name>e</name> <operator>-</operator> <name><name>parent</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"raxRemoveChild tail len: %d\n"</literal></expr></argument>, <argument><expr><name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><name>e</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the shift, that is the amount of bytes we should move our
     * child pointers to the left, since the removal of one edge character
     * and the corresponding padding change, may change the layout.
     * We just check if in the old version of the node there was at the
     * end just a single byte and all padding: in that case removing one char
     * will remove a whole sizeof(void*) word. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>shift</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>size</name></name><operator>+</operator><literal type="number">4</literal><operator>)</operator> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Move the children pointers before the deletion point. */</comment>
    <if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>cp</name><operator>)</operator><operator>-</operator><name>shift</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><name>taillen</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Move the remaining "tail" pointers at the right position as well. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>valuelen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parent</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>c</name><operator>)</operator><operator>-</operator><name>shift</name></expr></argument>,<argument><expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>taillen</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>+</operator><name>valuelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 4. Update size. */</comment>
    <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>size</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* realloc the node according to the theoretical memory usage, to free
     * data if we are over-allocating right now. */</comment>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>rax_realloc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>,<argument><expr><call><name>raxNodeCurrentLength</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newnode</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"raxRemoveChild after"</literal></expr></argument>, <argument><expr><name>newnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Note: if rax_realloc() fails we just return the old address, which
     * is valid. */</comment>
    <return>return <expr><ternary><condition><expr><name>newnode</name></expr> ?</condition><then> <expr><name>newnode</name></expr> </then><else>: <expr><name>parent</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified item. Returns 1 if the item was found and
 * deleted, 0 otherwise. */</comment>
<function><type><name>int</name></type> <name>raxRemove</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxStack</name></type> <name>ts</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"### Delete: %.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxStackInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>splitpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>raxLowWalk</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>splitpos</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>len</name> <operator>||</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name>splitpos</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>raxStackFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>old</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>old</name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* If this node has no children, the deletion needs to reclaim the
     * no longer used nodes. This is an iterative process that needs to
     * walk the three upward, deleting all the nodes with just one child
     * that are not keys, until the head of the rax is reached or the first
     * node with more than one child is found. */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>trycompress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Will be set to 1 if we should try to optimize the
                            tree resulting from the deletion. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Key deleted in node without children. Cleanup needed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><name>h</name> <operator>!=</operator> <name><name>rax</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>child</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Freeing child %p [%.*s] key:%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>child</name></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>child</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>child</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>iskey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>raxStackPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <comment type="block">/* If this node has more then one child, or actually holds
              * a key, stop here. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Unlinking child %p from parent %p\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>child</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>raxRemoveChild</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>new</name> <operator>!=</operator> <name>h</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><call><name>raxStackPeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>parentlink</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>parentlink</name> <operator>=</operator> <operator>&amp;</operator><name><name>rax</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>parentlink</name> <operator>=</operator> <call><name>raxFindParentLink</name><argument_list>(<argument><expr><name>parent</name></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>new</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* If after the removal the node has just a single child
             * and is not a key, we need to try to compress it. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>new</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>new</name><operator>-&gt;</operator><name>iskey</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>trycompress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>h</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If the node had just one child, after the removal of the key
         * further compression with adjacent nodes is pontentially possible. */</comment>
        <expr_stmt><expr><name>trycompress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Don't try node compression if our nodes pointers stack is not
     * complete because of OOM while executing raxLowWalk() */</comment>
    <if_stmt><if>if <condition>(<expr><name>trycompress</name> <operator>&amp;&amp;</operator> <name><name>ts</name><operator>.</operator><name>oom</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>trycompress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Recompression: if trycompress is true, 'h' points to a radix tree node
     * that changed in a way that could allow to compress nodes in this
     * sub-branch. Compressed nodes represent chains of nodes that are not
     * keys and have a single child, so there are two deletion events that
     * may alter the tree so that further compression is needed:
     *
     * 1) A node with a single child was a key and now no longer is a key.
     * 2) A node with two children now has just one child.
     *
     * We try to navigate upward till there are other nodes that can be
     * compressed, when we reach the upper node which is not a key and has
     * a single child, we scan the chain of children to collect the
     * compressable part of the tree, and replace the current node with the
     * new one, fixing the child pointer to reference the first non
     * compressable node.
     *
     * Example of case "1". A tree stores the keys "FOO" = 1 and
     * "FOOBAR" = 2:
     *
     *
     * "FOO" -&gt; "BAR" -&gt; [] (2)
     *           (1)
     *
     * After the removal of "FOO" the tree can be compressed as:
     *
     * "FOOBAR" -&gt; [] (2)
     *
     *
     * Example of case "2". A tree stores the keys "FOOBAR" = 1 and
     * "FOOTER" = 2:
     *
     *          |B| -&gt; "AR" -&gt; [] (1)
     * "FOO" -&gt; |-|
     *          |T| -&gt; "ER" -&gt; [] (2)
     *
     * After the removal of "FOOTER" the resulting tree is:
     *
     * "FOO" -&gt; |B| -&gt; "AR" -&gt; [] (1)
     *
     * That can be compressed into:
     *
     * "FOOBAR" -&gt; [] (1)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>trycompress</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"After removing %.*s:\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"Compression may be needed"</literal></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Seek start node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Try to reach the upper node that is compressible.
         * At the end of the loop 'h' will point to the first node we
         * can try to compress and 'parent' to its parent. */</comment>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
        <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>raxStackPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name> <operator>||</operator> <name><name>parent</name><operator>-&gt;</operator><name>iskey</name></name> <operator>||</operator>
                <operator>(</operator><operator>!</operator><name><name>parent</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>parent</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"Going up to"</literal></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>h</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Compression starting node. */</comment>

        <comment type="block">/* Scan chain of nodes we can compress. */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>comprsize</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nodes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <comment type="block">/* Stop here if going to the next node would result into
             * a compressed node larger than h-&gt;size can hold. */</comment>
            <if_stmt><if>if <condition>(<expr><name>comprsize</name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>RAX_NODE_MAX_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>comprsize</name> <operator>+=</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>nodes</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If we can compress, create the new node and populate it. */</comment>
            <decl_stmt><decl><type><name>size_t</name></type> <name>nodesize</name> <init>=
                <expr><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>comprsize</name><operator>+</operator><call><name>raxPadding</name><argument_list>(<argument><expr><name>comprsize</name></expr></argument>)</argument_list></call><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>rax_malloc</name><argument_list>(<argument><expr><name>nodesize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* An out of memory here just means we cannot optimize this
             * node, but the tree is left in a consistent state. */</comment>
            <if_stmt><if>if <condition>(<expr><name>new</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>raxStackFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>iskey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>comprsize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* Scan again, this time to populate the new node content and
             * to fix the new node child pointer. At the same time we free
             * all the nodes that we'll no longer use. */</comment>
            <expr_stmt><expr><name>comprsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
            <while>while<condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>comprsize</name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>comprsize</name> <operator>+=</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>h</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>--</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>iskey</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"New node"</literal></expr></argument>,<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Now 'h' points to the first node that we still need to use,
             * so our new node child pointer will point to it. */</comment>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Fix parent link. */</comment>
            <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>parentlink</name> <init>= <expr><call><name>raxFindParentLink</name><argument_list>(<argument><expr><name>parent</name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>parentlink</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>new</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Compressed %d nodes, %d total bytes\n"</literal></expr></argument>,
                <argument><expr><name>nodes</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>comprsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>raxStackFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the core of raxFree(): performs a depth-first scan of the
 * tree and releases all the nodes found. */</comment>
<function><type><name>void</name></type> <name>raxRecursiveFree</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>free_callback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"free traversing"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numchildren</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>numchildren</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxRecursiveFree</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>child</name></expr></argument>,<argument><expr><name>free_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>debugnode</name><argument_list>(<argument><expr><literal type="string">"free depth-first"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>free_callback</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free_callback</name><argument_list>(<argument><expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a whole radix tree, calling the specified callback in order to
 * free the auxiliary data. */</comment>
<function><type><name>void</name></type> <name>raxFreeWithCallback</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>free_callback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxRecursiveFree</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name><name>rax</name><operator>-&gt;</operator><name>head</name></name></expr></argument>,<argument><expr><name>free_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name>rax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a whole radix tree. */</comment>
<function><type><name>void</name></type> <name>raxFree</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name>rax</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------- Iterator --------------------------------- */</comment>

<comment type="block">/* Initialize a Rax iterator. This call should be performed a single time
 * to initialize the iterator, and must be followed by a raxSeek() call,
 * otherwise the raxPrev()/raxNext() functions will just return EOF. */</comment>
<function><type><name>void</name></type> <name>raxStart</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rt</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>RAX_ITER_EOF</name></expr>;</expr_stmt> <comment type="block">/* No crash if the iterator is not seeked. */</comment>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>rt</name></name> <operator>=</operator> <name>rt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>key_static_string</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_max</name></name> <operator>=</operator> <name>RAX_ITER_STATIC_LEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node_cb</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxStackInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append characters at the current key string of the iterator 'it'. This
 * is a low level function used to implement the iterator, not callable by
 * the user. Returns 0 on out of memory, otherwise 1 is returned. */</comment>
<function><type><name>int</name></type> <name>raxIteratorAddChars</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>key_max</name></name> <operator>&lt;</operator> <name><name>it</name><operator>-&gt;</operator><name>key_len</name></name><operator>+</operator><name>len</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>key_static_string</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
                                                                  <expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>new_max</name> <init>= <expr><operator>(</operator><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name><operator>+</operator><name>len</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>rax_realloc</name><argument_list>(<argument><expr><name>old</name></expr></argument>,<argument><expr><name>new_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name>old</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>it</name><operator>-&gt;</operator><name>key_static_string</name></name></expr> </then><else>: <expr><name>old</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>old</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>key_static_string</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_max</name></name> <operator>=</operator> <name>new_max</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Use memmove since there could be an overlap between 's' and
     * it-&gt;key when we use the current key in order to re-seek. */</comment>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name><operator>+</operator><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified number of chars from the right of the current
 * iterator key. */</comment>
<function><type><name>void</name></type> <name>raxIteratorDelChars</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name> <operator>-=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Do an iteration step towards the next element. At the end of the step the
 * iterator key will represent the (new) current key. If it is not possible
 * to step in the specified direction since there are no longer elements, the
 * iterator is flagged with RAX_ITER_EOF.
 *
 * If 'noup' is true the function starts directly scanning for the next
 * lexicographically smaller children, and the current node is already assumed
 * to be the parent of the last key node, so the first operation to go back to
 * the parent will be skipped. This option is used by raxSeek() when
 * implementing seeking a non existing element with the "&gt;" or "&lt;" options:
 * the starting node is not a key in that particular case, so we start the scan
 * from a node that does not represent the key set.
 *
 * The function returns 1 on success or 0 on out of memory. */</comment>
<function><type><name>int</name></type> <name>raxIteratorNextStep</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noup</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_EOF</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_JUST_SEEKED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>orig_key_len</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>orig_stack_items</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>items</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>orig_node</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>children</name> <init>= <expr><ternary><condition><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noup</name> <operator>&amp;&amp;</operator> <name>children</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"GO DEEPER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Seek the lexicographically smaller key in this subtree, which
             * is the first one found always going torwards the first child
             * of every successive node. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxStackPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Call the node callback if any, and replace the node pointer
             * if the callback returns true. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node_cb</name></name> <operator>&amp;&amp;</operator> <call><name><name>it</name><operator>-&gt;</operator><name>node_cb</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* For "next" step, stop every time we find a key along the
             * way, since the key is lexicograhically smaller compared to
             * what follows in the sub-children. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* If we finished exporing the previous sub-tree, switch to the
             * new one: go upper until a node is found where there are
             * children representing keys lexicographically greater than the
             * current key. */</comment>
            <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>old_noup</name> <init>= <expr><name>noup</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Already on head? Can't go up, iteration finished. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noup</name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_EOF</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>items</name></name> <operator>=</operator> <name>orig_stack_items</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name> <operator>=</operator> <name>orig_key_len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>orig_node</name></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* If there are no children at the current node, try parent's
                 * next child. */</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>prevchild</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>key</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noup</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>raxStackPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>noup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <comment type="block">/* Adjust the current key to represent the node we are
                 * at. */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>todel</name> <init>= <expr><ternary><condition><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>raxIteratorDelChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name>todel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Try visiting the next child if there was at least one
                 * additional child. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name>old_noup</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"SCAN NEXT %c\n"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>prevchild</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></while>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"SCAN found a new node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxStackPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Call the node callback if any, and replace the node
                         * pointer if the callback returns true. */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node_cb</name></name> <operator>&amp;&amp;</operator> <call><name><name>it</name><operator>-&gt;</operator><name>node_cb</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><literal type="number">1</literal></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Seek the grestest key in the subtree at the current node. Return 0 on
 * out of memory, otherwise 1. This is an helper function for different
 * iteration functions below. */</comment>
<function><type><name>int</name></type> <name>raxSeekGreatest</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <while>while<condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
                <argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxStackPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like raxIteratorNextStep() but implements an iteration step moving
 * to the lexicographically previous element. The 'noup' option has a similar
 * effect to the one of raxIteratorNextStep(). */</comment>
<function><type><name>int</name></type> <name>raxIteratorPrevStep</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noup</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_EOF</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_JUST_SEEKED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>orig_key_len</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>orig_stack_items</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>items</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>orig_node</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>old_noup</name> <init>= <expr><name>noup</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Already on head? Can't go up, iteration finished. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noup</name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_EOF</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>items</name></name> <operator>=</operator> <name>orig_stack_items</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name> <operator>=</operator> <name>orig_key_len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>orig_node</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>prevchild</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>key</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>noup</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>raxStackPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>noup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Adjust the current key to represent the node we are
         * at. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>todel</name> <init>= <expr><ternary><condition><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxIteratorDelChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name>todel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Try visiting the prev child if there is at least one
         * child. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name>old_noup</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"SCAN PREV %c\n"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>prevchild</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>cp</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <comment type="block">/* If we found a new subtree to explore in this node,
             * go deeper following all the last children in order to
             * find the key lexicographically greater. */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"SCAN found a new node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Enter the node we just found. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxStackPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Seek sub-tree max. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxSeekGreatest</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Return the key: this could be the key we found scanning a new
         * subtree, or if we did not find a new subtree to explore here,
         * before giving up with this node, check if it's a key itself. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Seek an iterator at the specified element.
 * Return 0 if the seek failed for syntax error or out of memory. Otherwise
 * 1 is returned. When 0 is returned for out of memory, errno is set to
 * the ENOMEM value. */</comment>
<function><type><name>int</name></type> <name>raxSeek</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>lt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>gt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>items</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Just resetting. Intialized by raxStart(). */</comment>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RAX_ITER_EOF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Set flags according to the operator used to perform the seek. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>gt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>lt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>eq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Error. */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If there are no elements, set the EOF condition immediately and
     * return. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>numele</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_EOF</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Seeking the first key greater or equal to the empty string
         * is equivalent to seeking the smaller key available. */</comment>
        <return>return <expr><call><name>raxSeek</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Find the greatest key taking always the last child till a
         * final node is found. */</comment>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxSeekGreatest</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iskey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We need to seek the specified key. What we do here is to actually
     * perform a lookup, and later invoke the prev/next key code that
     * we already use for iteration. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>splitpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>raxLowWalk</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>rt</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>splitpos</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Return OOM on incomplete stack info. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>oom</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>eq</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>||</operator> <name>splitpos</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We found our node, since the key matches and we have an
         * "equal" condition. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* OOM. */</comment>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lt</name> <operator>||</operator> <name>gt</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Exact key not found or eq flag not set. We have to set as current
         * key the one represented by the node we stopped at, and perform
         * a next/prev operation to seek. To reconstruct the key at this node
         * we start from the parent and go to the current node, accumulating
         * the characters found along the way. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxStackPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>items</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>stack</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>stack</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
                <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>aux</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>aux</name> <operator>==</operator> <name>child</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>raxStackPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We need to set the iterator in the correct state to call next/prev
         * step in order to seek the desired element. */</comment>
        <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"After initial seek: i=%d len=%d key=%.*s\n"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If we stopped in the middle of a normal node because of a
             * mismatch, add the mismatching character to the current key
             * and call the iterator with the 'noup' flag so that it will try
             * to seek the next/prev child in the current node directly based
             * on the mismatching character. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name>ele</name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Seek normal node on mismatch: %.*s\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>lt</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxIteratorPrevStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>gt</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxIteratorNextStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt> <comment type="block">/* Ignore next call. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>!=</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Compressed mismatch: %.*s\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* In case of a mismatch within a compressed node. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>nodechar</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>splitpos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>keychar</name> <init>= <expr><name><name>ele</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>gt</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If the key the compressed node represents is greater
                 * than our seek element, continue forward, otherwise set the
                 * state in order to go back to the next sub-tree. */</comment>
                <if_stmt><if>if <condition>(<expr><name>nodechar</name> <operator>&gt;</operator> <name>keychar</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorNextStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorNextStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>lt</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If the key the compressed node represents is smaller
                 * than our seek element, seek the greater key in this
                 * subtree, otherwise set the state in order to go back to
                 * the previous sub-tree. */</comment>
                <if_stmt><if>if <condition>(<expr><name>nodechar</name> <operator>&lt;</operator> <name>keychar</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxSeekGreatest</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>raxGetData</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorPrevStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt> <comment type="block">/* Ignore next call. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"No mismatch: %.*s\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key_len</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If there was no mismatch we are into a node representing the
             * key, (but which is not a key or the seek operator does not
             * include 'eq'), or we stopped in the middle of a compressed node
             * after processing all the key. Continue iterating as this was
             * a legitimate key we stopped at. */</comment>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iscompr</name></name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>iskey</name></name> <operator>&amp;&amp;</operator> <name>splitpos</name> <operator>&amp;&amp;</operator> <name>lt</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If we stopped in the middle of a compressed node with
                 * perfect match, and the condition is to seek a key "&lt;" than
                 * the specified one, then if this node is a key it already
                 * represents our match. For instance we may have nodes:
                 *
                 * "f" -&gt; "oobar" = 1 -&gt; "" = 2
                 *
                 * Representing keys "f" = 1, "foobar" = 2. A seek for
                 * the key &lt; "foo" will stop in the middle of the "oobar"
                 * node, but will be our match, representing the key "f".
                 *
                 * So in that case, we don't seek backward. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>gt</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxIteratorNextStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>lt</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxIteratorPrevStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_JUST_SEEKED</name></expr>;</expr_stmt> <comment type="block">/* Ignore next call. */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If we are here just eq was set but no match was found. */</comment>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_EOF</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Go to the next element in the scope of the iterator 'it'.
 * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is
 * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */</comment>
<function><type><name>int</name></type> <name>raxNext</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorNextStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_EOF</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Go to the previous element in the scope of the iterator 'it'.
 * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is
 * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */</comment>
<function><type><name>int</name></type> <name>raxPrev</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorPrevStep</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_EOF</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Perform a random walk starting in the current position of the iterator.
 * Return 0 if the tree is empty or on out of memory. Otherwise 1 is returned
 * and the iterator is set to the node reached after doing a random walk
 * of 'steps' steps. If the 'steps' argument is 0, the random walk is performed
 * using a random number of steps between 1 and two times the logarithm of
 * the number of elements.
 *
 * NOTE: if you use this function to generate random elements from the radix
 * tree, expect a disappointing distribution. A random walk produces good
 * random elements if the tree is not sparse, however in the case of a radix
 * tree certain keys will be reported much more often than others. At least
 * this function should be able to expore every possible element eventually. */</comment>
<function><type><name>int</name></type> <name>raxRandomWalk</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>steps</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>numele</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RAX_ITER_EOF</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>steps</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>fle</name> <init>= <expr><call><name>floor</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>numele</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>fle</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>steps</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>fle</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>steps</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>numchildren</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <operator>(</operator><name>numchildren</name><operator>+</operator><operator>(</operator><name>n</name> <operator>!=</operator> <name><name>it</name><operator>-&gt;</operator><name>rt</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>numchildren</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Go up to parent. */</comment>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>raxStackPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>todel</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>raxIteratorDelChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name>todel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Select a random child. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxIteratorAddChars</name><argument_list>(<argument><expr><name>it</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><name>r</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>+</operator><name>r</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxStackPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>steps</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare the key currently pointed by the iterator to the specified
 * key according to the specified operator. Returns 1 if the comparison is
 * true, otherwise 0 is returned. */</comment>
<function><type><name>int</name></type> <name>raxCompare</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>key_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>lt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>gt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eq</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>gt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Syntax error. */</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>minlen</name> <init>= <expr><ternary><condition><expr><name>key_len</name> <operator>&lt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>key_len</name></name></expr> ?</condition><then> <expr><name>key_len</name></expr> </then><else>: <expr><name><name>iter</name><operator>-&gt;</operator><name>key_len</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Handle == */</comment>
    <if_stmt><if>if <condition>(<expr><name>lt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>gt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>key_len</name> <operator>==</operator> <name><name>iter</name><operator>-&gt;</operator><name>key_len</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Handle &gt;, &gt;=, &lt;, &lt;= */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Same prefix: longer wins. */</comment>
        <if_stmt><if>if <condition>(<expr><name>eq</name> <operator>&amp;&amp;</operator> <name>key_len</name> <operator>==</operator> <name><name>iter</name><operator>-&gt;</operator><name>key_len</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>lt</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>key_len</name></name> <operator>&lt;</operator> <name>key_len</name></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>gt</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>key_len</name></name> <operator>&gt;</operator> <name>key_len</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt> <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>gt</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></if> <else>else <comment type="block">/* (cmp &lt; 0) */</comment> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name>lt</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the iterator. */</comment>
<function><type><name>void</name></type> <name>raxStop</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>!=</operator> <name><name>it</name><operator>-&gt;</operator><name>key_static_string</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rax_free</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>raxStackFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return if the iterator is in an EOF state. This happens when raxSeek()
 * failed to seek an appropriate element, so that raxNext() or raxPrev()
 * will return zero, or when an EOF condition was reached while iterating
 * with raxNext() and raxPrev(). */</comment>
<function><type><name>int</name></type> <name>raxEOF</name><parameter_list>(<parameter><decl><type><name>raxIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RAX_ITER_EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the number of elements inside the radix tree. */</comment>
<function><type><name>uint64_t</name></type> <name>raxSize</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>rax</name><operator>-&gt;</operator><name>numele</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------- Introspection ------------------------------ */</comment>

<comment type="block">/* This function is mostly used for debugging and learning purposes.
 * It shows an ASCII representation of a tree on standard output, outling
 * all the nodes and the contained keys.
 *
 * The representation is as follow:
 *
 *  "foobar" (compressed node)
 *  [abc] (normal node with three children)
 *  [abc]=0x12345678 (node is a key, pointing to value 0x12345678)
 *  [] (a normal empty node)
 *
 *  Children are represented in new idented lines, each children prefixed by
 *  the "`-(x)" string, where "x" is the edge byte.
 *
 *  [abc]
 *   `-(a) "ladin"
 *   `-(b) [kj]
 *   `-(c) []
 *
 *  However when a node has a single child the following representation
 *  is used instead:
 *
 *  [abc] -&gt; "ladin" -&gt; []
 */</comment>

<comment type="block">/* The actual implementation of raxShow(). */</comment>
<function><type><name>void</name></type> <name>raxRecursiveShow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lpad</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>s</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="char">'"'</literal></expr> </then><else>: <expr><literal type="char">'['</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>e</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="char">'"'</literal></expr> </then><else>: <expr><literal type="char">']'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>numchars</name> <init>= <expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c%.*s%c"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>numchars</name> <operator>+=</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"=%p"</literal></expr></argument>,<argument><expr><call><name>raxGetData</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>numchildren</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Note that 7 and 4 magic constants are the string length
     * of " `-(x) " and " -&gt; " respectively. */</comment>
    <if_stmt><if>if <condition>(<expr><name>level</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>lpad</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name>numchildren</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">7</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>numchildren</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lpad</name> <operator>+=</operator> <name>numchars</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numchildren</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><literal type="string">" `-(%c) "</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>numchildren</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lpad</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>branch</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxRecursiveShow</name><argument_list>(<argument><expr><name>level</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>lpad</name></expr></argument>,<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Show a tree, as outlined in the comment above. */</comment>
<function><type><name>void</name></type> <name>raxShow</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxRecursiveShow</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>rax</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Used by debugnode() macro to show info about a given node. */</comment>
<function><type><name>void</name></type> <name>raxDebugShowNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>raxDebugMsg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: %p [%.*s] key:%d size:%d children:"</literal></expr></argument>,
        <argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numcld</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cldptr</name> <init>= <expr><call><name>raxNodeLastChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>numcld</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>numcld</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>,<argument><expr><name>cldptr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cldptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%p "</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Touch all the nodes of a tree returning a check sum. This is useful
 * in order to make Valgrind detect if there is something wrong while
 * reading the data structure.
 *
 * This function was used in order to identify Rax bugs after a big refactoring
 * using this technique:
 *
 * 1. The rax-test is executed using Valgrind, adding a printf() so that for
 *    the fuzz tester we see what iteration in the loop we are in.
 * 2. After every modification of the radix tree made by the fuzz tester
 *    in rax-test.c, we add a call to raxTouch().
 * 3. Now as soon as an operation will corrupt the tree, raxTouch() will
 *    detect it (via Valgrind) immediately. We can add more calls to narrow
 *    the state.
 * 4. At this point a good idea is to enable Rax debugging messages immediately
 *    before the moment the tree is corrupted, to see what happens.
 */</comment>
<function><type><name>PORT_ULONG</name></type> <name>raxTouch</name><parameter_list>(<parameter><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>debugf</name><argument_list>(<argument><expr><literal type="string">"Touching %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>iskey</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><call><name>raxGetData</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>numchildren</name> <init>= <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>iscompr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>raxNodeFirstChildPtr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numchildren</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>numchildren</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>raxNode</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>,<argument><expr><name>cp</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0x65d1760</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>raxTouch</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>
</unit>
