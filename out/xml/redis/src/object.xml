<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/object.c"><comment type="block">/* Redis Object implementation.
 *
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32fixes.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CYGWIN__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtold</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((PORT_LONGDOUBLE)strtod((a),(b)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===================== Creation and parsing of objects ==================== */</comment>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createObject</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_RAW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <operator>(</operator><call><name>LFUGetTimeInMinutes</name><argument_list>()</argument_list></call><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>LFU_INIT_VAL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <call><name>LRU_CLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set a special refcount in the object to make it "shared":
 * incrRefCount and decrRefCount() will test for this special refcount
 * and will not touch the object. This way it is free to access shared
 * objects such as small integers from different threads without any
 * mutex.
 *
 * A common patter to create shared objects:
 *
 * robj *myobject = makeObjectShared(createObject(...));
 *
 */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>makeObjectShared</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <name>OBJ_SHARED_REFCOUNT</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain
 * string object where o-&gt;ptr points to a proper sds string. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createRawStringObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is
 * an object where the sds string is actually an unmodifiable string
 * allocated in the same chunk as the object itself. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createEmbeddedStringObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sdshdr8</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sdshdr8</name></name> <modifier>*</modifier></type><name>sh</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>o</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>OBJ_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_EMBSTR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>sh</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <operator>(</operator><call><name>LFUGetTimeInMinutes</name><argument_list>()</argument_list></call><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>LFU_INIT_VAL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <call><name>LRU_CLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>SDS_TYPE_8</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>SDS_NOINIT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a string object with EMBSTR encoding if it is smaller than
 * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
 * used.
 *
 * The current limit of 44 is chosen so that the biggest string object
 * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ_ENCODING_EMBSTR_SIZE_LIMIT</name></cpp:macro> <cpp:value>44</cpp:value></cpp:define>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createStringObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>OBJ_ENCODING_EMBSTR_SIZE_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>createEmbeddedStringObject</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>createRawStringObject</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a string object from a long long value. When possible returns a
 * shared integer object, or at least an integer encoded one.
 *
 * If valueobj is non zero, the function avoids returning a a shared
 * integer, because the object is going to be used as value in the Redis key
 * space (for instance when the INCR command is used), so we want LFU/LRU
 * values specific for each key. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createStringObjectFromLongLongWithOptions</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>valueobj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>!</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_NO_SHARED_INTEGERS</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If the maxmemory policy permits, we can still return shared integers
         * even if valueobj is true. */</comment>
        <expr_stmt><expr><name>valueobj</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;</operator> <name>OBJ_SHARED_INTEGERS</name> <operator>&amp;&amp;</operator> <name>valueobj</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>shared</name><operator>.</operator><name>integers</name><index>[<expr><name>value</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>integers</name><index>[<expr><name>value</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>PORT_LONG_MIN</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>PORT_LONG_MAX</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_INT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>value</name><operator>)</operator></expr>;</expr_stmt>                                            <comment type="block">/* WIN_PORT_FIX: (PORT_LONG) cast removed */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for createStringObjectFromLongLongWithOptions() always demanding
 * to create a shared object if possible. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createStringObjectFromLongLong</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>createStringObjectFromLongLongWithOptions</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for createStringObjectFromLongLongWithOptions() avoiding a shared
 * object when LFU/LRU info are needed, that is, when the object is used
 * as a value in the key space, and Redis is configured to evict based on
 * LFU/LRU. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createStringObjectFromLongLongForValue</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>createStringObjectFromLongLongWithOptions</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a string object from a long double. If humanfriendly is non-zero
 * it does not use exponential format and trims trailing zeroes at the end,
 * however this results in loss of precision. Otherwise exp format is used
 * and the output of snprintf() is not modified.
 *
 * The 'humanfriendly' option is used for INCRBYFLOAT and HINCRBYFLOAT. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createStringObjectFromLongDouble</name><parameter_list>(<parameter><decl><type><name>PORT_LONGDOUBLE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>humanfriendly</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_LONG_DOUBLE_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ld2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>humanfriendly</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Duplicate a string object, with the guarantee that the returned object
 * has the same encoding as the original one.
 *
 * This function also guarantees that duplicating a small integer object
 * (or a string object that contains a representation of a small integer)
 * will always result in a fresh object that is unshared (refcount == 1).
 *
 * The resulting object always has refcount set to 1. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>dupStringObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_ENCODING_RAW</name></expr>:</case>
        <return>return <expr><call><name>createRawStringObject</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_EMBSTR</name></expr>:</case>
        <return>return <expr><call><name>createEmbeddedStringObject</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_INT</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_INT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <return>return <expr><name>d</name></expr>;</return>
    <default>default:</default>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Wrong encoding."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createQuicklistObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>quicklistCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_LIST</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_QUICKLIST</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createZiplistObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_LIST</name></expr></argument>,<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createSetObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>setDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_SET</name></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_HT</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createIntsetObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>intset</name> <modifier>*</modifier></type><name>is</name> <init>= <expr><call><name>intsetNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_SET</name></expr></argument>,<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_INTSET</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createHashObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_HASH</name></expr></argument>, <argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createZsetObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zsetDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name> <operator>=</operator> <call><name>zslCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_ZSET</name></expr></argument>,<argument><expr><name>zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createZsetZiplistObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_ZSET</name></expr></argument>,<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createStreamObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>streamNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STREAM</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_STREAM</name></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>createModuleObject</name><parameter_list>(<parameter><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>mt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_MODULE</name></expr></argument>,<argument><expr><name>mv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeStringObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeListObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_QUICKLIST</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown list encoding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeSetObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_ENCODING_HT</name></expr>:</case>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><operator>(</operator><name>dict</name><operator>*</operator><operator>)</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>OBJ_ENCODING_INTSET</name></expr>:</case>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeZsetObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_ENCODING_SKIPLIST</name></expr>:</case>
        <expr_stmt><expr><name>zs</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zslFree</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>OBJ_ENCODING_ZIPLIST</name></expr>:</case>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeHashObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_ENCODING_HT</name></expr>:</case>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><operator>(</operator><name>dict</name><operator>*</operator><operator>)</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>OBJ_ENCODING_ZIPLIST</name></expr>:</case>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown hash encoding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeModuleObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mv</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name><name>mv</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>mv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeStreamObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>freeStream</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>incrRefCount</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>!=</operator> <name>OBJ_SHARED_REFCOUNT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>decrRefCount</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>OBJ_STRING</name></expr>:</case> <expr_stmt><expr><call><name>freeStringObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_LIST</name></expr>:</case> <expr_stmt><expr><call><name>freeListObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_SET</name></expr>:</case> <expr_stmt><expr><call><name>freeSetObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_ZSET</name></expr>:</case> <expr_stmt><expr><call><name>freeZsetObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_HASH</name></expr>:</case> <expr_stmt><expr><call><name>freeHashObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_MODULE</name></expr>:</case> <expr_stmt><expr><call><name>freeModuleObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_STREAM</name></expr>:</case> <expr_stmt><expr><call><name>freeStreamObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <default>default:</default> <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown object type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"decrRefCount against refcount &lt;= 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>!=</operator> <name>OBJ_SHARED_REFCOUNT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This variant of decrRefCount() gets its argument as void, and is useful
 * as free method in data structures that expect a 'void free_object(void*)'
 * prototype for the free method. */</comment>
<function><type><name>void</name></type> <name>decrRefCountVoid</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function set the ref count to zero without freeing the object.
 * It is useful in order to pass a new object to functions incrementing
 * the ref count of the received object. Example:
 *
 *    functionThatWillIncrementRefCount(resetRefCount(CreateObject(...)));
 *
 * Otherwise you need to resort to the less elegant pattern:
 *
 *    *obj = createObject(...);
 *    functionThatWillIncrementRefCount(obj);
 *    decrRefCount(obj);
 */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>resetRefCount</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>checkType</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>type</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>isSdsRepresentableAsLongLong</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>llval</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><call><name>string2ll</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>llval</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>C_OK</name></expr> </then><else>: <expr><name>C_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>isObjectRepresentableAsLongLong</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>llval</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>llval</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>llval</name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>isSdsRepresentableAsLongLong</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>llval</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Optimize the SDS string inside the string object to require little space,
 * in case there is more than 10% of free space at the end of the SDS
 * string. This happens because SDS strings tend to overallocate to avoid
 * wasting too much time in allocations when appending to the string. */</comment>
<function><type><name>void</name></type> <name>trimStringObjectIfNeeded</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_RAW</name> <operator>&amp;&amp;</operator>
        <call><name>sdsavail</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">10</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsRemoveFreeSpace</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Try to encode a string object in order to save space */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>tryObjectEncoding</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure this is a string object, the only type we encode
     * in this function. Other types use encoded memory efficient
     * representations but are handled by the commands implementing
     * the type. */</comment>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We try some specialized encoding only for objects that are
     * RAW or EMBSTR encoded, in other words objects that are still
     * in represented by an actually array of chars. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>o</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* It's not safe to encode shared objects: shared objects can be shared
     * everywhere in the "object space" of Redis and may end in places where
     * they are not handled. We handle them only as values in the keyspace. */</comment>
     <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>o</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Check if we can represent this string as a long integer.
     * Note that we are sure that a string larger than 20 chars is not
     * representable as a 32 nor 64 bit integer. */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">20</literal> <operator>&amp;&amp;</operator> <call><name>string2l</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* This object is encodable as a long. Try to use a shared object.
         * Note that we avoid using shared integers when maxmemory is used
         * because every object needs to have a private LRU field for the LRU
         * algorithm to work well. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>!</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_NO_SHARED_INTEGERS</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
            <name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>value</name> <operator>&lt;</operator> <name>OBJ_SHARED_INTEGERS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>shared</name><operator>.</operator><name>integers</name><index>[<expr><name>value</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>shared</name><operator>.</operator><name>integers</name><index>[<expr><name>value</name></expr>]</index></name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_INT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>value</name></expr>;</expr_stmt>
                <return>return <expr><name>o</name></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_EMBSTR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>createStringObjectFromLongLongForValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the string is small and is still RAW encoded,
     * try the EMBSTR encoding which is more efficient.
     * In this representation the object and the SDS string are allocated
     * in the same chunk of memory to save space and cache misses. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>OBJ_ENCODING_EMBSTR_SIZE_LIMIT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>emb</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_EMBSTR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>o</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>emb</name> <operator>=</operator> <call><name>createEmbeddedStringObject</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>emb</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can't encode the object...
     *
     * Do the last try, and at least optimize the SDS string inside
     * the string object to require little space, in case there
     * is more than 10% of free space at the end of the SDS string.
     *
     * We do that only for relatively large strings as this branch
     * is only entered if the length of the string is greater than
     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</comment>
    <expr_stmt><expr><call><name>trimStringObjectIfNeeded</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return the original object. */</comment>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get a decoded version of an encoded object (returned as a new object).
 * If the object is already raw-encoded just increment the ref count. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>getDecodedObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dec</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>o</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name> <operator>&amp;&amp;</operator> <name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">32</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dec</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>dec</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown encoding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Compare two string objects via strcmp() or strcoll() depending on flags.
 * Note that the objects may be integer-encoded. In such a case we
 * use ll2string() to get a string representation of the numbers on the stack
 * and compare the strings, it's much faster than calling getDecodedObject().
 *
 * Important note: when REDIS_COMPARE_BINARY is used a binary-safe comparison
 * is used. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_COMPARE_BINARY</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_COMPARE_COLL</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>

<function><type><name>int</name></type> <name>compareStringObjectsWithFlags</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>a</name></expr></argument>,<argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>bufa</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>bufb</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>astr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>alen</name></decl>, <decl><type ref="prev"/><name>blen</name></decl>, <decl><type ref="prev"/><name>minlen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>astr</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>alen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>astr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>alen</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>bufa</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufa</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>astr</name> <operator>=</operator> <name>bufa</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>bstr</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>blen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>blen</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>bufb</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufb</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bstr</name> <operator>=</operator> <name>bufb</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDIS_COMPARE_COLL</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>strcoll</name><argument_list>(<argument><expr><name>astr</name></expr></argument>,<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>minlen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>alen</name> <operator>&lt;</operator> <name>blen</name><operator>)</operator></expr> ?</condition><then> <expr><name>alen</name></expr> </then><else>: <expr><name>blen</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>astr</name></expr></argument>,<argument><expr><name>bstr</name></expr></argument>,<argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>alen</name><operator>-</operator><name>blen</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>                                  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
        <return>return <expr><name>cmp</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Wrapper for compareStringObjectsWithFlags() using binary comparison. */</comment>
<function><type><name>int</name></type> <name>compareStringObjects</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>compareStringObjectsWithFlags</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>REDIS_COMPARE_BINARY</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for compareStringObjectsWithFlags() using collation. */</comment>
<function><type><name>int</name></type> <name>collateStringObjects</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>compareStringObjectsWithFlags</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>REDIS_COMPARE_COLL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Equal string objects return 1 if the two objects are the same from the
 * point of view of a string comparison, otherwise 0 is returned. Note that
 * this function is faster then checking for (compareStringObject(a,b) == 0)
 * because it can perform some more optimization. */</comment>
<function><type><name>int</name></type> <name>equalStringObjects</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name> <operator>&amp;&amp;</operator>
        <name><name>b</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition><block>{<block_content>
        <comment type="block">/* If both strings are integer encoded just check if the stored
         * long is the same. */</comment>
        <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>compareStringObjects</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>stringObjectLen</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>sdigits10</name><argument_list>(<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getDoubleFromObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>eptr</name><operator>-</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator> <operator>!=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>value</name> <operator>==</operator> <name>HUGE_VAL</name> <operator>||</operator> <name>value</name> <operator>==</operator> <operator>-</operator><name>HUGE_VAL</name> <operator>||</operator> <name>value</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
                <call><name>isnan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown string encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getDoubleFromObjectOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"value is not a valid float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getLongDoubleFromObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGDOUBLE</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGDOUBLE</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><call><name>IF_WIN32</name><argument_list>(<argument><expr><name>wstrtod</name></expr></argument>,<argument><expr><name>strtold</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// TODO: verify for 32-bit</comment>
            <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>eptr</name><operator>-</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator> <operator>!=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name>value</name> <operator>==</operator> <name>HUGE_VAL</name> <operator>||</operator> <name>value</name> <operator>==</operator> <operator>-</operator><name>HUGE_VAL</name> <operator>||</operator> <name>value</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
                <call><name>isnan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown string encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getLongDoubleFromObjectOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGDOUBLE</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGDOUBLE</name></type> <name>value</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getLongDoubleFromObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"value is not a valid float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getLongLongFromObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>value</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown string encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>target</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getLongLongFromObjectOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>value</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"value is not an integer or out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getLongFromObjectOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>value</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>value</name> <argument_list type="generic">&lt; <argument><expr><name>PORT_LONG_MIN</name> <operator>||</operator> <name>value</name></expr></argument> &gt;</argument_list></name> <name>PORT_LONG_MAX</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"value is out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>value</name></expr>;</expr_stmt>                                                 <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_LONG) */</comment>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>strEncoding</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch<condition>(<expr><name>encoding</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_ENCODING_RAW</name></expr>:</case> <return>return <expr><literal type="string">"raw"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_INT</name></expr>:</case> <return>return <expr><literal type="string">"int"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_HT</name></expr>:</case> <return>return <expr><literal type="string">"hashtable"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_QUICKLIST</name></expr>:</case> <return>return <expr><literal type="string">"quicklist"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_ZIPLIST</name></expr>:</case> <return>return <expr><literal type="string">"ziplist"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_INTSET</name></expr>:</case> <return>return <expr><literal type="string">"intset"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_SKIPLIST</name></expr>:</case> <return>return <expr><literal type="string">"skiplist"</literal></expr>;</return>
    <case>case <expr><name>OBJ_ENCODING_EMBSTR</name></expr>:</case> <return>return <expr><literal type="string">"embstr"</literal></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* =========================== Memory introspection ========================= */</comment>


<comment type="block">/* This is an helper function with the goal of estimating the memory
 * size of a radix tree that is used to store Stream IDs.
 *
 * Note: to guess the size of the radix tree is not trivial, so we
 * approximate it considering 16 bytes of data overhead for each
 * key (the ID), and then adding the number of bare nodes, plus some
 * overhead due by the data and child pointers. This secret recipe
 * was obtained by checking the average radix tree created by real
 * workloads, and then adjusting the constants to get numbers that
 * more or less match the real memory usage.
 *
 * Actually the number of nodes and keys may be different depending
 * on the insertion speed and thus the ability of the radix tree
 * to compress prefixes. */</comment>
<function><type><name>size_t</name></type> <name>streamRadixTreeMemoryUsage</name><parameter_list>(<parameter><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>rax</name><operator>-&gt;</operator><name>numele</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>raxNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/* Add a fixed overhead due to the aux data pointer, children, ... */</comment>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PORT_LONG</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">30</literal></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the size in bytes consumed by the key's value in RAM.
 * Note that the returned value is just an approximation, especially in the
 * case of aggregated data types where only "sample_size" elements
 * are checked and averaged to estimate the total size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ_COMPUTE_SIZE_DEF_SAMPLES</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> <comment type="block">/* Default sample size. */</comment>
<function><type><name>size_t</name></type> <name>objectComputeSize</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sample_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>, <decl><type ref="prev"/><name>ele2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dictEntry</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>elesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>samples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_EMBSTR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown string encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_QUICKLIST</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <do>do <block>{<block_content>
                <expr_stmt><expr><name>elesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>quicklistNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>zl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>samples</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>samples</name> <operator>&lt;</operator> <name>sample_size</name></expr>)</condition>;</do>
            <expr_stmt><expr><name>asize</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>elesize</name><operator>/</operator><name>samples</name><operator>*</operator><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown list encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>dictSlots</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>samples</name> <operator>&lt;</operator> <name>sample_size</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>elesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>dictEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>samples</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>samples</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>asize</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>elesize</name><operator>/</operator><name>samples</name><operator>*</operator><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>intset</name> <modifier>*</modifier></type><name>is</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>is</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name><name>is</name><operator>-&gt;</operator><name>encoding</name></name><operator>*</operator><operator>(</operator><name>size_t</name><operator>)</operator><name><name>is</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>  <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (size_t) */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>zset</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name>dict</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><operator>(</operator><operator>(</operator><name>zset</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name>zsl</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name> <init>= <expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zset</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zskiplist</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></sizeof><operator>+</operator>
                    <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>dictSlots</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>)</operator><operator>+</operator>
                    <call><name>zmalloc_size</name><argument_list>(<argument><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><name>znode</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>samples</name> <operator>&lt;</operator> <name>sample_size</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>elesize</name> <operator>+=</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name><name>znode</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>elesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>dictEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>zmalloc_size</name><argument_list>(<argument><expr><name>znode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>samples</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>znode</name> <operator>=</operator> <name><name>znode</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name>samples</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>asize</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>elesize</name><operator>/</operator><name>samples</name><operator>*</operator><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>dictSlots</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>samples</name> <operator>&lt;</operator> <name>sample_size</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ele2</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>elesize</name> <operator>+=</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name>ele2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>elesize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>dictEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>samples</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>samples</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>asize</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>elesize</name><operator>/</operator><name>samples</name><operator>*</operator><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown hash encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STREAM</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>o</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>asize</name> <operator>+=</operator> <call><name>streamRadixTreeMemoryUsage</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we have to add the listpacks. The last listpack is often non
         * complete, so we estimate the size of the first N listpacks, and
         * use the average to compute the size of the first N-1 listpacks, and
         * finally add the real size of the last node. */</comment>
        <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>lpsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>samples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><name>samples</name> <operator>&lt;</operator> <name>sample_size</name> <operator>&amp;&amp;</operator> <call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>lpsize</name> <operator>+=</operator> <call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>samples</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>rax</name><operator>-&gt;</operator><name>numele</name></name> <operator>&lt;=</operator> <name>samples</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>+=</operator> <name>lpsize</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>samples</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lpsize</name> <operator>/=</operator> <name>samples</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Compute the average. */</comment>
            <expr_stmt><expr><name>asize</name> <operator>+=</operator> <name>lpsize</name> <operator>*</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>rax</name><operator>-&gt;</operator><name>numele</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <comment type="block">/* No need to check if seek succeeded, we enter this branch only
             * if there are a few elements in the radix tree. */</comment>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>asize</name> <operator>+=</operator> <call><name>lpBytes</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Consumer groups also have a non trivial memory overhead if there
         * are many consumers and many groups, let's count at least the
         * overhead of the pending entries in the groups and consumers
         * PELs. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>asize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>asize</name> <operator>+=</operator> <call><name>streamRadixTreeMemoryUsage</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>asize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>streamNACK</name></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* For each consumer we also need to add the basic data
                 * structures and the PEL memory usage. */</comment>
                <decl_stmt><decl><type><name>raxIterator</name></type> <name>cri</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cri</name></expr></argument>,<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>cri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>asize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>consumer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><name>asize</name> <operator>+=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>asize</name> <operator>+=</operator> <call><name>streamRadixTreeMemoryUsage</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Don't count NACKs again, they are shared with the
                     * consumer group PEL. */</comment>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_MODULE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><name><name>mv</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mt</name><operator>-&gt;</operator><name>mem_usage</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name><name>mt</name><operator>-&gt;</operator><name>mem_usage</name></name><argument_list>(<argument><expr><name><name>mv</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>asize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown object type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>asize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release data obtained with getMemoryOverheadData(). */</comment>
<function><type><name>void</name></type> <name>freeMemoryOverheadData</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisMemOverhead</name></name> <modifier>*</modifier></type><name>mh</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>mh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return a struct redisMemOverhead filled with memory overhead
 * information used for the MEMORY OVERHEAD and INFO command. The returned
 * structure pointer should be freed calling freeMemoryOverheadData(). */</comment>
<function><type><name><name>struct</name> <name>redisMemOverhead</name></name> <modifier>*</modifier></type><name>getMemoryOverheadData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mem_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>zmalloc_used</name> <init>= <expr><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisMemOverhead</name></name> <modifier>*</modifier></type><name>mh</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mh</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>total_allocated</name></name> <operator>=</operator> <name>zmalloc_used</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>startup_allocated</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>initial_memory_usage</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>peak_allocated</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>stat_peak_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>total_frag</name></name> <operator>=</operator>
        <operator>(</operator><name>float</name><operator>)</operator><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>process_rss</name></name> <operator>/</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>zmalloc_used</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>total_frag_bytes</name></name> <operator>=</operator>
        <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>process_rss</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>zmalloc_used</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_frag</name></name> <operator>=</operator>
        <operator>(</operator><name>float</name><operator>)</operator><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_active</name></name> <operator>/</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_allocated</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_frag_bytes</name></name> <operator>=</operator>
        <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_active</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_allocated</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_rss</name></name> <operator>=</operator>
        <operator>(</operator><name>float</name><operator>)</operator><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_resident</name></name> <operator>/</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_active</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_rss_bytes</name></name> <operator>=</operator>
        <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_resident</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_active</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>rss_extra</name></name> <operator>=</operator>
        <operator>(</operator><name>float</name><operator>)</operator><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>process_rss</name></name> <operator>/</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_resident</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>rss_extra_bytes</name></name> <operator>=</operator>
        <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>process_rss</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_resident</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mem_total</name> <operator>+=</operator> <name><name>server</name><operator>.</operator><name>initial_memory_usage</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>zmalloc_size</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>repl_backlog</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_total</name> <operator>+=</operator> <name>mem</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>getClientOutputBufferMemoryUsage</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mem</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>clients_slaves</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_total</name><operator>+=</operator><name>mem</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MONITOR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>getClientOutputBufferMemoryUsage</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mem</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>clients_normal</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_total</name><operator>+=</operator><name>mem</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>!=</operator> <name>AOF_OFF</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>sdsalloc</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>aofRewriteBufferSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>aof_buffer</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_total</name><operator>+=</operator><name>mem</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mem</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>lua_scripts_mem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>lua_scripts</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <call><name>dictSlots</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>lua_scripts</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <call><name>dictSlots</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>mem</name> <operator>+=</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>listNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> 
            <call><name>sdsZmallocSize</name><argument_list>(<argument><expr><call><name>listNodeValue</name><argument_list>(<argument><expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>lua_caches</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem_total</name><operator>+=</operator><name>mem</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>j</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>keyscount</name> <init>= <expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyscount</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>total_keys</name></name> <operator>+=</operator> <name>keyscount</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name></expr>]</index></name><operator>.</operator><name>dbid</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
              <call><name>dictSlots</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator>
              <call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>robj</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name></expr>]</index></name><operator>.</operator><name>overhead_ht_main</name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mem_total</name><operator>+=</operator><name>mem</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
              <call><name>dictSlots</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name></expr>]</index></name><operator>.</operator><name>overhead_ht_expires</name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mem_total</name><operator>+=</operator><name>mem</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>overhead_total</name></name> <operator>=</operator> <name>mem_total</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>dataset</name></name> <operator>=</operator> <name>zmalloc_used</name> <operator>-</operator> <name>mem_total</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>peak_perc</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>zmalloc_used</name><operator>*</operator><literal type="number">100</literal><operator>/</operator><name><name>mh</name><operator>-&gt;</operator><name>peak_allocated</name></name></expr>;</expr_stmt>

    <comment type="block">/* Metrics computed after subtracting the startup memory from
     * the total memory. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>net_usage</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>zmalloc_used</name> <operator>&gt;</operator> <name><name>mh</name><operator>-&gt;</operator><name>startup_allocated</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>net_usage</name> <operator>=</operator> <name>zmalloc_used</name> <operator>-</operator> <name><name>mh</name><operator>-&gt;</operator><name>startup_allocated</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>dataset_perc</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>mh</name><operator>-&gt;</operator><name>dataset</name></name><operator>*</operator><literal type="number">100</literal><operator>/</operator><name>net_usage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>bytes_per_key</name></name> <operator>=</operator> <ternary><condition><expr><name><name>mh</name><operator>-&gt;</operator><name>total_keys</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>net_usage</name> <operator>/</operator> <name><name>mh</name><operator>-&gt;</operator><name>total_keys</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

    <return>return <expr><name>mh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper for "MEMORY allocator-stats", used as a callback for the jemalloc
 * stats output. */</comment>
<function><type><name>void</name></type> <name>inputCatSds</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* result is actually a (sds *), so re-cast it here */</comment>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>sds</name> <operator>*</operator><operator>)</operator><name>result</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>info</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><operator>*</operator><name>info</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This implements MEMORY DOCTOR. An human readable analysis of the Redis
 * memory condition. */</comment>
<function><type><name>sds</name></type> <name>getMemoryDoctorReport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Instance is empty or almost empty. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>big_peak</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Memory peak is much larger than used mem. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>high_frag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* High fragmentation. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>high_alloc_frag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* High allocator fragmentation. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>high_proc_rss</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* High process rss overhead. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>high_alloc_rss</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* High rss overhead. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>big_slave_buf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Slave buffers are too big. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>big_client_buf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Client buffers are too big. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>many_scripts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Script cache has too many scripts. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>num_reports</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisMemOverhead</name></name> <modifier>*</modifier></type><name>mh</name> <init>= <expr><call><name>getMemoryOverheadData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>total_allocated</name></name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">5</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>empty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Peak is &gt; 150% of current used memory? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name><name>mh</name><operator>-&gt;</operator><name>peak_allocated</name></name> <operator>/</operator> <name><name>mh</name><operator>-&gt;</operator><name>total_allocated</name></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">1.5</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>big_peak</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Fragmentation is higher than 1.4 and 10MB ?*/</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>total_frag</name></name> <operator>&gt;</operator> <literal type="number">1.4</literal> <operator>&amp;&amp;</operator> <name><name>mh</name><operator>-&gt;</operator><name>total_frag_bytes</name></name> <operator>&gt;</operator> <literal type="number">10</literal><operator>&lt;&lt;</operator><literal type="number">20</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>high_frag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* External fragmentation is higher than 1.1 and 10MB? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_frag</name></name> <operator>&gt;</operator> <literal type="number">1.1</literal> <operator>&amp;&amp;</operator> <name><name>mh</name><operator>-&gt;</operator><name>allocator_frag_bytes</name></name> <operator>&gt;</operator> <literal type="number">10</literal><operator>&lt;&lt;</operator><literal type="number">20</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>high_alloc_frag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Allocator fss is higher than 1.1 and 10MB ? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_rss</name></name> <operator>&gt;</operator> <literal type="number">1.1</literal> <operator>&amp;&amp;</operator> <name><name>mh</name><operator>-&gt;</operator><name>allocator_rss_bytes</name></name> <operator>&gt;</operator> <literal type="number">10</literal><operator>&lt;&lt;</operator><literal type="number">20</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>high_alloc_rss</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Non-Allocator fss is higher than 1.1 and 10MB ? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>rss_extra</name></name> <operator>&gt;</operator> <literal type="number">1.1</literal> <operator>&amp;&amp;</operator> <name><name>mh</name><operator>-&gt;</operator><name>rss_extra_bytes</name></name> <operator>&gt;</operator> <literal type="number">10</literal><operator>&lt;&lt;</operator><literal type="number">20</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>high_proc_rss</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Clients using more than 200k each average? */</comment>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>numslaves</name> <init>= <expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PORT_LONG</name></type> <name>numclients</name> <init>= <expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>)</argument_list></call><operator>-</operator><name>numslaves</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>clients_normal</name></name> <operator>/</operator> <name>numclients</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">200</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>big_client_buf</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Slaves using more than 10 MB each? */</comment>
        <if_stmt><if>if <condition>(<expr><name>numslaves</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mh</name><operator>-&gt;</operator><name>clients_slaves</name></name> <operator>/</operator> <name>numslaves</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">10</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>big_slave_buf</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Too many scripts are cached? */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>lua_scripts</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>many_scripts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_reports</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>sds</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_reports</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(
        <argument><expr><literal type="string">"Hi Sam, I can't find any memory issue in your instance. "</literal>
        <literal type="string">"I can only account for what occurs on this base.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>empty</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(
        <argument><expr><literal type="string">"Hi Sam, this instance is empty or is using very little memory, "</literal>
        <literal type="string">"my issues detector can't be used in these conditions. "</literal>
        <literal type="string">"Please, leave for your mission on Earth and fill it with some data. "</literal>
        <literal type="string">"The new Sam and I will be back to our programming as soon as I "</literal>
        <literal type="string">"finished rebooting.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"Sam, I detected a few issues in this Redis instance memory implants:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>big_peak</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * Peak memory: In the past this instance used more than 150% the memory that is currently using. The allocator is normally not able to release memory after a peak, so you can expect to see a big fragmentation ratio, however this is actually harmless and is only due to the memory peak, and if the Redis instance Resident Set Size (RSS) is currently bigger than expected, the memory will be used as soon as you fill the Redis instance with more data. If the memory peak was only occasional and you want to try to reclaim memory, please try the MEMORY PURGE command, otherwise the only other option is to shutdown and restart the instance.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>high_frag</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * High total RSS: This instance has a memory fragmentation and RSS overhead greater than 1.4 (this means that the Resident Set Size of the Redis process is much larger than the sum of the logical allocations Redis performed). This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. If the problem is a large peak memory, then there is no issue. Otherwise, make sure you are using the Jemalloc allocator and not the default libc malloc. Note: The currently used allocator is \"%s\".\n\n"</literal></expr></argument>, <argument><expr><name>ZMALLOC_LIB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>high_alloc_frag</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * High allocator fragmentation: This instance has an allocator external fragmentation greater than 1.1. This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. You can try enabling 'activedefrag' config option.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>high_alloc_rss</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * High allocator RSS overhead: This instance has an RSS memory overhead is greater than 1.1 (this means that the Resident Set Size of the allocator is much larger than the sum what the allocator actually holds). This problem is usually due to a large peak memory (check if there is a peak memory entry above in the report), you can try the MEMORY PURGE command to reclaim it.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>high_proc_rss</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * High process RSS overhead: This instance has non-allocator RSS memory overhead is greater than 1.1 (this means that the Resident Set Size of the Redis process is much larger than the RSS the allocator holds). This problem may be due to Lua scripts or Modules.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>big_slave_buf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * Big replica buffers: The replica output buffers in this instance are greater than 10MB for each replica (on average). This likely means that there is some replica instance that is struggling receiving data, either because it is too slow or because of networking issues. As a result, data piles on the master output buffers. Please try to identify what replica is not receiving data correctly and why. You can use the INFO output in order to check the replicas delays and the CLIENT LIST command to check the output buffers of each replica.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>big_client_buf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * Big client buffers: The clients output buffers in this instance are greater than 200K per client (on average). This may result from different causes, like Pub/Sub clients subscribed to channels bot not receiving data fast enough, so that data piles on the Redis instance output buffer, or clients sending commands with large replies or very large sequences of commands in the same pipeline. Please use the CLIENT LIST command in order to investigate the issue if it causes problems in your instance, or to understand better why certain clients are using a big amount of memory.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>many_scripts</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">" * Many scripts: There seem to be many cached scripts in this instance (more than 1000). This may be because scripts are generated and `EVAL`ed, instead of being parameterized (with KEYS and ARGV), `SCRIPT LOAD`ed and `EVALSHA`ed. Unless `SCRIPT FLUSH` is called periodically, the scripts' caches may end up consuming most of your memory.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"I'm here to keep you safe, Sam. I want to help you.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>freeMemoryOverheadData</name><argument_list>(<argument><expr><name>mh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set the object LRU/LFU depending on server.maxmemory_policy.
 * The lfu_freq arg is only relevant if policy is MAXMEMORY_FLAG_LFU.
 * The lru_idle and lru_clock args are only relevant if policy
 * is MAXMEMORY_FLAG_LRU.
 * Either or both of them may be &lt;0, in that case, nothing is set. */</comment>
<function><type><name>void</name></type> <name>objectSetLRUOrLFU</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>lfu_freq</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>lru_idle</name></decl></parameter>,
                       <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>lru_clock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>lfu_freq</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>lfu_freq</name> <operator>&lt;=</operator> <literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <operator>(</operator><call><name>LFUGetTimeInMinutes</name><argument_list>()</argument_list></call><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>lfu_freq</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lru_idle</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Provided LRU idle time is in seconds. Scale
         * according to the LRU clock resolution this Redis
         * instance was compiled with (normally 1000 ms, so the
         * below statement will expand to lru_idle*1000/1000. */</comment>
        <expr_stmt><expr><name>lru_idle</name> <operator>=</operator> <name>lru_idle</name><operator>*</operator><literal type="number">1000</literal><operator>/</operator><name>LRU_CLOCK_RESOLUTION</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>lru_abs</name> <init>= <expr><name>lru_clock</name> <operator>-</operator> <name>lru_idle</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Absolute access time. */</comment>
        <comment type="block">/* If the LRU field underflows (since LRU it is a wrapping
         * clock), the best we can do is to provide a large enough LRU
         * that is half-way in the circlular LRU clock we use: this way
         * the computed idle time for this object will stay high for quite
         * some time. */</comment>
        <if_stmt><if>if <condition>(<expr><name>lru_abs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lru_abs</name> <operator>=</operator> <operator>(</operator><name>lru_clock</name><operator>+</operator><operator>(</operator><name>LRU_CLOCK_MAX</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <name>LRU_CLOCK_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <name>lru_abs</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ======================= The OBJECT and MEMORY commands =================== */</comment>

<comment type="block">/* This is a helper function for the OBJECT command. We need to lookup keys
 * without any modification of LRU or other parameters. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>objectCommandLookup</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>robj</name><operator>*</operator><operator>)</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>objectCommandLookupOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>objectCommandLookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Object command allows to inspect the internals of an Redis Object.
 * Usage: OBJECT &lt;refcount|encoding|idletime|freq&gt; &lt;key&gt; */</comment>
<function><type><name>void</name></type> <name>objectCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"ENCODING &lt;key&gt; -- Return the kind of internal representation used in order to store the value associated with a key."</literal></expr>,
<expr><literal type="string">"FREQ &lt;key&gt; -- Return the access frequency index of the key. The returned integer is proportional to the logarithm of the recent access frequency of the key."</literal></expr>,
<expr><literal type="string">"IDLETIME &lt;key&gt; -- Return the idle time of the key, that is the approximated number of seconds elapsed since the last access to the key."</literal></expr>,
<expr><literal type="string">"REFCOUNT &lt;key&gt; -- Return the number of references of the value associated with the specified key."</literal></expr>,
<expr><name>NULL</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"refcount"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>objectCommandLookupOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
                <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>objectCommandLookupOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
                <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>strEncoding</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"idletime"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>objectCommandLookupOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
                <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"An LFU maxmemory policy is selected, idle time not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>estimateObjectIdleTime</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"freq"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>objectCommandLookupOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
                <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* LFUDecrAndReturn should be called
         * in case of the key has not been accessed for a long time,
         * because we update the access time only
         * when the key is read or overwritten. */</comment>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>LFUDecrAndReturn</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* The memory command will eventually be a complete interface for the
 * memory introspection capabilities of Redis.
 *
 * Usage: MEMORY usage &lt;key&gt; */</comment>
<function><type><name>void</name></type> <name>memoryCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"DOCTOR - Return memory problems reports."</literal></expr>,
<expr><literal type="string">"MALLOC-STATS -- Return internal statistics report from the memory allocator."</literal></expr>,
<expr><literal type="string">"PURGE -- Attempt to purge dirty pages for reclamation by the allocator."</literal></expr>,
<expr><literal type="string">"STATS -- Return information about the memory usage of the server."</literal></expr>,
<expr><literal type="string">"USAGE &lt;key&gt; [SAMPLES &lt;count&gt;] -- Return memory in bytes used by &lt;key&gt; and its value. Nested values are sampled up to &lt;count&gt; times (default: 5)."</literal></expr>,
<expr><name>NULL</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"usage"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>samples</name> <init>= <expr><name>OBJ_COMPUTE_SIZE_DEF_SAMPLES</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"samples"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <name>j</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>samples</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                     <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>samples</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>samples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>samples</name> <operator>=</operator> <name>LLONG_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt><empty_stmt>;</empty_stmt>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* skip option argument. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>usage</name> <init>= <expr><call><name>objectComputeSize</name><argument_list>(<argument><expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>samples</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>sdsAllocSize</name><argument_list>(<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>usage</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"stats"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>redisMemOverhead</name></name> <modifier>*</modifier></type><name>mh</name> <init>= <expr><call><name>getMemoryOverheadData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><literal type="number">25</literal><operator>+</operator><name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"peak.allocated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>peak_allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"total.allocated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>total_allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"startup.allocated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>startup_allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"replication.backlog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>repl_backlog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"clients.slaves"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>clients_slaves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"clients.normal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>clients_normal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"aof.buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>aof_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"lua.caches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>lua_caches</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>mh</name><operator>-&gt;</operator><name>num_dbs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>dbname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"db.%zd"</literal></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"overhead.hashtable.main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>overhead_ht_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"overhead.hashtable.expires"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>overhead_ht_expires</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"overhead.total"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>overhead_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"keys.count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>total_keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"keys.bytes-per-key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>bytes_per_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"dataset.bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>dataset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"dataset.percentage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>dataset_perc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"peak.percentage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>peak_perc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator.allocated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator.active"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator.resident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cron_malloc_stats</name><operator>.</operator><name>allocator_resident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator-fragmentation.ratio"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_frag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator-fragmentation.bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_frag_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator-rss.ratio"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_rss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"allocator-rss.bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>allocator_rss_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"rss-overhead.ratio"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>rss_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"rss-overhead.bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>rss_extra_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"fragmentation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* this is the total RSS overhead, including fragmentation */</comment>
        <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>total_frag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* it is kept here for backwards compatibility */</comment>

        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"fragmentation.bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>mh</name><operator>-&gt;</operator><name>total_frag_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>freeMemoryOverheadData</name><argument_list>(<argument><expr><name>mh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"malloc-stats"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_JEMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <decl_stmt><decl><type><name>sds</name></type> <name>info</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>je_malloc_stats_print</name><argument_list>(<argument><expr><name>inputCatSds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Stats not supported for the current allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"doctor"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>report</name> <init>= <expr><call><name>getMemoryDoctorReport</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"purge"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_JEMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>narenas</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"arenas.narenas"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>narenas</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"arena.%d.purge"</literal></expr></argument>, <argument><expr><name>narenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>je_mallctl</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"Error purging dirty pages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Nothing to do for other allocators. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"Unknown subcommand or wrong number of arguments for '%s'. Try MEMORY HELP"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
