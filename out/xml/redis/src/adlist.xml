<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/adlist.c"><comment type="block">/* adlist.c - A generic doubly linked list implementation
 *
 * Copyright (c) 2006-2010, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32_types.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>

<comment type="block">/* Create a new list. The created list can be freed with
 * AlFreeList(), but private value of every node need to be freed
 * by the user before to call AlFreeList().
 *
 * On error, NULL is returned. Otherwise the pointer to the new list. */</comment>
<function><type><name>list</name> <modifier>*</modifier></type><name>listCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>list</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>dup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>match</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove all the elements from the list without destroying the list itself. */</comment>
<function><type><name>void</name></type> <name>listEmpty</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>free</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>list</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the whole list.
 *
 * This function can't fail. */</comment>
<function><type><name>void</name></type> <name>listRelease</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>listEmpty</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a new node to the list, to head, containing the specified 'value'
 * pointer as value.
 *
 * On error, NULL is returned and no operation is performed (i.e. the
 * list remains unaltered).
 * On success the 'list' pointer you pass to the function is returned. */</comment>
<function><type><name>list</name> <modifier>*</modifier></type><name>listAddNodeHead</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new node to the list, to tail, containing the specified 'value'
 * pointer as value.
 *
 * On error, NULL is returned and no operation is performed (i.e. the
 * list remains unaltered).
 * On success the 'list' pointer you pass to the function is returned. */</comment>
<function><type><name>list</name> <modifier>*</modifier></type><name>listAddNodeTail</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>list</name> <modifier>*</modifier></type><name>listInsertNode</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>listNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>after</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>old_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>old_node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>old_node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified node from the specified list.
 * It's up to the caller to free the private value of the node.
 *
 * This function can't fail. */</comment>
<function><type><name>void</name></type> <name>listDelNode</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>free</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>list</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns a list iterator 'iter'. After the initialization every
 * call to listNext() will return the next element of the list.
 *
 * This function can't fail. */</comment>
<function><type><name>listIter</name> <modifier>*</modifier></type><name>listGetIterator</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>iter</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
    <return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release the iterator memory */</comment>
<function><type><name>void</name></type> <name>listReleaseIterator</name><parameter_list>(<parameter><decl><type><name>listIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create an iterator in the list private iterator structure */</comment>
<function><type><name>void</name></type> <name>listRewind</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>listIter</name> <modifier>*</modifier></type><name>li</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>AL_START_HEAD</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>listRewindTail</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>listIter</name> <modifier>*</modifier></type><name>li</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>AL_START_TAIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the next element of an iterator.
 * It's valid to remove the currently returned element using
 * listDelNode(), but not to remove other elements.
 *
 * The function returns a pointer to the next element of the list,
 * or NULL if there are no more elements, so the classical usage patter
 * is:
 *
 * iter = listGetIterator(list,&lt;direction&gt;);
 * while ((node = listNext(iter)) != NULL) {
 *     doSomethingWith(listNodeValue(node));
 * }
 *
 * */</comment>
<function><type><name>listNode</name> <modifier>*</modifier></type><name>listNext</name><parameter_list>(<parameter><decl><type><name>listIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>current</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>current</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>current</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Duplicate the whole list. On out of memory NULL is returned.
 * On success a copy of the original list is returned.
 *
 * The 'Dup' method set with listSetDupMethod() function is used
 * to copy the node value. Otherwise the same pointer value of
 * the original node is used as value of the copied node.
 *
 * The original list both on success or error is never modified. */</comment>
<function><type><name>list</name> <modifier>*</modifier></type><name>listDup</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>copy</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>dup</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>dup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>match</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>match</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>copy</name><operator>-&gt;</operator><name>dup</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name><name>copy</name><operator>-&gt;</operator><name>dup</name></name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search the list for a node matching a given key.
 * The match is performed using the 'match' method
 * set with listSetMatchMethod(). If no 'match' method
 * is set, the 'value' pointer of every node is directly
 * compared with the 'key' pointer.
 *
 * On success the first matching node pointer is returned
 * (search starts from head). If no matching node exists
 * NULL is returned. */</comment>
<function><type><name>listNode</name> <modifier>*</modifier></type><name>listSearchKey</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>match</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>list</name><operator>-&gt;</operator><name>match</name></name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>node</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>node</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the element at the specified zero-based index
 * where 0 is the head, 1 is the element next to head
 * and so on. Negative integers are used in order to count
 * from the tail, -1 is the last element, -2 the penultimate
 * and so on. If the index is out of range NULL is returned. */</comment>
<function><type><name>listNode</name> <modifier>*</modifier></type><name>listIndex</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>index</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>index</name><operator>--</operator> <operator>&amp;&amp;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>index</name><operator>--</operator> <operator>&amp;&amp;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Rotate the list removing the tail node and inserting it to the head. */</comment>
<function><type><name>void</name></type> <name>listRotateTailToHead</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Detach current tail */</comment>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>tail</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* Move it as head */</comment>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Rotate the list removing the head node and inserting it to the tail. */</comment>
<function><type><name>void</name></type> <name>listRotateHeadToTail</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Detach current head */</comment>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* Move it as tail */</comment>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add all the elements of the list 'o' at the end of the
 * list 'l'. The list 'other' remains empty but otherwise valid. */</comment>
<function><type><name>void</name></type> <name>listJoin</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name><name>o</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* Setup other as an empty list. */</comment>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
