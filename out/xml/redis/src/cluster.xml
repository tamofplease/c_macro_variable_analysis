<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/cluster.c"><comment type="block">/* Redis Cluster implementation.
 *
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"endianconv.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;sys/socket.h&gt;</argument>)</argument_list></macro>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;arpa/inet.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;unistd.h&gt;</argument>)</argument_list></macro>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;sys/socket.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;sys/file.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>WSIOCP_QueueAccept</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>listenfd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Error.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A global reference to myself is handy to make code more clear.
 * Myself always points to server.cluster-&gt;myself, that is, the clusterNode
 * that represents this node. */</comment>
<decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>myself</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>createClusterNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterAddNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterAcceptHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterReadHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterSendPing</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterSendFail</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterSendFailoverAuthIfNeeded</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>request</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterUpdateState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterNodeGetSlotBit</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>sds</name></type> <name>clusterGenNodesDescription</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>filter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>clusterLookupNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterNodeAddSlave</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>slave</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterAddSlot</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterDelSlot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterDelNodeSlots</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterNodeSetSlotBit</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterSetMaster</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterHandleSlaveFailover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterHandleSlaveMigration</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_slaves</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>bitmapTestBit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterDoBeforeSleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterSendUpdate</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>resetManualFailover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterCloseAllSlots</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterSetNodeAsMaster</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clusterDelNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>delnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>sds</name></type> <name>representClusterNodeFlags</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>ci</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uint64_t</name></type> <name>clusterGetMaxEpoch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>clusterBumpConfigEpochWithoutConsensus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>moduleCallClusterReceivers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sender_id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>module_id</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* -----------------------------------------------------------------------------
 * Initialization
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Load the cluster config from 'filename'.
 *
 * If the file does not exist or is zero-length (this may happen because
 * when we lock the nodes.conf file, we create a zero-length one for the
 * sake of locking if it does not already exist), C_ERR is returned.
 * If the configuration was loaded from the file, C_OK is returned. */</comment>
<function><type><name>int</name></type> <name>clusterLoadConfig</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><literal type="string">"rb"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>IF_WIN32</name></name></type><argument_list>(<argument><expr><name>_stat64</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list> <name>sb</name></decl>;</decl_stmt>                                           <comment type="line">// TODO: verify for 32-bit</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxline</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Loading the cluster node config from %s: %s"</literal></expr></argument>,
                <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if the file is zero-length: if so return C_ERR to signal
     * we have to write the config. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse the file. Note that single lines of the cluster config file can
     * be really long as they include all the hash slots of the node.
     * This means in the worst possible case, half of the Redis slots will be
     * present in a single line, possibly in importing or migrating state, so
     * together with the node ID of the sender/receiver.
     *
     * To simplify we allocate 1024+CLUSTER_SLOTS*128 bytes per line. */</comment>
    <expr_stmt><expr><name>maxline</name> <operator>=</operator> <literal type="number">1024</literal><operator>+</operator><name>CLUSTER_SLOTS</name><operator>*</operator><literal type="number">128</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>maxline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>maxline</name></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>master</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

        <comment type="block">/* Skip blank lines, they can be created either by users manually
         * editing nodes.conf or by the config writing process if stopped
         * before the truncate() call. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Split the line into arguments for processing. */</comment>
        <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>sdssplitargs</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fmterr</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Handle the special "vars" line. Don't pretend it is the last
         * line even if it actually is when generated by Redis. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"vars"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>argc</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fmterr</name>;</goto></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"currentEpoch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator>
                            <call><name>strtoull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"lastVoteEpoch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>lastVoteEpoch</name></name> <operator>=</operator>
                            <call><name>strtoull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                        <argument><expr><literal type="string">"Skipping unknown cluster config variable '%s'"</literal></expr></argument>,
                        <argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Regular config lines have at least eight fields */</comment>
        <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fmterr</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Create this node if it does not exist */</comment>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>createClusterNode</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Address and port */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fmterr</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>port</name> <init>= <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>busp</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>port</name></expr></argument>,<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>busp</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>busp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>busp</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* In older versions of nodes.conf the "@busport" part is missing.
         * In this case we set it to the default offset of 10000 from the
         * base port. */</comment>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <ternary><condition><expr><name>busp</name></expr> ?</condition><then> <expr><call><name>atoi</name><argument_list>(<argument><expr><name>busp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name> <operator>+</operator> <name>CLUSTER_PORT_INCR</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* Parse flags */</comment>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"myself"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>myself</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_MYSELF</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"master"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_MASTER</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"slave"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_SLAVE</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"fail?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_PFAIL</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"fail"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_FAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>fail_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"handshake"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_HANDSHAKE</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"noaddr"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_NOADDR</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"nofailover"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_NOFAILOVER</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"noflags"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* nothing to do */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown flag in redis cluster config file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Get master if any. Set the master and populate master's
         * slave list. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>master</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>master</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>master</name> <operator>=</operator> <call><name>createClusterNode</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>master</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>=</operator> <name>master</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterNodeAddSlave</name><argument_list>(<argument><expr><name>master</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Set ping sent / pong received timestamps */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>pong_received</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Set configEpoch for this node. */</comment>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Populate hash slots served by this instance. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Here we handle migrating / importing slots */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name>direction</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>cn</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>direction</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* Either '&gt;' or '&lt;' */</comment>
                <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>slot</name> <operator>&gt;=</operator> <name>CLUSTER_SLOTS</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>fmterr</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>cn</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cn</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>cn</name> <operator>=</operator> <call><name>createClusterNode</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>cn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>cn</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>cn</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>stop</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>stop</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>start</name> <operator>&gt;=</operator> <name>CLUSTER_SLOTS</name> <operator>||</operator>
                <name>stop</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>stop</name> <operator>&gt;=</operator> <name>CLUSTER_SLOTS</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>fmterr</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <while>while<condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>stop</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterAddSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>start</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* Config sanity check */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fmterr</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Node configuration loaded, I'm %.40s"</literal></expr></argument>, <argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Something that should never happen: currentEpoch smaller than
     * the max epoch found in the nodes configuration. However we handle this
     * as some form of protection against manual editing of critical files. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clusterGetMaxEpoch</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator> <call><name>clusterGetMaxEpoch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>fmterr</name>:</label>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
        <argument><expr><literal type="string">"Unrecoverable error: corrupted cluster config file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Cluster node configuration is exactly the same as CLUSTER NODES output.
 *
 * This function writes the node config and returns 0, on error -1
 * is returned.
 *
 * Note: we need to write the file in an atomic way from the point of view
 * of the POSIX filesystem semantics, so that if the server is stopped
 * or crashes during the write, we'll end with either the old file or the
 * new one. Since we have the full payload to write available we can use
 * a single write to write the whole file. If the pre-existing file was
 * bigger we pad our payload with newlines that are anyway ignored and truncate
 * the file afterward. */</comment>
<function><type><name>int</name></type> <name>clusterSaveConfig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>do_fsync</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>ci</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>content_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>IF_WIN32</name></name></type><argument_list>(<argument><expr><name>_stat64</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list> <name>sb</name></decl>;</decl_stmt>                                           <comment type="line">// TODO: verify for 32-bit</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr>;</expr_stmt>

    <comment type="block">/* Get the nodes description and concatenate our "vars" directive to
     * save currentEpoch and lastVoteEpoch. */</comment>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>clusterGenNodesDescription</name><argument_list>(<argument><expr><name>CLUSTER_NODE_HANDSHAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">"vars currentEpoch %llu lastVoteEpoch %llu\n"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>lastVoteEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>content_size</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster_configfile</name></name></expr></argument>,<argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name></expr></argument>,<argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call><operator>)</operator>
        <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Pad the new payload if the existing file length is greater. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator><name>content_size</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdsgrowzero</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><name><name>sb</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ci</name><operator>+</operator><name>content_size</name></expr></argument>,<argument><expr><literal type="char">'\n'</literal></expr></argument>,<argument><expr><name><name>sb</name><operator>.</operator><name>st_size</name></name><operator>-</operator><name>content_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>ci</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>do_fsync</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_TODO_FSYNC_CONFIG</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Truncate the file if needed to remove the final \n padding that
     * is just garbage. */</comment>
    <if_stmt><if>if <condition>(<expr><name>content_size</name> <operator>!=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>content_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* ftruncate() failing is not a critical error. */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clusterSaveConfigOrDie</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>do_fsync</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>clusterSaveConfig</name><argument_list>(<argument><expr><name>do_fsync</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Fatal: can't update cluster config file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Lock the cluster config using flock(), and leaks the file descritor used to
 * acquire the lock so that the file will be locked forever.
 *
 * This works because we always update nodes.conf with a new version
 * in-place, reopening the file, and writing to it in place (later adjusting
 * the length with ftruncate()).
 *
 * On success C_OK is returned, otherwise an error is logged and
 * the function returns C_ERR to signal a lock was not acquired. */</comment>
<function><type><name>int</name></type> <name>clusterLockConfig</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
<comment type="block">/* flock() does not exist on Solaris
 * and a fcntl-based solution won't help, as we constantly re-open that file,
 * which will release _all_ locks anyway
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* To lock it, we need to open the file in a way it is created if
     * it does not exist, otherwise there is a race condition with other
     * processes. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name></expr></argument>,<argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Can't open %s in order to acquire a lock: %s"</literal></expr></argument>,
            <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><call><name>flock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>LOCK_EX</name><operator>|</operator><name>LOCK_NB</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name> <init>= <expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>FDAPI_get_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>ovlp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>size_lower</name></decl>, <decl><type ref="prev"/><name>size_upper</name></decl>;</decl_stmt>
    <comment type="line">// start offset is 0, and also zero the remaining members of the struct</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>ovlp</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// get file size</comment>
    <expr_stmt><expr><name>size_lower</name> <operator>=</operator> <call><name>GetFileSize</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockFileEx</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><name>LOCKFILE_EXCLUSIVE_LOCK</name> <operator>|</operator> <name>LOCKFILE_FAIL_IMMEDIATELY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size_lower</name></expr></argument>, <argument><expr><name>size_upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>DWORD</name></type> <name>err</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>ERROR_LOCK_VIOLATION</name></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                 <argument><expr><literal type="string">"Sorry, the cluster configuration file %s is already used "</literal>
                 <literal type="string">"by a different Redis Cluster node. Please make sure that "</literal>
                 <literal type="string">"different nodes use different cluster configuration "</literal>
                 <literal type="string">"files."</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Impossible to lock %s: %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Lock acquired: leak the 'fd' by not closing it, so that we'll retain the
     * lock to the file as long as the process exists. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __sun */</comment>

    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<comment type="block">/* Some flags (currently just the NOFAILOVER flag) may need to be updated
 * in the "myself" node based on the current configuration of the node,
 * that may change at runtime via CONFIG SET. This function changes the
 * set of flags in myself-&gt;flags accordingly. */</comment>
<function><type><name>void</name></type> <name>clusterUpdateMyselfFlags</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>oldflags</name> <init>= <expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nofailover</name> <init>= <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>cluster_slave_no_failover</name></name></expr> ?</condition><then>
                     <expr><name>CLUSTER_NODE_NOFAILOVER</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_NOFAILOVER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>nofailover</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name> <operator>!=</operator> <name>oldflags</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                             <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clusterInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>saveconf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CLUSTER_FAIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clusterNodesDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes_black_list</name></name> <operator>=</operator>
        <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clusterNodesBlackListDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_epoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>cant_failover_reason</name></name> <operator>=</operator> <name>CLUSTER_CANT_FAILOVER_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>lastVoteEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTERMSG_TYPE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_sent</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_received</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_pfail_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterCloseAllSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>   <comment type="line">// TODO: review this to verify if we can lock the file on Windows</comment>
    <comment type="block">/* Lock the cluster config file to make sure every node uses
     * its own nodes.conf. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clusterLockConfig</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster_configfile</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Load or create a new nodes configuration. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clusterLoadConfig</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster_configfile</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No configuration found. We will just use the random name provided
         * by the createClusterNode() function. */</comment>
        <expr_stmt><expr><name>myself</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name></name> <operator>=</operator>
            <call><name>createClusterNode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>CLUSTER_NODE_MYSELF</name><operator>|</operator><name>CLUSTER_NODE_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"No cluster configuration found, I'm %.40s"</literal></expr></argument>,
            <argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>saveconf</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>saveconf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterSaveConfigOrDie</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need a listening TCP port for our cluster messaging needs. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cfd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Port sanity check II
     * The other handshake port check is triggered too late to stop
     * us from trying to use a too-high cluster port number. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>port</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">65535</literal><operator>-</operator><name>CLUSTER_PORT_INCR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Redis port number too high. "</literal>
                   <literal type="string">"Cluster communication port is 10,000 port "</literal>
                   <literal type="string">"numbers higher than your Redis port. "</literal>
                   <literal type="string">"Your Redis port number must be "</literal>
                   <literal type="string">"lower than 55535."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>listenToPort</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>port</name></name><operator>+</operator><name>CLUSTER_PORT_INCR</name></expr></argument>,
        <argument><expr><name><name>server</name><operator>.</operator><name>cfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>cfd_count</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>cfd_count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>cfd</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>AE_READABLE</name></expr></argument>,
                <argument><expr><name>clusterAcceptHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unrecoverable error creating Redis Cluster "</literal>
                                <literal type="string">"file event."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* The slots -&gt; keys map is a radix tree. Initialize it here. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set myself-&gt;port / cport to my listening ports, we'll just need to
     * discover the IP address via MEET messages. */</comment>
    <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>port</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>port</name></name><operator>+</operator><name>CLUSTER_PORT_INCR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_announce_port</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster_announce_port</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_announce_bus_port</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster_announce_bus_port</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterUpdateMyselfFlags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reset a node performing a soft or hard reset:
 *
 * 1) All other nodes are forget.
 * 2) All the assigned / open slots are released.
 * 3) If the node is a slave, it turns into a master.
 * 5) Only for hard reset: a new Node ID is generated.
 * 6) Only for hard reset: currentEpoch and configEpoch are set to 0.
 * 7) The new configuration is saved and the cluster state updated.
 * 8) If the node was a slave, the whole data set is flushed away. */</comment>
<function><type><name>void</name></type> <name>clusterReset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hard</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Turn into master. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterSetNodeAsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>replicationUnsetMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>emptyDb</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>EMPTYDB_NO_FLAGS</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Close slots, reset manual failover state. */</comment>
    <expr_stmt><expr><call><name>clusterCloseAllSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unassign all the slots. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Forget all the nodes, but myself. */</comment>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>myself</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterDelNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Hard reset only: set epochs to 0, change node ID. */</comment>
    <if_stmt><if>if <condition>(<expr><name>hard</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>oldname</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>lastVoteEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"configEpoch set to 0 via CLUSTER RESET HARD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* To change the Node ID we need to remove the old name from the
         * nodes table, change the ID, and re-add back with new name. */</comment>
        <expr_stmt><expr><name>oldname</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,<argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getRandomHexChars</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Node hard reset, now I'm %.40s"</literal></expr></argument>, <argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make sure to persist the new config and update the state. */</comment>
    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                         <name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator>
                         <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER communication link
 * -------------------------------------------------------------------------- */</comment>

<function><type><name>clusterLink</name> <modifier>*</modifier></type><name>createClusterLink</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>link</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>ctime</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>link</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a cluster link, but does not free the associated node of course.
 * This function will just make sure that the original node associated
 * with this link will have the 'link' field set to NULL. */</comment>
<function><type><name>void</name></type> <name>freeClusterLink</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_READABLE</name><operator>|</operator><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CLUSTER_ACCEPTS_PER_CALL</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>clusterAcceptHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cport</name></decl>, <decl><type ref="prev"/><name>cfd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><name>MAX_CLUSTER_ACCEPTS_PER_CALL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the server is starting up, don't accept cluster connections:
     * UPDATE messages may interact with the database content. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>loading</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>WSIOCP_QueueAccept</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while<condition>(<expr><name>max</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cfd</name> <operator>=</operator> <call><name>anetTcpAccept</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cip</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cip</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cfd</name> <operator>==</operator> <name>ANET_ERR</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
                    <argument><expr><literal type="string">"Error accepting cluster node: %s"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>WSIOCP_QueueAccept</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"acceptTcpHandler: failed to queue another accept."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>cfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>anetEnableTcpNoDelay</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>cfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Use non-blocking I/O for cluster messages. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,<argument><expr><literal type="string">"Accepted cluster node %s:%d"</literal></expr></argument>, <argument><expr><name>cip</name></expr></argument>, <argument><expr><name>cport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Create a link object we use to handle the connection.
         * It gets passed to the readable handler when data is available.
         * Initiallly the link-&gt;node pointer is set to NULL as we don't know
         * which node is, but the right node is references once we know the
         * node identity. */</comment>
        <expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>createClusterLink</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>cfd</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>cfd</name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>,<argument><expr><name>clusterReadHandler</name></expr></argument>,<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Key space handling
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* We have 16384 hash slots. The hash slot of a given key is obtained
 * as the least significant 14 bits of the crc16 of the key.
 *
 * However if the key contains the {...} pattern, only the part between
 * { and } is hashed. This may be useful in the future to force certain
 * keys to be in the same node (assuming no resharding is in progress). */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>keyHashSlot</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt> <comment type="block">/* start-end indexes of { and } */</comment>

    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>keylen</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* No '{' ? Hash the whole key. This is the base case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>keylen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>crc16</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* '{' found? Check if we have the corresponding '}'. */</comment>
    <for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>s</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>e</name> <operator>&lt;</operator> <name>keylen</name></expr>;</condition> <incr><expr><name>e</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>e</name></expr>]</index></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* No '}' or nothing between {} ? Hash the whole key. */</comment>
    <if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>keylen</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>s</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>crc16</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */</comment>
    <return>return <expr><call><name>crc16</name><argument_list>(<argument><expr><name>key</name><operator>+</operator><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>s</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER node API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Create a new cluster node, with the specified flags.
 * If "nodename" is NULL this is considered a first handshake and a random
 * node name is assigned to this node (it will be fixed later when we'll
 * receive the first pong).
 *
 * The node is created and returned to the user, but it is not automatically
 * added to the nodes hash table. */</comment>
<function><type><name>clusterNode</name> <modifier>*</modifier></type><name>createClusterNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nodename</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>getRandomHexChars</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ctime</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numslots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numslaves</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>pong_received</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data_received</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fail_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fail_reports</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>voted_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>orphaned_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>repl_offset_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>repl_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fail_reports</name></name></expr></argument>,<argument><expr><name>zfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called every time we get a failure report from a node.
 * The side effect is to populate the fail_reports list (or to update
 * the timestamp of an existing report).
 *
 * 'failing' is the node that is in failure state according to the
 * 'sender' node.
 *
 * The function returns 0 if it just updates a timestamp of an existing
 * failure report from the same sender. 1 is returned if a new failure
 * report is created. */</comment>
<function><type><name>int</name></type> <name>clusterNodeAddFailureReport</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>failing</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>failing</name><operator>-&gt;</operator><name>fail_reports</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNodeFailReport</name> <modifier>*</modifier></type><name>fr</name></decl>;</decl_stmt>

    <comment type="block">/* If a failure report from the same sender already exists, just update
     * the timestamp. */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fr</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>fr</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name>sender</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>fr</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Otherwise create a new report. */</comment>
    <expr_stmt><expr><name>fr</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fr</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>sender</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fr</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>fr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove failure reports that are too old, where too old means reasonably
 * older than the global node timeout. Note that anyway for a node to be
 * flagged as FAIL we need to have a local PFAIL state that is at least
 * older than the global node timeout, so we don't just trust the number
 * of failure reports from other nodes. */</comment>
<function><type><name>void</name></type> <name>clusterNodeCleanupFailureReports</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>fail_reports</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNodeFailReport</name> <modifier>*</modifier></type><name>fr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>maxtime</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name> <operator>*</operator>
                     <name>CLUSTER_FAIL_REPORT_VALIDITY_MULT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fr</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name><name>fr</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;</operator> <name>maxtime</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Remove the failing report for 'node' if it was previously considered
 * failing by 'sender'. This function is called when a node informs us via
 * gossip that a node is OK from its point of view (no FAIL or PFAIL flags).
 *
 * Note that this function is called relatively often as it gets called even
 * when there are no nodes failing, and is O(N), however when the cluster is
 * fine the failure reports list is empty so the function runs in constant
 * time.
 *
 * The function returns 1 if the failure report was found and removed.
 * Otherwise 0 is returned. */</comment>
<function><type><name>int</name></type> <name>clusterNodeDelFailureReport</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>fail_reports</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNodeFailReport</name> <modifier>*</modifier></type><name>fr</name></decl>;</decl_stmt>

    <comment type="block">/* Search for a failure report from this sender. */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fr</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>fr</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name>sender</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ln</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* No failure report from this sender. */</comment>

    <comment type="block">/* Remove the failure report. */</comment>
    <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterNodeCleanupFailureReports</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the number of external nodes that believe 'node' is failing,
 * not including this node, that may have a PFAIL or FAIL state for this
 * node as well. */</comment>
<function><type><name>int</name></type> <name>clusterNodeFailureReportsCount</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>clusterNodeCleanupFailureReports</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>listLength</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fail_reports</name></name></expr></argument>)</argument_list></call></expr>;</return>                                <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>clusterNodeRemoveSlave</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>slave</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>slave</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>remaining_slaves</name> <init>= <expr><operator>(</operator><name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name></name><operator>+</operator><name>j</name></expr></argument>,<argument><expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name></name><operator>+</operator><operator>(</operator><name>j</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>master</name><operator>-&gt;</operator><name>slaves</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>remaining_slaves</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_MIGRATE_TO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>C_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>clusterNodeAddSlave</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>slave</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* If it's already a slave, don't add it again. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>slave</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name></name></expr></argument>,
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name></expr>]</index></name> <operator>=</operator> <name>slave</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_MIGRATE_TO</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>clusterCountNonFailingSlaves</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>okslaves</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>okslaves</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>okslaves</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Low level cleanup of the node structure. Only called by clusterDelNode(). */</comment>
<function><type><name>void</name></type> <name>freeClusterNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* If the node has associated slaves, we have to set
     * all the slaves-&gt;slaveof fields to NULL (unknown). */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>slaveof</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Remove this node from the list of slaves of its master. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>slaveof</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterNodeRemoveSlave</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Unlink from the set of nodes. */</comment>
    <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,<argument><expr><name>nodename</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release link and associated data structures. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClusterLink</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>fail_reports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a node to the nodes hash table */</comment>
<function><type><name>int</name></type> <name>clusterAddNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
            <argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>retval</name> <operator>==</operator> <name>DICT_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>C_OK</name></expr> </then><else>: <expr><name>C_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove a node from the cluster. The functio performs the high level
 * cleanup, calling freeClusterNode() for the low level cleanup.
 * Here we do the following:
 *
 * 1) Mark all the slots handled by it as unassigned.
 * 2) Remove all the failure reports sent by this node and referenced by
 *    other nodes.
 * 3) Free the node with freeClusterNode() that will in turn remove it
 *    from the hash table and from the list of slaves of its master, if
 *    it is a slave node.
 */</comment>
<function><type><name>void</name></type> <name>clusterDelNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>delnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <comment type="block">/* 1) Mark slots as unassigned. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>delnode</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>delnode</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>delnode</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* 2) Remove failure reports. */</comment>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>delnode</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterNodeDelFailureReport</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>delnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 3) Free the node, unlinking it from the cluster. */</comment>
    <expr_stmt><expr><call><name>freeClusterNode</name><argument_list>(<argument><expr><name>delnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Node lookup by name */</comment>
<function><type><name>clusterNode</name> <modifier>*</modifier></type><name>clusterLookupNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is only used after the handshake. When we connect a given IP/PORT
 * as a result of CLUSTER MEET we don't have the node name yet, so we
 * pick a random one, and will fix it when we receive the PONG request using
 * this function. */</comment>
<function><type><name>void</name></type> <name>clusterRenameNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"Renaming node %.40s into %.40s"</literal></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>newname</name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER config epoch handling
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return the greatest configEpoch found in the cluster, or the current
 * epoch if greater than any node configEpoch. */</comment>
<function><type><name>uint64_t</name></type> <name>clusterGetMaxEpoch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>configEpoch</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>max</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If this node epoch is zero or is not already the greatest across the
 * cluster (from the POV of the local configuration), this function will:
 *
 * 1) Generate a new config epoch, incrementing the current epoch.
 * 2) Assign the new epoch to this node, WITHOUT any consensus.
 * 3) Persist the configuration on disk before sending packets with the
 *    new configuration.
 *
 * If the new config epoch is generated and assigend, C_OK is returned,
 * otherwise C_ERR is returned (since the node has already the greatest
 * configuration around) and no operation is performed.
 *
 * Important note: this function violates the principle that config epochs
 * should be generated with consensus and should be unique across the cluster.
 * However Redis Cluster uses this auto-generated new config epochs in two
 * cases:
 *
 * 1) When slots are closed after importing. Otherwise resharding would be
 *    too expensive.
 * 2) When CLUSTER FAILOVER is called with options that force a slave to
 *    failover its master even if there is not master majority able to
 *    create a new configuration epoch.
 *
 * Redis Cluster will not explode using this function, even in the case of
 * a collision between this node and another node, generating the same
 * configuration epoch unilaterally, because the config epoch conflict
 * resolution algorithm will eventually move colliding nodes to different
 * config epochs. However using this function may violate the "last failover
 * wins" rule, so should only be used with care. */</comment>
<function><type><name>int</name></type> <name>clusterBumpConfigEpochWithoutConsensus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>maxEpoch</name> <init>= <expr><call><name>clusterGetMaxEpoch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>!=</operator> <name>maxEpoch</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                             <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"New configEpoch set to %llu"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called when this node is a master, and we receive from
 * another master a configuration epoch that is equal to our configuration
 * epoch.
 *
 * BACKGROUND
 *
 * It is not possible that different slaves get the same config
 * epoch during a failover election, because the slaves need to get voted
 * by a majority. However when we perform a manual resharding of the cluster
 * the node will assign a configuration epoch to itself without to ask
 * for agreement. Usually resharding happens when the cluster is working well
 * and is supervised by the sysadmin, however it is possible for a failover
 * to happen exactly while the node we are resharding a slot to assigns itself
 * a new configuration epoch, but before it is able to propagate it.
 *
 * So technically it is possible in this condition that two nodes end with
 * the same configuration epoch.
 *
 * Another possibility is that there are bugs in the implementation causing
 * this to happen.
 *
 * Moreover when a new cluster is created, all the nodes start with the same
 * configEpoch. This collision resolution code allows nodes to automatically
 * end with a different configEpoch at startup automatically.
 *
 * In all the cases, we want a mechanism that resolves this issue automatically
 * as a safeguard. The same configuration epoch for masters serving different
 * set of slots is not harmful, but it is if the nodes end serving the same
 * slots for some reason (manual errors or software bugs) without a proper
 * failover procedure.
 *
 * In general we want a system that eventually always ends with different
 * masters having different configuration epochs whatever happened, since
 * nothign is worse than a split-brain condition in a distributed system.
 *
 * BEHAVIOR
 *
 * When this function gets called, what happens is that if this node
 * has the lexicographically smaller Node ID compared to the other node
 * with the conflicting epoch (the 'sender' node), it will assign itself
 * the greatest configuration epoch currently detected among nodes plus 1.
 *
 * This means that even if there are multiple nodes colliding, the node
 * with the greatest Node ID never moves forward, so eventually all the nodes
 * end with a different configuration epoch.
 */</comment>
<function><type><name>void</name></type> <name>clusterHandleConfigEpochCollision</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Prerequisites: nodes have the same configEpoch and are both masters. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>!=</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>||</operator>
        <operator>!</operator><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Don't act if the colliding node has a smaller Node ID. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Get the next ID available at the best of this node knowledge. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSaveConfigOrDie</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
        <argument><expr><literal type="string">"WARNING: configEpoch collision with node %.40s."</literal>
        <literal type="string">" configEpoch set to %llu"</literal></expr></argument>,
        <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER nodes blacklist
 *
 * The nodes blacklist is just a way to ensure that a given node with a given
 * Node ID is not readded before some time elapsed (this time is specified
 * in seconds in CLUSTER_BLACKLIST_TTL).
 *
 * This is useful when we want to remove a node from the cluster completely:
 * when CLUSTER FORGET is called, it also puts the node into the blacklist so
 * that even if we receive gossip messages from other nodes that still remember
 * about the node we want to remove, we don't re-add it before some time.
 *
 * Currently the CLUSTER_BLACKLIST_TTL is set to 1 minute, this means
 * that redis-trib has 60 seconds to send CLUSTER FORGET messages to nodes
 * in the cluster without dealing with the problem of other nodes re-adding
 * back the node to nodes we already sent the FORGET command to.
 *
 * The data structure used is a hash table with an sds string representing
 * the node ID as key, and the time when it is ok to re-add the node as
 * value.
 * -------------------------------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_BLACKLIST_TTL</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>      <comment type="block">/* 1 minute. */</comment>


<comment type="block">/* Before of the addNode() or Exists() operations we always remove expired
 * entries from the black list. This is an O(N) operation but it is not a
 * problem since add / exists operations are called very infrequently and
 * the hash table is supposed to contain very little elements at max.
 * However without the cleanup during long uptimes and with some automated
 * node add/removal procedures, entries could accumulate. */</comment>
<function><type><name>void</name></type> <name>clusterBlacklistCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes_black_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>expire</name> <init>= <expr><call><name>dictGetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes_black_list</name></name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Cleanup the blacklist and add a new node ID to the black list. */</comment>
<function><type><name>void</name></type> <name>clusterBlacklistAddNode</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>id</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clusterBlacklistCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes_black_list</name></name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If the key was added, duplicate the sds string representation of
         * the key for the next lookup. We'll free it at the end. */</comment>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes_black_list</name></name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictSetUnsignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>+</operator><name>CLUSTER_BLACKLIST_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if the specified node ID exists in the blacklist.
 * You don't need to pass an sds string here, any pointer to 40 bytes
 * will work. */</comment>
<function><type><name>int</name></type> <name>clusterBlacklistExists</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>id</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clusterBlacklistCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes_black_list</name></name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER messages exchange - PING/PONG and gossip
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This function checks if a given node should be marked as FAIL.
 * It happens if the following conditions are met:
 *
 * 1) We received enough failure reports from other master nodes via gossip.
 *    Enough means that the majority of the masters signaled the node is
 *    down recently.
 * 2) We believe this node is in PFAIL state.
 *
 * If a failure is detected we also inform the whole cluster about this
 * event trying to force every other node to set the FAIL flag for the node.
 *
 * Note that the form of agreement used here is weak, as we collect the majority
 * of masters state during some time, and even if we force agreement by
 * propagating the FAIL message, because of partitions we may not reach every
 * node. However:
 *
 * 1) Either we reach the majority and eventually the FAIL state will propagate
 *    to all the cluster.
 * 2) Or there is no majority so no slave promotion will be authorized and the
 *    FAIL flag will be cleared after some time.
 */</comment>
<function><type><name>void</name></type> <name>markNodeAsFailingIfNeeded</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>failures</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needed_quorum</name> <init>= <expr><operator>(</operator><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nodeTimedOut</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* We can reach it. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeFailed</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Already FAILing. */</comment>

    <expr_stmt><expr><name>failures</name> <operator>=</operator> <call><name>clusterNodeFailureReportsCount</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Also count myself as a voter if I'm a master. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>failures</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>failures</name> <operator>&lt;</operator> <name>needed_quorum</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* No weak agreement from masters. */</comment>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
        <argument><expr><literal type="string">"Marking node %.40s as failing (quorum reached)."</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Mark the node as failing. */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_PFAIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_FAIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fail_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Broadcast the failing node name to everybody, forcing all the other
     * reachable nodes to flag the node as FAIL. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterSendFail</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called only if a node is marked as FAIL, but we are able
 * to reach it again. It checks if there are the conditions to undo the FAIL
 * state. */</comment>
<function><type><name>void</name></type> <name>clearNodeFailureIfNeeded</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>nodeFailed</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* For slaves we always clear the FAIL flag if we can contact the
     * node again. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Clear FAIL state for node %.40s: %s is reachable again."</literal></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                <argument><expr><ternary><condition><expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"replica"</literal></expr> </then><else>: <expr><literal type="string">"master without slots"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_FAIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If it is a master and...
     * 1) The FAIL state is old enough.
     * 2) It is yet serving slots from our point of view (not failed over).
     * Apparently no one is going to fix these slots, clear the FAIL flag. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslots</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>fail_time</name></name><operator>)</operator> <operator>&gt;</operator>
        <operator>(</operator><name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name> <operator>*</operator> <name>CLUSTER_FAIL_UNDO_TIME_MULT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Clear FAIL state for node %.40s: is reachable again and nobody is serving its slots after some time."</literal></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_FAIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if we already have a node in HANDSHAKE state matching the
 * specified ip address and port number. This function is used in order to
 * avoid adding a new handshake node for the same address multiple times. */</comment>
<function><type><name>int</name></type> <name>clusterHandshakeInProgress</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cport</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nodeInHandshake</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>==</operator> <name>port</name> <operator>&amp;&amp;</operator>
            <name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>==</operator> <name>cport</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Start an handshake with the specified address if there is not one
 * already in progress. Returns non-zero if the handshake was actually
 * started. On error zero is returned and errno is set to one of the
 * following values:
 *
 * EAGAIN - There is already an handshake in progress for this address.
 * EINVAL - IP or port are not valid. */</comment>
<function><type><name>int</name></type> <name>clusterStartHandshake</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cport</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>norm_ip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>sa</name></decl>;</decl_stmt>

    <comment type="block">/* IP sanity check */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sa</name><operator>)</operator><operator>-&gt;</operator><name>sin_addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>ss_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sa</name><operator>)</operator><operator>-&gt;</operator><name>sin6_addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>ss_family</name></name> <operator>=</operator> <name>AF_INET6</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Port sanity check */</comment>
    <if_stmt><if>if <condition>(<expr><name>port</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>port</name> <operator>&gt;</operator> <literal type="number">65535</literal> <operator>||</operator> <name>cport</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>cport</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set norm_ip as the normalized string representation of the node
     * IP address. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>norm_ip</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>sa</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>,
            <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sa</name><operator>)</operator><operator>-&gt;</operator><name>sin_addr</name><operator>)</operator></expr></argument>,
            <argument><expr><name>norm_ip</name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>,
            <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sa</name><operator>)</operator><operator>-&gt;</operator><name>sin6_addr</name><operator>)</operator></expr></argument>,
            <argument><expr><name>norm_ip</name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>clusterHandshakeInProgress</name><argument_list>(<argument><expr><name>norm_ip</name></expr></argument>,<argument><expr><name>port</name></expr></argument>,<argument><expr><name>cport</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add the node with a random address (NULL as first argument to
     * createClusterNode()). Everything will be fixed during the
     * handshake. */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>createClusterNode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>CLUSTER_NODE_HANDSHAKE</name><operator>|</operator><name>CLUSTER_NODE_MEET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>norm_ip</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <name>cport</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Process the gossip section of PING or PONG packets.
 * Note that this function assumes that the packet is already sanity-checked
 * by the caller, not in the content of the gossip section, but in the
 * length. */</comment>
<function><type><name>void</name></type> <name>clusterProcessGossipSection</name><parameter_list>(<parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>count</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsgDataGossip</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator><name>clusterMsgDataGossip</name><operator>*</operator><operator>)</operator> <name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ping</name><operator>.</operator><name>gossip</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender</name> <init>= <expr><ternary><condition><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr> ?</condition><then> <expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr> </then><else>: <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>flags</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>ci</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>verbosity</name></name> <operator>==</operator> <name>LL_DEBUG</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>representClusterNodeFlags</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"GOSSIP %.40s %s:%d@%d %s"</literal></expr></argument>,
                <argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,
                <argument><expr><name><name>g</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update our state accordingly to the gossip sections */</comment>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We already know this node.
               Handle failure reports, only when the sender is a master. */</comment>
            <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator> <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>node</name> <operator>!=</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>|</operator><name>CLUSTER_NODE_PFAIL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>clusterNodeAddFailureReport</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
                            <argument><expr><literal type="string">"Node %.40s reported node %.40s as not reachable."</literal></expr></argument>,
                            <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>markNodeAsFailingIfNeeded</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>clusterNodeDelFailureReport</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
                            <argument><expr><literal type="string">"Node %.40s reported node %.40s is back online."</literal></expr></argument>,
                            <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* If from our POV the node is up (no failure flags are set),
             * we have no pending ping for the node, nor we have failure
             * reports for this node, update the last pong time with the
             * one we see from the other nodes. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>|</operator><name>CLUSTER_NODE_PFAIL</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
                <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <call><name>clusterNodeFailureReportsCount</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>mstime_t</name></type> <name>pongtime</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>pong_received</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>pongtime</name> <operator>*=</operator> <literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* Convert back to milliseconds. */</comment>

                <comment type="block">/* Replace the pong time with the received one only if
                 * it's greater than our view but is not in the future
                 * (with 500 milliseconds tolerance) from the POV of our
                 * clock. */</comment>
                <if_stmt><if>if <condition>(<expr><name>pongtime</name> <operator>&lt;=</operator> <operator>(</operator><name><name>server</name><operator>.</operator><name>mstime</name></name><operator>+</operator><literal type="number">500</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                    <name>pongtime</name> <operator>&gt;</operator> <name><name>node</name><operator>-&gt;</operator><name>pong_received</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pong_received</name></name> <operator>=</operator> <name>pongtime</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* If we already know this node, but it is not reachable, and
             * we see a different address in the gossip section of a node that
             * can talk with this other node, update the address, disconnect
             * the old link if any, so that we'll attempt to connect with the
             * new address. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>|</operator><name>CLUSTER_NODE_PFAIL</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CLUSTER_NODE_NOADDR</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>|</operator><name>CLUSTER_NODE_PFAIL</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                 <name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>!=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                 <name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>!=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClusterLink</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_NOADDR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* If it's not in NOADDR state and we don't have it, we
             * add it to our trusted dict with exact nodeid and flag.
             * Note that we cannot simply start a handshake against
             * this IP/PORT pairs, since IP/PORT can be reused already,
             * otherwise we risk joining another cluster.
             *
             * Note that we require that the sender of this gossip message
             * is a well known node in our cluster, otherwise we risk
             * joining another cluster. */</comment>
            <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CLUSTER_NODE_NOADDR</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>clusterBlacklistExists</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>createClusterNode</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Next node */</comment>
        <expr_stmt><expr><name>g</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* IP -&gt; string conversion. 'buf' is supposed to at least be 46 bytes.
 * If 'announced_ip' length is non-zero, it is used instead of extracting
 * the IP from the socket peer address. */</comment>
<function><type><name>void</name></type> <name>nodeIp2String</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>announced_ip</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>announced_ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>announced_ip</name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>NET_IP_STR_LEN</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* We are not sure the input is sane. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>anetPeerToString</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NET_IP_STR_LEN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Update the node address to the IP address that can be extracted
 * from link-&gt;fd, or if hdr-&gt;myip is non empty, to the address the node
 * is announcing us. The port is taken from the packet header as well.
 *
 * If the address or port changed, disconnect the node link so that we'll
 * connect again to the new address.
 *
 * If the ip/port pair are already correct no operation is performed at
 * all.
 *
 * The function returns 0 if the node address is still the same,
 * otherwise 1 is returned. */</comment>
<function><type><name>int</name></type> <name>nodeUpdateAddressIfNeeded</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>,
                              <parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cport</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We don't proceed if the link is the same as the sender link, as this
     * function is designed to see if the node link is consistent with the
     * symmetric link that is used to receive PINGs from the node.
     *
     * As a side effect this function never frees the passed 'link', so
     * it is safe to call during packet processing. */</comment>
    <if_stmt><if>if <condition>(<expr><name>link</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>nodeIp2String</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><name>link</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>==</operator> <name>port</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>==</operator> <name>cport</name> <operator>&amp;&amp;</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* IP / port is different, update it. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <name>cport</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClusterLink</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_NOADDR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Address updated for node %.40s, now %s:%d"</literal></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if this is our master and we have to change the
     * replication target as well. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>replicationSetMaster</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reconfigure the specified node 'n' as a master. This function is called when
 * a node that we believed to be a slave is now acting as master in order to
 * update the state of the node. */</comment>
<function><type><name>void</name></type> <name>clusterSetNodeAsMaster</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>slaveof</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterNodeRemoveSlave</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name>myself</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_MIGRATE_TO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Update config and state. */</comment>
    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                         <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called when we receive a master configuration via a
 * PING, PONG or UPDATE packet. What we receive is a node, a configEpoch of the
 * node, and the set of slots claimed under this configEpoch.
 *
 * What we do is to rebind the slots with newer configuration compared to our
 * local configuration, and if needed, we turn ourself into a replica of the
 * node (see the function comments for more info).
 *
 * The 'sender' is the node for which we received a configuration update.
 * Sometimes it is not actually the "Sender" of the information, like in the
 * case we receive the info via an UPDATE packet. */</comment>
<function><type><name>void</name></type> <name>clusterUpdateSlotsConfigWith</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>senderConfigEpoch</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>slots</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>curmaster</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newmaster</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* The dirty slots list is a list of slots for which we lose the ownership
     * while having still keys inside. This usually happens after a failover
     * or after a manual cluster reconfiguration operated by the admin.
     *
     * If the update message is not able to demote a master to slave (in this
     * case we'll resync with the master updating the whole key space), we
     * need to delete all the keys in the slots we lost ownership. */</comment>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name><name>dirty_slots</name><index>[<expr><name>CLUSTER_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dirty_slots_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Here we set curmaster to this node or the node this node
     * replicates to if it's a slave. In the for loop we are
     * interested to check if slots are taken away from curmaster. */</comment>
    <expr_stmt><expr><name>curmaster</name> <operator>=</operator> <ternary><condition><expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>myself</name></expr> </then><else>: <expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>==</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Discarding UPDATE message about myself."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>bitmapTestBit</name><argument_list>(<argument><expr><name>slots</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* The slot is already bound to the sender of this message. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>sender</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* The slot is in importing state, it should be modified only
             * manually via redis-trib (example: a resharding is in progress
             * and the migrating side slot was already closed and is advertising
             * a new config. We still want the slot to be closed manually). */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* We rebind the slot to the new node claiming it if:
             * 1) The slot was unassigned or the new node claims it with a
             *    greater configEpoch.
             * 2) We are not currently importing the slot. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>configEpoch</name> <operator>&lt;</operator> <name>senderConfigEpoch</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Was this slot mine, and still contains keys? Mark it as
                 * a dirty slot. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>myself</name> <operator>&amp;&amp;</operator>
                    <call><name>countKeysInSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <name>sender</name> <operator>!=</operator> <name>myself</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>dirty_slots</name><index>[<expr><name>dirty_slots_count</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dirty_slots_count</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>curmaster</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>newmaster</name> <operator>=</operator> <name>sender</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterAddSlot</name><argument_list>(<argument><expr><name>sender</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                     <name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator>
                                     <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* After updating the slots configuration, don't do any actual change
     * in the state of the server if a module disabled Redis Cluster
     * keys redirections. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MODULE_FLAG_NO_REDIRECTION</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If at least one slot was reassigned from a node to another node
     * with a greater configEpoch, it is possible that:
     * 1) We are a master left without slots. This means that we were
     *    failed over and we should turn into a replica of the new
     *    master.
     * 2) We are a slave and our master is left without slots. We need
     *    to replicate to the new slots owner. */</comment>
    <if_stmt><if>if <condition>(<expr><name>newmaster</name> <operator>&amp;&amp;</operator> <name><name>curmaster</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Configuration change detected. Reconfiguring myself "</literal>
            <literal type="string">"as a replica of %.40s"</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterSetMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                             <name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator>
                             <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dirty_slots_count</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we are here, we received an update message which removed
         * ownership for certain slots we still have keys about, but still
         * we are serving some slots, so this master node was not demoted to
         * a slave.
         *
         * In order to maintain a consistent state between keys and slots
         * we need to remove all the keys from the slots we lost. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dirty_slots_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>delKeysInSlot</name><argument_list>(<argument><expr><name><name>dirty_slots</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* When this function is called, there is a packet to process starting
 * at node-&gt;rcvbuf. Releasing the buffer is up to the caller, so this
 * function should just handle the higher level stuff of processing the
 * packet, modifying the cluster state if needed.
 *
 * The function returns 1 if the link is still valid after the packet
 * was processed, otherwise 0 if the link was freed since the packet
 * processing lead to some inconsistency error (for instance a PONG
 * received from the wrong sender ID). */</comment>
<function><type><name>int</name></type> <name>clusterProcessPacket</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totlen</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <name>CLUSTERMSG_TYPE_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_received</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <macro><name>serverLog</name><argument_list>(<argument>LL_DEBUG</argument>,<argument><literal type="string">"--- Processing packet of type %d, %Iu bytes"</literal></argument>, <argument>WIN_PORT_FIX <comment type="block">/* %lu -&gt; %Iu */</comment>
        type</argument>, <argument>(PORT_ULONG) totlen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <comment type="block">/* Perform sanity checks */</comment>
    <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* At least signature, version, totlen, count. */</comment>
    <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>&gt;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ver</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CLUSTER_PROTO_VER</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Can't handle messages of different versions. */</comment>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint16_t</name></type> <name>flags</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>senderCurrentEpoch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>senderConfigEpoch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PING</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PONG</name> <operator>||</operator>
        <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MEET</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>count</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>explen</name></decl>;</decl_stmt> <comment type="block">/* expected length of this packet */</comment>

        <expr_stmt><expr><name>explen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>explen</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataGossip</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>explen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAIL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>explen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>explen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataFail</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>explen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PUBLISH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>explen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>explen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataPublish</name></expr></argument>)</argument_list></sizeof> <operator>-</operator>
                <literal type="number">8</literal> <operator>+</operator>
                <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>channel_len</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
                <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>explen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</name> <operator>||</operator>
               <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</name> <operator>||</operator>
               <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MFSTART</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>explen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>explen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_UPDATE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>explen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>explen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataUpdate</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>explen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MODULE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>explen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>explen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataPublish</name></expr></argument>)</argument_list></sizeof> <operator>-</operator>
                <literal type="number">3</literal> <operator>+</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>explen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if the sender is a known node. */</comment>
    <expr_stmt><expr><name>sender</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update the last time we saw any data from this node. We
     * use this in order to avoid detecting a timeout from a node that
     * is just sending a lot of data in the cluster bus, for instance
     * because of Pub/Sub. */</comment>
    <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>data_received</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>nodeInHandshake</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Update our curretEpoch if we see a newer epoch in the cluster. */</comment>
        <expr_stmt><expr><name>senderCurrentEpoch</name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>senderConfigEpoch</name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>senderCurrentEpoch</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator> <name>senderCurrentEpoch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Update the sender configEpoch if it is publishing a newer one. */</comment>
        <if_stmt><if>if <condition>(<expr><name>senderConfigEpoch</name> <operator>&gt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>configEpoch</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <name>senderConfigEpoch</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                 <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Update the replication offset info for this node. */</comment>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>repl_offset</name></name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>repl_offset_time</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
        <comment type="block">/* If we are a slave performing a manual failover and our master
         * sent its offset while already paused, populate the MF state. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>&amp;&amp;</operator>
            <call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>sender</name> <operator>&amp;&amp;</operator>
            <name><name>hdr</name><operator>-&gt;</operator><name>mflags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>CLUSTERMSG_FLAG0_PAUSED</name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_master_offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_master_offset</name></name> <operator>=</operator> <name><name>sender</name><operator>-&gt;</operator><name>repl_offset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Received replication offset for paused "</literal>
                <literal type="string">"master manual failover: %lld"</literal></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_master_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initial processing of PING and MEET requests replying with a PONG. */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PING</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MEET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"Ping packet received: %p"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We use incoming MEET messages in order to set the address
         * for 'myself', since only other cluster nodes will send us
         * MEET messages on handshakes, when the cluster joins, or
         * later if we changed address, and those nodes will use our
         * official address to connect to us. So by obtaining this address
         * from the socket is a simple way to discover / update our own
         * address in the cluster without it being hardcoded in the config.
         *
         * However if we don't have an address at all, we update the address
         * even with a normal PING packet. If it's wrong it will be fixed
         * by MEET later. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MEET</name> <operator>||</operator> <name><name>myself</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>cluster_announce_ip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>anetSockName</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"IP address for this node updated to %s"</literal></expr></argument>,
                    <argument><expr><name><name>myself</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Add this node if it is new for us and the msg type is MEET.
         * In this stage we don't try to add the node with the right
         * flags, slaveof pointer, and so forth, as this details will be
         * resolved when we'll receive PONGs from the node. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MEET</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>createClusterNode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>CLUSTER_NODE_HANDSHAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>nodeIp2String</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>link</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterAddNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If this is a MEET packet from an unknown node, we still process
         * the gossip section here since we have to trust the sender because
         * of the message type. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MEET</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterProcessGossipSection</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Anyway reply with a PONG */</comment>
        <expr_stmt><expr><call><name>clusterSendPing</name><argument_list>(<argument><expr><name>link</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_PONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* PING, PONG, MEET: process config information. */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PING</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PONG</name> <operator>||</operator>
        <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MEET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"%s packet received: %p"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PING</name></expr> ?</condition><then> <expr><literal type="string">"ping"</literal></expr> </then><else>: <expr><literal type="string">"pong"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>nodeInHandshake</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If we already have this node, try to change the
                 * IP/port of the node with the new one. */</comment>
                <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
                        <argument><expr><literal type="string">"Handshake: we already know node %.40s, "</literal>
                        <literal type="string">"updating the address if needed."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>nodeUpdateAddressIfNeeded</name><argument_list>(<argument><expr><name>sender</name></expr></argument>,<argument><expr><name>link</name></expr></argument>,<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                             <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* Free this node as we already have it. This will
                     * cause the link to be freed as well. */</comment>
                    <expr_stmt><expr><call><name>clusterDelNode</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* First thing to do is replacing the random name with the
                 * right node name if this was a handshake stage. */</comment>
                <expr_stmt><expr><call><name>clusterRenameNode</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"Handshake with node %.40s completed."</literal></expr></argument>,
                    <argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_HANDSHAKE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name><operator>&amp;</operator><operator>(</operator><name>CLUSTER_NODE_MASTER</name><operator>|</operator><name>CLUSTER_NODE_SLAVE</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>,
                        <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* If the reply has a non matching node ID we
                 * disconnect this node and set it as not having an associated
                 * address. */</comment>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d"</literal></expr></argument>,
                    <argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>now</name><operator>-</operator><operator>(</operator><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>ctime</name></name><operator>)</operator><operator>)</operator></expr></argument>,
                    <argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_NOADDR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>freeClusterLink</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Copy the CLUSTER_NODE_NOFAILOVER flag from what the sender
         * announced. This is a dynamic flag that we receive from the
         * sender, and the latest status must be trusted. We need it to
         * be propagated because the slave ranking used to understand the
         * delay of each slave in the voting process, needs to know
         * what are the instances really competing. */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nofailover</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>CLUSTER_NODE_NOFAILOVER</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_NOFAILOVER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>nofailover</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update the node address if it changed. */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PING</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>nodeInHandshake</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>nodeUpdateAddressIfNeeded</name><argument_list>(<argument><expr><name>sender</name></expr></argument>,<argument><expr><name>link</name></expr></argument>,<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                 <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update our info about the node */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PONG</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>pong_received</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="block">/* The PFAIL condition can be reversed without external
             * help if it is momentary (that is, if it does not
             * turn into a FAIL state).
             *
             * The FAIL condition is also reversible under specific
             * conditions detected by clearNodeFailureIfNeeded(). */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>nodeTimedOut</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_PFAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                     <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clearNodeFailureIfNeeded</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check for role switch: slave -&gt; master or master -&gt; slave. */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><name>CLUSTER_NODE_NULL_NAME</name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Node is a master. */</comment>
                <expr_stmt><expr><call><name>clusterSetNodeAsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* Node is a slave. */</comment>
                <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Master turned into a slave! Reconfigure the node. */</comment>
                    <expr_stmt><expr><call><name>clusterDelNodeSlots</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CLUSTER_NODE_MASTER</name><operator>|</operator>
                                       <name>CLUSTER_NODE_MIGRATE_TO</name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_SLAVE</name></expr>;</expr_stmt>

                    <comment type="block">/* Update config and state. */</comment>
                    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                         <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Master node changed for this slave? */</comment>
                <if_stmt><if>if <condition>(<expr><name>master</name> <operator>&amp;&amp;</operator> <name><name>sender</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>!=</operator> <name>master</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>slaveof</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>clusterNodeRemoveSlave</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>clusterNodeAddSlave</name><argument_list>(<argument><expr><name>master</name></expr></argument>,<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>=</operator> <name>master</name></expr>;</expr_stmt>

                    <comment type="block">/* Update config. */</comment>
                    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update our info about served slots.
         *
         * Note: this MUST happen after we update the master/slave state
         * so that CLUSTER_NODE_MASTER flag will be set. */</comment>

        <comment type="block">/* Many checks are only needed if the set of served slots this
         * instance claims is different compared to the set of slots we have
         * for it. Check this ASAP to avoid other computational expansive
         * checks later. */</comment>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>sender_master</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Sender or its master if slave. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>dirty_slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Sender claimed slots don't match my view? */</comment>

        <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sender_master</name> <operator>=</operator> <ternary><condition><expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>sender</name></expr> </then><else>: <expr><name><name>sender</name><operator>-&gt;</operator><name>slaveof</name></name></expr></else></ternary></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>sender_master</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>dirty_slots</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>sender_master</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,
                        <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myslots</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myslots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* 1) If the sender of the message is a master, and we detected that
         *    the set of slots it claims changed, scan the slots to see if we
         *    need to update our configuration. */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator> <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>dirty_slots</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterUpdateSlotsConfigWith</name><argument_list>(<argument><expr><name>sender</name></expr></argument>,<argument><expr><name>senderConfigEpoch</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* 2) We also check for the reverse condition, that is, the sender
         *    claims to serve slots we know are served by a master with a
         *    greater configEpoch. If this happens we inform the sender.
         *
         * This is useful because sometimes after a partition heals, a
         * reappearing master may be the last one to claim a given set of
         * hash slots, but with a configuration that other instances know to
         * be deprecated. Example:
         *
         * A and B are master and slave for slots 1,2,3.
         * A is partitioned away, B gets promoted.
         * B is partitioned away, and A returns available.
         *
         * Usually B would PING A publishing its set of served slots and its
         * configEpoch, but because of the partition B can't inform A of the
         * new configuration, so other nodes that have an updated table must
         * do it. In this way A will stop to act as a master (or can try to
         * failover if there are the conditions to win the election). */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator> <name>dirty_slots</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>bitmapTestBit</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myslots</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>sender</name> <operator>||</operator>
                        <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>configEpoch</name> <operator>&gt;</operator>
                        <name>senderConfigEpoch</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
                            <argument><expr><literal type="string">"Node %.40s has old slots configuration, sending "</literal>
                            <literal type="string">"an UPDATE message about %.40s"</literal></expr></argument>,
                                <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>clusterSendUpdate</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
                            <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* TODO: instead of exiting the loop send every other
                         * UPDATE packet for other nodes that are the new owner
                         * of sender's slots. */</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If our config epoch collides with the sender's try to fix
         * the problem. */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name> <operator>&amp;&amp;</operator>
            <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name>senderConfigEpoch</name> <operator>==</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>clusterHandleConfigEpochCollision</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Get info from the gossip section */</comment>
        <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterProcessGossipSection</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAIL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>failing</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>sender</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>failing</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fail</name><operator>.</operator><name>about</name><operator>.</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>failing</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><operator>(</operator><name><name>failing</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>|</operator><name>CLUSTER_NODE_MYSELF</name><operator>)</operator><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                    <argument><expr><literal type="string">"FAIL message received from %.40s about %.40s"</literal></expr></argument>,
                    <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fail</name><operator>.</operator><name>about</name><operator>.</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>failing</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_FAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>failing</name><operator>-&gt;</operator><name>fail_time</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>failing</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_PFAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                                     <name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                <argument><expr><literal type="string">"Ignoring FAIL message from unknown node %.40s about %.40s"</literal></expr></argument>,
                <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fail</name><operator>.</operator><name>about</name><operator>.</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PUBLISH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>channel</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>channel_len</name></decl>, <decl><type ref="prev"/><name>message_len</name></decl>;</decl_stmt>

        <comment type="block">/* Don't bother creating useless objects if there are no
         * Pub/Sub subscribers. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>pubsub_channels</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
           <call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>pubsub_patterns</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>channel_len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>channel_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>message_len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>channel</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(
                        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>bulk_data</name></name></expr></argument>,<argument><expr><name>channel_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(
                        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>bulk_data</name></name><operator>+</operator><name>channel_len</name></expr></argument>,
                        <argument><expr><name>message_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pubsubPublishMessage</name><argument_list>(<argument><expr><name>channel</name></expr></argument>,<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* We don't know that node. */</comment>
        <expr_stmt><expr><call><name>clusterSendFailoverAuthIfNeeded</name><argument_list>(<argument><expr><name>sender</name></expr></argument>,<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* We don't know that node. */</comment>
        <comment type="block">/* We consider this vote only if the sender is a master serving
         * a non zero number of slots, and its currentEpoch is greater or
         * equal to epoch where this node started the election. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>sender</name><operator>-&gt;</operator><name>numslots</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>senderCurrentEpoch</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_epoch</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_count</name></name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* Maybe we reached a quorum here, set a flag to make sure
             * we check ASAP. */</comment>
            <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_HANDLE_FAILOVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MFSTART</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* This message is acceptable only if I'm a master and the sender
         * is one of my slaves. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name> <operator>||</operator> <name><name>sender</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>!=</operator> <name>myself</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* Manual failover requested from slaves. Initialize the state
         * accordingly. */</comment>
        <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>=</operator> <name>now</name> <operator>+</operator> <name>CLUSTER_MF_TIMEOUT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_slave</name></name> <operator>=</operator> <name>sender</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pauseClients</name><argument_list>(<argument><expr><name>now</name><operator>+</operator><operator>(</operator><name>CLUSTER_MF_TIMEOUT</name><operator>*</operator><name>CLUSTER_MF_PAUSE_MULT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Manual failover requested by replica %.40s."</literal></expr></argument>,
            <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_UPDATE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt> <comment type="block">/* The node the update is about. */</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>reportedConfigEpoch</name> <init>=
                    <expr><call><name>ntohu64</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>update</name><operator>.</operator><name>nodecfg</name><operator>.</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* We don't know the sender. */</comment>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>update</name><operator>.</operator><name>nodecfg</name><operator>.</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* We don't know the reported node. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>&gt;=</operator> <name>reportedConfigEpoch</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Nothing new. */</comment>

        <comment type="block">/* If in our current config the node is a slave, set it as a master. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterSetNodeAsMaster</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Update the node's configEpoch. */</comment>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <name>reportedConfigEpoch</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                             <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check the bitmap of served slots and update our
         * config accordingly. */</comment>
        <expr_stmt><expr><call><name>clusterUpdateSlotsConfigWith</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>reportedConfigEpoch</name></expr></argument>,
            <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>update</name><operator>.</operator><name>nodecfg</name><operator>.</operator><name>slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_MODULE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Protect the module from unknown nodes. */</comment>
        <comment type="block">/* We need to route this message back to the right module subscribed
         * for the right message type. */</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>module_id</name> <init>= <expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>module_id</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Endian-safe ID */</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>type</name> <init>= <expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>payload</name> <init>= <expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>bulk_data</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>moduleCallClusterReceivers</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>module_id</name></expr></argument>,<argument><expr><name>type</name></expr></argument>,<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Received unknown packet type: %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called when we detect the link with this node is lost.
   We set the node as no longer connected. The Cluster Cron will detect
   this connection and will try to get it connected again.

   Instead if the node is a temporary node used to accept a query, we
   completely free the node on error. */</comment>
<function><type><name>void</name></type> <name>handleLinkIOError</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>freeClusterLink</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function><type><name>void</name></type> <name>clusterWriteDone</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>written</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>WSIOCP_Request</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>WSIOCP_Request</name> <operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><operator>(</operator><name>clusterLink</name> <operator>*</operator><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>written</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>, <argument><expr><name>written</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"clusterWriteDone written %d fd %d"</literal></expr></argument>, <argument><expr><name>written</name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clusterWriteHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><operator>(</operator><name>clusterLink</name><operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>WSIOCP_SocketSend</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,
        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
        <argument><expr><name>el</name></expr></argument>,
        <argument><expr><name>link</name></expr></argument>,
        <argument><expr><name>NULL</name></expr></argument>,
        <argument><expr><name>clusterWriteDone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>WSA_IO_PENDING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"WSA_IO_PENDING writing to socket fd %d"</literal></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>WSA_IO_PENDING</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error writing to socket fd %d"</literal></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>handleLinkIOError</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Send data. This is handled using a trivial send buffer that gets
 * consumed by write(). We don't try to optimize this for speed too much
 * as this is a very low traffic channel. */</comment>
<function><type><name>void</name></type> <name>clusterWriteHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><operator>(</operator><name>clusterLink</name><operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"I/O error writing to node link: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"short write"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>handleLinkIOError</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>,<argument><expr><name>nwritten</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read data. Try to read the first field of the header first to check the
 * full length of the packet. When a whole packet is in memory this function
 * will call the function to process the packet. And so forth. */</comment>
<function><type><name>void</name></type> <name>clusterReadHandler</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><operator>(</operator><name>clusterLink</name><operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>readlen</name></decl>, <decl><type ref="prev"/><name>rcvbuflen</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* Read as long as there is data to read. */</comment>
        <expr_stmt><expr><name>rcvbuflen</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                         <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (unsigned int) */</comment>
        <if_stmt><if>if <condition>(<expr><name>rcvbuflen</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* First, obtain the first 8 bytes to get the full message
             * length. */</comment>
            <expr_stmt><expr><name>readlen</name> <operator>=</operator> <literal type="number">8</literal> <operator>-</operator> <name>rcvbuflen</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Finally read the full message. */</comment>
            <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rcvbuflen</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Perform some sanity check on the message signature
                 * and length. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sig</name></name></expr></argument>,<argument><expr><literal type="string">"RCmb"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>CLUSTERMSG_MIN_LEN</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                        <argument><expr><literal type="string">"Bad message length or signature received "</literal>
                        <literal type="string">"from Cluster bus."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>handleLinkIOError</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>readlen</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>rcvbuflen</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>readlen</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>readlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>readlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition> <block>{<block_content> <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro> <return>return;</return> </block_content>}</block></if></if_stmt> <comment type="block">/* No more data ready. */</comment>

        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* I/O error... */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"I/O error reading from node link: %s"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>nread</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"connection closed"</literal></expr> </then><else>: <expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>handleLinkIOError</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Read data and recast the pointer to the new buffer. */</comment>
            <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rcvbuflen</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>nread</name></expr>;</expr_stmt>                                   <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (unsigned int) */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Total length obtained? Process this packet. */</comment>
        <if_stmt><if>if <condition>(<expr><name>rcvbuflen</name> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>rcvbuflen</name> <operator>==</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>clusterProcessPacket</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>rcvbuf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return;</return> <comment type="block">/* Link no longer valid. */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
</block_content>}</block></function>

<comment type="block">/* Put stuff into the send buffer.
 *
 * It is guaranteed that this function will never have as a side effect
 * the link to be invalidated, so it is safe to call this function
 * from event handlers that will do stuff with the same link later. */</comment>
<function><type><name>void</name></type> <name>clusterSendMessage</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>msglen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>msglen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name><operator>|</operator><name>AE_BARRIER</name></expr></argument>,
                    <argument><expr><name>clusterWriteHandler</name></expr></argument>,<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>sndbuf</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Populate sent messages stats. */</comment>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>msg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <name>CLUSTERMSG_TYPE_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_sent</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a message to all the nodes that are part of the cluster having
 * a connected link.
 *
 * It is guaranteed that this function will never have as a side effect
 * some node-&gt;link to be invalidated, so it is safe to call this function
 * from event handlers that will do stuff with node links later. */</comment>
<function><type><name>void</name></type> <name>clusterBroadcastMessage</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_MYSELF</name><operator>|</operator><name>CLUSTER_NODE_HANDSHAKE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Build the message header. hdr must point to a buffer at least
 * sizeof(clusterMsg) in bytes. */</comment>
<function><type><name>void</name></type> <name>clusterBuildMessageHdr</name><parameter_list>(<parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>totlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name></decl>;</decl_stmt>

    <comment type="block">/* If this node is a master, we send its slots bitmap and configEpoch.
     * If this node is a slave we send the master's information instead (the
     * node is flagged as slave so the receiver knows that it is NOT really
     * in charge for this slots. */</comment>
    <expr_stmt><expr><name>master</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name><operator>)</operator></expr> ?</condition><then>
              <expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr> </then><else>: <expr><name>myself</name></expr></else></ternary></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>ver</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>CLUSTER_PROTO_VER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>sig</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'R'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>sig</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'C'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>sig</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>sig</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>,<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If cluster-announce-ip option is enabled, force the receivers of our
     * packets to use the specified address for this node. Otherwise if the
     * first byte is zero, they'll do auto discovery. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myip</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_announce_ip</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myip</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cluster_announce_ip</name></name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>myip</name><index>[<expr><name>NET_IP_STR_LEN</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle cluster-announce-port as well. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>announced_port</name> <init>= <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>cluster_announce_port</name></name></expr> ?</condition><then>
                         <expr><name><name>server</name><operator>.</operator><name>cluster_announce_port</name></name></expr> </then><else>: <expr><name><name>server</name><operator>.</operator><name>port</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>announced_cport</name> <init>= <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>cluster_announce_bus_port</name></name></expr> ?</condition><then>
                          <expr><name><name>server</name><operator>.</operator><name>cluster_announce_bus_port</name></name></expr> </then><else>:
                          <expr><operator>(</operator><name><name>server</name><operator>.</operator><name>port</name></name> <operator>+</operator> <name>CLUSTER_PORT_INCR</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myslots</name></name></expr></argument>,<argument><expr><name><name>master</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>myslots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>announced_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>announced_cport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set the currentEpoch and configEpochs. */</comment>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>master</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the replication offset. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>replicationGetSlaveOffset</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the message flags. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>mflags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name>CLUSTERMSG_FLAG0_PAUSED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Compute the message length for certain messages. For other messages
     * this is up to the caller. */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_FAIL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataFail</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_UPDATE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataUpdate</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */</comment>
</block_content>}</block></function>

<comment type="block">/* Return non zero if the node is already present in the gossip section of the
 * message pointed by 'hdr' and having 'count' gossip entries. Otherwise
 * zero is returned. Helper for clusterSendPing(). */</comment>
<function><type><name>int</name></type> <name>clusterNodeIsInGossipSection</name><parameter_list>(<parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ping</name><operator>.</operator><name>gossip</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>j</name> <operator>!=</operator> <name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set the i-th entry of the gossip section in the message pointed by 'hdr'
 * to the info of the specified node 'n'. */</comment>
<function><type><name>void</name></type> <name>clusterSetGossipEntry</name><parameter_list>(<parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterMsgDataGossip</name> <modifier>*</modifier></type><name>gossip</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>gossip</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ping</name><operator>.</operator><name>gossip</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>gossip</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gossip</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ping_sent</name></name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gossip</name><operator>-&gt;</operator><name>pong_received</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>pong_received</name></name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>gossip</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gossip</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gossip</name><operator>-&gt;</operator><name>cport</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gossip</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gossip</name><operator>-&gt;</operator><name>notused1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a PING or PONG packet to the specified node, making sure to add enough
 * gossip informations. */</comment>
<function><type><name>void</name></type> <name>clusterSendPing</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>gossipcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Number of gossip sections added so far. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>wanted</name></decl>;</decl_stmt> <comment type="block">/* Number of gossip sections we want to append if possible. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>totlen</name></decl>;</decl_stmt> <comment type="block">/* Total packet length. */</comment>
    <comment type="block">/* freshnodes is the max number of nodes we can hope to append at all:
     * nodes available minus two (ourself and the node we are sending the
     * message to). However practically there may be less valid nodes since
     * nodes in handshake state, disconnected, are not considered. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>freshnodes</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>                    <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>

    <comment type="block">/* How many gossip sections we want to add? 1/10 of the number of nodes
     * and anyway at least 3. Why 1/10?
     *
     * If we have N masters, with N/10 entries, and we consider that in
     * node_timeout we exchange with each other node at least 4 packets
     * (we ping in the worst case in node_timeout/2 time, and we also
     * receive two pings from the host), we have a total of 8 packets
     * in the node_timeout*2 falure reports validity time. So we have
     * that, for a single PFAIL node, we can expect to receive the following
     * number of failure reports (in the specified window of time):
     *
     * PROB * GOSSIP_ENTRIES_PER_PACKET * TOTAL_PACKETS:
     *
     * PROB = probability of being featured in a single gossip entry,
     *        which is 1 / NUM_OF_NODES.
     * ENTRIES = 10.
     * TOTAL_PACKETS = 2 * 4 * NUM_OF_MASTERS.
     *
     * If we assume we have just masters (so num of nodes and num of masters
     * is the same), with 1/10 we always get over the majority, and specifically
     * 80% of the number of nodes, to account for many masters failing at the
     * same time.
     *
     * Since we have non-voting slaves that lower the probability of an entry
     * to feature our node, we set the number of entries per packet as
     * 10% of the total nodes we have. */</comment>
    <name>wanted</name> <init>= <expr><call><name>floor</name><argument_list>(<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>wanted</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>wanted</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>wanted</name> <operator>&gt;</operator> <name>freshnodes</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>wanted</name> <operator>=</operator> <name>freshnodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Include all the nodes in PFAIL state, so that failure reports are
     * faster to propagate to go from PFAIL to FAIL state. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>pfail_wanted</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_pfail_nodes</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Compute the maxium totlen to allocate our buffer. We'll fix the totlen
     * later according to the number of gossip sections we really were able
     * to put inside the packet. */</comment>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataGossip</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>wanted</name><operator>+</operator><name>pfail_wanted</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* Note: clusterBuildMessageHdr() expects the buffer to be always at least
     * sizeof(clusterMsg) or more. */</comment>
    <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

    <comment type="block">/* Populate the header. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>link</name><operator>-&gt;</operator><name>node</name></name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>CLUSTERMSG_TYPE_PING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Populate the gossip fields */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>maxiterations</name> <init>= <expr><name>wanted</name><operator>*</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>freshnodes</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>gossipcount</name> <operator>&lt;</operator> <name>wanted</name> <operator>&amp;&amp;</operator> <name>maxiterations</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Don't include this node: the whole packet header is about us
         * already, so we just gossip about other nodes. */</comment>
        <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>myself</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* PFAIL nodes will be added later. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_PFAIL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* In the gossip section don't include:
         * 1) Nodes in HANDSHAKE state.
         * 3) Nodes with the NOADDR flag set.
         * 4) Disconnected nodes if they don't have configured slots.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_HANDSHAKE</name><operator>|</operator><name>CLUSTER_NODE_NOADDR</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name><name>this</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>this</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>freshnodes</name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* Tecnically not correct, but saves CPU. */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Do not add a node we already have. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>clusterNodeIsInGossipSection</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>gossipcount</name></expr></argument>,<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Add it */</comment>
        <expr_stmt><expr><call><name>clusterSetGossipEntry</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>gossipcount</name></expr></argument>,<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>freshnodes</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>gossipcount</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* If there are PFAIL nodes, add them at the end. */</comment>
    <if_stmt><if>if <condition>(<expr><name>pfail_wanted</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pfail_wanted</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_HANDSHAKE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_NOADDR</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_PFAIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>clusterSetGossipEntry</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>gossipcount</name></expr></argument>,<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>freshnodes</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>gossipcount</name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* We take the count of the slots we allocated, since the
             * PFAIL stats may not match perfectly with the current number
             * of PFAIL nodes. */</comment>
            <expr_stmt><expr><name>pfail_wanted</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Ready to send... fix the totlen fiend and queue the message in the
     * output buffer. */</comment>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataGossip</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>gossipcount</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>gossipcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name>link</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a PONG packet to every connected node that's not in handshake state
 * and for which we have a valid link.
 *
 * In Redis Cluster pongs are not used just for failure detection, but also
 * to carry important configuration information. So broadcasting a pong is
 * useful when something changes in the configuration and we want to make
 * the cluster aware ASAP (for instance after a slave promotion).
 *
 * The 'target' argument specifies the receiving instances using the
 * defines below:
 *
 * CLUSTER_BROADCAST_ALL -&gt; All known instances.
 * CLUSTER_BROADCAST_LOCAL_SLAVES -&gt; All slaves in my master-slaves ring.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_BROADCAST_ALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_BROADCAST_LOCAL_SLAVES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>clusterBroadcastPong</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>myself</name> <operator>||</operator> <call><name>nodeInHandshake</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>CLUSTER_BROADCAST_LOCAL_SLAVES</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>local_slave</name> <init>=
                <expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>myself</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_slave</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterSendPing</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_PONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a PUBLISH message.
 *
 * If link is NULL, then the message is broadcasted to the whole cluster. */</comment>
<function><type><name>void</name></type> <name>clusterSendPublish</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>payload</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>channel_len</name></decl>, <decl><type ref="prev"/><name>message_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>channel</name> <operator>=</operator> <call><name>getDecodedObject</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>getDecodedObject</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>channel_len</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>channel</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                               <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (uint32_t) */</comment>
    <name>message_len</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                               <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (uint32_t) */</comment>

    <name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_PUBLISH</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgDataPublish</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">8</literal> <operator>+</operator> <name>channel_len</name> <operator>+</operator> <name>message_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>channel_len</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>channel_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_len</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>message_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Try to use the local buffer if possible */</comment>
    <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>payload</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>payload</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>hdr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>payload</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>bulk_data</name></name></expr></argument>,<argument><expr><name><name>channel</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>channel</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>publish</name><operator>.</operator><name>msg</name><operator>.</operator><name>bulk_data</name></name><operator>+</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>channel</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name><name>message</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>link</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name>link</name></expr></argument>,<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterBroadcastMessage</name><argument_list>(<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>payload</name> <operator>!=</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a FAIL message to all the nodes we are able to contact.
 * The FAIL message is sent when we detect that a node is failing
 * (CLUSTER_NODE_PFAIL) and we also receive a gossip confirmation of this:
 * we switch the node state to CLUSTER_NODE_FAIL and ask all the other
 * nodes to do the same ASAP. */</comment>
<function><type><name>void</name></type> <name>clusterSendFail</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fail</name><operator>.</operator><name>about</name><operator>.</operator><name>nodename</name></name></expr></argument>,<argument><expr><name>nodename</name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterBroadcastMessage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send an UPDATE message to the specified link carrying the specified 'node'
 * slots configuration. The node name, slots bitmap, and configEpoch info
 * are included. */</comment>
<function><type><name>void</name></type> <name>clusterSendUpdate</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>link</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>update</name><operator>.</operator><name>nodecfg</name><operator>.</operator><name>nodename</name></name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>update</name><operator>.</operator><name>nodecfg</name><operator>.</operator><name>configEpoch</name></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>update</name><operator>.</operator><name>nodecfg</name><operator>.</operator><name>slots</name></name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name>link</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a MODULE message.
 *
 * If link is NULL, then the message is broadcasted to the whole cluster. */</comment>
<function><type><name>void</name></type> <name>clusterSendModule</name><parameter_list>(<parameter><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>module_id</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>,
                       <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>heapbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totlen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsgModule</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">3</literal> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>module_id</name></name> <operator>=</operator> <name>module_id</name></expr>;</expr_stmt> <comment type="block">/* Already endian adjusted. */</comment>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Try to use the local buffer if possible */</comment>
    <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>heapbuf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>heapbuf</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>heapbuf</name></expr></argument>,<argument><expr><name>hdr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>heapbuf</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>module</name><operator>.</operator><name>msg</name><operator>.</operator><name>bulk_data</name></name></expr></argument>,<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>link</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name>link</name></expr></argument>,<argument><expr><name>heapbuf</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterBroadcastMessage</name><argument_list>(<argument><expr><name>heapbuf</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>heapbuf</name> <operator>!=</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>heapbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function gets a cluster node ID string as target, the same way the nodes
 * addresses are represented in the modules side, resolves the node, and sends
 * the message. If the target is NULL the message is broadcasted.
 *
 * The function returns C_OK if the target is valid, otherwise C_ERR is
 * returned. */</comment>
<function><type><name>int</name></type> <name>clusterSendModuleMessageToTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>module_id</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>clusterSendModule</name><argument_list>(<argument><expr><ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                      <argument><expr><name>module_id</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER Pub/Sub support
 *
 * For now we do very little, just propagating PUBLISH messages across the whole
 * cluster. In the future we'll try to get smarter and avoiding propagating those
 * messages to hosts without receives for a given channel.
 * -------------------------------------------------------------------------- */</comment>
<function><type><name>void</name></type> <name>clusterPropagatePublish</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>clusterSendPublish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * SLAVE node specific functions
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This function sends a FAILOVE_AUTH_REQUEST message to every node in order to
 * see if there is the quorum for this slave instance to failover its failing
 * master.
 *
 * Note that we send the failover request to everybody, master and slave nodes,
 * but only the masters are supposed to reply to our query. */</comment>
<function><type><name>void</name></type> <name>clusterRequestFailoverAuth</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totlen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit
     * in the header to communicate the nodes receiving the message that
     * they should authorized the failover even if the master is working. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>mflags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name>CLUSTERMSG_FLAG0_FORCEACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterBroadcastMessage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a FAILOVER_AUTH_ACK message to the specified node. */</comment>
<function><type><name>void</name></type> <name>clusterSendFailoverAuth</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totlen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a MFSTART message to the specified node. */</comment>
<function><type><name>void</name></type> <name>clusterSendMFStart</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>clusterMsg</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totlen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterBuildMessageHdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>CLUSTERMSG_TYPE_MFSTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterMsg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr>union <name>clusterMsgData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totlen</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSendMessage</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Vote for the node asking for our vote if there are the conditions. */</comment>
<function><type><name>void</name></type> <name>clusterSendFailoverAuthIfNeeded</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>clusterMsg</name> <modifier>*</modifier></type><name>request</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>requestCurrentEpoch</name> <init>= <expr><call><name>ntohu64</name><argument_list>(<argument><expr><name><name>request</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>requestConfigEpoch</name> <init>= <expr><call><name>ntohu64</name><argument_list>(<argument><expr><name><name>request</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>claimed_slots</name> <init>= <expr><name><name>request</name><operator>-&gt;</operator><name>myslots</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>force_ack</name> <init>= <expr><name><name>request</name><operator>-&gt;</operator><name>mflags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>CLUSTERMSG_FLAG0_FORCEACK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* IF we are not a master serving at least 1 slot, we don't have the
     * right to vote, as the cluster size in Redis Cluster is the number
     * of masters serving at least one slot, and quorum is the cluster
     * size + 1 */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>myself</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Request epoch must be &gt;= our currentEpoch.
     * Note that it is impossible for it to actually be greater since
     * our currentEpoch was updated as a side effect of receiving this
     * request, if the request epoch was greater. */</comment>
    <if_stmt><if>if <condition>(<expr><name>requestCurrentEpoch</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Failover auth denied to %.40s: reqEpoch (%llu) &lt; curEpoch(%llu)"</literal></expr></argument>,
            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name>requestCurrentEpoch</name></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* I already voted for this epoch? Return ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>lastVoteEpoch</name></name> <operator>==</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Failover auth denied to %.40s: already voted for epoch %llu"</literal></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Node must be a slave and its master down.
     * The master can be non failing if the request is flagged
     * with CLUSTERMSG_FLAG0_FORCEACK (manual failover). */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>master</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><operator>!</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name>master</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>force_ack</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"Failover auth denied to %.40s: it is a master node"</literal></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>master</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"Failover auth denied to %.40s: I don't know its master"</literal></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name>master</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"Failover auth denied to %.40s: its master is up"</literal></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We did not voted for a slave about this master for two
     * times the node timeout. This is not strictly needed for correctness
     * of the algorithm but makes the base case more linear. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>voted_time</name></name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Failover auth denied to %.40s: "</literal>
                <literal type="string">"can't vote about this master before %lld milliseconds"</literal></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <operator>(</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>-</operator>
                             <operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>voted_time</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The slave requesting the vote must have a configEpoch for the claimed
     * slots that is &gt;= the one of the masters currently serving the same
     * slots in the current configuration. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>bitmapTestBit</name><argument_list>(<argument><expr><name>claimed_slots</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>configEpoch</name> <operator>&lt;=</operator> <name>requestConfigEpoch</name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* If we reached this point we found a slot that in our current slots
         * is served by a master with a greater configEpoch than the one claimed
         * by the slave requesting our vote. Refuse to vote for this slave. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Failover auth denied to %.40s: "</literal>
                <literal type="string">"slot %d epoch (%llu) &gt; reqEpoch (%llu)"</literal></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>configEpoch</name></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name>requestConfigEpoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></for>

    <comment type="block">/* We can vote for this slave. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>lastVoteEpoch</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>voted_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator><name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSendFailoverAuth</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Failover auth granted to %.40s for epoch %llu"</literal></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function returns the "rank" of this instance, a slave, in the context
 * of its master-slaves ring. The rank of the slave is given by the number of
 * other slaves for the same master that have a better replication offset
 * compared to the local one (better means, greater, so they claim more data).
 *
 * A slave with rank 0 is the one with the greatest (most up to date)
 * replication offset, and so forth. Note that because how the rank is computed
 * multiple slaves may have the same rank, in case they have the same offset.
 *
 * The slave rank is used to add a delay to start an election in order to
 * get voted and replace a failing master. Slaves with better replication
 * offsets are more likely to win. */</comment>
<function><type><name>int</name></type> <name>clusterGetSlaveRank</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>myoffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>rank</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>master</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>master</name> <operator>=</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>master</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Never called by slaves without master. */</comment>

    <expr_stmt><expr><name>myoffset</name> <operator>=</operator> <call><name>replicationGetSlaveOffset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>master</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>myself</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>nodeCantFailover</name><argument_list>(<argument><expr><name><name>master</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>master</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>repl_offset</name> <operator>&gt;</operator> <name>myoffset</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rank</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>rank</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called by clusterHandleSlaveFailover() in order to
 * let the slave log why it is not able to failover. Sometimes there are
 * not the conditions, but since the failover function is called again and
 * again, we can't log the same things continuously.
 *
 * This function works by logging only if a given set of conditions are
 * true:
 *
 * 1) The reason for which the failover can't be initiated changed.
 *    The reasons also include a NONE reason we reset the state to
 *    when the slave finds that its master is fine (no FAIL flag).
 * 2) Also, the log is emitted again if the master is still down and
 *    the reason for not failing over is still the same, but more than
 *    CLUSTER_CANT_FAILOVER_RELOG_PERIOD seconds elapsed.
 * 3) Finally, the function only logs if the slave is down for more than
 *    five seconds + NODE_TIMEOUT. This way nothing is logged when a
 *    failover starts in a reasonable time.
 *
 * The function is called with the reason why the slave can't failover
 * which is one of the integer macros CLUSTER_CANT_FAILOVER_*.
 *
 * The function is guaranteed to be called only if 'myself' is a slave. */</comment>
<function><type><name>void</name></type> <name>clusterLogCantFailover</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>lastlog_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>nolog_fail_time</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name> <operator>+</operator> <literal type="number">5000</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Don't log if we have the same reason for some time. */</comment>
    <if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>cant_failover_reason</name></name> <operator>&amp;&amp;</operator>
        <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>-</operator><name>lastlog_time</name> <operator>&lt;</operator> <name>CLUSTER_CANT_FAILOVER_RELOG_PERIOD</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>cant_failover_reason</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>

    <comment type="block">/* We also don't emit any log if the master failed no long ago, the
     * goal of this function is to log slaves in a stalled condition for
     * a long time. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>&amp;&amp;</operator>
        <call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>fail_time</name></name><operator>)</operator> <operator>&lt;</operator> <name>nolog_fail_time</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name>reason</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CLUSTER_CANT_FAILOVER_DATA_AGE</name></expr>:</case>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"Disconnected from master for longer than allowed. "</literal>
              <literal type="string">"Please check the 'cluster-replica-validity-factor' configuration "</literal>
              <literal type="string">"option."</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>CLUSTER_CANT_FAILOVER_WAITING_DELAY</name></expr>:</case>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"Waiting the delay before I can start a new failover."</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>CLUSTER_CANT_FAILOVER_EXPIRED</name></expr>:</case>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"Failover attempt expired."</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>CLUSTER_CANT_FAILOVER_WAITING_VOTES</name></expr>:</case>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"Waiting for votes, but majority still not reached."</literal></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"Unknown reason code."</literal></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>lastlog_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Currently unable to failover: %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function implements the final part of automatic and manual failovers,
 * where the slave grabs its master's hash slots, and propagates the new
 * configuration.
 *
 * Note that it's up to the caller to be sure that the node got a new
 * configuration epoch already. */</comment>
<function><type><name>void</name></type> <name>clusterFailoverReplaceYourMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>oldmaster</name> <init>= <expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>oldmaster</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* 1) Turn this node into a master. */</comment>
    <expr_stmt><expr><call><name>clusterSetNodeAsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replicationUnsetMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 2) Claim all the slots assigned to our master. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>clusterNodeGetSlotBit</name><argument_list>(<argument><expr><name>oldmaster</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterAddSlot</name><argument_list>(<argument><expr><name>myself</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* 3) Update state and save config. */</comment>
    <expr_stmt><expr><call><name>clusterUpdateState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterSaveConfigOrDie</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 4) Pong all the other nodes so that they can update the state
     *    accordingly and detect that we switched to master role. */</comment>
    <expr_stmt><expr><call><name>clusterBroadcastPong</name><argument_list>(<argument><expr><name>CLUSTER_BROADCAST_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 5) If there was a manual failover in progress, clear the state. */</comment>
    <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called if we are a slave node and our master serving
 * a non-zero amount of hash slots is in FAIL state.
 *
 * The gaol of this function is:
 * 1) To check if we are able to perform a failover, is our data updated?
 * 2) Try to get elected by masters.
 * 3) Perform the failover informing all the other nodes.
 */</comment>
<function><type><name>void</name></type> <name>clusterHandleSlaveFailover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>data_age</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>auth_age</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needed_quorum</name> <init>= <expr><operator>(</operator><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>manual_failover</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                          <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_can_start</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>auth_timeout</name></decl>, <decl><type ref="prev"/><name>auth_retry_time</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_TODO_HANDLE_FAILOVER</name></expr>;</expr_stmt>

    <comment type="block">/* Compute the failover timeout (the max time we have to send votes
     * and wait for replies), and the failover retry time (the time to wait
     * before trying to get voted again).
     *
     * Timeout is MAX(NODE_TIMEOUT*2,2000) milliseconds.
     * Retry is two times the Timeout.
     */</comment>
    <expr_stmt><expr><name>auth_timeout</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>auth_timeout</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>auth_timeout</name> <operator>=</operator> <literal type="number">2000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>auth_retry_time</name> <operator>=</operator> <name>auth_timeout</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/* Pre conditions to run the function, that must be met both in case
     * of an automatic or manual failover:
     * 1) We are a slave.
     * 2) Our master is flagged as FAIL, or this is a manual failover.
     * 3) We don't have the no failover configuration set, and this is
     *    not a manual failover.
     * 4) It is serving slots. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><operator>!</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>manual_failover</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>server</name><operator>.</operator><name>cluster_slave_no_failover</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>manual_failover</name><operator>)</operator> <operator>||</operator>
        <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* There are no reasons to failover, so we set the reason why we
         * are returning without failing over to NONE. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>cant_failover_reason</name></name> <operator>=</operator> <name>CLUSTER_CANT_FAILOVER_NONE</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set data_age to the number of seconds we are disconnected from
     * the master. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>data_age</name> <operator>=</operator> <operator>(</operator><name>mstime_t</name><operator>)</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>lastinteraction</name></name><operator>)</operator>
                   <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>data_age</name> <operator>=</operator> <operator>(</operator><name>mstime_t</name><operator>)</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>repl_down_since</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Remove the node timeout from the data age as it is fine that we are
     * disconnected from our master at least for the time it was down to be
     * flagged as FAIL, that's the baseline. */</comment>
    <if_stmt><if>if <condition>(<expr><name>data_age</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>data_age</name> <operator>-=</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check if our data is recent enough according to the slave validity
     * factor configured by the user.
     *
     * Check bypassed for manual failovers. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_slave_validity_factor</name></name> <operator>&amp;&amp;</operator>
        <name>data_age</name> <operator>&gt;</operator>
        <operator>(</operator><operator>(</operator><operator>(</operator><name>mstime_t</name><operator>)</operator><name><name>server</name><operator>.</operator><name>repl_ping_slave_period</name></name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator> <operator>+</operator>
         <operator>(</operator><name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name> <operator>*</operator> <name><name>server</name><operator>.</operator><name>cluster_slave_validity_factor</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>manual_failover</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterLogCantFailover</name><argument_list>(<argument><expr><name>CLUSTER_CANT_FAILOVER_DATA_AGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the previous failover attempt timedout and the retry time has
     * elapsed, we can setup a new one. */</comment>
    <if_stmt><if>if <condition>(<expr><name>auth_age</name> <operator>&gt;</operator> <name>auth_retry_time</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call> <operator>+</operator>
            <literal type="number">500</literal> <operator>+</operator> <comment type="block">/* Fixed delay of 500 milliseconds, let FAIL msg propagate. */</comment>
            <call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">500</literal></expr>;</expr_stmt> <comment type="block">/* Random delay between 0 and 500 milliseconds. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name> <operator>=</operator> <call><name>clusterGetSlaveRank</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We add another delay that is proportional to the slave rank.
         * Specifically 1 second * rank. This way slaves that have a probably
         * less updated replication offset, are penalized. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name> <operator>+=</operator>
            <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        <comment type="block">/* However if this is a manual failover, no delay is needed. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_HANDLE_FAILOVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Start of election delayed for %lld milliseconds "</literal>
            <literal type="string">"(rank #%d, offset %lld)."</literal></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name> <operator>-</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name></expr></argument>,
            <argument><expr><call><name>replicationGetSlaveOffset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Now that we have a scheduled election, broadcast our offset
         * to all the other slaves so that they'll updated their offsets
         * if our offset is better. */</comment>
        <expr_stmt><expr><call><name>clusterBroadcastPong</name><argument_list>(<argument><expr><name>CLUSTER_BROADCAST_LOCAL_SLAVES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* It is possible that we received more updated offsets from other
     * slaves for the same master since we computed our election delay.
     * Update the delay if our rank changed.
     *
     * Not performed if this is a manual failover. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_sent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>newrank</name> <init>= <expr><call><name>clusterGetSlaveRank</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>newrank</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>added_delay</name> <init>=
                <expr><operator>(</operator><name>newrank</name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name> <operator>+=</operator> <name>added_delay</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_rank</name></name> <operator>=</operator> <name>newrank</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Replica rank updated to #%d, added %lld milliseconds of delay."</literal></expr></argument>,
                <argument><expr><name>newrank</name></expr></argument>, <argument><expr><name>added_delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return ASAP if we can't still start the election. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>mstime</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_time</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterLogCantFailover</name><argument_list>(<argument><expr><name>CLUSTER_CANT_FAILOVER_WAITING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return ASAP if the election is too old to be valid. */</comment>
    <if_stmt><if>if <condition>(<expr><name>auth_age</name> <operator>&gt;</operator> <name>auth_timeout</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterLogCantFailover</name><argument_list>(<argument><expr><name>CLUSTER_CANT_FAILOVER_EXPIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Ask for votes if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_sent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_epoch</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Starting a failover election for epoch %llu."</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterRequestFailoverAuth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_sent</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator>
                             <name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator>
                             <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return> <comment type="block">/* Wait for replies. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if we reached the quorum. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_count</name></name> <operator>&gt;=</operator> <name>needed_quorum</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We have the quorum, we can finally failover the master. */</comment>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Failover election won: I'm the new master."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Update my configEpoch to the epoch of the election. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_epoch</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>failover_auth_epoch</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"configEpoch set to %llu after successful failover"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Take responsibility for the cluster slots. */</comment>
        <expr_stmt><expr><call><name>clusterFailoverReplaceYourMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>clusterLogCantFailover</name><argument_list>(<argument><expr><name>CLUSTER_CANT_FAILOVER_WAITING_VOTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER slave migration
 *
 * Slave migration is the process that allows a slave of a master that is
 * already covered by at least another slave, to "migrate" to a master that
 * is orpaned, that is, left with no working slaves.
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* This function is responsible to decide if this replica should be migrated
 * to a different (orphaned) master. It is called by the clusterCron() function
 * only if:
 *
 * 1) We are a slave node.
 * 2) It was detected that there is at least one orphaned master in
 *    the cluster.
 * 3) We are a slave of one of the masters with the greatest number of
 *    slaves.
 *
 * This checks are performed by the caller since it requires to iterate
 * the nodes anyway, so we spend time into clusterHandleSlaveMigration()
 * if definitely needed.
 *
 * The fuction is called with a pre-computed max_slaves, that is the max
 * number of working (not in FAIL state) slaves for a single master.
 *
 * Additional conditions for migration are examined inside the function.
 */</comment>
<function><type><name>void</name></type> <name>clusterHandleSlaveMigration</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_slaves</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>okslaves</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>mymaster</name> <init>= <expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>candidate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <comment type="block">/* Step 1: Don't migrate if the cluster state is not ok. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CLUSTER_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Step 2: Don't migrate if my master will not be left with at least
     *         'migration-barrier' slaves after my migration. */</comment>
    <if_stmt><if>if <condition>(<expr><name>mymaster</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>mymaster</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>mymaster</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>nodeTimedOut</name><argument_list>(<argument><expr><name><name>mymaster</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>okslaves</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>okslaves</name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>cluster_migration_barrier</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Step 3: Identify a candidate for migration, and check if among the
     * masters with the greatest number of ok slaves, I'm the one with the
     * smallest node ID (the "candidate slave").
     *
     * Note: this means that eventually a replica migration will occur
     * since slaves that are reachable again always have their FAIL flag
     * cleared, so eventually there must be a candidate. At the same time
     * this does not mean that there are no race conditions possible (two
     * slaves migrating at the same time), but this is unlikely to
     * happen, and harmless when happens. */</comment>
    <expr_stmt><expr><name>candidate</name> <operator>=</operator> <name>myself</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>okslaves</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_orphaned</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We want to migrate only if this master is working, orphaned, and
         * used to have slaves or if failed over a master that had slaves
         * (MIGRATE_TO flag). This way we only migrate to instances that were
         * supposed to have replicas. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>nodeFailed</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_orphaned</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MIGRATE_TO</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_orphaned</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Check number of working slaves. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>okslaves</name> <operator>=</operator> <call><name>clusterCountNonFailingSlaves</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>okslaves</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_orphaned</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>is_orphaned</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslots</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>target</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Track the starting time of the orphaned condition for this
             * master. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>orphaned_time</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>orphaned_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>orphaned_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Check if I'm the slave candidate for the migration: attached
         * to a master with the maximum number of slaves and with the smallest
         * node ID. */</comment>
        <if_stmt><if>if <condition>(<expr><name>okslaves</name> <operator>==</operator> <name>max_slaves</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
                           <argument><expr><name><name>candidate</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                           <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>candidate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Step 4: perform the migration if there is a target, and if I'm the
     * candidate, but only if the master is continuously orphaned for a
     * couple of seconds, so that during failovers, we give some time to
     * the natural slaves of this instance to advertise their switch from
     * the old master to the new one. */</comment>
    <if_stmt><if>if <condition>(<expr><name>target</name> <operator>&amp;&amp;</operator> <name>candidate</name> <operator>==</operator> <name>myself</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name><name>target</name><operator>-&gt;</operator><name>orphaned_time</name></name><operator>)</operator> <operator>&gt;</operator> <name>CLUSTER_SLAVE_MIGRATION_DELAY</name> <operator>&amp;&amp;</operator>
       <operator>!</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MODULE_FLAG_NO_FAILOVER</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Migrating to orphaned master %.40s"</literal></expr></argument>,
            <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterSetMaster</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER manual failover
 *
 * This are the important steps performed by slaves during a manual failover:
 * 1) User send CLUSTER FAILOVER command. The failover state is initialized
 *    setting mf_end to the millisecond unix time at which we'll abort the
 *    attempt.
 * 2) Slave sends a MFSTART message to the master requesting to pause clients
 *    for two times the manual failover timeout CLUSTER_MF_TIMEOUT.
 *    When master is paused for manual failover, it also starts to flag
 *    packets with CLUSTERMSG_FLAG0_PAUSED.
 * 3) Slave waits for master to send its replication offset flagged as PAUSED.
 * 4) If slave received the offset from the master, and its offset matches,
 *    mf_can_start is set to 1, and clusterHandleSlaveFailover() will perform
 *    the failover as usually, with the difference that the vote request
 *    will be modified to force masters to vote for a slave that has a
 *    working master.
 *
 * From the point of view of the master things are simpler: when a
 * PAUSE_CLIENTS packet is received the master sets mf_end as well and
 * the sender in mf_slave. During the time limit for the manual failover
 * the master will just send PINGs more often to this slave, flagged with
 * the PAUSED flag, so that the slave will set mf_master_offset when receiving
 * a packet from the master with this flag set.
 *
 * The gaol of the manual failover is to perform a fast failover without
 * data loss due to the asynchronous master-slave replication.
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Reset the manual failover state. This works for both masters and slavesa
 * as all the state about manual failover is cleared.
 *
 * The function can be used both to initialize the manual failover state at
 * startup or to abort a manual failover in progress. */</comment>
<function><type><name>void</name></type> <name>resetManualFailover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>&amp;&amp;</operator> <call><name>clientsArePaused</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>clients_pause_end_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clientsArePaused</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Just use the side effect of the function. */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* No manual failover in progress. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_can_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_slave</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_master_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* If a manual failover timed out, abort it. */</comment>
<function><type><name>void</name></type> <name>manualFailoverCheckTimeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>&lt;</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Manual failover timed out."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called from the cluster cron function in order to go
 * forward with a manual failover state machine. */</comment>
<function><type><name>void</name></type> <name>clusterHandleManualFailover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Return ASAP if no manual failover is in progress. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If mf_can_start is non-zero, the failover was already triggered so the
     * next steps are performed by clusterHandleSlaveFailover(). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_can_start</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_master_offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Wait for offset... */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_master_offset</name></name> <operator>==</operator> <call><name>replicationGetSlaveOffset</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Our replication offset matches the master replication offset
         * announced after clients were paused. We can start the failover. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_can_start</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"All master replication stream processed, "</literal>
            <literal type="string">"manual failover can start."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER cron job
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This is executed 10 times every second */</comment>
<function><type><name>void</name></type> <name>clusterCron</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>update_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>orphaned_masters</name></decl>;</decl_stmt> <comment type="block">/* How many masters there are without ok slaves. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_slaves</name></decl>;</decl_stmt> <comment type="block">/* Max number of ok slaves for a single master. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>this_slaves</name></decl>;</decl_stmt> <comment type="block">/* Number of ok slaves for our master (if we are slave). */</comment>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>min_pong</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>min_pong_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PORT_ULONGLONG</name></type> <name>iteration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>handshake_timeout</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iteration</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Number of times this function was called so far. */</comment>

    <comment type="block">/* We want to take myself-&gt;ip in sync with the cluster-announce-ip option.
     * The option can be set at runtime via CONFIG SET, so we periodically check
     * if the option changed to reflect this into myself-&gt;ip. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>prev_ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curr_ip</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster_announce_ip</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>changed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>prev_ip</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>curr_ip</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>changed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>prev_ip</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>curr_ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>changed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>prev_ip</name> <operator>&amp;&amp;</operator> <name>curr_ip</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>prev_ip</name></expr></argument>,<argument><expr><name>curr_ip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>changed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>prev_ip</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>prev_ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>prev_ip</name> <operator>=</operator> <name>curr_ip</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>curr_ip</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* We always take a copy of the previous IP address, by
                 * duplicating the string. This way later we can check if
                 * the address really changed. */</comment>
                <expr_stmt><expr><name>prev_ip</name> <operator>=</operator> <call><name>zstrdup</name><argument_list>(<argument><expr><name>prev_ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cluster_announce_ip</name></name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>ip</name><index>[<expr><name>NET_IP_STR_LEN</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* Force autodetection. */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* The handshake timeout is the time after which a handshake node that was
     * not turned into a normal node is removed from the nodes. Usually it is
     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use
     * the value of 1 second. */</comment>
    <expr_stmt><expr><name>handshake_timeout</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>handshake_timeout</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>handshake_timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Update myself flags. */</comment>
    <expr_stmt><expr><call><name>clusterUpdateMyselfFlags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if we have disconnected nodes and re-establish the connection.
     * Also update a few stats while we are here, that can be used to make
     * better decisions in other part of the code. */</comment>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_pfail_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Not interested in reconnecting the link with myself or nodes
         * for which we have no address. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_MYSELF</name><operator>|</operator><name>CLUSTER_NODE_NOADDR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_PFAIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_pfail_nodes</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* A Node in HANDSHAKE state has a limited lifespan equal to the
         * configured node timeout. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeInHandshake</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>ctime</name></name> <operator>&gt;</operator> <name>handshake_timeout</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterDelNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>mstime_t</name></type> <name>old_ping_sent</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>clusterLink</name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>anetTcpNonBlockBindConnect</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>, <argument><expr><name>NET_FIRST_BIND_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* We got a synchronous error from connect before
                 * clusterSendPing() had a chance to be called.
                 * If node-&gt;ping_sent is zero, failure detection can't work,
                 * so we claim we actually sent a ping now (that will
                 * be really sent as soon as the link is obtained). */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Unable to connect to "</literal>
                    <literal type="string">"Cluster Node [%s]:%d -&gt; %s"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>createClusterLink</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>link</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>link</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>,
                    <argument><expr><name>clusterReadHandler</name></expr></argument>,<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Queue a PING in the new connection ASAP: this is crucial
             * to avoid false positives in failure detection.
             *
             * If the node is flagged as MEET, we send a MEET message instead
             * of a PING one, to force the receiver to add us in its node
             * table. */</comment>
            <expr_stmt><expr><name>old_ping_sent</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterSendPing</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MEET</name></expr> ?</condition><then>
                    <expr><name>CLUSTERMSG_TYPE_MEET</name></expr> </then><else>: <expr><name>CLUSTERMSG_TYPE_PING</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>old_ping_sent</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If there was an active ping before the link was
                 * disconnected, we want to restore the ping time, otherwise
                 * replaced by the clusterSendPing() call. */</comment>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <name>old_ping_sent</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* We can clear the flag after the first packet is sent.
             * If we'll never receive a PONG, we'll never send new packets
             * to this node. Instead after the PONG is received and we
             * are no longer in meet/handshake status, we want to send
             * normal PING packets. */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_NODE_MEET</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"Connecting with Node %.40s at %s:%d"</literal></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Ping some random node 1 time every 10 iterations, so that we usually ping
     * one random node every second. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>iteration</name> <operator>%</operator> <literal type="number">10</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Check a few random nodes and ping the one with the oldest
         * pong_received time. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Don't ping nodes disconnected or with a ping currently active. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>this</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_MYSELF</name><operator>|</operator><name>CLUSTER_NODE_HANDSHAKE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>min_pong_node</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>min_pong</name> <operator>&gt;</operator> <name><name>this</name><operator>-&gt;</operator><name>pong_received</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>min_pong_node</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>min_pong</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>pong_received</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>min_pong_node</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"Pinging node %.40s"</literal></expr></argument>, <argument><expr><name><name>min_pong_node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterSendPing</name><argument_list>(<argument><expr><name><name>min_pong_node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>CLUSTERMSG_TYPE_PING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Iterate nodes to check if we need to flag something as failing.
     * This loop is also responsible to:
     * 1) Check if there are orphaned masters (masters without non failing
     *    slaves).
     * 2) Count the max number of non failing slaves for a single master.
     * 3) Count the number of slaves for our master, if we are a slave. */</comment>
    <expr_stmt><expr><name>orphaned_masters</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_slaves</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>this_slaves</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Use an updated time at every iteration. */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator>
            <operator>(</operator><name>CLUSTER_NODE_MYSELF</name><operator>|</operator><name>CLUSTER_NODE_NOADDR</name><operator>|</operator><name>CLUSTER_NODE_HANDSHAKE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Orphaned master check, useful only if the current instance
         * is a slave that may migrate to another master. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>okslaves</name> <init>= <expr><call><name>clusterCountNonFailingSlaves</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* A master is orphaned if it is serving a non-zero number of
             * slots, have no working slaves, but used to have at least one
             * slave, or failed over a master that used to have slaves. */</comment>
            <if_stmt><if>if <condition>(<expr><name>okslaves</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslots</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MIGRATE_TO</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>orphaned_masters</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>okslaves</name> <operator>&gt;</operator> <name>max_slaves</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_slaves</name> <operator>=</operator> <name>okslaves</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>this_slaves</name> <operator>=</operator> <name>okslaves</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we are not receiving any data for more than half the cluster
         * timeout, reconnect the link: maybe there is a connection
         * issue even if the node is alive. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>&amp;&amp;</operator> <comment type="block">/* is connected */</comment>
            <name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>link</name><operator>-&gt;</operator><name>ctime</name></name> <operator>&gt;</operator>
            <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name> <operator>&amp;&amp;</operator> <comment type="block">/* was not already reconnected */</comment>
            <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>&amp;&amp;</operator> <comment type="block">/* we already sent a ping */</comment>
            <name><name>node</name><operator>-&gt;</operator><name>pong_received</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>&amp;&amp;</operator> <comment type="block">/* still waiting pong */</comment>
            <comment type="block">/* and we are waiting for the pong more than timeout/2 */</comment>
            <name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name><operator>/</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <comment type="block">/* and in such interval we are not seeing any traffic at all. */</comment>
            <name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>data_received</name></name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name><operator>/</operator><literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Disconnect the link, it will be reconnected automatically. */</comment>
            <expr_stmt><expr><call><name>freeClusterLink</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we have currently no active ping in this instance, and the
         * received PONG is older than half the cluster timeout, send
         * a new ping now, to ensure all the nodes are pinged without
         * a too big delay. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>&amp;&amp;</operator>
            <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>pong_received</name></name><operator>)</operator> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name><operator>/</operator><literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>clusterSendPing</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>CLUSTERMSG_TYPE_PING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we are a master and one of the slaves requested a manual
         * failover, ping it continuously. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>&amp;&amp;</operator>
            <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_slave</name></name> <operator>==</operator> <name>node</name> <operator>&amp;&amp;</operator>
            <name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>clusterSendPing</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>CLUSTERMSG_TYPE_PING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check only if we have an active ping for this instance. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Compute the delay of the PONG. Note that if we already received
         * the PONG, then node-&gt;ping_sent is zero, so can't reach this
         * code at all. */</comment>
        <decl_stmt><decl><type><name>mstime_t</name></type> <name>delay</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We consider every incoming data as proof of liveness, since
         * our cluster bus link is also used for data: under heavy data
         * load pong delays are possible. */</comment>
        <decl_stmt><decl><type><name>mstime_t</name></type> <name>data_delay</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>data_received</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>data_delay</name> <operator>&lt;</operator> <name>delay</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>delay</name> <operator>=</operator> <name>data_delay</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Timeout reached. Set the node as possibly failing if it is
             * not already in this state. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_PFAIL</name><operator>|</operator><name>CLUSTER_NODE_FAIL</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"*** NODE %.40s possibly failing"</literal></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_PFAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>update_state</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we are a slave node but the replication is still turned off,
     * enable it if we know the address of our master and it appears to
     * be up. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>&amp;&amp;</operator>
        <call><name>nodeHasAddr</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>replicationSetMaster</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Abourt a manual failover if the timeout is reached. */</comment>
    <expr_stmt><expr><call><name>manualFailoverCheckTimeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterHandleManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MODULE_FLAG_NO_FAILOVER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterHandleSlaveFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* If there are orphaned slaves, and we are a slave among the masters
         * with the max number of non-failing slaves, consider migrating to
         * the orphaned masters. Note that it does not make sense to try
         * a migration if there is no master with at least *two* working
         * slaves. */</comment>
        <if_stmt><if>if <condition>(<expr><name>orphaned_masters</name> <operator>&amp;&amp;</operator> <name>max_slaves</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>this_slaves</name> <operator>==</operator> <name>max_slaves</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterHandleSlaveMigration</name><argument_list>(<argument><expr><name>max_slaves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>update_state</name> <operator>||</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CLUSTER_FAIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterUpdateState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called before the event handler returns to sleep for
 * events. It is useful to perform operations that must be done ASAP in
 * reaction to events fired but that are not safe to perform inside event
 * handlers, or to perform potentially expansive tasks that we need to do
 * a single time before replying to clients. */</comment>
<function><type><name>void</name></type> <name>clusterBeforeSleep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Handle failover, this is needed when it is likely that there is already
     * the quorum from masters in order to react fast. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;</operator> <name>CLUSTER_TODO_HANDLE_FAILOVER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterHandleSlaveFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Update the cluster state. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;</operator> <name>CLUSTER_TODO_UPDATE_STATE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterUpdateState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Save the config, possibly using fsync. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;</operator> <name>CLUSTER_TODO_SAVE_CONFIG</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>fsync</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;</operator>
                    <name>CLUSTER_TODO_FSYNC_CONFIG</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>clusterSaveConfigOrDie</name><argument_list>(<argument><expr><name>fsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Reset our flags (not strictly needed since every single function
     * called for flags set should be able to clear its flag). */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clusterDoBeforeSleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Slots management
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Test bit 'pos' in a generic bitmap. Return 1 if the bit is set,
 * otherwise 0. */</comment>
<function><type><name>int</name></type> <name>bitmapTestBit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>off_t</name></type> <name>byte</name> <init>= <expr><name>pos</name><operator>/</operator><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><name>pos</name><operator>&amp;</operator><literal type="number">7</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><name><name>bitmap</name><index>[<expr><name>byte</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>bit</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set the bit at position 'pos' in a bitmap. */</comment>
<function><type><name>void</name></type> <name>bitmapSetBit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>off_t</name></type> <name>byte</name> <init>= <expr><name>pos</name><operator>/</operator><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><name>pos</name><operator>&amp;</operator><literal type="number">7</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>bitmap</name><index>[<expr><name>byte</name></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>bit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Clear the bit at position 'pos' in a bitmap. */</comment>
<function><type><name>void</name></type> <name>bitmapClearBit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>off_t</name></type> <name>byte</name> <init>= <expr><name>pos</name><operator>/</operator><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><name>pos</name><operator>&amp;</operator><literal type="number">7</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>bitmap</name><index>[<expr><name>byte</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>bit</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if there is at least one master with slaves in the cluster.
 * Otherwise zero is returned. Used by clusterNodeSetSlotBit() to set the
 * MIGRATE_TO flag the when a master gets the first slot. */</comment>
<function><type><name>int</name></type> <name>clusterMastersHaveSlaves</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slaves</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>slaves</name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>slaves</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set the slot bit and return the old value. */</comment>
<function><type><name>int</name></type> <name>clusterNodeSetSlotBit</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>old</name> <init>= <expr><call><name>bitmapTestBit</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>bitmapSetBit</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>old</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>numslots</name></name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* When a master gets its first slot, even if it has no slaves,
         * it gets flagged with MIGRATE_TO, that is, the master is a valid
         * target for replicas migration, if and only if at least one of
         * the other masters has slaves right now.
         *
         * Normally masters are valid targerts of replica migration if:
         * 1. The used to have slaves (but no longer have).
         * 2. They are slaves failing over a master that used to have slaves.
         *
         * However new masters with slots assigned are considered valid
         * migration tagets if the rest of the cluster is not a slave-less.
         *
         * See https://github.com/antirez/redis/issues/3043 for more info. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>clusterMastersHaveSlaves</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_MIGRATE_TO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Clear the slot bit and return the old value. */</comment>
<function><type><name>int</name></type> <name>clusterNodeClearSlotBit</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>old</name> <init>= <expr><call><name>bitmapTestBit</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>bitmapClearBit</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>old</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>numslots</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the slot bit from the cluster node structure. */</comment>
<function><type><name>int</name></type> <name>clusterNodeGetSlotBit</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>bitmapTestBit</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add the specified slot to the list of slots that node 'n' will
 * serve. Return C_OK if the operation ended with success.
 * If the slot is already assigned to another instance this is considered
 * an error and C_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>clusterAddSlot</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterNodeSetSlotBit</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete the specified slot marking it as unassigned.
 * Returns C_OK if the slot was assigned, otherwise if the slot was
 * already unassigned C_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>clusterDelSlot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>clusterNodeClearSlotBit</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete all the slots associated with the specified node.
 * The number of deleted slots is returned. */</comment>
<function><type><name>int</name></type> <name>clusterDelNodeSlots</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>clusterNodeGetSlotBit</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>deleted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Clear the migrating / importing state for all the slots.
 * This is useful at initialization and when turning a master into slave. */</comment>
<function><type><name>void</name></type> <name>clusterCloseAllSlots</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Cluster state evaluation function
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* The following are defines that are only used in the evaluation function
 * and are based on heuristics. Actually the main point about the rejoin and
 * writable delay is that they should be a few orders of magnitude larger
 * than the network latency. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MAX_REJOIN_DELAY</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MIN_REJOIN_DELAY</name></cpp:macro> <cpp:value>500</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_WRITABLE_DELAY</name></cpp:macro> <cpp:value>2000</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>clusterUpdateState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>new_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>reachable_masters</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>mstime_t</name></type> <name>among_minority_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>mstime_t</name></type> <name>first_call_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>todo_before_sleep</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLUSTER_TODO_UPDATE_STATE</name></expr>;</expr_stmt>

    <comment type="block">/* If this is a master node, wait some time before turning the state
     * into OK, since it is not a good idea to rejoin the cluster as a writable
     * master, after a reboot, without giving the cluster a chance to
     * reconfigure this node. Note that the delay is calculated starting from
     * the first call to this function and not since the server start, in order
     * to don't count the DB loading time. */</comment>
    <if_stmt><if>if <condition>(<expr><name>first_call_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_call_time</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CLUSTER_FAIL</name> <operator>&amp;&amp;</operator>
        <call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>first_call_time</name> <operator>&lt;</operator> <name>CLUSTER_WRITABLE_DELAY</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Start assuming the state is OK. We'll turn it into FAIL if there
     * are the right conditions. */</comment>
    <expr_stmt><expr><name>new_state</name> <operator>=</operator> <name>CLUSTER_OK</name></expr>;</expr_stmt>

    <comment type="block">/* Check if all the slots are covered. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_require_full_coverage</name></name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_state</name> <operator>=</operator> <name>CLUSTER_FAIL</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute the cluster size, that is the number of master nodes
     * serving at least a single slot.
     *
     * At the same time count the number of reachable masters having
     * at least one slot. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslots</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_FAIL</name><operator>|</operator><name>CLUSTER_NODE_PFAIL</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>reachable_masters</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* If we are in a minority partition, change the cluster state
     * to FAIL. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>needed_quorum</name> <init>= <expr><operator>(</operator><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>reachable_masters</name> <operator>&lt;</operator> <name>needed_quorum</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>new_state</name> <operator>=</operator> <name>CLUSTER_FAIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>among_minority_time</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Log a state change */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_state</name> <operator>!=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>mstime_t</name></type> <name>rejoin_delay</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster_node_timeout</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If the instance is a master and was partitioned away with the
         * minority, don't let it accept queries for some time after the
         * partition heals, to make sure there is enough time to receive
         * a configuration update. */</comment>
        <if_stmt><if>if <condition>(<expr><name>rejoin_delay</name> <operator>&gt;</operator> <name>CLUSTER_MAX_REJOIN_DELAY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rejoin_delay</name> <operator>=</operator> <name>CLUSTER_MAX_REJOIN_DELAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>rejoin_delay</name> <operator>&lt;</operator> <name>CLUSTER_MIN_REJOIN_DELAY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rejoin_delay</name> <operator>=</operator> <name>CLUSTER_MIN_REJOIN_DELAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>new_state</name> <operator>==</operator> <name>CLUSTER_OK</name> <operator>&amp;&amp;</operator>
            <call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>among_minority_time</name> <operator>&lt;</operator> <name>rejoin_delay</name></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Change the state and log the event. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Cluster state changed: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>new_state</name> <operator>==</operator> <name>CLUSTER_OK</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"fail"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>new_state</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called after the node startup in order to verify that data
 * loaded from disk is in agreement with the cluster configuration:
 *
 * 1) If we find keys about hash slots we have no responsibility for, the
 *    following happens:
 *    A) If no other node is in charge according to the current cluster
 *       configuration, we add these slots to our node.
 *    B) If according to our config other nodes are already in charge for
 *       this lots, we set the slots as IMPORTING from our point of view
 *       in order to justify we have those slots, and in order to make
 *       redis-trib aware of the issue, so that it can try to fix it.
 * 2) If we find data in a DB different than DB0 we return C_ERR to
 *    signal the caller it should quit the server with an error message
 *    or take other actions.
 *
 * The function always returns C_OK even if it will try to correct
 * the error described in "1". However if data is found in DB different
 * from DB0, C_ERR is returned.
 *
 * The function also uses the logging facility in order to warn the user
 * about desynchronizations between the data we have in memory and the
 * cluster configuration. */</comment>
<function><type><name>int</name></type> <name>verifyClusterConfigWithData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>update_config</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Return ASAP if a module disabled cluster redirections. In that case
     * every master can store keys about every possible hash slot. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MODULE_FLAG_NO_REDIRECTION</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If this node is a slave, don't perform the check at all as we
     * completely depend on the replication stream. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Make sure we only have keys in DB0. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Check that all the slots we see populated memory have a corresponding
     * entry in the cluster table. Otherwise fix the table. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>countKeysInSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* No keys in this slot. */</comment>
        <comment type="block">/* Check if we are assigned to this slot or if we are importing it.
         * In both cases check the next slot as the configuration makes
         * sense. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>myself</name> <operator>||</operator>
            <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* If we are here data and cluster config don't agree, and we have
         * slot 'j' populated even if we are not importing it, nor we are
         * assigned to this slot. Fix this condition. */</comment>

        <expr_stmt><expr><name>update_config</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Case A: slot is unassigned. Take responsibility for it. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"I have keys for unassigned slot %d. "</literal>
                                    <literal type="string">"Taking responsibility for it."</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterAddSlot</name><argument_list>(<argument><expr><name>myself</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"I have keys for slot %d, but the slot is "</literal>
                                    <literal type="string">"assigned to another node. "</literal>
                                    <literal type="string">"Setting it to importing state."</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>update_config</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterSaveConfigOrDie</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * SLAVE nodes handling
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Set the specified node 'n' as master for this node.
 * If this node is currently a master, it is turned into a slave. */</comment>
<function><type><name>void</name></type> <name>clusterSetMaster</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CLUSTER_NODE_MASTER</name><operator>|</operator><name>CLUSTER_NODE_MIGRATE_TO</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_NODE_SLAVE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterCloseAllSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterNodeRemoveSlave</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>,<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterNodeAddSlave</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replicationSetMaster</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Nodes to string representation functions.
 * -------------------------------------------------------------------------- */</comment>

<struct>struct <name>redisNodeFlags</name> <block>{
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>flag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>redisNodeFlags</name></name></type> <name><name>redisNodeFlagsTable</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><name>CLUSTER_NODE_MYSELF</name></expr>,       <expr><literal type="string">"myself,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_MASTER</name></expr>,       <expr><literal type="string">"master,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_SLAVE</name></expr>,        <expr><literal type="string">"slave,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_PFAIL</name></expr>,        <expr><literal type="string">"fail?,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_FAIL</name></expr>,         <expr><literal type="string">"fail,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_HANDSHAKE</name></expr>,    <expr><literal type="string">"handshake,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_NOADDR</name></expr>,       <expr><literal type="string">"noaddr,"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>CLUSTER_NODE_NOFAILOVER</name></expr>,   <expr><literal type="string">"nofailover,"</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Concatenate the comma separated list of node flags to the given SDS
 * string 'ci'. */</comment>
<function><type><name>sds</name></type> <name>representClusterNodeFlags</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>ci</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>orig_len</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>redisNodeFlagsTable</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>redisNodeFlags</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>redisNodeFlags</name></name> <modifier>*</modifier></type><name>nodeflag</name> <init>= <expr><name>redisNodeFlagsTable</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name><name>nodeflag</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name><name>nodeflag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* If no flag was added, add the "noflags" special flag. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>orig_len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">"noflags,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Remove trailing comma. */</comment>
    <return>return <expr><name>ci</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate a csv-alike representation of the specified cluster node.
 * See clusterGenNodesDescription() top comment for more information.
 *
 * The function returns the string representation as an SDS string. */</comment>
<function><type><name>sds</name></type> <name>clusterGenNodeDescription</name><parameter_list>(<parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ci</name></decl>;</decl_stmt>

    <comment type="block">/* Node coordinates */</comment>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%.40s %s:%d@%d "</literal></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Flags */</comment>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>representClusterNodeFlags</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Slave of... or just "-" */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">" %.40s "</literal></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">" - "</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Latency from the POV of this node, config epoch, link status */</comment>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">"%lld %lld %llu %s"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>pong_received</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>link</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MYSELF</name><operator>)</operator></expr> ?</condition><then>
                    <expr><literal type="string">"connected"</literal></expr> </then><else>: <expr><literal type="string">"disconnected"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Slots served by this instance */</comment>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bit</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>bit</name> <operator>=</operator> <call><name>clusterNodeGetSlotBit</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>bit</name> <operator>||</operator> <name>j</name> <operator>==</operator> <name>CLUSTER_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <name>CLUSTER_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>j</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">" %d"</literal></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">" %d-%d"</literal></expr></argument>,<argument><expr><name>start</name></expr></argument>,<argument><expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Just for MYSELF node we also dump info about slots that
     * we are migrating to other instances or importing from other
     * instances. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MYSELF</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">" [%d-&gt;-%.40s]"</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>,
                    <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">" [%d-&lt;-%.40s]"</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>,
                    <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ci</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate a csv-alike representation of the nodes we are aware of,
 * including the "myself" node, and return an SDS string containing the
 * representation (it is up to the caller to free it).
 *
 * All the nodes matching at least one of the node flags specified in
 * "filter" are excluded from the output, so using zero as a filter will
 * include all the known nodes in the representation, including nodes in
 * the HANDSHAKE state.
 *
 * The representation obtained using this function is used for the output
 * of the CLUSTER NODES function, and as format for the cluster
 * configuration file (nodes.conf) for a given node. */</comment>
<function><type><name>sds</name></type> <name>clusterGenNodesDescription</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>filter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>ci</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>ni</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>filter</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ni</name> <operator>=</operator> <call><name>clusterGenNodeDescription</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatsds</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>ci</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ci</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * CLUSTER command
 * -------------------------------------------------------------------------- */</comment>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>clusterGetMessageTypeString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch<condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CLUSTERMSG_TYPE_PING</name></expr>:</case> <return>return <expr><literal type="string">"ping"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_PONG</name></expr>:</case> <return>return <expr><literal type="string">"pong"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_MEET</name></expr>:</case> <return>return <expr><literal type="string">"meet"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_FAIL</name></expr>:</case> <return>return <expr><literal type="string">"fail"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_PUBLISH</name></expr>:</case> <return>return <expr><literal type="string">"publish"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</name></expr>:</case> <return>return <expr><literal type="string">"auth-req"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</name></expr>:</case> <return>return <expr><literal type="string">"auth-ack"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_UPDATE</name></expr>:</case> <return>return <expr><literal type="string">"update"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_MFSTART</name></expr>:</case> <return>return <expr><literal type="string">"mfstart"</literal></expr>;</return>
    <case>case <expr><name>CLUSTERMSG_TYPE_MODULE</name></expr>:</case> <return>return <expr><literal type="string">"module"</literal></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>getSlotOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>slot</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name> <operator>||</operator>
        <name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>slot</name> <operator>&gt;=</operator> <name>CLUSTER_SLOTS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid or out of range slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clusterReplyMultiBulkSlots</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Format: 1) 1) start slot
     *            2) end slot
     *            3) 1) master IP
     *               2) master port
     *               3) node ID
     *            4) 1) replica IP
     *               2) replica port
     *               3) node ID
     *           ... continued until done
     */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>num_masters</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>slot_replylen</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nested_elements</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip slaves (that are iterated when producing the output of their
         * master) and  masters not serving any slot. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>numslots</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>nested_elements</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>bit</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>bit</name> <operator>=</operator> <call><name>clusterNodeGetSlotBit</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>bit</name> <operator>||</operator> <name>j</name> <operator>==</operator> <name>CLUSTER_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>nested_elements</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* slots (2) + master addr (1). */</comment>

                <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <name>CLUSTER_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* If slot exists in output map, add to it's list.
                 * else, create a new output map for this slot */</comment>
                <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>j</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* only one slot; low==high */</comment>
                    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* low */</comment>
                    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* high */</comment>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <comment type="block">/* First node reply position is always the master */</comment>
                <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Remaining nodes in reply are replicas for slot range */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <comment type="block">/* This loop is copy/pasted from clusterGenNodeDescription()
                     * with modifications for per-slot node aggregation */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>num_masters</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>slot_replylen</name></expr></argument>, <argument><expr><name>num_masters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clusterCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"This instance has cluster support disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"ADDSLOTS &lt;slot&gt; [slot ...] -- Assign slots to current node."</literal></expr>,
<expr><literal type="string">"BUMPEPOCH -- Advance the cluster config epoch."</literal></expr>,
<expr><literal type="string">"COUNT-failure-reports &lt;node-id&gt; -- Return number of failure reports for &lt;node-id&gt;."</literal></expr>,
<expr><literal type="string">"COUNTKEYSINSLOT &lt;slot&gt; - Return the number of keys in &lt;slot&gt;."</literal></expr>,
<expr><literal type="string">"DELSLOTS &lt;slot&gt; [slot ...] -- Delete slots information from current node."</literal></expr>,
<expr><literal type="string">"FAILOVER [force|takeover] -- Promote current replica node to being a master."</literal></expr>,
<expr><literal type="string">"FORGET &lt;node-id&gt; -- Remove a node from the cluster."</literal></expr>,
<expr><literal type="string">"GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; -- Return key names stored by current node in a slot."</literal></expr>,
<expr><literal type="string">"FLUSHSLOTS -- Delete current node own slots information."</literal></expr>,
<expr><literal type="string">"INFO - Return onformation about the cluster."</literal></expr>,
<expr><literal type="string">"KEYSLOT &lt;key&gt; -- Return the hash slot for &lt;key&gt;."</literal></expr>,
<expr><literal type="string">"MEET &lt;ip&gt; &lt;port&gt; [bus-port] -- Connect nodes into a working cluster."</literal></expr>,
<expr><literal type="string">"MYID -- Return the node id."</literal></expr>,
<expr><literal type="string">"NODES -- Return cluster configuration seen by node. Output format:"</literal></expr>,
<expr><literal type="string">"    &lt;id&gt; &lt;ip:port&gt; &lt;flags&gt; &lt;master&gt; &lt;pings&gt; &lt;pongs&gt; &lt;epoch&gt; &lt;link&gt; &lt;slot&gt; ... &lt;slot&gt;"</literal></expr>,
<expr><literal type="string">"REPLICATE &lt;node-id&gt; -- Configure current node as replica to &lt;node-id&gt;."</literal></expr>,
<expr><literal type="string">"RESET [hard|soft] -- Reset current node (default: soft)."</literal></expr>,
<expr><literal type="string">"SET-config-epoch &lt;epoch&gt; - Set config epoch of current node."</literal></expr>,
<expr><literal type="string">"SETSLOT &lt;slot&gt; (importing|migrating|stable|node &lt;node-id&gt;) -- Set slot state."</literal></expr>,
<expr><literal type="string">"REPLICAS &lt;node-id&gt; -- Return &lt;node-id&gt; replicas."</literal></expr>,
<expr><literal type="string">"SLOTS -- Return information about slots range mappings. Each range is made of:"</literal></expr>,
<expr><literal type="string">"    start, end, master and replicas IP addresses, ports and ids"</literal></expr>,
<expr><name>NULL</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"meet"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER MEET &lt;ip&gt; &lt;port&gt; [cport] */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>cport</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObject</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid TCP base port specified: %s"</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObject</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cport</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid TCP bus port specified: %s"</literal></expr></argument>,
                                    <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>cport</name> <operator>=</operator> <name>port</name> <operator>+</operator> <name>CLUSTER_PORT_INCR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>clusterStartHandshake</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>port</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>cport</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
            <name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid node address specified: %s:%s"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"nodes"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER NODES */</comment>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>ci</name> <init>= <expr><call><name>clusterGenNodesDescription</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"myid"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER MYID */</comment>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CLUSTER_NAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"slots"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER SLOTS */</comment>
        <expr_stmt><expr><call><name>clusterReplyMultiBulkSlots</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"flushslots"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER FLUSHSLOTS */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dict</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"DB must be empty to perform CLUSTER FLUSHSLOTS."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterDelNodeSlots</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"addslots"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
               <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"delslots"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLUSTER ADDSLOTS &lt;slot&gt; [slot] ... */</comment>
        <comment type="block">/* CLUSTER DELSLOTS &lt;slot&gt; [slot] ... */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>slots</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>CLUSTER_SLOTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>del</name> <init>= <expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"delslots"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>slots</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>CLUSTER_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Check that all the arguments are parseable and that all the
         * slots are not already busy. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>getSlotOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>del</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Slot %d is already unassigned"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>del</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Slot %d is already busy"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name><operator>++</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Slot %d specified multiple times"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

                <comment type="block">/* If this slot was set as importing we can clear this
                 * state as now we are the real owner of the slot. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>retval</name> <operator>=</operator> <ternary><condition><expr><name>del</name></expr> ?</condition><then> <expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> </then><else>:
                               <expr><call><name>clusterAddSlot</name><argument_list>(<argument><expr><name>myself</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>retval</name> <operator>==</operator> <name>C_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"setslot"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* SETSLOT 10 MIGRATING &lt;node ID&gt; */</comment>
        <comment type="block">/* SETSLOT 10 IMPORTING &lt;node ID&gt; */</comment>
        <comment type="block">/* SETSLOT 10 STABLE */</comment>
        <comment type="block">/* SETSLOT 10 NODE &lt;node ID&gt; */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Please use SETSLOT only with masters."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>getSlotOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"migrating"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>!=</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"I'm not the owner of hash slot %u"</literal></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"I don't know about node %s"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"importing"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>==</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"I'm already the owner of hash slot %u"</literal></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"I don't know about node %s"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"stable"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* CLUSTER SETSLOT &lt;SLOT&gt; STABLE */</comment>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"node"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* CLUSTER SETSLOT &lt;SLOT&gt; NODE &lt;NODE ID&gt; */</comment>
            <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown node %s"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* If this hash slot was served by 'myself' before to switch
             * make sure there are no longer local keys for this hash slot. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>==</operator> <name>myself</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>!=</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>countKeysInSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                        <argument><expr><literal type="string">"Can't assign hashslot %d to a different node "</literal>
                        <literal type="string">"while I still hold keys for this hash slot."</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* If this slot is in migrating status but we have no keys
             * for it assigning the slot to another node will clear
             * the migratig status. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>countKeysInSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* If this node was importing this slot, assigning the slot to
             * itself also clears the importing status. */</comment>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>myself</name> <operator>&amp;&amp;</operator>
                <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* This slot was manually migrated, set this node configEpoch
                 * to a new epoch so that the new version can be propagated
                 * by the cluster.
                 *
                 * Note that if this ever results in a collision with another
                 * node getting the same configEpoch, for example because a
                 * failover happens at the same time we close the slot, the
                 * configEpoch collision resolution will fix it assigning
                 * a different epoch to each node. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>clusterBumpConfigEpochWithoutConsensus</name><argument_list>()</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                        <argument><expr><literal type="string">"configEpoch updated after importing slot %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>clusterDelSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterAddSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                <argument><expr><literal type="string">"Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_SAVE_CONFIG</name><operator>|</operator><name>CLUSTER_TODO_UPDATE_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"bumpepoch"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER BUMPEPOCH */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>clusterBumpConfigEpochWithoutConsensus</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>reply</name> <init>= <expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"+%s %llu\r\n"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>retval</name> <operator>==</operator> <name>C_OK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"BUMPED"</literal></expr> </then><else>: <expr><literal type="string">"STILL"</literal></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER INFO */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>statestr</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"ok"</literal></expr>,<expr><literal type="string">"fail"</literal></expr>,<expr><literal type="string">"needhelp"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>slots_assigned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>slots_ok</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>slots_pfail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>slots_fail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>myepoch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>slots_assigned</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>nodeFailed</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>slots_fail</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>nodeTimedOut</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>slots_pfail</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>slots_ok</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>myepoch</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name><operator>)</operator></expr> ?</condition><then>
                  <expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>configEpoch</name></name></expr> </then><else>: <expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></else></ternary></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>sds</name></type> <name>info</name> <init>= <expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><literal type="string">"cluster_state:%s\r\n"</literal>
            <literal type="string">"cluster_slots_assigned:%d\r\n"</literal>
            <literal type="string">"cluster_slots_ok:%d\r\n"</literal>
            <literal type="string">"cluster_slots_pfail:%d\r\n"</literal>
            <literal type="string">"cluster_slots_fail:%d\r\n"</literal>
            <literal type="string">"cluster_known_nodes:%Iu\r\n"</literal>                                       <name>WIN_PORT_FIX</name> <comment type="block">/* %lu -&gt; %Iu */</comment>
            <literal type="string">"cluster_size:%d\r\n"</literal>
            <literal type="string">"cluster_current_epoch:%llu\r\n"</literal>
            <literal type="string">"cluster_my_epoch:%llu\r\n"</literal></expr></argument>
            , <argument><expr><name><name>statestr</name><index>[<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name></expr>]</index></name></expr></argument>,
            <argument><expr><name>slots_assigned</name></expr></argument>,
            <argument><expr><name>slots_ok</name></expr></argument>,
            <argument><expr><name>slots_pfail</name></expr></argument>,
            <argument><expr><name>slots_fail</name></expr></argument>,
            <argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name>myepoch</name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Show stats about messages sent and received. */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>tot_msg_sent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>tot_msg_received</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTERMSG_TYPE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_sent</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tot_msg_sent</name> <operator>+=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_sent</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>info</name></expr></argument>,
                <argument><expr><literal type="string">"cluster_stats_messages_%s_sent:%lld\r\n"</literal></expr></argument>,
                <argument><expr><call><name>clusterGetMessageTypeString</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_sent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>info</name></expr></argument>,
            <argument><expr><literal type="string">"cluster_stats_messages_sent:%lld\r\n"</literal></expr></argument>, <argument><expr><name>tot_msg_sent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTERMSG_TYPE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_received</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tot_msg_received</name> <operator>+=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_received</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>info</name></expr></argument>,
                <argument><expr><literal type="string">"cluster_stats_messages_%s_received:%lld\r\n"</literal></expr></argument>,
                <argument><expr><call><name>clusterGetMessageTypeString</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>stats_bus_messages_received</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>info</name></expr></argument>,
            <argument><expr><literal type="string">"cluster_stats_messages_received:%lld\r\n"</literal></expr></argument>, <argument><expr><name>tot_msg_received</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Produce the reply protocol. */</comment>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"$%Iu\r\n"</literal></expr></argument>, <argument><expr><macro><name>WIN_PORT_FIX</name> <comment type="block">/* %lu -&gt; %Iu */</comment>
            <argument_list>(<argument>PORT_ULONG</argument>)</argument_list></macro><call><name>sdslen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>crlf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"saveconfig"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>clusterSaveConfig</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"error saving the cluster node config: %s"</literal></expr></argument>,
                <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"keyslot"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER KEYSLOT &lt;key&gt; */</comment>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>keyHashSlot</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"countkeysinslot"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER COUNTKEYSINSLOT &lt;slot&gt; */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>slot</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>slot</name> <operator>&gt;=</operator> <name>CLUSTER_SLOTS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>countKeysInSlot</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (unsigned int) */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"getkeysinslot"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>maxkeys</name></decl>, <decl><type ref="prev"/><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>numkeys</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxkeys</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
            <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>slot</name> <operator>&gt;=</operator> <name>CLUSTER_SLOTS</name> <operator>||</operator> <name>maxkeys</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid slot or number of keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Avoid allocating more than needed in case of large COUNT argument
         * and smaller actual number of keys. */</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>keys_in_slot</name> <init>= <expr><call><name>countKeysInSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>maxkeys</name> <operator>&gt;</operator> <name>keys_in_slot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxkeys</name> <operator>=</operator> <name>keys_in_slot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>maxkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numkeys</name> <operator>=</operator> <call><name>getKeysInSlot</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>slot</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>maxkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (unsigned int) */</comment>
        <name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>numkeys</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numkeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>keys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"forget"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER FORGET &lt;NODE ID&gt; */</comment>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown node %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"I tried hard but I can't forget myself..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Can't forget my master!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterBlacklistAddNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDelNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator>
                             <name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"replicate"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER REPLICATE &lt;NODE ID&gt; */</comment>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Lookup the specified node in our table. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown node %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* I can't replicate myself. */</comment>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>myself</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Can't replicate myself"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Can't replicate a slave. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"I can only replicate a master, not a replica."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the instance is currently a master, it should have no assigned
         * slots nor keys to accept to replicate some other node.
         * Slaves can switch to another master without issues. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>myself</name><operator>-&gt;</operator><name>numslots</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dict</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                <argument><expr><literal type="string">"To set a master the node must be empty and "</literal>
                <literal type="string">"without assigned slots."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Set the master. */</comment>
        <expr_stmt><expr><call><name>clusterSetMaster</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator><name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"slaves"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"replicas"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* CLUSTER SLAVES &lt;NODE ID&gt; */</comment>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Lookup the specified node in our table. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown node %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The specified node is not a master"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>numslaves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>numslaves</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>ni</name> <init>= <expr><call><name>clusterGenNodeDescription</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>slaves</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"count-failure-reports"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
               <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLUSTER COUNT-FAILURE-REPORTS &lt;NODE ID&gt; */</comment>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown node %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>clusterNodeFailureReportsCount</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"failover"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
               <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLUSTER FAILOVER [FORCE|TAKEOVER] */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>force</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>takeover</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"force"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>force</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"takeover"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>takeover</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>force</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Takeover also implies force. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check preconditions. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"You should send CLUSTER FAILOVER to a replica"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"I'm a replica but my master is unknown to me"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator>
                   <operator>(</operator><call><name>nodeFailed</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Master is down or failed, "</literal>
                            <literal type="string">"please use CLUSTER FAILOVER FORCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>resetManualFailover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call> <operator>+</operator> <name>CLUSTER_MF_TIMEOUT</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>takeover</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* A takeover does not perform any initial check. It just
             * generates a new configuration epoch for this node without
             * consensus, claims the master's slots, and broadcast the new
             * configuration. */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Taking over the master (user request)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterBumpConfigEpochWithoutConsensus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterFailoverReplaceYourMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>force</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If this is a forced failover, we don't need to talk with our
             * master to agree about the offset. We just failover taking over
             * it without coordination. */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Forced failover user request accepted."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_can_start</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Manual failover user request accepted."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterSendMFStart</name><argument_list>(<argument><expr><name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"set-config-epoch"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLUSTER SET-CONFIG-EPOCH &lt;epoch&gt;
         *
         * The user is allowed to set the config epoch only when a node is
         * totally fresh: no config epoch, no other known node, and so forth.
         * This happens at cluster creation time to start with a cluster where
         * every node has a different node ID, without to rely on the conflicts
         * resolution system which is too slow when a big cluster is created. */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>epoch</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>epoch</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>epoch</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid config epoch specified: %lld"</literal></expr></argument>,<argument><expr><name>epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The user can assign a config epoch only when the "</literal>
                            <literal type="string">"node does not know any other node."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Node config epoch is already non-zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name> <operator>=</operator> <name>epoch</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>myself</name><operator>-&gt;</operator><name>configEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>&lt;</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>epoch</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>currentEpoch</name></name> <operator>=</operator> <name>epoch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* No need to fsync the config here since in the unlucky event
             * of a failure to persist the config, the conflict resolution code
             * will assign an unique config to this node. */</comment>
            <expr_stmt><expr><call><name>clusterDoBeforeSleep</name><argument_list>(<argument><expr><name>CLUSTER_TODO_UPDATE_STATE</name><operator>|</operator>
                                 <name>CLUSTER_TODO_SAVE_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
               <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CLUSTER RESET [SOFT|HARD] */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>hard</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Parse soft/hard argument. Default is soft. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"hard"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>hard</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"soft"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>hard</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Slaves can be reset while containing data, but not master nodes
         * that must be empty. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeIsMaster</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"CLUSTER RESET can't be called with "</literal>
                            <literal type="string">"master nodes containing keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterReset</name><argument_list>(<argument><expr><name>hard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * DUMP, RESTORE and MIGRATE commands
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Generates a DUMP-format representation of the object 'o', adding it to the
 * io stream pointed by 'rio'. This function can't fail. */</comment>
<function><type><name>void</name></type> <name>createDumpPayload</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>crc</name></decl>;</decl_stmt>

    <comment type="block">/* Serialize the object in a RDB-like format. It consist of an object type
     * byte followed by the serialized object. This is understood by RESTORE. */</comment>
    <expr_stmt><expr><call><name>rioInitWithBuffer</name><argument_list>(<argument><expr><name>payload</name></expr></argument>,<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>rdbSaveObjectType</name><argument_list>(<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>rdbSaveObject</name><argument_list>(<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write the footer, this is how it looks like:
     * ----------------+---------------------+---------------+
     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |
     * ----------------+---------------------+---------------+
     * RDB version and CRC are both in little endian.
     */</comment>

    <comment type="block">/* RDB version */</comment>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>RDB_VERSION</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>RDB_VERSION</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>payload</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>payload</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* CRC64 */</comment>
    <expr_stmt><expr><name>crc</name> <operator>=</operator> <call><name>crc64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>payload</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>,
                <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>payload</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memrev64ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>payload</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>payload</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>crc</name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Verify that the RDB version of the dump payload matches the one of this Redis
 * instance and that the checksum is ok.
 * If the DUMP payload looks valid C_OK is returned, otherwise C_ERR
 * is returned. */</comment>
<function><type><name>int</name></type> <name>verifyDumpPayload</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>footer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>rdbver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>crc</name></decl>;</decl_stmt>

    <comment type="block">/* At least 2 bytes of RDB version and 8 of CRC64 should be present. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>footer</name> <operator>=</operator> <name>p</name><operator>+</operator><operator>(</operator><name>len</name><operator>-</operator><literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Verify RDB version */</comment>
    <expr_stmt><expr><name>rdbver</name> <operator>=</operator> <operator>(</operator><name><name>footer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>footer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rdbver</name> <operator>&gt;</operator> <name>RDB_VERSION</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Verify CRC64 */</comment>
    <expr_stmt><expr><name>crc</name> <operator>=</operator> <call><name>crc64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>len</name><operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memrev64ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>crc</name></expr></argument>,<argument><expr><name>footer</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>C_OK</name></expr> </then><else>: <expr><name>C_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* DUMP keyname
 * DUMP is actually not used by Redis Cluster but it is the obvious
 * complement of RESTORE and can be useful for different applications. */</comment>
<function><type><name>void</name></type> <name>dumpCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dumpobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rio</name></type> <name>payload</name></decl>;</decl_stmt>

    <comment type="block">/* Check if the key is here. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create the DUMP encoded representation. */</comment>
    <expr_stmt><expr><call><name>createDumpPayload</name><argument_list>(<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Transfer to the client */</comment>
    <expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name><name>payload</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>dumpobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>dumpobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* RESTORE key ttl serialized-value [REPLACE] */</comment>
<function><type><name>void</name></type> <name>restoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ttl</name></decl>, <decl><type ref="prev"/><name>lfu_freq</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>lru_idle</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>lru_clock</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rio</name></type> <name>payload</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>replace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>absttl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

    <comment type="block">/* Parse additional options */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>additional</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>replace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"absttl"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>absttl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"idletime"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>additional</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                   <name>lfu_freq</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lru_idle</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                    <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>lru_idle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid IDLETIME value, must be &gt;= 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>lru_clock</name> <operator>=</operator> <call><name>LRU_CLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Consume additional arg. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"freq"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>additional</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                   <name>lru_idle</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lfu_freq</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                    <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>lfu_freq</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>lfu_freq</name></expr></argument> &gt;</argument_list></name> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid FREQ value, must be &gt;= 0 and &lt;= 255"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Consume additional arg. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Make sure this key does not already exist here... */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name> <operator>&amp;&amp;</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>busykeyerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if the TTL value makes sense */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ttl</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ttl</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid TTL value, must be &gt;= 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Verify RDB version and data checksum. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>verifyDumpPayload</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"DUMP payload version or checksum are wrong"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>rioInitWithBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>type</name> <operator>=</operator> <call><name>rdbLoadObjectType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>(</operator><name>obj</name> <operator>=</operator> <call><name>rdbLoadObject</name><argument_list>(<argument><expr><name>type</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Bad data format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Remove the old key if needed. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>absttl</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ttl</name><operator>+=</operator><call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>&amp;&amp;</operator> <call><name>checkAlreadyExpired</name><argument_list>(<argument><expr><name>ttl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>del</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create the key and set the TTL if any */</comment>
    <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ttl</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setExpire</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>ttl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>objectSetLRUOrLFU</name><argument_list>(<argument><expr><name>obj</name></expr></argument>,<argument><expr><name>lfu_freq</name></expr></argument>,<argument><expr><name>lru_idle</name></expr></argument>,<argument><expr><name>lru_clock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* MIGRATE socket cache implementation.
 *
 * We take a map between host:ip and a TCP socket that we used to connect
 * to this instance in recent time.
 * This sockets are closed when the max number we cache is reached, and also
 * in serverCron() when they are around for more than a few seconds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIGRATE_SOCKET_CACHE_ITEMS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define> <comment type="block">/* max num of items in the cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIGRATE_SOCKET_CACHE_TTL</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> <comment type="block">/* close cached sockets after 10 sec. */</comment>

<typedef>typedef <type><struct>struct <name>migrateCachedSocket</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>last_dbid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>last_use_time</name></decl>;</decl_stmt>
}</block></struct></type> <name>migrateCachedSocket</name>;</typedef>

<comment type="block">/* Return a migrateCachedSocket containing a TCP socket connected with the
 * target instance, possibly returning a cached one.
 *
 * This function is responsible of sending errors to the client if a
 * connection can't be established. In this case -1 is returned.
 * Otherwise on success the socket is returned, and the caller should not
 * attempt to free it after usage.
 *
 * If the caller detects an error while using the socket, migrateCloseSocket()
 * should be called so that the connection will be created from scratch
 * the next time. */</comment>
<function><type><name>migrateCachedSocket</name><modifier>*</modifier></type> <name>migrateGetSocket</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>timeout</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>name</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>migrateCachedSocket</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>

    <comment type="block">/* Check if we have an already cached socket for this ip:port pair. */</comment>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>host</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>host</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">":"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>port</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>last_use_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
        <return>return <expr><name>cs</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No cached socket, create one. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MIGRATE_SOCKET_CACHE_ITEMS</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Too many items, drop one at random. */</comment>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create the socket */</comment>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>anetTcpNonBlockConnect</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
                                <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Can't connect to target node: %s"</literal></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>anetEnableTcpNoDelay</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>neterr</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if it connects within the specified timeout. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>aeWait</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>,<argument><expr><name>timeout</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>AE_WRITABLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-IOERR error or timeout connecting to the client\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add to the cache and return it to the caller. */</comment>
    <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>last_dbid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>last_use_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a migrate cached connection. */</comment>
<function><type><name>void</name></type> <name>migrateCloseSocket</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>name</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>migrateCachedSocket</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>host</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>host</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">":"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>port</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cs</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>migrateCloseTimedoutSockets</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>migrateCachedSocket</name> <modifier>*</modifier></type><name>cs</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>cs</name><operator>-&gt;</operator><name>last_use_time</name></name><operator>)</operator> <operator>&gt;</operator> <name>MIGRATE_SOCKET_CACHE_TTL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>migrate_cached_sockets</name></name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* MIGRATE host port key dbid timeout [COPY | REPLACE | AUTH password]
 *
 * On in the multiple keys form:
 *
 * MIGRATE host port "" dbid timeout [COPY | REPLACE | AUTH password] KEYS key1
 * key2 ... keyN */</comment>
<function><type><name>void</name></type> <name>migrateCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>migrateCachedSocket</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>copy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>replace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>dbid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>ov</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Objects to migrate. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>kv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Key names. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>newargv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Used to rewrite the command as DEL ... keys ... */</comment>
    <decl_stmt><decl><type><name>rio</name></type> <name>cmd</name></decl>, <decl><type ref="prev"/><name>payload</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>may_retry</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>write_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argv_rewritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* To support the KEYS option we need the following additional state. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>first_key</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Argument index of the first key. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>num_keys</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* By default only migrate the 'key' argument. */</comment>

    <comment type="block">/* Parse additional options */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">6</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"copy"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>copy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>replace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"auth"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>moreargs</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"keys"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                    <argument><expr><literal type="string">"When using MIGRATE KEYS option, the key argument"</literal>
                    <literal type="string">" must be set to the empty string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>first_key</name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_keys</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break> <comment type="block">/* All the remaining args are keys. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Sanity check */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name> <operator>||</operator>
        <call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>dbid</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check if the keys are here. If at least one key is to migrate, do it
     * otherwise if all the keys are missing reply with "NOKEY" to signal
     * the caller there was nothing to migrate. We don't return an error in
     * this case, since often this is due to a normal condition like the key
     * expiring in the meantime. */</comment>
    <expr_stmt><expr><name>ov</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>ov</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>num_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>kv</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>num_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>oi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_keys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ov</name><index>[<expr><name>oi</name></expr>]</index></name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>first_key</name><operator>+</operator><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>kv</name><index>[<expr><name>oi</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>first_key</name><operator>+</operator><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oi</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>num_keys</name> <operator>=</operator> <name>oi</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_keys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"+NOKEY\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

<label><name>try_again</name>:</label>
    <expr_stmt><expr><name>write_error</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Connect */</comment>
    <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>migrateGetSocket</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return> <comment type="block">/* error sent to the client by migrateGetSocket() */</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>rioInitWithBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Authentication */</comment>
    <if_stmt><if>if <condition>(<expr><name>password</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"AUTH"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><name>password</name></expr></argument>,
            <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send the SELECT command if the current DB is not already selected. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>select</name> <init>= <expr><name><name>cs</name><operator>-&gt;</operator><name>last_dbid</name></name> <operator>!=</operator> <name>dbid</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Should we emit SELECT? */</comment>
    <if_stmt><if>if <condition>(<expr><name>select</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"SELECT"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>non_expired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Number of keys that we'll find non expired.
                            Note that serializing large keys may take some time
                            so certain keys that were found non expired by the
                            lookupKey() function, may be expired later. */</comment>

    <comment type="block">/* Create RESTORE payload and generate the protocol to call the command. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_keys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ttl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>expireat</name> <init>= <expr><call><name>getExpire</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>expireat</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ttl</name> <operator>=</operator> <name>expireat</name><operator>-</operator><call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>ttl</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ttl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Relocate valid (non expired) keys into the array in successive
         * positions to remove holes created by the keys that were present
         * in the first lookup but are now expired after the second lookup. */</comment>
        <expr_stmt><expr><name><name>kv</name><index>[<expr><name>non_expired</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
            <argument><expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><ternary><condition><expr><name>replace</name></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
                <argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"RESTORE-ASKING"</literal></expr></argument>,<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"RESTORE"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
                <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><name>ttl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Emit the payload argument, that is the serialized object using
         * the DUMP format. */</comment>
        <expr_stmt><expr><call><name>createDumpPayload</name><argument_list>(<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>,<argument><expr><name><name>ov</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
            <argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><name><name>payload</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>,
                               <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>payload</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>payload</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Add the REPLACE option to the RESTORE command if it was specified
         * as a MIGRATE option. */</comment>
        <if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"REPLACE"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Fix the actual number of keys we are migrating. */</comment>
    <expr_stmt><expr><name>num_keys</name> <operator>=</operator> <name>non_expired</name></expr>;</expr_stmt>

    <comment type="block">/* Transfer the query to the other node in 64K chunks. */</comment>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>buf</name> <init>= <expr><name><name>cmd</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>towrite</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nwritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <while>while <condition>(<expr><operator>(</operator><name>towrite</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>pos</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>towrite</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>towrite</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">64</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr> </then><else>: <expr><name>towrite</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>nwritten</name> <operator>!=</operator> <operator>(</operator><name>signed</name><operator>)</operator> <name>towrite</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>syncWrite</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><operator>(</operator><name>ssize_t</name><operator>)</operator> <name>towrite</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>!=</operator> <operator>(</operator><name>signed</name><operator>)</operator> <name>towrite</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>DWORD</name></type> <name>err</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Likely send buffer is full. A short delay or two is sufficient to allow this to work.</comment>
                        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"In migrate. WSAEWOULDBLOCK with synchronous socket: sleeping for 0.1s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"SyncWrite failure toWrite=%d  written=%d err=%d timeout=%d "</literal></expr></argument>, <argument><expr><name>towrite</name></expr></argument>, <argument><expr><name>nwritten</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>socket_err</name>;</goto>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <while>while <condition>(<expr><operator>(</operator><name>towrite</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>-</operator><name>pos</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>towrite</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>towrite</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">64</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">64</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr> </then><else>: <expr><name>towrite</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>syncWrite</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>buf</name><operator>+</operator><name>pos</name></expr></argument>,<argument><expr><name>towrite</name></expr></argument>,<argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>!=</operator> <operator>(</operator><name>signed</name><operator>)</operator><name>towrite</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>write_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <goto>goto <name>socket_err</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
        </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf0</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Auth reply. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf1</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Select reply. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf2</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Restore reply. */</comment>

    <comment type="block">/* Read the AUTH reply if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>password</name> <operator>&amp;&amp;</operator> <call><name>syncReadLine</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf0</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf0</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>socket_err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Read the SELECT reply if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>select</name> <operator>&amp;&amp;</operator> <call><name>syncReadLine</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>socket_err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Read the RESTORE replies. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>error_from_target</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>socket_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>del_idx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Index of the key argument for the replicated DEL op. */</comment>

    <comment type="block">/* Allocate the new argument vector that will replace the current command,
     * to propagate the MIGRATE as a DEL command (if no COPY option was given).
     * We allocate num_keys+1 because the additional argument is for "DEL"
     * command name itself. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newargv</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>num_keys</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_keys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>syncReadLine</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>socket_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>password</name> <operator>&amp;&amp;</operator> <name><name>buf0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>select</name> <operator>&amp;&amp;</operator> <name><name>buf1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>||</operator>
            <name><name>buf2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* On error assume that last_dbid is no longer valid. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>error_from_target</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>last_dbid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>password</name> <operator>&amp;&amp;</operator> <name><name>buf0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errbuf</name> <operator>=</operator> <name>buf0</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>select</name> <operator>&amp;&amp;</operator> <name><name>buf1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errbuf</name> <operator>=</operator> <name>buf1</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>errbuf</name> <operator>=</operator> <name>buf2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>error_from_target</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Target instance replied with error: %s"</literal></expr></argument>,
                    <argument><expr><name>errbuf</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* No COPY option: remove the local key, signal the change. */</comment>
                <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>

                <comment type="block">/* Populate the argument vector to replace the old one. */</comment>
                <expr_stmt><expr><name><name>newargv</name><index>[<expr><name>del_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>kv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* On socket error, if we want to retry, do it now before rewriting the
     * command vector. We only retry if we are sure nothing was processed
     * and we failed to read the first reply (j == 0 test). */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>error_from_target</name> <operator>&amp;&amp;</operator> <name>socket_error</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>may_retry</name> <operator>&amp;&amp;</operator>
        <name>errno</name> <operator>!=</operator> <name>ETIMEDOUT</name></expr>)</condition>
    <block>{<block_content>
        <goto>goto <name>socket_err</name>;</goto> <comment type="block">/* A retry is guaranteed because of tested conditions.*/</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* On socket errors, close the migration socket now that we still have
     * the original host/port in the ARGV. Later the original command may be
     * rewritten to DEL and will be too later. */</comment>
    <if_stmt><if>if <condition>(<expr><name>socket_error</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>migrateCloseSocket</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Translate MIGRATE as DEL for replication/AOF. Note that we do
         * this only for the keys for which we received an acknowledgement
         * from the receiving Redis server, by using the del_idx index. */</comment>
        <if_stmt><if>if <condition>(<expr><name>del_idx</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>newargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"DEL"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Note that the following call takes ownership of newargv. */</comment>
            <expr_stmt><expr><call><name>replaceClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>del_idx</name></expr></argument>,<argument><expr><name>newargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>argv_rewritten</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* No key transfer acknowledged, no need to rewrite as DEL. */</comment>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>newargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>newargv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Make it safe to call zfree() on it in the future. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we are here and a socket error happened, we don't want to retry.
     * Just signal the problem to the client, but only do it if we did not
     * already queue a different error reported by the destination server. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>error_from_target</name> <operator>&amp;&amp;</operator> <name>socket_error</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>may_retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>socket_err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>error_from_target</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Success! Update the last_dbid in migrateCachedSocket, so that we can
         * avoid SELECT the next time if the target DB is the same. Reply +OK.
         *
         * Note: If we reached this point, even if socket_error is true
         * still the SELECT command succeeded (otherwise the code jumps to
         * socket_err label. */</comment>
        <expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>last_dbid</name></name> <operator>=</operator> <name>dbid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* On error we already sent it in the for loop above, and set
         * the currently selected socket to -1 to force SELECT the next time. */</comment>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>newargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

<comment type="block">/* On socket errors we try to close the cached socket and try again.
 * It is very common for the cached socket to get closed, if just reopening
 * it works it's a shame to notify the error to the caller. */</comment>
<label><name>socket_err</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"syncReadLine failure err=%d timeout=%d "</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Cleanup we want to perform in both the retry and no retry case.
     * Note: Closing the migrate socket will also force SELECT next time. */</comment>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>io</name><operator>.</operator><name>buffer</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the command was rewritten as DEL and there was a socket error,
     * we already closed the socket earlier. While migrateCloseSocket()
     * is idempotent, the host/port arguments are now gone, so don't do it
     * again. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>argv_rewritten</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>migrateCloseSocket</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>newargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newargv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* This will get reallocated on retry. */</comment>

    <comment type="block">/* Retry only if it's not a timeout and we never attempted a retry
     * (or the code jumping here did not set may_retry to zero). */</comment>
    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ETIMEDOUT</name> <operator>&amp;&amp;</operator> <name>may_retry</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>may_retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>try_again</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Cleanup we want to do if no retry is attempted. */</comment>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
        <argument><expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><literal type="string">"-IOERR error or timeout %s to target instance\r\n"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>write_error</name></expr> ?</condition><then> <expr><literal type="string">"writing"</literal></expr> </then><else>: <expr><literal type="string">"reading"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Cluster functions related to serving / redirecting clients
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* The ASKING command is required after a -ASK redirection.
 * The client should issue ASKING before to actually send the command to
 * the target instance. See the Redis Cluster specification for more
 * information. */</comment>
<function><type><name>void</name></type> <name>askingCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"This instance has cluster support disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_ASKING</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The READONLY command is used by clients to enter the read-only mode.
 * In this mode slaves will not redirect clients as long as clients access
 * with read-only commands to keys that are served by the slave's master. */</comment>
<function><type><name>void</name></type> <name>readonlyCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"This instance has cluster support disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_READONLY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The READWRITE command just clears the READONLY command state. */</comment>
<function><type><name>void</name></type> <name>readwriteCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_READONLY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the pointer to the cluster node that is able to serve the command.
 * For the function to succeed the command should only target either:
 *
 * 1) A single key (even multiple times like LPOPRPUSH mylist mylist).
 * 2) Multiple keys in the same hash slot, while the slot is stable (no
 *    resharding in progress).
 *
 * On success the function returns the node that is able to serve the request.
 * If the node is not 'myself' a redirection must be perfomed. The kind of
 * redirection is specified setting the integer passed by reference
 * 'error_code', which will be set to CLUSTER_REDIR_ASK or
 * CLUSTER_REDIR_MOVED.
 *
 * When the node is 'myself' 'error_code' is set to CLUSTER_REDIR_NONE.
 *
 * If the command fails NULL is returned, and the reason of the failure is
 * provided via 'error_code', which will be set to:
 *
 * CLUSTER_REDIR_CROSS_SLOT if the request contains multiple keys that
 * don't belong to the same hash slot.
 *
 * CLUSTER_REDIR_UNSTABLE if the request contains multiple keys
 * belonging to the same slot, but the slot is not stable (in migration or
 * importing state, likely because a resharding is in progress).
 *
 * CLUSTER_REDIR_DOWN_UNBOUND if the request addresses a slot which is
 * not bound to any node. In this case the cluster global state should be
 * already "down" but it is fragile to rely on the update of the global state,
 * so we also handle it here.
 *
 * CLUSTER_REDIR_DOWN_STATE if the cluster is down but the user attempts to
 * execute a command that addresses one or more keys. */</comment>
<function><type><name>clusterNode</name> <modifier>*</modifier></type><name>getNodeByQuery</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hashslot</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>error_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>firstkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>multiple_keys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>multiState</name> <modifier>*</modifier></type><name>ms</name></decl>, <decl><type ref="prev"/><name>_ms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>multiCmd</name></type> <name>mc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>slot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>migrating_slot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>importing_slot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>missing_keys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Allow any key to be set if a module disabled cluster redirections. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MODULE_FLAG_NO_REDIRECTION</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>myself</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Set error code optimistically for the base case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>error_code</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Modules can turn off Redis Cluster redirection: this is useful
     * when writing a module that implements a completely different
     * distributed system. */</comment>

    <comment type="block">/* We handle all the cases as if they were EXEC commands, so we have
     * a common code path for everything */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>execCommand</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If CLIENT_MULTI flag is not set EXEC is just going to return an
         * error. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>myself</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ms</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>mstate</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* In order to have a single codepath create a fake Multi State
         * structure if the client is not in MULTI/EXEC state, this way
         * we have a single codepath below. */</comment>
        <expr_stmt><expr><name>ms</name> <operator>=</operator> <operator>&amp;</operator><name>_ms</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>_ms</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>&amp;</operator><name>mc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>_ms</name><operator>.</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mc</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mc</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mc</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Check that all the keys are in the same hash slot, and obtain this
     * slot and the node associated. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>mcmd</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>margv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>margc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keyindex</name></decl>, <decl><type ref="prev"/><name>numkeys</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>mcmd</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>commands</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmd</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>margc</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>commands</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>margv</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>commands</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argv</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>keyindex</name> <operator>=</operator> <call><name>getKeysFromCommand</name><argument_list>(<argument><expr><name>mcmd</name></expr></argument>,<argument><expr><name>margv</name></expr></argument>,<argument><expr><name>margc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numkeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>thiskey</name> <init>= <expr><name><name>margv</name><index>[<expr><name><name>keyindex</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>thisslot</name> <init>= <expr><call><name>keyHashSlot</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>thiskey</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>thiskey</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>              <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>

            <if_stmt><if>if <condition>(<expr><name>firstkey</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* This is the first key we see. Check what is the slot
                 * and node. */</comment>
                <expr_stmt><expr><name>firstkey</name> <operator>=</operator> <name>thiskey</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>slot</name> <operator>=</operator> <name>thisslot</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/* Error: If a slot is not served, we are in "cluster down"
                 * state. However the state is yet to be updated, so this was
                 * not trapped earlier in processCommand(). Report the same
                 * error to the client. */</comment>
                <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>getKeysFreeResult</name><argument_list>(<argument><expr><name>keyindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>error_code</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_DOWN_UNBOUND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* If we are migrating or importing this slot, we need to check
                 * if we have all the keys in the request (the only way we
                 * can safely serve the request, otherwise we return a TRYAGAIN
                 * error). To do so we set the importing/migrating state and
                 * increment a counter for every missing key. */</comment>
                <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>myself</name> <operator>&amp;&amp;</operator>
                    <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>migrating_slot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>importing_slot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* If it is not the first key, make sure it is exactly
                 * the same key as the first we saw. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equalStringObjects</name><argument_list>(<argument><expr><name>firstkey</name></expr></argument>,<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>thisslot</name></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* Error: multiple keys from different slots. */</comment>
                        <expr_stmt><expr><call><name>getKeysFreeResult</name><argument_list>(<argument><expr><name>keyindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>error_code</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_CROSS_SLOT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <return>return <expr><name>NULL</name></expr>;</return>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="block">/* Flag this request as one with multiple different
                         * keys. */</comment>
                        <expr_stmt><expr><name>multiple_keys</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Migarting / Improrting slot? Count keys we don't have. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>migrating_slot</name> <operator>||</operator> <name>importing_slot</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>lookupKeyRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>missing_keys</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>getKeysFreeResult</name><argument_list>(<argument><expr><name>keyindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* No key at all in command? then we can serve the request
     * without redirections or errors in all the cases. */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>myself</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Cluster is globally down but we got keys? We can't serve the request. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CLUSTER_OK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>error_code</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_DOWN_STATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return the hashslot by reference. */</comment>
    <if_stmt><if>if <condition>(<expr><name>hashslot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>hashslot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* MIGRATE always works in the context of the local node if the slot
     * is open (migrating or importing state). We need to be able to freely
     * move keys among instances in this case. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>migrating_slot</name> <operator>||</operator> <name>importing_slot</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>migrateCommand</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>myself</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we don't have all the keys and we are migrating the slot, send
     * an ASK redirection. */</comment>
    <if_stmt><if>if <condition>(<expr><name>migrating_slot</name> <operator>&amp;&amp;</operator> <name>missing_keys</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>error_code</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_ASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>migrating_slots_to</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we are receiving the slot, and the client correctly flagged the
     * request as "ASKING", we can serve the request. However if the request
     * involves multiple keys and we don't have them all, the only option is
     * to send a TRYAGAIN error. */</comment>
    <if_stmt><if>if <condition>(<expr><name>importing_slot</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_ASKING</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_ASKING</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>multiple_keys</name> <operator>&amp;&amp;</operator> <name>missing_keys</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>error_code</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_UNSTABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><name>myself</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle the read-only client case reading from a slave: if this
     * node is a slave and the request is about an hash slot our master
     * is serving, we can reply without redirection. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_READONLY</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_READONLY</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>evalCommand</name> <operator>||</operator>
         <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>evalShaCommand</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>n</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>myself</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Base case: just return the right node. However if this node is not
     * myself, set error_code to MOVED since we need to issue a rediretion. */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name>myself</name> <operator>&amp;&amp;</operator> <name>error_code</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>error_code</name> <operator>=</operator> <name>CLUSTER_REDIR_MOVED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send the client the right redirection code, according to error_code
 * that should be set to one of CLUSTER_REDIR_* macros.
 *
 * If CLUSTER_REDIR_ASK or CLUSTER_REDIR_MOVED error codes
 * are used, then the node 'n' should not be NULL, but should be the
 * node we want to mention in the redirection. Moreover hashslot should
 * be set to the hash slot that caused the redirection. */</comment>
<function><type><name>void</name></type> <name>clusterRedirectClient</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hashslot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_CROSS_SLOT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-CROSSSLOT Keys in request don't hash to the same slot\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_UNSTABLE</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* The request spawns multiple keys in the same slot,
         * but the slot is not "stable" currently as there is
         * a migration or import in progress. */</comment>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-TRYAGAIN Multiple keys request during rehashing of slot\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_DOWN_STATE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-CLUSTERDOWN The cluster is down\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_DOWN_UNBOUND</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-CLUSTERDOWN Hash slot not served\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_MOVED</name> <operator>||</operator>
               <name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_ASK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><literal type="string">"-%s %d %s:%d\r\n"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>error_code</name> <operator>==</operator> <name>CLUSTER_REDIR_ASK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"ASK"</literal></expr> </then><else>: <expr><literal type="string">"MOVED"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name>hashslot</name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"getNodeByQuery() unknown error."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called by the function processing clients incrementally
 * to detect timeouts, in order to handle the following case:
 *
 * 1) A client blocks with BLPOP or similar blocking operation.
 * 2) The master migrates the hash slot elsewhere or turns into a slave.
 * 3) The client may remain blocked forever (or up to the max timeout time)
 *    waiting for a key change that will never happen.
 *
 * If the client is found to be blocked into an hash slot this node no
 * longer handles, the client is sent a redirection error, and the function
 * returns 1. Otherwise 0 is returned and no operation is performed. */</comment>
<function><type><name>int</name></type> <name>clusterRedirectBlockedClientIfNeeded</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>btype</name></name> <operator>==</operator> <name>BLOCKED_LIST</name> <operator>||</operator>
         <name><name>c</name><operator>-&gt;</operator><name>btype</name></name> <operator>==</operator> <name>BLOCKED_ZSET</name> <operator>||</operator>
         <name><name>c</name><operator>-&gt;</operator><name>btype</name></name> <operator>==</operator> <name>BLOCKED_STREAM</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

        <comment type="block">/* If the cluster is down, unblock the client with the right error. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CLUSTER_FAIL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterRedirectClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>CLUSTER_REDIR_DOWN_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* All keys must belong to the same slot, so check first key only. */</comment>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>slot</name> <init>= <expr><call><name>keyHashSlot</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
            <name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* if the client is read-only and attempting to access key that our
             * replica can handle, allow it. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_READONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>lastcmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_READONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>nodeIsSlave</name><argument_list>(<argument><expr><name>myself</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>myself</name><operator>-&gt;</operator><name>slaveof</name></name> <operator>==</operator> <name>node</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name>myself</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* We send an error and unblock the client if:
             * 1) The slot is unassigned, emitting a cluster down error.
             * 2) The slot is not handled by this node, nor being imported. */</comment>
            <if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>myself</name> <operator>&amp;&amp;</operator>
                <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>importing_slots_from</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>clusterRedirectClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><name>CLUSTER_REDIR_DOWN_UNBOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>clusterRedirectClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>node</name></expr></argument>,<argument><expr><name>slot</name></expr></argument>,
                        <argument><expr><name>CLUSTER_REDIR_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function></block_content></block></if></if_stmt></block_content></block></function>
</unit>
