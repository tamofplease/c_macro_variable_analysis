<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/db.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_QFork.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"atomicvar.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/*-----------------------------------------------------------------------------
 * C-level DB API
 *----------------------------------------------------------------------------*/</comment>

<function_decl><type><name>int</name></type> <name>keyIsExpired</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Update LFU when an object is accessed.
 * Firstly, decrement the counter if the decrement time is reached.
 * Then logarithmically increment the counter, and update the access time. */</comment>
<function><type><name>void</name></type> <name>updateLFU</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>counter</name> <init>= <expr><call><name>LFUDecrAndReturn</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>counter</name> <operator>=</operator> <call><name>LFULogIncr</name><argument_list>(<argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <operator>(</operator><call><name>LFUGetTimeInMinutes</name><argument_list>()</argument_list></call><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>counter</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Low level key lookup API, not actually called directly from commands
 * implementations that should instead rely on lookupKeyRead(),
 * lookupKeyWrite() and lookupKeyReadWithFlags(). */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKey</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Update the access time for the ageing algorithm.
         * Don't do it if we have a saving child, as this will trigger
         * a copy on write madness. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>LOOKUP_NOTOUCH</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>updateLFU</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <call><name>LRU_CLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>val</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Lookup a key for read operations, or return NULL if the key is not found
 * in the specified DB.
 *
 * As a side effect of calling this function:
 * 1. A key gets expired if it reached it's TTL.
 * 2. The key last access time is updated.
 * 3. The global keys hits/misses stats are updated (reported in INFO).
 *
 * This API should not be used when we write to the key after obtaining
 * the object linked to the key, but only for read only operations.
 *
 * Flags change the behavior of this command:
 *
 *  LOOKUP_NONE (or zero): no special flags are passed.
 *  LOOKUP_NOTOUCH: don't alter the last access time of the key.
 *
 * Note: this function also returns NULL if the key is logically expired
 * but still existing, in case this is a slave, since this API is called only
 * for read operations. Even if the key expiry is master-driven, we can
 * correctly report a key is expired on slaves even if the master is lagging
 * expiring our key via DELs in the replication link. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKeyReadWithFlags</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>expireIfNeeded</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Key expired. If we are in the context of a master, expireIfNeeded()
         * returns 0 only when the key does not exist at all, so it's safe
         * to return NULL ASAP. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_keyspace_misses</name></name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* However if we are in the context of a slave, expireIfNeeded() will
         * not really try to expire the key, it only returns information
         * about the "logical" status of the key: key expiring is up to the
         * master in order to have a consistent view of master's data set.
         *
         * However, if the command caller is not the master, and as additional
         * safety measure, the command invoked is a read-only command, we can
         * safely return NULL here, and provide a more consistent behavior
         * to clients accessign expired values in a read-only fashion, that
         * will say the key as non existing.
         *
         * Notably this covers GETs when slaves are used to scale reads. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>current_client</name></name> <operator>!=</operator> <name><name>server</name><operator>.</operator><name>master</name></name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>current_client</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>current_client</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_READONLY</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_keyspace_misses</name></name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lookupKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_keyspace_misses</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_keyspace_hits</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like lookupKeyReadWithFlags(), but does not use any flag, which is the
 * common case. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKeyRead</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>lookupKeyReadWithFlags</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>LOOKUP_NONE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Lookup a key for write operations, and as a side effect, if needed, expires
 * the key if its TTL is reached.
 *
 * Returns the linked value object if the key exists or NULL if the key
 * does not exist in the specified DB. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKeyWrite</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>expireIfNeeded</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>lookupKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>LOOKUP_NONE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKeyReadOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKeyWriteOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add the key to the DB. It's up to the caller to increment the reference
 * counter of the value if needed.
 *
 * The program is aborted if the key already exists. */</comment>
<function><type><name>void</name></type> <name>dbAdd</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>copy</name> <init>= <expr><call><name>sdsdup</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name> <operator>||</operator>
        <name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>signalKeyAsReady</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>slotToKeyAdd</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Overwrite an existing key with a new value. Incrementing the reference
 * count of the new value is up to the caller.
 * This function does not modify the expire time of the existing key.
 *
 * The program is aborted if the key was not already present. */</comment>
<function><type><name>void</name></type> <name>dbOverwrite</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>dictEntry</name></type> <name>auxentry</name> <init>= <expr><operator>*</operator><name>de</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <name><name>old</name><operator>-&gt;</operator><name>lru</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dictSetVal</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name>de</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_server_del</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeObjAsync</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictSetVal</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auxentry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>dictFreeVal</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auxentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* High level Set operation. This function can be used in order to set
 * a key, whatever it was existing or not, to a new object.
 *
 * 1) The ref count of the value object is incremented.
 * 2) clients WATCHing for the destination key notified.
 * 3) The expire time of the key is reset (the key is made persistent).
 *
 * All the new keys in the database should be created via this interface. */</comment>
<function><type><name>void</name></type> <name>setKey</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>dbOverwrite</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>removeExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>dbExists</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a random key, in form of a Redis object.
 * If there are no keys, NULL is returned.
 *
 * The function makes sure to return keys not already expired. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>dbRandomKey</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxtries</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>allvolatile</name> <init>= <expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>keyobj</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>keyobj</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>allvolatile</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <operator>--</operator><name>maxtries</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If the DB is composed only of keys with an expire set,
                 * it could happen that all the keys are already logically
                 * expired in the slave, so the function cannot stop because
                 * expireIfNeeded() is false, nor it can stop because
                 * dictGetRandomKey() returns NULL (there are keys to return).
                 * To prevent the infinite loop we do some tries, but if there
                 * are the conditions for an infinite loop, eventually we
                 * return a key name that may be already expired. */</comment>
                <return>return <expr><name>keyobj</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>expireIfNeeded</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue> <comment type="block">/* search for another key. This expired. */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>keyobj</name></expr>;</return>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Delete a key, value, and associated expiration entry if any, from the DB */</comment>
<function><type><name>int</name></type> <name>dbSyncDelete</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Deleting an entry from the expires dict will not free the sds of
     * the key, because it is shared with the main dictionary. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>slotToKeyDel</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This is a wrapper whose behavior depends on the Redis lazy free
 * configuration. Deletes the key synchronously or asynchronously. */</comment>
<function><type><name>int</name></type> <name>dbDelete</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_server_del</name></name></expr> ?</condition><then> <expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                             <expr><call><name>dbSyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Prepare the string object stored at 'key' to be modified destructively
 * to implement commands like SETBIT or APPEND.
 *
 * An object is usually ready to be modified unless one of the two conditions
 * are true:
 *
 * 1) The object 'o' is shared (refcount &gt; 1), we don't want to affect
 *    other users.
 * 2) The object encoding is not "RAW".
 *
 * If the object is found in one of the above conditions (or both) by the
 * function, an unshared / not-encoded copy of the string object is stored
 * at 'key' in the specified 'db'. Otherwise the object 'o' itself is
 * returned.
 *
 * USAGE:
 *
 * The object 'o' is what the caller already obtained by looking up 'key'
 * in 'db', the usage pattern looks like this:
 *
 * o = lookupKeyWrite(db,key);
 * if (checkType(c,o,OBJ_STRING)) return;
 * o = dbUnshareStringValue(db,key,o);
 *
 * At this point the caller is ready to modify the object, for example
 * using an sdscat() call to append some data, or anything else.
 */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>dbUnshareStringValue</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>refcount</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>OBJ_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>decoded</name> <init>= <expr><call><name>getDecodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createRawStringObject</name><argument_list>(<argument><expr><name><name>decoded</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>decoded</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbOverwrite</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove all keys from all the databases in a Redis server.
 * If callback is given the function is called from time to time to
 * signal that work is in progress.
 *
 * The dbnum can be -1 if all the DBs should be flushed, or the specified
 * DB number if we want to flush only a single Redis database number.
 *
 * Flags are be EMPTYDB_NO_FLAGS if no special flags are specified or
 * EMPTYDB_ASYNC if we want the memory to be freed in a different thread
 * and the function to return ASAP.
 *
 * On success the fuction returns the number of keys removed from the
 * database(s). Otherwise -1 is returned in the specific case the
 * DB number is out of range, and errno is set to EINVAL. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>emptyDb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dbnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type>(<name>callback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>async</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EMPTYDB_ASYNC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dbnum</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>dbnum</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>startdb</name></decl>, <decl><type ref="prev"/><name>enddb</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>startdb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>enddb</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>startdb</name> <operator>=</operator> <name>enddb</name> <operator>=</operator> <name>dbnum</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>startdb</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>enddb</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>removed</name> <operator>+=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>async</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>emptyDbAsync</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>dictEmpty</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dict</name></expr></argument>,<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictEmpty</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>expires</name></expr></argument>,<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>async</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>slotToKeyFlushAsync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>slotToKeyFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>flushSlaveKeysWithExpireList</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>selectDb</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>id</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>id</name></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Hooks for key space changes.
 *
 * Every time a key in the database is modified the function
 * signalModifiedKey() is called.
 *
 * Every time a DB is flushed the function signalFlushDb() is called.
 *----------------------------------------------------------------------------*/</comment>

<function><type><name>void</name></type> <name>signalModifiedKey</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>touchWatchedKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>signalFlushedDb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>touchWatchedKeysOnFlush</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Type agnostic commands operating on the key space
 *----------------------------------------------------------------------------*/</comment>

<comment type="block">/* Return the set of flags to use for the emptyDb() call for FLUSHALL
 * and FLUSHDB commands.
 *
 * Currently the command just attempts to parse the "ASYNC" option. It
 * also checks if the command arity is wrong.
 *
 * On success C_OK is returned and the flags are stored in *flags, otherwise
 * C_ERR is returned and the function sends an error to the client. */</comment>
<function><type><name>int</name></type> <name>getFlushCommandFlags</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Parse the optional ASYNC option. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"async"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>EMPTYDB_ASYNC</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>EMPTYDB_NO_FLAGS</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* FLUSHDB [ASYNC]
 *
 * Flushes the currently SELECTed Redis DB. */</comment>
<function><type><name>void</name></type> <name>flushdbCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getFlushCommandFlags</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>signalFlushedDb</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <call><name>emptyDb</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>flags</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* FLUSHALL [ASYNC]
 *
 * Flushes the whole server data set. */</comment>
<function><type><name>void</name></type> <name>flushallCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getFlushCommandFlags</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>signalFlushedDb</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <call><name>emptyDb</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>flags</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>AbortForkOperation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name></expr></argument>,<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rdbRemoveTempFile</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>saveparamslen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Normally rdbSave() will reset dirty, but we don't want this here
         * as otherwise FLUSHALL will not be replicated nor put into the AOF. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>saved_dirty</name> <init>= <expr><name><name>server</name><operator>.</operator><name>dirty</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>rdbSaveInfo</name></type> <name>rsi</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rsiptr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rsiptr</name> <operator>=</operator> <call><name>rdbPopulateSaveInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rdbSave</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>,<argument><expr><name>rsiptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>=</operator> <name>saved_dirty</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This command implements DEL and LAZYDEL. */</comment>
<function><type><name>void</name></type> <name>delGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lazy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>numdel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>expireIfNeeded</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>deleted</name>  <init>= <expr><ternary><condition><expr><name>lazy</name></expr> ?</condition><then> <expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
                              <expr><call><name>dbSyncDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,
                <argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>numdel</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>numdel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>delCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>delGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>unlinkCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>delGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* EXISTS key1 key2 ... key_N.
 * Return value is the number of keys existing. */</comment>
<function><type><name>void</name></type> <name>existsCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>selectCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>id</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,
        <argument><expr><literal type="string">"invalid DB index"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name> <operator>&amp;&amp;</operator> <name>id</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"SELECT is not allowed in cluster mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>selectDb</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>                                     <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
        <name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"DB index is out of range"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>randomkeyCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>key</name> <operator>=</operator> <call><name>dbRandomKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>keysCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>pattern</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>plen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>allkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>numkeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>replylen</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>allkeys</name> <operator>=</operator> <operator>(</operator><name><name>pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name>plen</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>keyobj</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>allkeys</name> <operator>||</operator> <call><name>stringmatchlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>,<argument><expr><name>plen</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>keyobj</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>keyIsExpired</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>numkeys</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>replylen</name></expr></argument>,<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This callback is used by scanGenericCommand in order to collect elements
 * returned by the dictionary iterator into a list. */</comment>
<function><type><name>void</name></type> <name>scanCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pd</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><name><name>pd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>pd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdskey</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdskey</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdskey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>keysds</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>keysds</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>keysds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdskey</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdsval</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdskey</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdskey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdsval</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdskey</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdskey</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdskey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>createStringObjectFromLongDouble</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Type not handled in SCAN callback."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Try to parse a SCAN cursor stored at object 'o':
 * if the cursor is valid, store it as unsigned integer into *cursor and
 * returns C_OK. Otherwise return C_ERR and send an error to the
 * client. */</comment>
<function><type><name>int</name></type> <name>parseScanCursorOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>

    <comment type="block">/* Use strtoul() because we need an *unsigned* long, so
     * getLongLongFromObject() does not cover the whole cursor space. */</comment>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cursor</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"invalid cursor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This command implements SCAN, HSCAN and SSCAN commands.
 * If object 'o' is passed, then it must be a Hash or Set object, otherwise
 * if 'o' is NULL the command will operate on the dictionary associated with
 * the current database.
 *
 * When 'o' is not NULL the function assumes that the first argument in
 * the client arguments vector is a key so it skips it before iterating
 * in order to parse options.
 *
 * In the case of a Hash object the function returns both the field and value
 * of every element on the Hash. */</comment>
<function><type><name>void</name></type> <name>scanGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name></type> <name>cursor</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>pat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>patlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>use_pattern</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

    <comment type="block">/* Object must be NULL (to iterate keys names), or the type of the object
     * must be Set, Sorted Set, or Hash. */</comment>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name> <operator>||</operator>
                <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set i to the first option argument. The previous one is the cursor. */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>o</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr>;</expr_stmt> <comment type="block">/* Skip the key argument if needed. */</comment>

    <comment type="block">/* Step 1: Parse options. */</comment>
    <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>j</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                <operator>!=</operator> <name>C_OK</name></expr>)</condition>
            <block>{<block_content>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"match"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>j</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>pat</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>patlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                          <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>

            <comment type="block">/* The pattern always matches if it is exactly "*", so it is
             * equivalent to disabling it. */</comment>
            <name>use_pattern</name> <init>= <expr><operator>!</operator><operator>(</operator><name><name>pat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name>patlen</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Step 2: Iterate the collection.
     *
     * Note that if the object is encoded with a ziplist, intset, or any other
     * representation that is not a hash table, we are sure that it is also
     * composed of a small number of elements. So to avoid taking state we
     * just return everything inside the object in a single call, setting the
     * cursor to zero to signal the end of the iteration. */</comment>

    <comment type="block">/* Handle the case of a hash table. */</comment>
    <expr_stmt><expr><name>ht</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ht</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name> <operator>&amp;&amp;</operator> <name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ht</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name> <operator>&amp;&amp;</operator> <name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ht</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* We return key / value for this type. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name> <operator>&amp;&amp;</operator> <name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ht</name> <operator>=</operator> <name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* We return key / value for this type. */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>privdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
        <comment type="block">/* We set the max number of iterations to ten times the specified
         * COUNT, so if the hash table is in a pathological state (very
         * sparsely populated) we avoid to block too much time at the cost
         * of returning no or very few elements. */</comment>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>maxiterations</name> <init>= <expr><name>count</name><operator>*</operator><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We pass two pointers to the callback: the list to which it will
         * add new elements, and the object containing the dictionary so that
         * it is possible to fetch more data in a type-dependent way. */</comment>
        <expr_stmt><expr><name><name>privdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>keys</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>privdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
        <do>do <block>{<block_content>
            <expr_stmt><expr><name>cursor</name> <operator>=</operator> <call><name>dictScan</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>scanCallback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><name>cursor</name> <operator>&amp;&amp;</operator>
              <name>maxiterations</name><operator>--</operator> <operator>&amp;&amp;</operator>
              <call><name>listLength</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name>count</name></expr>)</condition>;</do>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>ll</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><call><name>intsetGet</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>pos</name><operator>++</operator></expr></argument>,<argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>keys</name></expr></argument>,<argument><expr><call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>cursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vll</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>keys</name></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>vstr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>createStringObject</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                 <expr><call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>vll</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>cursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Not handled encoding in SCAN."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Step 3: Filter elements. */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>listFirst</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>kobj</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nextnode</name> <operator>=</operator> <call><name>listNextNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>filter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Filter element if it does not match the pattern. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>filter</name> <operator>&amp;&amp;</operator> <name>use_pattern</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>kobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>stringmatchlen</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name><name>kobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>kobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
                    <name>filter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>kobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>kobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>stringmatchlen</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>filter</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Filter element if it is an expired key. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>filter</name> <operator>&amp;&amp;</operator> <name>o</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>expireIfNeeded</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>kobj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>filter</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Remove the element and its associted value if needed. */</comment>
        <if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>kobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If this is a hash or a sorted set, we have a flat list of
         * key-value elements, so if this element was filtered, remove the
         * value, or skip it if it was not filtered: we only match keys. */</comment>
        <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name>nextnode</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextnode</name> <operator>=</operator> <call><name>listNextNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>kobj</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>kobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name>nextnode</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Step 4: Reply to the client. */</comment>
    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>node</name> <operator>=</operator> <call><name>listFirst</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>kobj</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>kobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>kobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name>keys</name></expr></argument>,<argument><expr><name>decrRefCountVoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The SCAN command completely relies on scanGenericCommand. */</comment>
<function><type><name>void</name></type> <name>scanCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>cursor</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>parseScanCursorOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>scanGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dbsizeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lastsaveCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>lastsave</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>typeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyReadWithFlags</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>LOOKUP_NOTOUCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"none"</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>OBJ_STRING</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"string"</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_LIST</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"list"</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_SET</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"set"</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_ZSET</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"zset"</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_HASH</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"hash"</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_STREAM</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"stream"</literal></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>OBJ_MODULE</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>mv</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        </block_content>}</block><empty_stmt>;</empty_stmt> <break>break;</break>
        <default>default:</default> <expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"unknown"</literal></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>addReplyStatus</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>shutdownCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"nosave"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SHUTDOWN_NOSAVE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"save"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SHUTDOWN_SAVE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>prepareForShutdown</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Errors trying to SHUTDOWN. Check logs."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>renameGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>expire</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>samekey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* When source and dest key is the same, no operation is performed,
     * if the key exists, however we still return an error on unexisting key. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>sdscmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>samekey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nokeyerr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>samekey</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>nx</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>expire</name> <operator>=</operator> <call><name>getExpire</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>nx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Overwrite: delete the old key before creating the new one
         * with the same name. */</comment>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setExpire</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>expire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"rename_from"</literal></expr></argument>,
        <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"rename_to"</literal></expr></argument>,
        <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>nx</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>renameCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>renameGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>renamenxCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>renameGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moveCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>srcid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>dbid</name></decl>, <decl><type ref="prev"/><name>expire</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"MOVE is not allowed in cluster mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Obtain source and target DB pointers */</comment>
    <expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>srcid</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObject</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>dbid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name> <operator>||</operator>
        <name><name>dbid</name> <argument_list type="generic">&lt; <argument><expr><name>INT_MIN</name> <operator>||</operator> <name>dbid</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name> <operator>||</operator>
        <call><name>selectDb</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dbid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>                                     <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>outofrangeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>dst</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>srcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Back to the source DB */</comment>

    <comment type="block">/* If the user is moving using as target the same
     * DB as the source DB it is probably an error. */</comment>
    <if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>dst</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>sameobjecterr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if the element exists and get a reference */</comment>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>expire</name> <operator>=</operator> <call><name>getExpire</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return zero if the key already exists in the target DB */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setExpire</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>dst</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>expire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* OK! key moved, free the entry in the source DB */</comment>
    <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name>src</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function for dbSwapDatabases(): scans the list of keys that have
 * one or more blocked clients for B[LR]POP or other blocking commands
 * and signal the keys as ready if they are of the right type. See the comment
 * where the function is used for more info. */</comment>
<function><type><name>void</name></type> <name>scanDatabaseForReadyLists</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>blocking_keys</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>lookupKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>LOOKUP_NOTOUCH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name> <operator>||</operator>
                      <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STREAM</name> <operator>||</operator>
                      <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>signalKeyAsReady</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Swap two databases at runtime so that all clients will magically see
 * the new database even if already connected. Note that the client
 * structure c-&gt;db points to a given DB, so we need to be smarter and
 * swap the underlying referenced structures, otherwise we would need
 * to fix all the references to the Redis DB structure.
 *
 * Returns C_ERR if at least one of the DB ids are out of range, otherwise
 * C_OK is returned. */</comment>
<function><type><name>int</name></type> <name>dbSwapDatabases</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>id1</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>id1</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name> <operator>||</operator>
        <name>id2</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>id2</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>id1</name> <operator>==</operator> <name>id2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>redisDb</name></type> <name>aux</name> <init>= <expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>id1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db1</name> <init>= <expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>id1</name></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>db2</name> <init>= <expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name>id2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Swap hash tables. Note that we don't swap blocking_keys,
     * ready_keys and watched_keys, since we want clients to
     * remain in the same DB they were. */</comment>
    <expr_stmt><expr><name><name>db1</name><operator>-&gt;</operator><name>dict</name></name> <operator>=</operator> <name><name>db2</name><operator>-&gt;</operator><name>dict</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db1</name><operator>-&gt;</operator><name>expires</name></name> <operator>=</operator> <name><name>db2</name><operator>-&gt;</operator><name>expires</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db1</name><operator>-&gt;</operator><name>avg_ttl</name></name> <operator>=</operator> <name><name>db2</name><operator>-&gt;</operator><name>avg_ttl</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>db2</name><operator>-&gt;</operator><name>dict</name></name> <operator>=</operator> <name><name>aux</name><operator>.</operator><name>dict</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db2</name><operator>-&gt;</operator><name>expires</name></name> <operator>=</operator> <name><name>aux</name><operator>.</operator><name>expires</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db2</name><operator>-&gt;</operator><name>avg_ttl</name></name> <operator>=</operator> <name><name>aux</name><operator>.</operator><name>avg_ttl</name></name></expr>;</expr_stmt>

    <comment type="block">/* Now we need to handle clients blocked on lists: as an effect
     * of swapping the two DBs, a client that was waiting for list
     * X in a given DB, may now actually be unblocked if X happens
     * to exist in the new version of the DB, after the swap.
     *
     * However normally we only do this check for efficiency reasons
     * in dbAdd() when a list is created. So here we need to rescan
     * the list of clients blocked on lists and signal lists as ready
     * if needed. */</comment>
    <expr_stmt><expr><call><name>scanDatabaseForReadyLists</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scanDatabaseForReadyLists</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* SWAPDB db1 db2 */</comment>
<function><type><name>void</name></type> <name>swapdbCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>id1</name></decl>, <decl><type ref="prev"/><name>id2</name></decl>;</decl_stmt>

    <comment type="block">/* Not allowed in cluster mode: we have just DB 0 there. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"SWAPDB is not allowed in cluster mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the two DBs indexes. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id1</name></expr></argument>,
        <argument><expr><literal type="string">"invalid first DB index"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id2</name></expr></argument>,
        <argument><expr><literal type="string">"invalid second DB index"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Swap... */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dbSwapDatabases</name><argument_list>(<argument><expr><name>id1</name></expr></argument>,<argument><expr><name>id2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"DB index is out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 * Expires API
 *----------------------------------------------------------------------------*/</comment>

<function><type><name>int</name></type> <name>removeExpire</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* An expire may only be removed if there is a corresponding entry in the
     * main dict. Otherwise, the key will never be freed. */</comment>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set an expire to the specified key. If the expire is set in the context
 * of an user calling a command 'c' is the client, otherwise 'c' is set
 * to NULL. The 'when' parameter is the absolute unix time in milliseconds
 * after which the key will no longer be considered valid. */</comment>
<function><type><name>void</name></type> <name>setExpire</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>when</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>kde</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <comment type="block">/* Reuse the sds from the main dict in the expire dict */</comment>
    <expr_stmt><expr><name>kde</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>kde</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictAddOrFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>kde</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictSetSignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>writable_slave</name> <init>= <expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_slave_ro</name></name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;&amp;</operator> <name>writable_slave</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>rememberSlaveKeyWithExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the expire time of the specified key, or -1 if no expire
 * is associated with this key (i.e. the key is non volatile) */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>getExpire</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <comment type="block">/* No expire? return ASAP */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
       <operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* The entry was found in the expire dict, this means it should also
     * be present in the main dict (safety check). */</comment>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>dictGetSignedIntegerVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Propagate expires into slaves and the AOF file.
 * When a key expires in the master, a DEL operation for this key is sent
 * to all the slaves and the AOF file if enabled.
 *
 * This way the key expiry is centralized in one place, and since both
 * AOF and the master-&gt;slave link guarantee operation ordering, everything
 * will be consistent even if we allow write operations against expiring
 * keys. */</comment>
<function><type><name>void</name></type> <name>propagateExpire</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lazy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>lazy</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>unlink</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>del</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>!=</operator> <name>AOF_OFF</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>feedAppendOnlyFile</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>delCommand</name></name></expr></argument>,<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>replicationFeedSlaves</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if the key is expired. */</comment>
<function><type><name>int</name></type> <name>keyIsExpired</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>when</name> <init>= <expr><call><name>getExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>when</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* No expire for this key */</comment>

    <comment type="block">/* Don't expire anything while loading. It will be done later. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we are in the context of a Lua script, we pretend that time is
     * blocked to when the Lua script started. This way a key can expire
     * only the first time it is accessed and not in the middle of the
     * script execution, making propagation to slaves / AOF consistent.
     * See issue #1525 on Github for more information. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lua_caller</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>lua_time_start</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* If we are in the middle of a command execution, we still want to use
     * a reference time that does not change: in that case we just use the
     * cached time, that we update before each call in the call() function.
     * This way we avoid that commands such as RPOPLPUSH or similar, that
     * may re-open the same key multiple times, can invalidate an already
     * open object in a next call, if the next call will see the key expired,
     * while the first did not. */</comment>
    <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>fixed_time_expire</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>mstime</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* For the other cases, we want to use the most fresh time we have. */</comment>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* The key expired if the current (virtual or real) time is greater
     * than the expire time of the key. */</comment>
    <return>return <expr><name>now</name> <operator>&gt;</operator> <name>when</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called when we are going to perform some operation
 * in a given key, but such key may be already logically expired even if
 * it still exists in the database. The main way this function is called
 * is via lookupKey*() family of functions.
 *
 * The behavior of the function depends on the replication role of the
 * instance, because slave instances do not expire keys, they wait
 * for DELs from the master for consistency matters. However even
 * slaves will try to have a coherent return value for the function,
 * so that read commands executed in the slave side will be able to
 * behave like if the key is expired even if still present (because the
 * master has yet to propagate the DEL).
 *
 * In masters as a side effect of finding a key which is expired, such
 * key will be evicted from the database. Also this may trigger the
 * propagation of a DEL/UNLINK command in AOF / replication stream.
 *
 * The return value of the function is 0 if the key is still valid,
 * otherwise the function returns 1 if the key is expired. */</comment>
<function><type><name>int</name></type> <name>expireIfNeeded</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>keyIsExpired</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we are running in the context of a slave, instead of
     * evicting the expired key from the database, we return ASAP:
     * the slave key expiration is controlled by the master that will
     * send us synthesized DEL operations for expired keys.
     *
     * Still we try to return the right information to the caller,
     * that is, 0 if we think the key should be still valid, 1 if
     * we think the key is expired at this time. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Delete the key */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_expiredkeys</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>propagateExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_expire</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_EXPIRED</name></expr></argument>,
        <argument><expr><literal type="string">"expired"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_expire</name></name></expr> ?</condition><then> <expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                         <expr><call><name>dbSyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * API to get key arguments from commands
 * ---------------------------------------------------------------------------*/</comment>

<comment type="block">/* The base case is to use the keys position as given in the command table
 * (firstkey, lastkey, step). */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>getKeysUsingCommandTable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,<parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>last</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>firstkey</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>lastkey</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>last</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>last</name> <operator>=</operator> <name>argc</name><operator>+</operator><name>last</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <name>last</name> <operator>-</operator> <name><name>cmd</name><operator>-&gt;</operator><name>firstkey</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cat (PORT_ULONG) */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>firstkey</name></name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>keystep</name></name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Modules commands, and standard commands with a not fixed number
             * of arguments (negative arity parameter) do not have dispatch
             * time arity checks, so we need to handle the case where the user
             * passed an invalid number of arguments here. In this case we
             * return no keys and expect the command implementation to report
             * an arity or syntax error. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_MODULE</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Redis built-in command declared keys positions not matching the arity requirements."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return all the arguments that are keys in the command passed via argc / argv.
 *
 * The command returns the positions of all the key arguments inside the array,
 * so the actual return value is an heap allocated array of integers. The
 * length of the array is returned by reference into *numkeys.
 *
 * 'cmd' must be point to the corresponding entry into the redisCommand
 * table, according to the command name in argv[0].
 *
 * This function uses the command table if a command-specific helper function
 * is not required, otherwise it calls the command-specific function. */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>getKeysFromCommand</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_MODULE_GETKEYS</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>moduleGetCommandKeysViaAPI</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CMD_MODULE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>getkeys_proc</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>cmd</name><operator>-&gt;</operator><name>getkeys_proc</name></name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>getKeysUsingCommandTable</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the result of getKeysFromCommand. */</comment>
<function><type><name>void</name></type> <name>getKeysFreeResult</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function to extract keys from following commands:
 * ZUNIONSTORE &lt;destkey&gt; &lt;num-keys&gt; &lt;key&gt; &lt;key&gt; ... &lt;key&gt; &lt;options&gt;
 * ZINTERSTORE &lt;destkey&gt; &lt;num-keys&gt; &lt;key&gt; &lt;key&gt; ... &lt;key&gt; &lt;options&gt; */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>zunionInterGetKeys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Sanity check. Don't return any key if the command is going to
     * reply with syntax error. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>num</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>num</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name>argc</name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Keys in z{union,inter}store come from two places:
     * argv[1] = storage key,
     * argv[3...n] = keys to intersect */</comment>
    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name>num</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_ULONG) */</comment>

    <comment type="block">/* Add all key positions for argv[3...n] to keys[] */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>+</operator><name>i</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Finally add the argv[1] key position (the storage key target). */</comment>
    <expr_stmt><expr><name><name>keys</name><index>[<expr><name>num</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>num</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Total keys = {union,inter} keys + storage key */</comment>
    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function to extract keys from the following commands:
 * EVAL &lt;script&gt; &lt;num-keys&gt; &lt;key&gt; &lt;key&gt; ... &lt;key&gt; [more stuff]
 * EVALSHA &lt;script&gt; &lt;num-keys&gt; &lt;key&gt; &lt;key&gt; ... &lt;key&gt; [more stuff] */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>evalGetKeys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Sanity check. Don't return any key if the command is going to
     * reply with syntax error. */</comment>
    <if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>num</name> <operator>&gt;</operator> <operator>(</operator><name>argc</name><operator>-</operator><literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>

    <comment type="block">/* Add all key positions for argv[3...n] to keys[] */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal><operator>+</operator><name>i</name></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function to extract keys from the SORT command.
 *
 * SORT &lt;sort-key&gt; ... STORE &lt;store-key&gt; ...
 *
 * The first argument of SORT is always a key, however a list of options
 * follow in SQL-alike style. Here we parse just the minimum in order to
 * correctly identify keys in the "STORE" option. */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>sortGetKeys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>, <decl><type ref="prev"/><name>found_store</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Alloc 2 places for the worst case. */</comment>

    <expr_stmt><expr><name><name>keys</name><index>[<expr><name>num</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* &lt;sort-key&gt; is always present. */</comment>

    <comment type="block">/* Search for STORE option. By default we consider options to don't
     * have arguments, so if we find an unknown option name we scan the
     * next. However there are options with 1 or 2 arguments, so we
     * provide a list here in order to skip the right number of args. */</comment>
    <struct>struct <block>{
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>skip</name></decl>;</decl_stmt>
    }</block> <decl><name><name>skiplist</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{<expr><literal type="string">"limit"</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"get"</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"by"</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
        <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr> <comment type="block">/* End of elements. */</comment>
    }</block></expr></init></decl>;</struct>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>skiplist</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name><name>skiplist</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>skiplist</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>skip</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"store"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Note: we don't increment "num" here and continue the loop
                 * to be sure to process the *last* "STORE" option if multiple
                 * ones are provided. This is same behavior as SORT. */</comment>
                <expr_stmt><expr><name>found_store</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>keys</name><index>[<expr><name>num</name></expr>]</index></name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* &lt;store-key&gt; */</comment>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>num</name> <operator>+</operator> <name>found_store</name></expr>;</expr_stmt>
    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <modifier>*</modifier></type><name>migrateGetKeys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"/><name>first</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Assume the obvious form. */</comment>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* But check for the extended one with the KEYS option. */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">6</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"keys"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>sdslen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>num</name> <operator>=</operator> <name>argc</name><operator>-</operator><name>first</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>first</name><operator>+</operator><name>i</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function to extract keys from following commands:
 * GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]
 *                             [COUNT count] [STORE key] [STOREDIST key]
 * GEORADIUSBYMEMBER key member radius unit ... options ... */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>georadiusGetKeys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for the presence of the stored key in the command */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>stored_key</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">5</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* For the case when user specifies both "store" and "storedist" options, the
         * second key specified would override the first key. This behavior is kept
         * the same as in georadiusCommand method.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"store"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"storedist"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>argc</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>stored_key</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>stored_key</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Keys in the command come from two places:
     * argv[1] = key,
     * argv[5...n] = stored key if present
     */</comment>
    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add all key positions to keys[] */</comment>
    <expr_stmt><expr><name><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>stored_key</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* XREAD [BLOCK &lt;milliseconds&gt;] [COUNT &lt;count&gt;] [GROUP &lt;groupname&gt; &lt;ttl&gt;]
 *       STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>xreadGetKeys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We need to parse the options of the command in order to seek the first
     * "STREAMS" string which is actually the option. This is needed because
     * "STREAMS" could also be the name of the consumer group and even the
     * name of the stream key. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>streams_pos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Skip option argument. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Skip option argument. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"group"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* Skip option argument. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"noack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Nothing to do. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"streams"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>streams_pos</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <break>break;</break> <comment type="block">/* Syntax error. */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>streams_pos</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>num</name> <operator>=</operator> <name>argc</name> <operator>-</operator> <name>streams_pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Syntax error. */</comment>
    <if_stmt><if>if <condition>(<expr><name>streams_pos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>num</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>num</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>num</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* We have half the keys as there are arguments because
                 there are also the IDs, one per key. */</comment>

    <expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>streams_pos</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name><operator>-</operator><name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name><operator>-</operator><name>streams_pos</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
    <return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Slot to Key API. This is used by Redis Cluster in order to obtain in
 * a fast way a key that belongs to a specified hash slot. This is useful
 * while rehashing the cluster and in other conditions when we need to
 * understand if we have keys for a given hash slot. */</comment>
<function><type><name>void</name></type> <name>slotToKeyUpdateKey</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hashslot</name> <init>= <expr><call><name>keyHashSlot</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>indexed</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>keylen</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name><index>[<expr><name>hashslot</name></expr>]</index></name> <operator>+=</operator> <ternary><condition><expr><name>add</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>keylen</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>indexed</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>keylen</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>indexed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>hashslot</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexed</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>hashslot</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>indexed</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>add</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name></expr></argument>,<argument><expr><name>indexed</name></expr></argument>,<argument><expr><name>keylen</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name></expr></argument>,<argument><expr><name>indexed</name></expr></argument>,<argument><expr><name>keylen</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>indexed</name> <operator>!=</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>indexed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>slotToKeyAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>slotToKeyUpdateKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>slotToKeyDel</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>slotToKeyUpdateKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>slotToKeyFlush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Pupulate the specified array of objects with keys in the specified slot.
 * New objects are returned to represent keys, it's up to the caller to
 * decrement the reference count to release the keys names. */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>getKeysInSlot</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashslot</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>indexed</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>indexed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>hashslot</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexed</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>hashslot</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>indexed</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>count</name><operator>--</operator> <operator>&amp;&amp;</operator> <call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>.</operator><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>indexed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>iter</name><operator>.</operator><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>indexed</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>keys</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>iter</name><operator>.</operator><name>key</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>iter</name><operator>.</operator><name>key_len</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove all the keys in the specified hash slot.
 * The number of removed items is returned. */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>delKeysInSlot</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashslot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>indexed</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>indexed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>hashslot</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexed</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>hashslot</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_to_keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name><index>[<expr><name>hashslot</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>indexed</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>iter</name><operator>.</operator><name>key</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>iter</name><operator>.</operator><name>key_len</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name>countKeysInSlot</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hashslot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>slots_keys_count</name><index>[<expr><name>hashslot</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
</unit>
