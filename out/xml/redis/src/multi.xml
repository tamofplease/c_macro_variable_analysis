<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/multi.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<comment type="block">/* ================================ MULTI/EXEC ============================== */</comment>

<comment type="block">/* Client state initialization for MULTI/EXEC */</comment>
<function><type><name>void</name></type> <name>initClientMultiState</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>cmd_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Release all the resources associated with MULTI/EXEC state */</comment>
<function><type><name>void</name></type> <name>freeClientMultiState</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>multiCmd</name> <modifier>*</modifier></type><name>mc</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name></name><operator>+</operator><name>j</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mc</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>mc</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>mc</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a new command into the MULTI commands queue */</comment>
<function><type><name>void</name></type> <name>queueMultiCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>multiCmd</name> <modifier>*</modifier></type><name>mc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name></name></expr></argument>,
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>multiCmd</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mc</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name></name><operator>+</operator><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mc</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>cmd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mc</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mc</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>mc</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>mc</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>cmd_flags</name></name> <operator>|=</operator> <name><name>c</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>discardTransaction</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>freeClientMultiState</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initClientMultiState</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CLIENT_MULTI</name><operator>|</operator><name>CLIENT_DIRTY_CAS</name><operator>|</operator><name>CLIENT_DIRTY_EXEC</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unwatchAllKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Flag the transacation as DIRTY_EXEC so that EXEC will fail.
 * Should be called every time there is an error while queueing a command. */</comment>
<function><type><name>void</name></type> <name>flagTransaction</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_DIRTY_EXEC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>multiCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"MULTI calls can not be nested"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_MULTI</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>discardCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"DISCARD without MULTI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>discardTransaction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a MULTI command to all the slaves and AOF file. Check the execCommand
 * implementation for more information. */</comment>
<function><type><name>void</name></type> <name>execCommandPropagateMulti</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>multistring</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"MULTI"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>propagate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>multiCommand</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>multistring</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,
              <argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>multistring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>execCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>orig_argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>orig_argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>orig_cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>must_propagate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Need to propagate MULTI/EXEC to AOF / slaves? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>was_master</name> <init>= <expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"EXEC without MULTI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if we need to abort the EXEC because:
     * 1) Some WATCHed key was touched.
     * 2) There was a previous error while queueing commands.
     * A failed EXEC in the first case returns a multi bulk nil object
     * (technically it is not an error but a special behavior), while
     * in the second an EXECABORT error is returned. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_DIRTY_CAS</name><operator>|</operator><name>CLIENT_DIRTY_EXEC</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_DIRTY_EXEC</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>execaborterr</name></name></expr> </then><else>:
                                                  <expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>discardTransaction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>handle_monitor</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If there are write commands inside the transaction, and this is a read
     * only slave, we want to send an error. This happens when the transaction
     * was initiated when the instance was a master or a writable replica and
     * then the configuration changed (for example instance was turned into
     * a replica). */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>loading</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_slave_ro</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>cmd_flags</name></name> <operator>&amp;</operator> <name>CMD_WRITE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><literal type="string">"Transaction contains write commands but instance "</literal>
            <literal type="string">"is now a read-only slave. EXEC aborted."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>discardTransaction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>handle_monitor</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Exec all the queued commands */</comment>
    <expr_stmt><expr><call><name>unwatchAllKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Unwatch ASAP otherwise we'll waste CPU cycles */</comment>
    <expr_stmt><expr><name>orig_argv</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>orig_argc</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>orig_cmd</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>cmd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>argc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>argv</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cmd</name></expr>;</expr_stmt>

        <comment type="block">/* Propagate a MULTI request once we encounter the first command which
         * is not readonly nor an administrative one.
         * This way we'll deliver the MULTI/..../EXEC block as a whole and
         * both the AOF and the replication link will have the same consistency
         * and atomicity guarantees. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>must_propagate</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CMD_READONLY</name><operator>|</operator><name>CMD_ADMIN</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>execCommandPropagateMulti</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>must_propagate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>call</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>loading</name></name></expr> ?</condition><then> <expr><name>CMD_CALL_NONE</name></expr> </then><else>: <expr><name>CMD_CALL_FULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Commands may alter argc/argv, restore mstate. */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>argc</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>argv</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>mstate</name><operator>.</operator><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cmd</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>cmd</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>orig_argv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>orig_argc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>orig_cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>discardTransaction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure the EXEC command will be propagated as well if MULTI
     * was already propagated. */</comment>
    <if_stmt><if>if <condition>(<expr><name>must_propagate</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>is_master</name> <init>= <expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* If inside the MULTI/EXEC block this instance was suddenly
         * switched from master to slave (using the SLAVEOF command), the
         * initial MULTI was propagated into the replication backlog, but the
         * rest was not. We need to make sure to at least terminate the
         * backlog with the final EXEC. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>&amp;&amp;</operator> <name>was_master</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_master</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>execcmd</name> <init>= <expr><literal type="string">"*1\r\n$4\r\nEXEC\r\n"</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>feedReplicationBacklog</name><argument_list>(<argument><expr><name>execcmd</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>execcmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>handle_monitor</name>:</label>
    <comment type="block">/* Send EXEC to clients waiting data from MONITOR. We do it here
     * since the natural order of commands execution is actually:
     * MUTLI, EXEC, ... commands inside transaction ...
     * Instead EXEC is flagged as CMD_SKIP_MONITOR in the command
     * table, and we do it here with correct ordering. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>monitors</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>server</name><operator>.</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>replicationFeedMonitors</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>monitors</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ===================== WATCH (CAS alike for MULTI/EXEC) ===================
 *
 * The implementation uses a per-DB hash table mapping keys to list of clients
 * WATCHing those keys, so that given a key that is going to be modified
 * we can mark all the associated clients as dirty.
 *
 * Also every client contains a list of WATCHed keys so that's possible to
 * un-watch such keys when the client is freed or when UNWATCH is called. */</comment>

<comment type="block">/* In the client-&gt;watched_keys list we need to use watchedKey structures
 * as in order to identify a key in Redis we need both the key name and the
 * DB */</comment>
<typedef>typedef <type><struct>struct <name>watchedKey</name> <block>{
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
}</block></struct></type> <name>watchedKey</name>;</typedef>

<comment type="block">/* Watch for the specified key */</comment>
<function><type><name>void</name></type> <name>watchForKey</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>clients</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>watchedKey</name> <modifier>*</modifier></type><name>wk</name></decl>;</decl_stmt>

    <comment type="block">/* Check if we are already watching for this key */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>wk</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>wk</name><operator>-&gt;</operator><name>db</name></name> <operator>==</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name></name> <operator>&amp;&amp;</operator> <call><name>equalStringObjects</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>wk</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Key already watched */</comment>
    </block_content>}</block></while>
    <comment type="block">/* This key is not already watched in this DB. Let's add it */</comment>
    <expr_stmt><expr><name>clients</name> <operator>=</operator> <call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>clients</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>clients</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>clients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>clients</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Add the new key to the list of keys watched by this client */</comment>
    <expr_stmt><expr><name>wk</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wk</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wk</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><name>wk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Unwatch all the keys watched by this client. To clean the EXEC dirty
 * flag is up to the caller. */</comment>
<function><type><name>void</name></type> <name>unwatchAllKeys</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>clients</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>watchedKey</name> <modifier>*</modifier></type><name>wk</name></decl>;</decl_stmt>

        <comment type="block">/* Lookup the watched key -&gt; clients list and remove the client
         * from the list */</comment>
        <expr_stmt><expr><name>wk</name> <operator>=</operator> <call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>clients</name> <operator>=</operator> <call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>wk</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>, <argument><expr><name><name>wk</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>clients</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>clients</name></expr></argument>,<argument><expr><call><name>listSearchKey</name><argument_list>(<argument><expr><name>clients</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Kill the entry at all if this was the only client */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>clients</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>wk</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>, <argument><expr><name><name>wk</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Remove this watched key from the client-&gt;watched list */</comment>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>wk</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>wk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* "Touch" a key, so that if this key is being WATCHed by some client the
 * next EXEC will fail. */</comment>
<function><type><name>void</name></type> <name>touchWatchedKey</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>clients</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>clients</name> <operator>=</operator> <call><name>dictFetchValue</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>clients</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</comment>
    <comment type="block">/* Check if we are already watching for this key */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>clients</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_DIRTY_CAS</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* On FLUSHDB or FLUSHALL all the watched keys that are present before the
 * flush but will be deleted as effect of the flushing operation should
 * be touched. "dbid" is the DB that's getting the flush. -1 if it is
 * a FLUSHALL operation (all the DBs flushed). */</comment>
<function><type><name>void</name></type> <name>touchWatchedKeysOnFlush</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li1</name></decl>, <decl><type ref="prev"/><name>li2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <comment type="block">/* For every client, check all the waited keys */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>watchedKey</name> <modifier>*</modifier></type><name>wk</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* For every watched key matching the specified DB, if the
             * key exists, mark the client as dirty, as the key will be
             * removed. */</comment>
            <if_stmt><if>if <condition>(<expr><name>dbid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>wk</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>dbid</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>wk</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name><name>wk</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_DIRTY_CAS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>watchCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"WATCH inside MULTI is not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>watchForKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>unwatchCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>unwatchAllKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>CLIENT_DIRTY_CAS</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
