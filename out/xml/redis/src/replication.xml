<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/replication.c"><comment type="block">/* Asynchronous replication implementation.
 *
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_FDAPI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_ThreadControl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_QFork.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Error.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cluster.h"</cpp:file></cpp:include>

<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;sys/time.h&gt;</argument>)</argument_list></macro>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;unistd.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<macro><name>POSIX_ONLY</name><argument_list>(<argument>#include &lt;sys/socket.h&gt;</argument>)</argument_list></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<function_decl><type><name>void</name></type> <name>replicationDiscardCachedMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>replicationResurrectCachedMaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>replicationSendAck</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>putSlaveOnline</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>cancelReplicationHandshake</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* --------------------------- Utility functions ---------------------------- */</comment>

<comment type="block">/* Return the pointer to a string representing the slave ip:listening_port
 * pair. Mostly useful for logging, since we want to log a slave using its
 * IP address and its listening port which is more clear for the user, for
 * example: "Closing connection with replica 10.1.2.3:6380". */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>replicationGetSlaveName</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><name>NET_PEER_ID_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator>
        <call><name>anetPeerToString</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Note that the 'ip' buffer is always larger than 'c-&gt;slave_ip' */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>slave_listening_port</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>anetFormatAddr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>slave_listening_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%s:&lt;unknown-replica-port&gt;"</literal></expr></argument>,<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"client id #%llu"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------- MASTER -------------------------------- */</comment>

<function><type><name>void</name></type> <name>createReplicationBacklog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* We don't have any data inside our buffer, but virtually the first
     * byte we have is the next byte that will be generated for the
     * replication stream. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called when the user modifies the replication backlog
 * size at runtime. It is up to the function to both update the
 * server.repl_backlog_size and to resize the buffer and setup it so that
 * it contains the same data as the previous one (possibly less data, but
 * the most recent bytes, or the same data and more free space in case the
 * buffer is enlarged). */</comment>
<function><type><name>void</name></type> <name>resizeReplicationBacklog</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>newsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&lt;</operator> <name>CONFIG_REPL_BACKLOG_MIN_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>CONFIG_REPL_BACKLOG_MIN_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name> <operator>==</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* What we actually do is to flush the old buffer and realloc a new
         * empty one. It will refill with new data incrementally.
         * The reason is that copying a few gigabytes adds latency and even
         * worse often we need to alloc additional space before freeing the
         * old buffer. */</comment>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Next byte we have is... the next since the buffer is empty. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeReplicationBacklog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add data to the replication backlog.
 * This function also increments the global replication offset stored at
 * server.master_repl_offset, because there is no case where we want to feed
 * the backlog without incrementing the offset. */</comment>
<function><type><name>void</name></type> <name>feedReplicationBacklog</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master_repl_offset</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* This is a circular buffer, so write as much data we can at every
     * iteration and rewind the "idx" index if we reach the limit. */</comment>
    <while>while<condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>thislen</name> <init>= <expr><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>thislen</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>thislen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name><operator>+</operator><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>thislen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name> <operator>+=</operator> <name>thislen</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name> <operator>==</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>thislen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>thislen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>+=</operator> <name>thislen</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Set the offset of the first byte we have in the backlog. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name> <operator>-</operator>
                              <name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Wrapper for feedReplicationBacklog() that takes Redis string objects
 * as input. */</comment>
<function><type><name>void</name></type> <name>feedReplicationBacklogWithObject</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>llstr</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>llstr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>llstr</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>llstr</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>feedReplicationBacklog</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Propagate write commands to slaves, and populate the replication backlog
 * as well. This function is used if the instance is a master: we use
 * the commands received by our clients in order to create the replication
 * stream. Instead if the instance is a slave and has sub-slaves attached,
 * we use replicationFeedSlavesFromMaster() */</comment>
<function><type><name>void</name></type> <name>replicationFeedSlaves</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>slaves</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictid</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>llstr</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* If the instance is not a top level master, return ASAP: we'll just proxy
     * the stream of data we receive from our master instead, in order to
     * propagate *identical* replication stream. In this way this slave can
     * advertise the same replication ID as the master (since it shares the
     * master replication history and has the same backlog and offsets). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If there aren't slaves, and there is no backlog buffer to populate,
     * we can return ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name>slaves</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* We can't have slaves attached and no backlog. */</comment>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>listLength</name><argument_list>(<argument><expr><name>slaves</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Send SELECT command to every slave if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>slaveseldb</name></name> <operator>!=</operator> <name>dictid</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>selectcmd</name></decl>;</decl_stmt>

        <comment type="block">/* For a few DBs we have pre-computed SELECT command. */</comment>
        <if_stmt><if>if <condition>(<expr><name>dictid</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dictid</name> <operator>&lt;</operator> <name>PROTO_SHARED_SELECT_CMDS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>selectcmd</name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>select</name><index>[<expr><name>dictid</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>dictid_len</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>dictid_len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>llstr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>llstr</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>dictid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>selectcmd</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,
                <argument><expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><literal type="string">"*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n"</literal></expr></argument>,
                <argument><expr><name>dictid_len</name></expr></argument>, <argument><expr><name>llstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Add the SELECT command into the backlog. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>feedReplicationBacklogWithObject</name><argument_list>(<argument><expr><name>selectcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Send it to slaves. */</comment>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>slaves</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>slave</name></expr></argument>,<argument><expr><name>selectcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>dictid</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>dictid</name> <operator>&gt;=</operator> <name>PROTO_SHARED_SELECT_CMDS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>selectcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>slaveseldb</name></name> <operator>=</operator> <name>dictid</name></expr>;</expr_stmt>

    <comment type="block">/* Write the command to the replication backlog if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>aux</name><index>[<expr><name>LONG_STR_SIZE</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* Add the multi bulk reply length. */</comment>
        <expr_stmt><expr><name><name>aux</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>aux</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aux</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aux</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>feedReplicationBacklog</name><argument_list>(<argument><expr><name>aux</name></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (size_t) */</comment>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>objlen</name> <init>= <expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator> <call><name>stringObjectLen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>            <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_LONG) */</comment>

            <comment type="block">/* We need to feed the buffer with the object as a bulk reply
             * not just as a plain string, so create the $..CRLF payload len
             * and add the final CRLF */</comment>
            <name><name>aux</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <init>= <expr><literal type="char">'$'</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>aux</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>objlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aux</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aux</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>feedReplicationBacklog</name><argument_list>(<argument><expr><name>aux</name></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (size_t) */</comment>
            <name>feedReplicationBacklogWithObject</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>feedReplicationBacklog</name><argument_list>(<argument><expr><name>aux</name><operator>+</operator><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Write the command to every slave. */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>slaves</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Don't feed slaves that are still waiting for BGSAVE to start */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Feed slaves that are waiting for the initial SYNC (so these commands
         * are queued in the output buffer until the initial SYNC completes),
         * or are already in sync with the master. */</comment>

        <comment type="block">/* Add the multi bulk length. */</comment>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>slave</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Finally any additional argument that was not stored inside the
         * static buffer if any (from j to argc). */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>slave</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* This function is used in order to proxy what we receive from our master
 * to our sub-slaves. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<function><type><name>void</name></type> <name>replicationFeedSlavesFromMasterStream</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>slaves</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>

    <comment type="block">/* Debugging: this is handy to see the stream sent from master
     * to slaves. Disabled with if(0). */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%Iu:"</literal></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                        <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* %zu -&gt; %Iu */</comment>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>buflen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>feedReplicationBacklog</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>slaves</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Don't feed slaves that are still waiting for BGSAVE to start */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyString</name><argument_list>(<argument><expr><name>slave</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>replicationFeedMonitors</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>monitors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictid</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>cmdrepr</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>cmdobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><literal type="string">"%Id.%06Id "</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* %ld -&gt; %Id */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_LUA</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><literal type="string">"[%d lua] "</literal></expr></argument>,<argument><expr><name>dictid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_UNIX_SOCKET</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><literal type="string">"[%d unix:%s] "</literal></expr></argument>,<argument><expr><name>dictid</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>unixsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><literal type="string">"[%d %s] "</literal></expr></argument>,<argument><expr><name>dictid</name></expr></argument>,<argument><expr><call><name>getClientPeerId</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>encoding</name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>, <argument><expr><literal type="string">"\"%Id\""</literal></expr></argument>, <argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* %ld -&gt; %Id */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatrepr</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
                        <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>argc</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><literal type="string">" "</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>cmdrepr</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>cmdrepr</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmdobj</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>cmdrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>monitors</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>monitor</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>monitor</name></expr></argument>,<argument><expr><name>cmdobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>cmdobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Feed the slave 'c' with the replication backlog starting from the
 * specified 'offset' up to the end of the backlog. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>addReplyReplicationBacklog</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>skip</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Replica request offset: %lld"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Backlog history len is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Backlog size: %lld"</literal></expr></argument>,
             <argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] First byte: %lld"</literal></expr></argument>,
             <argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] History len: %lld"</literal></expr></argument>,
             <argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Current index: %lld"</literal></expr></argument>,
             <argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the amount of bytes we need to discard. */</comment>
    <expr_stmt><expr><name>skip</name> <operator>=</operator> <name>offset</name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Skipping: %lld"</literal></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Point j to the oldest byte, that is actually our
     * server.repl_backlog_off byte. */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name><name>server</name><operator>.</operator><name>repl_backlog_idx</name></name> <operator>+</operator>
        <operator>(</operator><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name><operator>-</operator><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name><operator>)</operator><operator>)</operator> <operator>%</operator>
        <name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Index of first byte: %lld"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Discard the amount of data to seek to the specified 'offset'. */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>j</name> <operator>+</operator> <name>skip</name><operator>)</operator> <operator>%</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name></expr>;</expr_stmt>

    <comment type="block">/* Feed slave with data. Since it is a circular buffer we have to
     * split the reply in two parts if we are cross-boundary. */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>-</operator> <name>skip</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] Reply total length: %lld"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>thislen</name> <init>=
            <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>&lt;</operator> <name>len</name><operator>)</operator></expr> ?</condition><then>
            <expr><operator>(</operator><name><name>server</name><operator>.</operator><name>repl_backlog_size</name></name> <operator>-</operator> <name>j</name><operator>)</operator></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"[PSYNC] addReply() length: %lld"</literal></expr></argument>, <argument><expr><name>thislen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>thislen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>thislen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name> <operator>-</operator> <name>skip</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the offset to provide as reply to the PSYNC command received
 * from the slave. The returned value is only valid immediately after
 * the BGSAVE process started and before executing any other command
 * from clients. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>getPsyncInitialOffset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>server</name><operator>.</operator><name>master_repl_offset</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send a FULLRESYNC reply in the specific case of a full resynchronization,
 * as a side effect setup the slave for a full sync in different ways:
 *
 * 1) Remember, into the slave client structure, the replication offset
 *    we sent here, so that if new slaves will later attach to the same
 *    background RDB saving process (by duplicating this client output
 *    buffer), we can get the right offset from this slave.
 * 2) Set the replication state of the slave to WAIT_BGSAVE_END so that
 *    we start accumulating differences from this point.
 * 3) Force the replication stream to re-emit a SELECT statement so
 *    the new slave incremental differences will start selecting the
 *    right database number.
 *
 * Normally this function should be called immediately after a successful
 * BGSAVE for replication was started, or when there is one already in
 * progress that we attached our slave to. */</comment>
<function><type><name>int</name></type> <name>replicationSetupSlaveForFullResync</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>psync_initial_offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_WAIT_BGSAVE_END</name></expr>;</expr_stmt>
    <comment type="block">/* We are going to accumulate the incremental changes for this
     * slave as well. Set slaveseldb to -1 in order to force to re-emit
     * a SELECT statement in the replication stream. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>slaveseldb</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Don't send this reply to slaves that approached us with
     * the old SYNC command. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>slave</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PRE_PSYNC</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"+FULLRESYNC %s %lld\r\n"</literal></expr></argument>,
                          <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>buflen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function handles the PSYNC command from the point of view of a
 * master receiving a request for partial resynchronization.
 *
 * On success return C_OK, otherwise C_ERR is returned and we proceed
 * with the usual full resync. */</comment>
<function><type><name>int</name></type> <name>masterTryPartialResynchronization</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>psync_offset</name></decl>, <decl><type ref="prev"/><name>psync_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>master_replid</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>

    <comment type="block">/* Parse the replication offset asked by the slave. Go to full sync
     * on parse error: this should never happen but we try to handle
     * it in a robust way compared to aborting. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>psync_offset</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
       <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>need_full_resync</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Is the replication ID of this master the same advertised by the wannabe
     * slave via PSYNC? If the replication ID changed this master has a
     * different replication history, and there is no way to continue.
     *
     * Note that there are two potentially valid replication IDs: the ID1
     * and the ID2. The ID2 however is only valid up to a specific offset. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>master_replid</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>master_replid</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
         <name>psync_offset</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>second_replid_offset</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Run id "?" is used by slaves that want to force a full resync. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>master_replid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>master_replid</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>strcasecmp</name><argument_list>(<argument><expr><name>master_replid</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Partial resynchronization not accepted: "</literal>
                    <literal type="string">"Replication ID mismatch (Replica asked for '%s', my "</literal>
                    <literal type="string">"replication IDs are '%s' and '%s')"</literal></expr></argument>,
                    <argument><expr><name>master_replid</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Partial resynchronization not accepted: "</literal>
                    <literal type="string">"Requested offset for second ID was %lld, but I can reply "</literal>
                    <literal type="string">"up to %lld"</literal></expr></argument>, <argument><expr><name>psync_offset</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>second_replid_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Full resync requested by replica %s"</literal></expr></argument>,
                <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <goto>goto <name>need_full_resync</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We still have the data our slave is asking for? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>||</operator>
        <call><name><name>psync_offset</name> <argument_list type="generic">&lt; <argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name> <operator>||</operator>
        <name>psync_offset</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_backlog_off</name></name> <operator>+</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_histlen</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld)."</literal></expr></argument>, <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>psync_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>psync_offset</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset."</literal></expr></argument>, <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <goto>goto <name>need_full_resync</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we reached this point, we are able to perform a partial resync:
     * 1) Set client state to make it a slave.
     * 2) Inform the client we can continue with +CONTINUE
     * 3) Send the backlog data (from the offset to the end) to the slave. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_ONLINE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_ack_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We can't use the connection buffers since they are used to accumulate
     * new commands at this stage. But we are sure the socket send buffer is
     * empty so this write will never fail actually. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name> <operator>&amp;</operator> <name>SLAVE_CAPA_PSYNC2</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"+CONTINUE %s\r\n"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"+CONTINUE\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>buflen</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>psync_len</name> <operator>=</operator> <call><name>addReplyReplicationBacklog</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>psync_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
        <argument><expr><literal type="string">"Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld."</literal></expr></argument>,
            <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>psync_len</name></expr></argument>, <argument><expr><name>psync_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Note that we don't need to set the selected DB at server.slaveseldb
     * to -1 to force the master to emit SELECT, since the slave already
     * has this state from the previous connection with the master. */</comment>

    <expr_stmt><expr><call><name>refreshGoodSlavesCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return> <comment type="block">/* The caller can return, no full resync needed. */</comment>

<label><name>need_full_resync</name>:</label>
    <comment type="block">/* We need a full resync for some reason... Note that we can't
     * reply to PSYNC right now if a full SYNC is needed. The reply
     * must include the master offset at the time the RDB file we transfer
     * is generated, so we need to delay the reply to that moment. */</comment>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Start a BGSAVE for replication goals, which is, selecting the disk or
 * socket target depending on the configuration, and making sure that
 * the script cache is flushed before to start.
 *
 * The mincapa argument is the bitwise AND among all the slaves capabilities
 * of the slaves waiting for this BGSAVE, so represents the slave capabilities
 * all the slaves support. Can be tested via SLAVE_CAPA_* macros.
 *
 * Side effects, other than starting a BGSAVE:
 *
 * 1) Handle the slaves in WAIT_START state, by preparing them for a full
 *    sync if the BGSAVE was successfully started, or sending them an error
 *    and dropping them from the list of slaves.
 *
 * 2) Flush the Lua scripting script cache if the BGSAVE was actually
 *    started.
 *
 * Returns C_OK on success or C_ERR otherwise. */</comment>
<function><type><name>int</name></type> <name>startBgsaveForReplication</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mincapa</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>socket_target</name> <init>= <expr><name><name>server</name><operator>.</operator><name>repl_diskless_sync</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>mincapa</name> <operator>&amp;</operator> <name>SLAVE_CAPA_EOF</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Starting BGSAVE for SYNC with target: %s"</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name>socket_target</name></expr> ?</condition><then> <expr><literal type="string">"replicas sockets"</literal></expr> </then><else>: <expr><literal type="string">"disk"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>rdbSaveInfo</name></type> <name>rsi</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rsiptr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rsiptr</name> <operator>=</operator> <call><name>rdbPopulateSaveInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Only do rdbSave* when rsiptr is not NULL,
     * otherwise slave will miss repl-stream-db. */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsiptr</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>socket_target</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveToSlavesSockets</name><argument_list>(<argument><expr><name>rsiptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveBackground</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>,<argument><expr><name>rsiptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"BGSAVE for replication: replication information not available, can't generate the RDB file right now. Try later."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>C_ERR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If we failed to BGSAVE, remove the slaves waiting for a full
     * resynchorinization from the list of salves, inform them with
     * an error about what happened, close the connection ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"BGSAVE for replication failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>REPL_STATE_NONE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_SLAVE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>slave</name></expr></argument>,
                    <argument><expr><literal type="string">"BGSAVE failed, replication can't continue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_CLOSE_AFTER_REPLY</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <return>return <expr><name>retval</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the target is socket, rdbSaveToSlavesSockets() already setup
     * the salves for a full resync. Otherwise for disk target do it now.*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>socket_target</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>replicationSetupSlaveForFullResync</name><argument_list>(<argument><expr><name>slave</name></expr></argument>,
                            <argument><expr><call><name>getPsyncInitialOffset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Flush the script cache, since we need that slave differences are
     * accumulated without requiring slaves to match our cached scripts. */</comment>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>replicationScriptCacheFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* SYNC and PSYNC command implemenation. */</comment>
<function><type><name>void</name></type> <name>syncCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* ignore SYNC if already slave or in monitor mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Refuse SYNC requests if we are a slave but the link with our master
     * is not ok... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>!=</operator> <name>REPL_STATE_CONNECTED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-NOMASTERLINK Can't SYNC while not connected with my master\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* SYNC can't be issued when the server has pending data to send to
     * the client about already issued commands. We need a fresh reply
     * buffer registering the differences between the BGSAVE and the current
     * dataset, so that we can copy to other slaves if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"SYNC and PSYNC are invalid with pending output"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Replica %s asks for synchronization"</literal></expr></argument>,
        <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Try a partial resynchronization if this is a PSYNC command.
     * If it fails, we continue with usual full resynchronization, however
     * when this happens masterTryPartialResynchronization() already
     * replied with:
     *
     * +FULLRESYNC &lt;replid&gt; &lt;offset&gt;
     *
     * So the slave knows the new replid and offset to try a PSYNC later
     * if the connection with the master is lost. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"psync"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>masterTryPartialResynchronization</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_sync_partial_ok</name></name><operator>++</operator></expr>;</expr_stmt>
            <return>return;</return> <comment type="block">/* No full resync needed, return. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>master_replid</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Increment stats for failed PSYNCs, but only if the
             * replid is not "?", as this is used by slaves to force a full
             * resync on purpose when they are not albe to partially
             * resync. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>master_replid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_sync_partial_err</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If a slave uses SYNC, we are dealing with an old implementation
         * of the replication protocol (like redis-cli --slave). Flag the client
         * so that we don't expect to receive REPLCONF ACK feedbacks. */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_PRE_PSYNC</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Full resynchronization. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_sync_full</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Setup the slave as one waiting for BGSAVE to start. The following code
     * paths will change the state if we handle the slave differently. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_disable_tcp_nodelay</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>anetDisableTcpNoDelay</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Non critical if it fails. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the replication backlog if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* When we create the backlog from scratch, we always use a new
         * replication ID and clear the ID2, since there is no valid
         * past history. */</comment>
        <expr_stmt><expr><call><name>changeReplicationId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clearReplicationId2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>createReplicationBacklog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* CASE 1: BGSAVE is in progress, with disk target. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>rdb_child_type</name></name> <operator>==</operator> <name>RDB_CHILD_TYPE_DISK</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Ok a background save is in progress. Let's check if it is a good
         * one for replication, i.e. if there is another slave that is
         * registering differences since the server forked to save. */</comment>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>slave</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_END</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <comment type="block">/* To attach this slave, we check that it has at least all the
         * capabilities of the slave that triggered the current BGSAVE. */</comment>
        <if_stmt><if>if <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name> <operator>&amp;</operator> <name><name>slave</name><operator>-&gt;</operator><name>slave_capa</name></name><operator>)</operator> <operator>==</operator> <name><name>slave</name><operator>-&gt;</operator><name>slave_capa</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Perfect, the server is already registering differences for
             * another slave. Set the right state, and copy the buffer. */</comment>
            <expr_stmt><expr><call><name>copyClientOutputBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>replicationSetupSlaveForFullResync</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>psync_initial_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Waiting for end of BGSAVE for SYNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* No way, we need to wait for the next BGSAVE in order to
             * register differences. */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Can't attach the replica to the current BGSAVE. Waiting for next BGSAVE for SYNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    <comment type="block">/* CASE 2: BGSAVE is in progress, with socket target. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
               <name><name>server</name><operator>.</operator><name>rdb_child_type</name></name> <operator>==</operator> <name>RDB_CHILD_TYPE_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* There is an RDB child process but it is writing directly to
         * children sockets. We need to wait for the next BGSAVE
         * in order to synchronize. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* CASE 3: There is no BGSAVE is progress. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_diskless_sync</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name> <operator>&amp;</operator> <name>SLAVE_CAPA_EOF</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Diskless replication RDB child is created inside
             * replicationCron() since we want to delay its start a
             * few seconds to wait for more slaves to arrive. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_diskless_sync_delay</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Delay next BGSAVE for diskless SYNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Target is disk (or the slave is not capable of supporting
             * diskless replication) and we don't have a BGSAVE in progress,
             * let's start one. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>startBgsaveForReplication</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                    <argument><expr><literal type="string">"No BGSAVE in progress, but an AOF rewrite is active. "</literal>
                    <literal type="string">"BGSAVE for replication delayed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* REPLCONF &lt;option&gt; &lt;value&gt; &lt;option&gt; &lt;value&gt; ...
 * This command is used by a slave in order to configure the replication
 * process before starting it with the SYNC command.
 *
 * Currently the only use of this command is to communicate to the master
 * what is the listening port of the Slave redis instance, so that the
 * master can accurately list slaves and their listening ports in
 * the INFO output.
 *
 * In the future the same command can be used in order to configure
 * the replication to initiate an incremental replication instead of a
 * full resync. */</comment>
<function><type><name>void</name></type> <name>replconfCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Number of arguments must be odd to make sure that every
         * option has a corresponding value. */</comment>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process every option-value pair. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"listening-port"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>port</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slave_listening_port</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>port</name></expr>;</expr_stmt>                               <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"ip-address"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>ip</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>slave_ip</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"REPLCONF ip-address provided by "</literal>
                    <literal type="string">"replica instance is too long: %zd bytes"</literal></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"capa"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Ignore capabilities not understood by this master. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"eof"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name> <operator>|=</operator> <name>SLAVE_CAPA_EOF</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"psync2"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slave_capa</name></name> <operator>|=</operator> <name>SLAVE_CAPA_PSYNC2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"ack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* REPLCONF ACK is used by slave to inform the master the amount
             * of replication stream that it processed so far. It is an
             * internal only command that normal clients should never use. */</comment>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>offset</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongLongFromObject</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>c</name><operator>-&gt;</operator><name>repl_ack_off</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_ack_off</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>repl_ack_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
            <comment type="block">/* If this was a diskless replication, we need to really put
             * the slave online when the first ACK is received (which
             * confirms slave is online and ready to get more data). This
             * allows for simpler and less CPU intensive EOF detection
             * when streaming RDB files. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_ONLINE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>putSlaveOnline</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Note: this command does not reply anything! */</comment>
            <return>return;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"getack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* REPLCONF GETACK is used in order to request an ACK ASAP
             * to the slave. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>master</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>replicationSendAck</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unrecognized REPLCONF option: %s"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function puts a replica in the online state, and should be called just
 * after a replica received the RDB file for the initial synchronization, and
 * we are finally ready to send the incremental stream of commands.
 *
 * It does a few things:
 *
 * 1) Put the slave in ONLINE state. Note that the function may also be called
 *    for a replicas that are already in ONLINE state, but having the flag
 *    repl_put_online_on_ack set to true: we still have to install the write
 *    handler in that case. This function will take care of that.
 * 2) Make sure the writable event is re-installed, since calling the SYNC
 *    command disables it, so that we can accumulate output buffer without
 *    sending it to the replica.
 * 3) Update the count of "good replicas". */</comment>
<function><type><name>void</name></type> <name>putSlaveOnline</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_ONLINE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repl_ack_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt> <comment type="block">/* Prevent false timeout. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>,
        <argument><expr><name>sendReplyToClient</name></expr></argument>, <argument><expr><name>slave</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unable to register writable event for replica bulk transfer: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>refreshGoodSlavesCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Synchronization with replica %s succeeded"</literal></expr></argument>,
        <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function><type><name>void</name></type> <name>sendBulkToSlaveLenDone</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>written</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>WSIOCP_Request</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>WSIOCP_Request</name> <operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sendBulkToSlaveDataDone</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nwritten</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>WSIOCP_Request</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>WSIOCP_Request</name> <operator>*</operator><operator>)</operator> <name>privdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><operator>(</operator><name>client</name> <operator>*</operator><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name> <operator>==</operator> <name><name>slave</name><operator>-&gt;</operator><name>repldbsize</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DeleteFileA</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putSlaveOnline</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sendBulkToSlave</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name>privdata</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>buflen</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Write the bulk write count before to transfer the DB. In theory here
         * we don't know how much room there is in the output buffer of the
         * socket, but in pratice SO_SNDLOWAT (the minimum count for output
         * operations) will never be smaller than the few bytes we need. */</comment>
        <decl_stmt><decl><type><name>sds</name></type> <name>bulkcount</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>bulkcount</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"$%lld\r\n"</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator>
            <name><name>slave</name><operator>-&gt;</operator><name>repldbsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>WSIOCP_SocketSend</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bulkcount</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>bulkcount</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>el</name></expr></argument>,
                                   <argument><expr><name>slave</name></expr></argument>, <argument><expr><name>bulkcount</name></expr></argument>, <argument><expr><name>sendBulkToSlaveLenDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>WSA_IO_PENDING</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>bulkcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lseek64</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name></expr></argument>,<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>zmalloc</name><argument_list>(<argument><expr><name>PROTO_IOBUF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>PROTO_IOBUF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Read error sending DB to slave: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>buflen</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"premature EOF"</literal></expr> </then><else>: <expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>WSIOCP_SocketSend</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>buflen</name></expr></argument>, <argument><expr><name>el</name></expr></argument>, <argument><expr><name>slave</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
                               <argument><expr><name>sendBulkToSlaveDataDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>WSA_IO_PENDING</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,<argument><expr><literal type="string">"Write error sending DB to slave: %s"</literal></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type> <name>sendBulkToSlave</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name>privdata</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PROTO_IOBUF_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name></decl>, <decl><type ref="prev"/><name>buflen</name></decl>;</decl_stmt>

    <comment type="block">/* Before sending the RDB file, we send the preamble as configured by the
     * replication process. Currently the preamble is just the bulk count of
     * the file in the form "$&lt;length&gt;\r\n". */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,<argument><expr><literal type="string">"Write error sending RDB preamble to replica: %s"</literal></expr></argument>,
                <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_net_output_bytes</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name></expr></argument>,<argument><expr><name>nwritten</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <comment type="block">/* fall through sending data. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the preamble was already transferred, send the RDB bulk data. */</comment>
    <expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name></expr></argument>,<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>PROTO_IOBUF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Read error sending DB to replica: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>buflen</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"premature EOF"</literal></expr> </then><else>: <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EAGAIN</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Write error sending DB to replica: %s"</literal></expr></argument>,
                <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_net_output_bytes</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name> <operator>==</operator> <name><name>slave</name><operator>-&gt;</operator><name>repldbsize</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putSlaveOnline</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This function is called at the end of every background saving,
 * or when the replication RDB transfer strategy is modified from
 * disk to socket or the other way around.
 *
 * The goal of this function is to handle slaves waiting for a successful
 * background saving in order to perform non-blocking synchronization, and
 * to schedule a new BGSAVE if there are slaves that attached while a
 * BGSAVE was in progress, but it was not a good one for replication (no
 * other slave was accumulating differences).
 *
 * The argument bgsaveerr is C_OK if the background saving succeeded
 * otherwise C_ERR is passed to the function.
 * The 'type' argument is the type of the child that terminated
 * (if it had a disk or socket target). */</comment>
<function><type><name>void</name></type> <name>updateSlavesWaitingBgsave</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bgsaveerr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>startbgsave</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mincapa</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>startbgsave</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>mincapa</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mincapa</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>slave</name><operator>-&gt;</operator><name>slave_capa</name></name></expr> </then><else>:
                                        <expr><operator>(</operator><name>mincapa</name> <operator>&amp;</operator> <name><name>slave</name><operator>-&gt;</operator><name>slave_capa</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_END</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>redis_stat</name></name></type> <name>buf</name></decl>;</decl_stmt>

            <comment type="block">/* If this was an RDB on disk save, we have to prepare to send
             * the RDB from disk to the slave socket. Otherwise if this was
             * already an RDB -&gt; Slaves socket transfer, used in the case of
             * diskless replication, our work is trivial, we can just put
             * the slave online. */</comment>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>RDB_CHILD_TYPE_SOCKET</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                    <argument><expr><literal type="string">"Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming"</literal></expr></argument>,
                        <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Note: we wait for a REPLCONF ACK message from the replica in
                 * order to really put it online (install the write handler
                 * so that the accumulated data can be transferred). However
                 * we change the replication state ASAP, since our slave
                 * is technically online now.
                 *
                 * So things work like that:
                 *
                 * 1. We end trasnferring the RDB file via socket.
                 * 2. The replica is put ONLINE but the write handler
                 *    is not installed.
                 * 3. The replica however goes really online, and pings us
                 *    back via REPLCONF ACK commands.
                 * 4. Now we finally install the write handler, and send
                 *    the buffers accumulated so far to the replica.
                 *
                 * But why we do that? Because the replica, when we stream
                 * the RDB directly via the socket, must detect the RDB
                 * EOF (end of file), that is a special random string at the
                 * end of the RDB (for streamed RDBs we don't know the length
                 * in advance). Detecting such final EOF string is much
                 * simpler and less CPU intensive if no more data is sent
                 * after such final EOF. So we don't want to glue the end of
                 * the RDB trasfer with the start of the other replication
                 * data. */</comment>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_ONLINE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repl_put_online_on_ack</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repl_ack_time</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt> <comment type="block">/* Timeout otherwise. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>bgsaveerr</name> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"SYNC failed. BGSAVE child returned an error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
                <comment type="block">/* As multiple slaves join asynchronously with the master, the synchronization process can launch multiple
                   RDB background saves before the first slaves are fully synchronized. This can cause a race condition 
                   for the RDB file produced by the forked process with the RDB file being used to feed the slaves.
                   I don't think this patch totally eliminates the race condition, but it does eliminate the deadlock 
                   that occurs when the forked process tries to copy the file it produces over the the RDB file being 
                   held open by the slave feeding code. */</comment>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>,<argument><expr><literal type="string">"%d_%s"</literal></expr></argument>,  <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><call><name>CopyFileA</name><argument_list>( <argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>, <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Failed to duplicate RDB file. Failing SYNC: %d"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<decl_stmt><expr><operator>(</operator><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replFileCopy</name></name></expr></argument>,<argument><expr><name>O_RDONLY</name><operator>|</operator><name>_O_BINARY</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator></expr></decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>,<argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <call><name>redis_fstat</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition></if></if_stmt></condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"SYNC failed. Can't open/stat DB after BGSAVE: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repldboff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>repldbsize</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_SEND_BULK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replpreamble</name></name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"$%lld\r\n"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name><name>slave</name><operator>-&gt;</operator><name>repldbsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>, <argument><expr><name>sendBulkToSlave</name></expr></argument>, <argument><expr><name>slave</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>startbgsave</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>startBgsaveForReplication</name><argument_list>(<argument><expr><name>mincapa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Change the current instance replication ID with a new, random one.
 * This will prevent successful PSYNCs between this master and other
 * slaves, so the command should be called when something happens that
 * alters the current story of the dataset. */</comment>
<function><type><name>void</name></type> <name>changeReplicationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>getRandomHexChars</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>replid</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Clear (invalidate) the secondary replication ID. This happens, for
 * example, after a full resynchronization, when we start a new replication
 * history. */</comment>
<function><type><name>void</name></type> <name>clearReplicationId2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>,<argument><expr><literal type="char">'0'</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>replid2</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>second_replid_offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Use the current replication ID / offset as secondary replication
 * ID, and change the current one in order to start a new history.
 * This should be used when an instance is switched from slave to master
 * so that it can serve PSYNC requests performed using the master
 * replication ID. */</comment>
<function><type><name>void</name></type> <name>shiftReplicationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We set the second replid offset to the master offset + 1, since
     * the slave will ask for the first byte it has not yet received, so
     * we need to add one to the offset: for example if, as a slave, we are
     * sure we have the same history as the master for 50 bytes, after we
     * are turned into a master, we can accept a PSYNC request with offset
     * 51, since the slave asking has the same history up to the 50th
     * byte, and is asking for the new bytes starting at offset 51. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>second_replid_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>changeReplicationId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>second_replid_offset</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------- SLAVE -------------------------------- */</comment>

<comment type="block">/* Returns 1 if the given replication state is a handshake state,
 * 0 otherwise. */</comment>
<function><type><name>int</name></type> <name>slaveIsInHandshakeState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>&gt;=</operator> <name>REPL_STATE_RECEIVE_PONG</name> <operator>&amp;&amp;</operator>
           <name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>&lt;=</operator> <name>REPL_STATE_RECEIVE_PSYNC</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Avoid the master to detect the slave is timing out while loading the
 * RDB file in initial synchronization. We send a single newline character
 * that is valid protocol but is guaranteed to either be sent entirely or
 * not, since the byte is indivisible.
 *
 * The function is called in two contexts: while we flush the current
 * data with emptyDb(), and while we load the new data received as an
 * RDB file from the master. */</comment>
<function><type><name>void</name></type> <name>replicationSendNewlineToMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>newline_sent</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>newline_sent</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>newline_sent</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Pinging back in this stage is best-effort. */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Callback used by emptyDb() while flushing away old data to load
 * the new dataset received by the master. */</comment>
<function><type><name>void</name></type> <name>replicationEmptyDbCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replicationSendNewlineToMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Once we have a link with the master and the synchroniziation was
 * performed, this function materializes the master client we store
 * at server.master, starting from the specified file descriptor. */</comment>
<function><type><name>void</name></type> <name>replicationCreateMasterClient</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name></name> <operator>=</operator> <call><name>createClient</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>authenticated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_initial_offset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>read_reploff</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>replid</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>master_replid</name></name></expr></argument>,
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master_replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If master offset is set to -1, this master is old and is not
     * PSYNC capable, so we flag it accordingly. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_PRE_PSYNC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbid</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>,<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This function will try to re-enable the AOF file after the
 * master-replica synchronization: if it fails after multiple attempts
 * the replica cannot be considered reliable and exists with an
 * error. */</comment>
<function><type><name>void</name></type> <name>restartAOFAfterSYNC</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tries</name></decl>, <decl><type ref="prev"/><name>max_tries</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>tries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tries</name> <operator>&lt;</operator> <name>max_tries</name></expr>;</condition> <incr><expr><operator>++</operator><name>tries</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>startAppendOnly</name><argument_list>()</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Failed enabling the AOF after successful master synchronization! "</literal>
            <literal type="string">"Trying it again in one second."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>tries</name> <operator>==</operator> <name>max_tries</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"FATAL: this replica instance finished the synchronization with "</literal>
            <literal type="string">"its master, but the AOF can't be turned on. Exiting now."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Asynchronously read the SYNC payload we receive from a master */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPL_MAX_WRITTEN_BEFORE_FSYNC</name></cpp:macro> <cpp:value>(1024*1024*8)</cpp:value></cpp:define> <comment type="block">/* 8 MB */</comment>
<function><type><name>void</name></type> <name>readSyncBulkPayload</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>, <decl><type ref="prev"/><name>readlen</name></decl>, <decl><type ref="prev"/><name>nwritten</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>off_t</name></type> <name>left</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Static vars used to hold the EOF mark, and the last bytes received
     * form the server: when they match, we reached the end of the transfer. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>eofmark</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lastbytes</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>usemark</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If repl_transfer_size == -1 we still have to read the bulk length
     * from the master reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>syncReadLine</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">1024</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name><name>server</name><operator>.</operator><name>repl_syncio_timeout</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_LONGLONG) */</comment>
            <name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"I/O error reading bulk count from MASTER: %s"</literal></expr></argument>,
                <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>

        <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"MASTER aborted replication with an error: %s"</literal></expr></argument>,
                <argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* At this stage just a newline works as a PING in order to take
             * the connection live. So we refresh our last interaction
             * timestamp. */</comment>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* There are two possible forms for the bulk payload. One is the
         * usual $&lt;count&gt; bulk format. The other is used for diskless transfers
         * when the master does not know beforehand the size of the file to
         * transfer. In the latter case, the following format is used:
         *
         * $EOF:&lt;40 bytes delimiter&gt;
         *
         * At the end of the file the announced delimiter is transmitted. The
         * delimiter is long and random enough that the probability of a
         * collision with the actual file content can be ignored. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"EOF:"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>CONFIG_RUN_ID_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>usemark</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>eofmark</name></expr></argument>,<argument><expr><name>buf</name><operator>+</operator><literal type="number">5</literal></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>lastbytes</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Set any repl_transfer_size to avoid entering this code path
             * at the next call. */</comment>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                <argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>usemark</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                <argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read bulk data */</comment>
    <if_stmt><if>if <condition>(<expr><name>usemark</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>readlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>readlen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>left</name> <operator>&lt;</operator> <operator>(</operator><name>signed</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> ?</condition><then> <expr><name>left</name></expr> </then><else>: <expr><operator>(</operator><name>signed</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>readlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"I/O error %d (left %Iu) trying to sync with MASTER: %s"</literal></expr></argument>,
                <argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"connection lost"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"I/O error trying to sync with MASTER: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"connection lost"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_net_input_bytes</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>

    <comment type="block">/* When a mark is used, we want to detect EOF asap in order to avoid
     * writing the EOF mark into the file... */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eof_reached</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>usemark</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Update the last bytes array, and check if it matches our delimiter.*/</comment>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;=</operator> <name>CONFIG_RUN_ID_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lastbytes</name></expr></argument>,<argument><expr><name>buf</name><operator>+</operator><name>nread</name><operator>-</operator><name>CONFIG_RUN_ID_SIZE</name></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>rem</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>CONFIG_RUN_ID_SIZE</name><operator>-</operator><name>nread</name><operator>)</operator></expr></init></decl>;</decl_stmt>                           <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
            <name>memmove</name><argument_list>(<argument><expr><name>lastbytes</name></expr></argument>,<argument><expr><name>lastbytes</name><operator>+</operator><name>nread</name></expr></argument>,<argument><expr><name>rem</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lastbytes</name><operator>+</operator><name>rem</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name> <name>suppress</name><name>:</name> <name>6385</name> <name>)</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>lastbytes</name></expr></argument>,<argument><expr><name>eofmark</name></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eof_reached</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>nread</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"short write"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>

    <comment type="block">/* Delete the last 40 bytes from the file if we reached EOF. */</comment>
    <if_stmt><if>if <condition>(<expr><name>usemark</name> <operator>&amp;&amp;</operator> <name>eof_reached</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ftruncate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name> <operator>-</operator> <name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error truncating the RDB file received from the master for SYNC: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Sync data on disk from time to time, otherwise at the end of the transfer
     * we may suffer a big delay as the memory buffers are copied into the
     * actual disk. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name> <operator>&gt;=</operator>
        <name><name>server</name><operator>.</operator><name>repl_transfer_last_fsync_off</name></name> <operator>+</operator> <name>REPL_MAX_WRITTEN_BEFORE_FSYNC</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>off_t</name></type> <name>sync_size</name> <init>= <expr><name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name> <operator>-</operator>
                          <name><name>server</name><operator>.</operator><name>repl_transfer_last_fsync_off</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>rdb_fsync_range</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_last_fsync_off</name></name></expr></argument>, <argument><expr><name>sync_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_last_fsync_off</name></name> <operator>+=</operator> <name>sync_size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if the transfer is now complete */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>usemark</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name> <operator>==</operator> <name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>eof_reached</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>eof_reached</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>aof_is_enabled</name> <init>= <expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>!=</operator> <name>AOF_OFF</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <comment type="block">/* Close temp, since rename is unable to delete open file */</comment>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Ensure background save doesn't overwrite synced data */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                <argument><expr><literal type="string">"Replica is about to load the RDB file received from the "</literal>
                <literal type="string">"master, but there is a pending RDB child running. "</literal>
                <literal type="string">"Killing process %ld and removing its temp file to avoid "</literal>
                <literal type="string">"any race"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>AbortForkOperation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name></expr></argument>,<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rdbRemoveTempFile</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Make sure the new file (also used for persistence) is fully synced
         * (not covered by earlier calls to rdb_fsync_range). */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Failed trying to sync the temp DB to disk in "</literal>
                <literal type="string">"MASTER &lt;-&gt; REPLICA synchronization: %s"</literal></expr></argument>,
                <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_tmpfile</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; REPLICA synchronization: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync: Flushing old data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We need to stop any AOFRW fork before flusing and parsing
         * RDB, otherwise we'll create a copy-on-write disaster. */</comment>
        <if_stmt><if>if<condition>(<expr><name>aof_is_enabled</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>stopAppendOnly</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>signalFlushedDb</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>emptyDb</name><argument_list>(
            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>repl_slave_lazy_flush</name></name></expr> ?</condition><then> <expr><name>EMPTYDB_ASYNC</name></expr> </then><else>: <expr><name>EMPTYDB_NO_FLAGS</name></expr></else></ternary></expr></argument>,
            <argument><expr><name>replicationEmptyDbCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Before loading the DB into memory we need to delete the readable
         * handler, otherwise it will get called recursively since
         * rdbLoad() will call the event loop to process events from time to
         * time for non blocking loading. */</comment>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync: Loading DB in memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>rdbSaveInfo</name></type> <name>rsi</name> <init>= <expr><name>RDB_SAVE_INFO_INIT</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rdbLoad</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>rsi</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Failed trying to load the MASTER synchronization DB from disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Re-enable the AOF if we disabled it earlier, in order to restore
             * the original configuration. */</comment>
            <if_stmt><if>if <condition>(<expr><name>aof_is_enabled</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>restartAOFAfterSYNC</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Final setup of the connected slave &lt;- master link */</comment>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_tmpfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_tmpfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* Moved before rename tmp-&gt;db in windows */</comment>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>replicationCreateMasterClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name></expr></argument>,<argument><expr><name><name>rsi</name><operator>.</operator><name>repl_stream_db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECTED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_down_since</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* After a full resynchroniziation we use the replication ID and
         * offset of the master. The secondary ID / offset are cleared since
         * we are starting a new history. */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>replid</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master_repl_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clearReplicationId2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Let's create the replication backlog if needed. Slaves need to
         * accumulate the backlog regardless of the fact they have sub-slaves
         * or not, in order to behave correctly if they are promoted to
         * masters after a failover. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>createReplicationBacklog</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync: Finished with success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Restart the AOF subsystem now that we finished the sync. This
         * will trigger an AOF rewrite, and when done will start appending
         * to the new file. */</comment>
        <if_stmt><if>if <condition>(<expr><name>aof_is_enabled</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>restartAOFAfterSYNC</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Send a synchronous command to the master. Used to send AUTH and
 * REPLCONF commands before starting the replication with SYNC.
 *
 * The command returns an sds string representing the result of the
 * operation. On error the first byte is a "-".
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNC_CMD_READ</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNC_CMD_WRITE</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNC_CMD_FULL</name></cpp:macro> <cpp:value>(SYNC_CMD_READ|SYNC_CMD_WRITE)</cpp:value></cpp:define>
<function><type><name>char</name> <modifier>*</modifier></type><name>sendSynchronousCommand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>

    <comment type="block">/* Create the command to send to the master, we use redis binary
     * protocol to make sure correct arguments are sent. This function
     * is not safe for all binary data. */</comment>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SYNC_CMD_WRITE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>cmd</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>cmdargs</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>argslen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>cmdargs</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmdargs</name></expr></argument>,<argument><expr><literal type="string">"$%Iu\r\n%s\r\n"</literal></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* zu-&gt;Iu */</comment>
            <name>argslen</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"*%Iu\r\n"</literal></expr></argument>,<argument><expr><name>argslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* zu-&gt;Iu */</comment>
        <name>cmd</name> <init>= <expr><call><name>sdscatsds</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name>cmdargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmdargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Transfer command to the server. */</comment>
        <if_stmt><if>if <condition>(<expr><macro><name>syncWrite</name><argument_list>(<argument>fd</argument>,<argument>cmd</argument>,<argument>(ssize_t)sdslen(cmd)</argument>,<argument>(PORT_LONGLONG)server.repl_syncio_timeout*<literal type="number">1000</literal></argument>)</argument_list></macro>      <name>WIN_PORT_FIX</name> <comment type="block">/* cast (ssize_t), cast (PORT_LONGLONG) */</comment>
            <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"-Writing to master: %s"</literal></expr></argument>,
                    <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read the reply from the server. */</comment>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SYNC_CMD_READ</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><macro><name>syncReadLine</name><argument_list>(<argument>fd</argument>,<argument>buf</argument>,<argument>sizeof(buf)</argument>,<argument>(PORT_LONGLONG)server.repl_syncio_timeout*<literal type="number">1000</literal></argument>)</argument_list></macro>  <name>WIN_PORT_FIX</name> <comment type="block">/* cast (PORT_LONGLONG) */</comment>
            <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"-Reading from master: %s"</literal></expr></argument>,
                    <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
        <return>return <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Try a partial resynchronization with the master if we are about to reconnect.
 * If there is no cached master structure, at least try to issue a
 * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC
 * command in order to obtain the master run id and the master replication
 * global offset.
 *
 * This function is designed to be called from syncWithMaster(), so the
 * following assumptions are made:
 *
 * 1) We pass the function an already connected socket "fd".
 * 2) This function does not close the file descriptor "fd". However in case
 *    of successful partial resynchronization, the function will reuse
 *    'fd' as file descriptor of the server.master client structure.
 *
 * The function is split in two halves: if read_reply is 0, the function
 * writes the PSYNC command on the socket, and a new function call is
 * needed, with read_reply set to 1, in order to read the reply of the
 * command. This is useful in order to support non blocking operations, so
 * that we write, return into the event loop, and read when there are data.
 *
 * When read_reply is 0 the function returns PSYNC_WRITE_ERR if there
 * was a write error, or PSYNC_WAIT_REPLY to signal we need another call
 * with read_reply set to 1. However even when read_reply is set to 1
 * the function may return PSYNC_WAIT_REPLY again to signal there were
 * insufficient data to read to complete its work. We should re-enter
 * into the event loop and wait in such a case.
 *
 * The function returns:
 *
 * PSYNC_CONTINUE: If the PSYNC command succeeded and we can continue.
 * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.
 *                   In this case the master run_id and global replication
 *                   offset is saved.
 * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and
 *                      the caller should fall back to SYNC.
 * PSYNC_WRITE_ERROR: There was an error writing the command to the socket.
 * PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.
 * PSYNC_TRY_LATER: Master is currently in a transient error condition.
 *
 * Notable side effects:
 *
 * 1) As a side effect of the function call the function removes the readable
 *    event handler from "fd", unless the return value is PSYNC_WAIT_REPLY.
 * 2) server.master_initial_offset is set to the right value according
 *    to the master reply. This will be used to populate the 'server.master'
 *    structure replication offset.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYNC_WRITE_ERROR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYNC_WAIT_REPLY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYNC_CONTINUE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYNC_FULLRESYNC</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYNC_NOT_SUPPORTED</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYNC_TRY_LATER</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>slaveTryPartialResynchronization</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>read_reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>psync_replid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>psync_offset</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>reply</name></decl>;</decl_stmt>

    <comment type="block">/* Writing half */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>read_reply</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Initially set master_initial_offset to -1 to mark the current
         * master run_id and offset as not valid. Later if we'll be able to do
         * a FULL resync using the PSYNC command we'll set the offset at the
         * right value, so that this information will be propagated to the
         * client structure representing the master into server.master. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master_initial_offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cached_master</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>psync_replid</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>replid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>psync_offset</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>psync_offset</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>reploff</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Trying a partial resynchronization (request %s:%s)."</literal></expr></argument>, <argument><expr><name>psync_replid</name></expr></argument>, <argument><expr><name>psync_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Partial resynchronization not possible (no cached master)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>psync_replid</name> <operator>=</operator> <literal type="string">"?"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>psync_offset</name></expr></argument>,<argument><expr><literal type="string">"-1"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Issue the PSYNC command */</comment>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_WRITE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"PSYNC"</literal></expr></argument>,<argument><expr><name>psync_replid</name></expr></argument>,<argument><expr><name>psync_offset</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unable to send PSYNC to master: %s"</literal></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PSYNC_WRITE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
        <return>return <expr><name>PSYNC_WAIT_REPLY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Reading half */</comment>
    <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_READ</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* The master may send empty newlines after it receives PSYNC
         * and before to reply, just to keep the connection alive. */</comment>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
        <return>return <expr><name>PSYNC_WAIT_REPLY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="string">"+FULLRESYNC"</literal></expr></argument>,<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>replid</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>offset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* FULL RESYNC, parse the reply in order to extract the run id
         * and the replication offset. */</comment>
        <expr_stmt><expr><name>replid</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>replid</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>replid</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>replid</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>offset</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>replid</name> <operator>||</operator> <operator>!</operator><name>offset</name> <operator>||</operator> <operator>(</operator><name>offset</name><operator>-</operator><name>replid</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>CONFIG_RUN_ID_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Master replied with wrong +FULLRESYNC syntax."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This is an unexpected condition, actually the +FULLRESYNC
             * reply means that the master supports PSYNC, but the reply
             * format seems wrong. To stay safe we blank the master
             * replid to make sure next PSYNCs will fail. */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master_replid</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master_replid</name></name></expr></argument>, <argument><expr><name>replid</name></expr></argument>, <argument><expr><name>offset</name><operator>-</operator><name>replid</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master_replid</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master_initial_offset</name></name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>offset</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Full resync from master: %s:%lld"</literal></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>master_replid</name></name></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>master_initial_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* We are going to full resync, discard the cached master structure. */</comment>
        <expr_stmt><expr><call><name>replicationDiscardCachedMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PSYNC_FULLRESYNC</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="string">"+CONTINUE"</literal></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Partial resync was accepted. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Successful partial resynchronization with master."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check the new replication ID advertised by the master. If it
         * changed, we need to set the new ID as primary ID, and set or
         * secondary ID as the old master ID up to the current offset, so
         * that our sub-slaves will be able to PSYNC with us after a
         * disconnection. */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>reply</name><operator>+</operator><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>reply</name><operator>+</operator><literal type="number">9</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><name><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>end</name><operator>-</operator><name>start</name> <operator>==</operator> <name>CONFIG_RUN_ID_SIZE</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>new</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>,<argument><expr><name>start</name></expr></argument>,<argument><expr><name>CONFIG_RUN_ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new</name><index>[<expr><name>CONFIG_RUN_ID_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>new</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>replid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Master ID changed. */</comment>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Master replication ID changed to %s"</literal></expr></argument>,<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Set the old ID as our ID2, up to the current offset+1. */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>replid</name></name></expr></argument>,
                    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid2</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>second_replid_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <comment type="block">/* Update the cached master ID and our own primary ID to the
                 * new one. */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>,<argument><expr><name>new</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>replid</name></name></expr></argument>,<argument><expr><name>new</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Disconnect all the sub-slaves: they need to be notified. */</comment>
                <expr_stmt><expr><call><name>disconnectSlaves</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Setup the replication to continue. */</comment>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>replicationResurrectCachedMaster</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If this instance was restarted and we read the metadata to
         * PSYNC from the persistence file, our replication backlog could
         * be still not initialized. Create it. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>createReplicationBacklog</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>PSYNC_CONTINUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we reach this point we received either an error (since the master does
     * not understand PSYNC or because it is in a special state and cannot
     * serve our request), or an unexpected reply from the master.
     *
     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise
     * return PSYNC_TRY_LATER if we believe this is a transient error. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="string">"-NOMASTERLINK"</literal></expr></argument>,<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="string">"-LOADING"</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Master is currently unable to PSYNC "</literal>
            <literal type="string">"but should be in the future: %s"</literal></expr></argument>, <argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PSYNC_TRY_LATER</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="string">"-ERR"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If it's not an error, log the unexpected event. */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Unexpected reply to PSYNC from master: %s"</literal></expr></argument>, <argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Master does not support PSYNC or is in "</literal>
            <literal type="string">"error state (reply: %s)"</literal></expr></argument>, <argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replicationDiscardCachedMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PSYNC_NOT_SUPPORTED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This handler fires when the non blocking connect was able to
 * establish a connection with the master. */</comment>
<function><type><name>void</name></type> <name>syncWithMaster</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmpfile</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxtries</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sockerr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>psync_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>socklen_t</name></type> <name>errlen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sockerr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this event fired after the user turned the instance into a master
     * with SLAVEOF NO ONE we must just return ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_NONE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for errors in the socket: after a non blocking connect() we
     * may find that the socket is in error state. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sockerr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sockerr</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>sockerr</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error condition on socket for SYNC: %s"</literal></expr></argument>,
            <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>sockerr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send a PING to check the master is able to reply without errors. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTING</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Non blocking connect for SYNC fired the event."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Delete the writable event so that the readable event remains
         * registered and we can wait for the PONG reply. */</comment>
        <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_RECEIVE_PONG</name></expr>;</expr_stmt>
        <comment type="block">/* Send the PING, don't check for errors at all, we have the timeout
         * that will take care about this. */</comment>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_WRITE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"PING"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>write_error</name>;</goto></block_content></block></if></if_stmt>
        <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Receive the PONG command. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_RECEIVE_PONG</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_READ</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We accept only two replies as valid, a positive +PONG reply
         * (we just check for "+") or an authentication error.
         * Note that older versions of Redis replied with "operation not
         * permitted" instead of using a proper error code, so we test
         * both. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>err</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"-NOAUTH"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"-ERR operation not permitted"</literal></expr></argument>,<argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error reply to PING from master: '%s'"</literal></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                <argument><expr><literal type="string">"Master replied to PING, replication can continue..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_AUTH</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* AUTH with the master if required. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_SEND_AUTH</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterauth</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_WRITE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"AUTH"</literal></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>masterauth</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>write_error</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_RECEIVE_AUTH</name></expr>;</expr_stmt>
            <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
            <return>return;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_PORT</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Receive AUTH reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_RECEIVE_AUTH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_READ</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>err</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unable to AUTH to MASTER: %s"</literal></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_PORT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set the slave port, so that Master's INFO command can list the
     * slave listening port correctly. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_SEND_PORT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>port</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>slave_announce_port</name></name></expr> ?</condition><then>
            <expr><name><name>server</name><operator>.</operator><name>slave_announce_port</name></name></expr> </then><else>: <expr><name><name>server</name><operator>.</operator><name>port</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_WRITE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"REPLCONF"</literal></expr></argument>,
                <argument><expr><literal type="string">"listening-port"</literal></expr></argument>,<argument><expr><name>port</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>write_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_RECEIVE_PORT</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Receive REPLCONF listening-port reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_RECEIVE_PORT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_READ</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Ignore the error if any, not all the Redis versions support
         * REPLCONF listening-port. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>err</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"(Non critical) Master does not understand "</literal>
                                <literal type="string">"REPLCONF listening-port: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_IP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Skip REPLCONF ip-address if there is no slave-announce-ip option set. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_SEND_IP</name> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>slave_announce_ip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_CAPA</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set the slave ip, so that Master's INFO command can list the
     * slave IP address port correctly in case of port forwarding or NAT. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_SEND_IP</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_WRITE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"REPLCONF"</literal></expr></argument>,
                <argument><expr><literal type="string">"ip-address"</literal></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>slave_announce_ip</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>write_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_RECEIVE_IP</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Receive REPLCONF ip-address reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_RECEIVE_IP</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_READ</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Ignore the error if any, not all the Redis versions support
         * REPLCONF listening-port. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>err</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"(Non critical) Master does not understand "</literal>
                                <literal type="string">"REPLCONF ip-address: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_CAPA</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Inform the master of our (slave) capabilities.
     *
     * EOF: supports EOF-style RDB transfer for diskless replication.
     * PSYNC2: supports PSYNC v2, so understands +CONTINUE &lt;new repl ID&gt;.
     *
     * The master will ignore capabilities it does not understand. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_SEND_CAPA</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_WRITE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"REPLCONF"</literal></expr></argument>,
                <argument><expr><literal type="string">"capa"</literal></expr></argument>,<argument><expr><literal type="string">"eof"</literal></expr></argument>,<argument><expr><literal type="string">"capa"</literal></expr></argument>,<argument><expr><literal type="string">"psync2"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>write_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_RECEIVE_CAPA</name></expr>;</expr_stmt>
        <macro><name>WIN32_ONLY</name><argument_list>(<argument>WSIOCP_QueueNextRead(fd);</argument>)</argument_list></macro>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Receive CAPA reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_RECEIVE_CAPA</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sendSynchronousCommand</name><argument_list>(<argument><expr><name>SYNC_CMD_READ</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Ignore the error if any, not all the Redis versions support
         * REPLCONF capa. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>err</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"(Non critical) Master does not understand "</literal>
                                  <literal type="string">"REPLCONF capa: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_SEND_PSYNC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Try a partial resynchonization. If we don't have a cached master
     * slaveTryPartialResynchronization() will at least try to use PSYNC
     * to start a full resynchronization so that we get the master run id
     * and the global offset, to try a partial resync at the next
     * reconnection attempt. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_SEND_PSYNC</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>slaveTryPartialResynchronization</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>PSYNC_WRITE_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"Write error sending the PSYNC command."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>write_error</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_RECEIVE_PSYNC</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>!=</operator> <name>REPL_STATE_RECEIVE_PSYNC</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"syncWithMaster(): state machine error, "</literal>
                             <literal type="string">"state should be RECEIVE_PSYNC but is %d"</literal></expr></argument>,
                             <argument><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>psync_result</name> <operator>=</operator> <call><name>slaveTryPartialResynchronization</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>psync_result</name> <operator>==</operator> <name>PSYNC_WAIT_REPLY</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Try again later... */</comment>

    <comment type="block">/* If the master is in an transient error, we should try to PSYNC
     * from scratch later, so go to the error path. This happens when
     * the server is loading the dataset or is not connected with its
     * master and so forth. */</comment>
    <if_stmt><if>if <condition>(<expr><name>psync_result</name> <operator>==</operator> <name>PSYNC_TRY_LATER</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Note: if PSYNC does not return WAIT_REPLY, it will take care of
     * uninstalling the read handler from the file descriptor. */</comment>

    <if_stmt><if>if <condition>(<expr><name>psync_result</name> <operator>==</operator> <name>PSYNC_CONTINUE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* PSYNC failed or is not supported: we want our slaves to resync with us
     * as well, if we have any sub-slaves. The master may transfer us an
     * entirely different data set and we have no way to incrementally feed
     * our slaves after that. */</comment>
    <expr_stmt><expr><call><name>disconnectSlaves</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Force our slaves to resync with us as well. */</comment>
    <expr_stmt><expr><call><name>freeReplicationBacklog</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Don't allow our chained slaves to PSYNC. */</comment>

    <comment type="block">/* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC
     * and the server.master_replid and master_initial_offset are
     * already populated. */</comment>
    <if_stmt><if>if <condition>(<expr><name>psync_result</name> <operator>==</operator> <name>PSYNC_NOT_SUPPORTED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Retrying with SYNC..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>syncWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"SYNC\r\n"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name><name>server</name><operator>.</operator><name>repl_syncio_timeout</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_LONGLONG) */</comment>
            <name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"I/O error writing to MASTER: %s"</literal></expr></argument>,
                <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Prepare a suitable temp file for bulk transfer */</comment>
    <while>while<condition>(<expr><name>maxtries</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,
            <argument><expr><literal type="string">"temp-%d.%d.rdb"</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><name>O_CREAT</name><operator>|</operator><name>O_WRONLY</name><operator>|</operator><name>O_EXCL</name><operator>|</operator><name>O_BINARY</name></expr></argument>,<argument><expr><name>_S_IREAD</name><operator>|</operator><name>_S_IWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,
            <argument><expr><literal type="string">"temp-%d.%ld.rdb"</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name></expr></argument>,<argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><name>O_CREAT</name><operator>|</operator><name>O_WRONLY</name><operator>|</operator><name>O_EXCL</name></expr></argument>,<argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>dfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>dfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Setup the non blocking download of the bulk file. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>AE_READABLE</name></expr></argument>,<argument><expr><name>readSyncBulkPayload</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
            <operator>==</operator> <name>AE_ERR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Can't create readable event for SYNC: %s (fd=%d)"</literal></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_TRANSFER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_size</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_read</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_last_fsync_off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name> <operator>=</operator> <name>dfd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_tmpfile</name></name> <operator>=</operator> <call><name>zstrdup</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_READABLE</name><operator>|</operator><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECT</name></expr>;</expr_stmt>
    <return>return;</return>

<label><name>write_error</name>:</label> <comment type="block">/* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */</comment>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Sending command to master in replication handshake: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>connectWithMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>anetTcpNonBlockBestEffortBindConnect</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
        <argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>masterport</name></name></expr></argument>,<argument><expr><name>NET_FIRST_BIND_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unable to connect to MASTER: %s"</literal></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_READABLE</name><operator>|</operator><name>AE_WRITABLE</name></expr></argument>,<argument><expr><name>syncWithMaster</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator>
            <name>AE_ERR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Can't create readable event for SYNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECTING</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function can be called when a non blocking connection is currently
 * in progress to undo it.
 * Never call this function directly, use cancelReplicationHandshake() instead.
 */</comment>
<function><type><name>void</name></type> <name>undoConnectWithMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>AE_READABLE</name><operator>|</operator><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_transfer_s</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Abort the async download of the bulk dataset while SYNC-ing with master.
 * Never call this function directly, use cancelReplicationHandshake() instead.
 */</comment>
<function><type><name>void</name></type> <name>replicationAbortSyncTransfer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_TRANSFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>undoConnectWithMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_tmpfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_transfer_tmpfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function aborts a non blocking replication attempt if there is one
 * in progress, by canceling the non-blocking connect attempt or
 * the initial bulk transfer.
 *
 * If there was a replication handshake in progress 1 is returned and
 * the replication state (server.repl_state) set to REPL_STATE_CONNECT.
 *
 * Otherwise zero is returned and no operation is perforemd at all. */</comment>
<function><type><name>int</name></type> <name>cancelReplicationHandshake</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_TRANSFER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>replicationAbortSyncTransfer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECT</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTING</name> <operator>||</operator>
               <call><name>slaveIsInHandshakeState</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>undoConnectWithMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECT</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set replication to the specified master address and port. */</comment>
<function><type><name>void</name></type> <name>replicationSetMaster</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>was_master</name> <init>= <expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>masterport</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>master</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>disconnectAllBlockedClients</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Clients blocked in master, now slave. */</comment>

    <comment type="block">/* Force our slaves to resync with us as well. They may hopefully be able
     * to partially resync with us, but we can notify the replid change. */</comment>
    <expr_stmt><expr><call><name>disconnectSlaves</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Before destroying our master state, create a cached master using
     * our own parameters, to later PSYNC with the new master. */</comment>
    <if_stmt><if>if <condition>(<expr><name>was_master</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>replicationDiscardCachedMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>replicationCacheMasterUsingMyself</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Cancel replication, setting the instance as a master itself. */</comment>
<function><type><name>void</name></type> <name>replicationUnsetMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Nothing to do. */</comment>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* When a slave is turned into a master, the current replication ID
     * (that was inherited from the master at synchronization time) is
     * used as secondary ID up to the current offset, and a new replication
     * ID is created to continue with a new replication history. */</comment>
    <expr_stmt><expr><call><name>shiftReplicationId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>master</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>replicationDiscardCachedMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Disconnecting all the slaves is required: we need to inform slaves
     * of the replication ID change (see shiftReplicationId() call). However
     * the slaves will be able to partially resync with us, so it will be
     * a very fast reconnection. */</comment>
    <expr_stmt><expr><call><name>disconnectSlaves</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* We need to make sure the new master will start the replication stream
     * with a SELECT statement. This is forced after a full resync, but
     * with PSYNC version 2, there is no need for full resync after a
     * master switch. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>slaveseldb</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Once we turn from slave to master, we consider the starting time without
     * slaves (that is used to count the replication backlog time to live) as
     * starting from now. Otherwise the backlog will be freed after a
     * failover if slaves do not connect immediately. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_no_slaves_since</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called when the slave lose the connection with the
 * master into an unexpected way. */</comment>
<function><type><name>void</name></type> <name>replicationHandleMasterDisconnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_down_since</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <comment type="block">/* We lost connection with our master, don't disconnect slaves yet,
     * maybe we'll be able to PSYNC with our master later. We'll disconnect
     * the slaves only if we'll have to do a full resync with our master. */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>replicaofCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* SLAVEOF is not allowed in cluster mode as replication is automatically
     * configured using the current address of the master node. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"REPLICAOF not allowed in cluster mode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The special host/port combination "NO" "ONE" turns the instance
     * into a master. Otherwise the new master address is set. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"one"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>replicationUnsetMaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>client</name> <init>= <expr><call><name>catClientInfoString</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"MASTER MODE enabled (user request from '%s')"</literal></expr></argument>,
                <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>port</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SLAVE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If a client is already a replica they cannot run this command,
             * because it involves flushing all replicas (including this
             * client) */</comment>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"Command is not valid when client is a replica."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Check if we are already attached to the specified slave */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>masterport</name></name> <operator>==</operator> <name>port</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"REPLICAOF would result into synchronization with the master we are already connected with. No operation performed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"+OK Already connected to specified master\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* There was no previous master or the user specified a different one,
         * we can continue. */</comment>
        <expr_stmt><expr><call><name>replicationSetMaster</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                       <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
        <name>sds</name></type> <name>client</name> <init>= <expr><call><name>catClientInfoString</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"REPLICAOF %s:%d enabled (user request from '%s')"</literal></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>masterport</name></name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ROLE command: provide information about the role of the instance
 * (master or slave) and additional information related to replication
 * in an easy to process format. */</comment>
<function><type><name>void</name></type> <name>roleCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mbcount</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>slaves</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"master"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>master_repl_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mbcount</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>slaveip</name> <init>= <expr><name><name>slave</name><operator>-&gt;</operator><name>slave_ip</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>slaveip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>anetPeerToString</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>ip</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>slaveip</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>!=</operator> <name>SLAVE_STATE_ONLINE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>slaveip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>slave_listening_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>repl_ack_off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>slaves</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>mbcount</name></expr></argument>,<argument><expr><name>slaves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slavestate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"slave"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>masterport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>slaveIsInHandshakeState</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"handshake"</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>REPL_STATE_NONE</name></expr>:</case> <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"none"</literal></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>REPL_STATE_CONNECT</name></expr>:</case> <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"connect"</literal></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>REPL_STATE_CONNECTING</name></expr>:</case> <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"connecting"</literal></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>REPL_STATE_TRANSFER</name></expr>:</case> <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"sync"</literal></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>REPL_STATE_CONNECTED</name></expr>:</case> <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"connected"</literal></expr>;</expr_stmt> <break>break;</break>
            <default>default:</default> <expr_stmt><expr><name>slavestate</name> <operator>=</operator> <literal type="string">"unknown"</literal></expr>;</expr_stmt> <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>slavestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr> ?</condition><then> <expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a REPLCONF ACK command to the master to inform it about the current
 * processed offset. If we are not connected with a master, the command has
 * no effects. */</comment>
<function><type><name>void</name></type> <name>replicationSendAck</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_MASTER_FORCE_REPLY</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"REPLCONF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"ACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reploff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_MASTER_FORCE_REPLY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */</comment>

<comment type="block">/* In order to implement partial synchronization we need to be able to cache
 * our master's client structure after a transient disconnection.
 * It is cached into server.cached_master and flushed away using the following
 * functions. */</comment>

<comment type="block">/* This function is called by freeClient() in order to cache the master
 * client structure instead of destroying it. freeClient() will return
 * ASAP after this function returns, so every action needed to avoid problems
 * with a client that is really "suspended" has to be done by this function.
 *
 * The other functions that will deal with the cached master are:
 *
 * replicationDiscardCachedMaster() that will make sure to kill the client
 * as for some reason we don't want to use it in the future.
 *
 * replicationResurrectCachedMaster() that is used after a successful PSYNC
 * handshake in order to reactivate the cached master.
 */</comment>
<function><type><name>void</name></type> <name>replicationCacheMaster</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>cached_master</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Caching the disconnected master state."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unlink the client from the server structures. */</comment>
    <expr_stmt><expr><call><name>unlinkClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the master client so that's ready to accept new commands:
     * we want to discard te non processed query buffers and non processed
     * offsets, including pending transactions, already populated arguments,
     * pending outputs to the master. */</comment>
    <expr_stmt><expr><call><name>sdsclear</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsclear</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>pending_querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>read_reploff</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>discardTransaction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listEmpty</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sentlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Save the master. Server.master will be set to null later by
     * replicationHandleMasterDisconnection(). */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cached_master</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master</name></name></expr>;</expr_stmt>

    <comment type="block">/* Invalidate the Peer ID cache. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Caching the master happens instead of the actual freeClient() call,
     * so make sure to adjust the replication state. This function will
     * also set server.master to NULL. */</comment>
    <expr_stmt><expr><call><name>replicationHandleMasterDisconnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is called when a master is turend into a slave, in order to
 * create from scratch a cached master for the new client, that will allow
 * to PSYNC with the slave that was promoted as the new master after a
 * failover.
 *
 * Assuming this instance was previously the master instance of the new master,
 * the new master will accept its replication ID, and potentiall also the
 * current offset if no data was lost during the failover. So we use our
 * current replication ID and offset in order to synthesize a cached master. */</comment>
<function><type><name>void</name></type> <name>replicationCacheMasterUsingMyself</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* The master client we create can be set to any DBID, because
     * the new master will start its replication stream with SELECT. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master_initial_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master_repl_offset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replicationCreateMasterClient</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Use our own ID / offset. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>replid</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>replid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set as cached master. */</comment>
    <expr_stmt><expr><call><name>unlinkClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cached_master</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a cached master, called when there are no longer the conditions for
 * a partial resync on reconnection. */</comment>
<function><type><name>void</name></type> <name>replicationDiscardCachedMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cached_master</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Discarding previously cached master state."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CLIENT_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cached_master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cached_master</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Turn the cached master into the current master, using the file descriptor
 * passed as argument as the socket for the new master.
 *
 * This function is called when successfully setup a partial resynchronization
 * so the stream of data that we'll receive will start from were this
 * master left. */</comment>
<function><type><name>void</name></type> <name>replicationResurrectCachedMaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newfd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cached_master</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cached_master</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>newfd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CLIENT_CLOSE_AFTER_REPLY</name><operator>|</operator><name>CLIENT_CLOSE_ASAP</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>authenticated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>lastinteraction</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>=</operator> <name>REPL_STATE_CONNECTED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_down_since</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Re-add to the list of clients. */</comment>
    <expr_stmt><expr><call><name>linkClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>AE_READABLE</name></expr></argument>,
                          <argument><expr><name>readQueryFromClient</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error resurrecting the cached master, impossible to add the readable handler: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close ASAP. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We may also need to install the write handler as well if there is
     * pending data in the write buffers. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>AE_WRITABLE</name></expr></argument>,
                          <argument><expr><name>sendReplyToClient</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error resurrecting the cached master, impossible to add the writable handler: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeClientAsync</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close ASAP. */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */</comment>

<comment type="block">/* This function counts the number of slaves with lag &lt;= min-slaves-max-lag.
 * If the option is active, the server will prevent writes if there are not
 * enough connected slaves with the specified lag (or less). */</comment>
<function><type><name>void</name></type> <name>refreshGoodSlavesCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>good</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>repl_min_slaves_to_write</name></name> <operator>||</operator>
        <operator>!</operator><name><name>server</name><operator>.</operator><name>repl_min_slaves_max_lag</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>time_t</name></type> <name>lag</name> <init>= <expr><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>slave</name><operator>-&gt;</operator><name>repl_ack_time</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_ONLINE</name> <operator>&amp;&amp;</operator>
            <name>lag</name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>repl_min_slaves_max_lag</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>good</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_good_slaves_count</name></name> <operator>=</operator> <name>good</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------- REPLICATION SCRIPT CACHE --------------------------
 * The goal of this code is to keep track of scripts already sent to every
 * connected slave, in order to be able to replicate EVALSHA as it is without
 * translating it to EVAL every time it is possible.
 *
 * We use a capped collection implemented by a hash table for fast lookup
 * of scripts we can send as EVALSHA, plus a linked list that is used for
 * eviction of the oldest entry when the max number of items is reached.
 *
 * We don't care about taking a different cache for every different slave
 * since to fill the cache again is not very costly, the goal of this code
 * is to avoid that the same big script is trasmitted a big number of times
 * per second wasting bandwidth and processor speed, but it is not a problem
 * if we need to rebuild the cache from scratch from time to time, every used
 * script will need to be transmitted a single time to reappear in the cache.
 *
 * This is how the system works:
 *
 * 1) Every time a new slave connects, we flush the whole script cache.
 * 2) We only send as EVALSHA what was sent to the master as EVALSHA, without
 *    trying to convert EVAL into EVALSHA specifically for slaves.
 * 3) Every time we trasmit a script as EVAL to the slaves, we also add the
 *    corresponding SHA1 of the script into the cache as we are sure every
 *    slave knows about the script starting from now.
 * 4) On SCRIPT FLUSH command, we replicate the command to all the slaves
 *    and at the same time flush the script cache.
 * 5) When the last slave disconnects, flush the cache.
 * 6) We handle SCRIPT LOAD as well since that's how scripts are loaded
 *    in the master sometimes.
 */</comment>

<comment type="block">/* Initialize the script cache, only called at startup. */</comment>
<function><type><name>void</name></type> <name>replicationScriptCacheInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_size</name></name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replScriptCacheDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Empty the script cache. Should be called every time we are no longer sure
 * that every slave knows about all the scripts in our set, or when the
 * current AOF "context" is no longer aware of the script. In general we
 * should flush the cache:
 *
 * 1) Every time a new slave reconnects to this master and performs a
 *    full SYNC (PSYNC does not require flushing).
 * 2) Every time an AOF rewrite is performed.
 * 3) Every time we are left without slaves at all, and AOF is off, in order
 *    to reclaim otherwise unused memory.
 */</comment>
<function><type><name>void</name></type> <name>replicationScriptCacheFlush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>dictEmpty</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add an entry into the script cache, if we reach max number of entries the
 * oldest is removed from the list. */</comment>
<function><type><name>void</name></type> <name>replicationScriptCacheAdd</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>sha1</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Evict oldest. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>server</name><operator>.</operator><name>repl_scriptcache_size</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listLast</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>oldest</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name></expr></argument>,<argument><expr><name>oldest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add current. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeHead</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns non-zero if the specified entry exists inside the cache, that is,
 * if all the slaves are aware of this script SHA1. */</comment>
<function><type><name>int</name></type> <name>replicationScriptCacheExists</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>sha1</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_dict</name></name></expr></argument>,<argument><expr><name>sha1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------- SYNCHRONOUS REPLICATION --------------------------
 * Redis synchronous replication design can be summarized in points:
 *
 * - Redis masters have a global replication offset, used by PSYNC.
 * - Master increment the offset every time new commands are sent to slaves.
 * - Slaves ping back masters with the offset processed so far.
 *
 * So synchronous replication adds a new WAIT command in the form:
 *
 *   WAIT &lt;num_replicas&gt; &lt;milliseconds_timeout&gt;
 *
 * That returns the number of replicas that processed the query when
 * we finally have at least num_replicas, or when the timeout was
 * reached.
 *
 * The command is implemented in this way:
 *
 * - Every time a client processes a command, we remember the replication
 *   offset after sending that command to the slaves.
 * - When WAIT is called, we ask slaves to send an acknowledgement ASAP.
 *   The client is blocked at the same time (see blocked.c).
 * - Once we receive enough ACKs for a given offset or when the timeout
 *   is reached, the WAIT command is unblocked and the reply sent to the
 *   client.
 */</comment>

<comment type="block">/* This just set a flag so that we broadcast a REPLCONF GETACK command
 * to all the slaves in the beforeSleep() function. Note that this way
 * we "group" all the clients that want to wait for synchronouns replication
 * in a given event loop iteration, and send a single GETACK for them all. */</comment>
<function><type><name>void</name></type> <name>replicationRequestAckFromSlaves</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>get_ack_from_slaves</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the number of slaves that already acknowledged the specified
 * replication offset. */</comment>
<function><type><name>int</name></type> <name>replicationCountAcksByOffset</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>!=</operator> <name>SLAVE_STATE_ONLINE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>repl_ack_off</name></name> <operator>&gt;=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* WAIT for N replicas to acknowledge the processing of our latest
 * write command (and all the previous commands). */</comment>
<function><type><name>void</name></type> <name>waitCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>numreplicas</name></decl>, <decl><type ref="prev"/><name>ackreplicas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>offset</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>woff</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Argument parsing. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numreplicas</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getTimeoutFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>,<argument><expr><name>UNIT_MILLISECONDS</name></expr></argument>)</argument_list></call>
        <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* First try without blocking at all. */</comment>
    <expr_stmt><expr><name>ackreplicas</name> <operator>=</operator> <call><name>replicationCountAcksByOffset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>woff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ackreplicas</name> <operator>&gt;=</operator> <name>numreplicas</name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ackreplicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise block the client and put it into our list of clients
     * waiting for ack from slaves. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name>timeout</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>reploffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>numreplicas</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>numreplicas</name></expr>;</expr_stmt>                                    <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
    <name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_waiting_acks</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>blockClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>BLOCKED_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure that the server will send an ACK request to all the slaves
     * before returning to the event loop. */</comment>
    <expr_stmt><expr><call><name>replicationRequestAckFromSlaves</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is called by unblockClient() to perform the blocking op type
 * specific cleanup. We just remove the client from the list of clients
 * waiting for replica acks. Never call it directly, call unblockClient()
 * instead. */</comment>
<function><type><name>void</name></type> <name>unblockClientWaitingReplicas</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_waiting_acks</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_waiting_acks</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if there are clients blocked in WAIT that can be unblocked since
 * we received enough ACKs from slaves. */</comment>
<function><type><name>void</name></type> <name>processClientsWaitingReplicas</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>last_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_numreplicas</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_waiting_acks</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Every time we find a client that is satisfied for a given
         * offset and number of replicas, we remember it so the next client
         * may be unblocked without calling replicationCountAcksByOffset()
         * if the requested offset / replicas were equal or less. */</comment>
        <if_stmt><if>if <condition>(<expr><name>last_offset</name> <operator>&amp;&amp;</operator> <name>last_offset</name> <operator>&gt;</operator> <name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>reploffset</name></name> <operator>&amp;&amp;</operator>
                           <name>last_numreplicas</name> <operator>&gt;</operator> <name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>numreplicas</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>unblockClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>last_numreplicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>numreplicas</name> <init>= <expr><call><name>replicationCountAcksByOffset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>reploffset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>numreplicas</name> <operator>&gt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>numreplicas</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>last_offset</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>reploffset</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>last_numreplicas</name> <operator>=</operator> <name>numreplicas</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>unblockClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>numreplicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Return the slave replication offset for this instance, that is
 * the offset for which we already processed the master replication stream. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>replicationGetSlaveOffset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>master</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>reploff</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>cached_master</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>cached_master</name><operator>-&gt;</operator><name>reploff</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* offset may be -1 when the master does not support it at all, however
     * this function is designed to return an offset that can express the
     * amount of data processed by the master, so we return a positive
     * integer. */</comment>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------- REPLICATION CRON  ---------------------------- */</comment>

<comment type="block">/* Replication cron function, called 1 time per second. */</comment>
<function><type><name>void</name></type> <name>replicationCron</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PORT_LONGLONG</name></type> <name>replication_cron_loops</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Non blocking connection timeout? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTING</name> <operator>||</operator>
         <call><name>slaveIsInHandshakeState</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
         <operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>-</operator><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name><operator>)</operator> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_timeout</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Timeout connecting to the MASTER..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Bulk transfer I/O timeout? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_TRANSFER</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>-</operator><name><name>server</name><operator>.</operator><name>repl_transfer_lastio</name></name><operator>)</operator> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_timeout</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cancelReplicationHandshake</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Timed out master when we are an already connected slave? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTED</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>-</operator><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>lastinteraction</name></name><operator>)</operator> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_timeout</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"MASTER timeout: no data nor PING received..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if we should connect to a MASTER */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Connecting to MASTER %s:%d"</literal></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>masterhost</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>masterport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>connectWithMaster</name><argument_list>()</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"MASTER &lt;-&gt; REPLICA sync started"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send ACK to master from time to time.
     * Note that we do not send periodic acks to masters that don't
     * support PSYNC and replication offsets. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>master</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name><name>server</name><operator>.</operator><name>master</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PRE_PSYNC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>replicationSendAck</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If we have attached slaves, PING them from time to time.
     * So slaves can implement an explicit timeout to masters, and will
     * be able to detect a link disconnection even if the TCP connection
     * will not actually go down. */</comment>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>ping_argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* First, send PING according to ping_slave_period. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>replication_cron_loops</name> <operator>%</operator> <name><name>server</name><operator>.</operator><name>repl_ping_slave_period</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Note that we don't send the PING if the clients are paused during
         * a Redis Cluster manual failover: the PING we send will otherwise
         * alter the replication offsets of master and slave, and will no longer
         * match the one stored into 'mf_master_offset' state. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>manual_failover_in_progress</name> <init>=
            <expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>mf_end</name></name> <operator>&amp;&amp;</operator>
            <call><name>clientsArePaused</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>manual_failover_in_progress</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>ping_argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"PING"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>replicationFeedSlaves</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>slaveseldb</name></name></expr></argument>,
                <argument><expr><name>ping_argv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>ping_argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Second, send a newline to all the slaves in pre-synchronization
     * stage, that is, slaves waiting for the master to create the RDB file.
     *
     * Also send the a newline to all the chained slaves we have, if we lost
     * connection from our master, to keep the slaves aware that their
     * master is online. This is needed since sub-slaves only receive proxied
     * data from top-level masters, so there is no explicit pinging in order
     * to avoid altering the replication offsets. This special out of band
     * pings (newlines) can be sent, they will have no effect in the offset.
     *
     * The newline will be ignored by the slave but will refresh the
     * last interaction timer preventing a timeout. In this case we ignore the
     * ping period and refresh the connection once per second since certain
     * timeouts are set at a few seconds (example: PSYNC response). */</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>is_presync</name> <init>=
            <expr><operator>(</operator><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name> <operator>||</operator>
            <operator>(</operator><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_END</name> <operator>&amp;&amp;</operator>
             <name><name>server</name><operator>.</operator><name>rdb_child_type</name></name> <operator>!=</operator> <name>RDB_CHILD_TYPE_SOCKET</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>is_presync</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>WSIOCP_SocketSend</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Don't worry about socket errors, it's just a ping. */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disconnect timedout slaves. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>!=</operator> <name>SLAVE_STATE_ONLINE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PRE_PSYNC</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>slave</name><operator>-&gt;</operator><name>repl_ack_time</name></name><operator>)</operator> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_timeout</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Disconnecting timedout replica: %s"</literal></expr></argument>,
                    <argument><expr><call><name>replicationGetSlaveName</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is a master without attached slaves and there is a replication
     * backlog active, in order to reclaim memory we can free it after some
     * (configured) time. Note that this cannot be done for slaves: slaves
     * without sub-slaves attached should still accumulate data into the
     * backlog, in order to reply to PSYNC queries if they are turned into
     * masters after a failover. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_time_limit</name></name> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>repl_backlog</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>time_t</name></type> <name>idle</name> <init>= <expr><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>repl_no_slaves_since</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_time_limit</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* When we free the backlog, we always use a new
             * replication ID and clear the ID2. This is needed
             * because when there is no backlog, the master_repl_offset
             * is not updated, but we would still retain our replication
             * ID, leading to the following problem:
             *
             * 1. We are a master instance.
             * 2. Our slave is promoted to master. It's repl-id-2 will
             *    be the same as our repl-id.
             * 3. We, yet as master, receive some updates, that will not
             *    increment the master_repl_offset.
             * 4. Later we are turned into a slave, connect to the new
             *    master that will accept our PSYNC request by second
             *    replication ID, but there will be data inconsistency
             *    because we received writes. */</comment>
            <expr_stmt><expr><call><name>changeReplicationId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clearReplicationId2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeReplicationBacklog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
                <argument><expr><literal type="string">"Replication backlog freed after %d seconds "</literal>
                <literal type="string">"without connected replicas."</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>repl_backlog_time_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If AOF is disabled and we no longer have attached slaves, we can
     * free our Replication Script Cache as there is no need to propagate
     * EVALSHA at all. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>==</operator> <name>AOF_OFF</name> <operator>&amp;&amp;</operator>
        <call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>repl_scriptcache_fifo</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>replicationScriptCacheFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Start a BGSAVE good for replication if we have slaves in
     * WAIT_BGSAVE_START state.
     *
     * In case of diskless replication, we make sure to wait the specified
     * number of seconds (according to configuration) so that other slaves
     * have the time to arrive before we start streaming. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>time_t</name></type> <name>idle</name></decl>, <decl><type ref="prev"/><name>max_idle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>slaves_waiting</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>mincapa</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replstate</name></name> <operator>==</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>idle</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>slave</name><operator>-&gt;</operator><name>lastinteraction</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&gt;</operator> <name>max_idle</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_idle</name> <operator>=</operator> <name>idle</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>slaves_waiting</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>mincapa</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mincapa</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>slave</name><operator>-&gt;</operator><name>slave_capa</name></name></expr> </then><else>:
                                            <expr><operator>(</operator><name>mincapa</name> <operator>&amp;</operator> <name><name>slave</name><operator>-&gt;</operator><name>slave_capa</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>slaves_waiting</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>!</operator><name><name>server</name><operator>.</operator><name>repl_diskless_sync</name></name> <operator>||</operator>
             <name>max_idle</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>repl_diskless_sync_delay</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Start the BGSAVE. The called function may start a
             * BGSAVE with socket target or disk target depending on the
             * configuration and slaves capabilities. */</comment>
            <expr_stmt><expr><call><name>startBgsaveForReplication</name><argument_list>(<argument><expr><name>mincapa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</comment>
    <expr_stmt><expr><call><name>refreshGoodSlavesCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>replication_cron_loops</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Incremented with frequency 1 HZ. */</comment>
</block_content>}</block></while></block_content></block></function>
</unit>
