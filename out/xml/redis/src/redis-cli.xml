<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/redis-cli.c"><comment type="block">/* Redis CLI (command line interface)
 *
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32fixes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_PThread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Error.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmacros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>STDIN_FILENO</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDIN_FILENO</name></cpp:macro> <cpp:value>(_fileno(stdin))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32fixes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Signal_Process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_ANSI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strcasecmp</name></cpp:macro> <cpp:value>_stricmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strncasecmp</name></cpp:macro> <cpp:value>_strnicmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtoull</name></cpp:macro> <cpp:value>_strtoui64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hiredis.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sds.h&gt;</cpp:file></cpp:include> <comment type="block">/* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"linenoise.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"help.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"anet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ae.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>V</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void) V)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_STANDARD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_RAW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_CSV</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_KEEPALIVE_INTERVAL</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define> <comment type="block">/* seconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_DEFAULT_PIPE_TIMEOUT</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> <comment type="block">/* seconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_HISTFILE_ENV</name></cpp:macro> <cpp:value>"REDISCLI_HISTFILE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_HISTFILE_DEFAULT</name></cpp:macro> <cpp:value>".rediscli_history"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_RCFILE_ENV</name></cpp:macro> <cpp:value>"REDISCLI_RCFILE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_RCFILE_DEFAULT</name></cpp:macro> <cpp:value>".redisclirc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_AUTH_ENV</name></cpp:macro> <cpp:value>"REDISCLI_AUTH"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_CLI_CLUSTER_YES_ENV</name></cpp:macro> <cpp:value>"REDISCLI_CLUSTER_YES"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_SLOTS</name></cpp:macro>               <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_MIGRATE_TIMEOUT</name></cpp:macro>     <cpp:value>60000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_MIGRATE_PIPELINE</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_REBALANCE_THRESHOLD</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></cpp:macro> \
    <cpp:value>"[ERR] Invalid arguments: you need to pass either a valid " \
    "address (ie. 120.0.0.1:7000) or space separated IP " \
    "and port (ie. 120.0.0.1 7000)\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_MODE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(config.cluster_manager_command.name != NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_MASTERS_COUNT</name><parameter_list>(<parameter><type><name>nodes</name></type></parameter>, <parameter><type><name>replicas</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(nodes/(replicas + 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_COMMAND</name><parameter_list>(<parameter><type><name>n</name></type></parameter>,<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
        <cpp:value>(redisCommand(n-&gt;context, __VA_ARGS__))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_NODE_ARRAY_FREE</name><parameter_list>(<parameter><type><name>array</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>zfree(array-&gt;alloc)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>err</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>clusterManagerLogErr("Node %s:%d replied with error:\n%s\n", \
                         n-&gt;ip, n-&gt;port, err);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clusterManagerLogInfo</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_INFO,__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clusterManagerLogErr</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_ERR,__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clusterManagerLogWarn</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_WARN,__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clusterManagerLogOk</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_SUCCESS,__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_FLAG_MYSELF</name></cpp:macro>     <cpp:value>1 &lt;&lt; 0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_FLAG_SLAVE</name></cpp:macro>      <cpp:value>1 &lt;&lt; 1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_FLAG_FRIEND</name></cpp:macro>     <cpp:value>1 &lt;&lt; 2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_FLAG_NOADDR</name></cpp:macro>     <cpp:value>1 &lt;&lt; 3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_FLAG_DISCONNECT</name></cpp:macro> <cpp:value>1 &lt;&lt; 4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_FLAG_FAIL</name></cpp:macro>       <cpp:value>1 &lt;&lt; 5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_FIX</name></cpp:macro>            <cpp:value>1 &lt;&lt; 0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_SLAVE</name></cpp:macro>          <cpp:value>1 &lt;&lt; 1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_YES</name></cpp:macro>            <cpp:value>1 &lt;&lt; 2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS</name></cpp:macro>    <cpp:value>1 &lt;&lt; 3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER</name></cpp:macro>    <cpp:value>1 &lt;&lt; 4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_SIMULATE</name></cpp:macro>       <cpp:value>1 &lt;&lt; 5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_REPLACE</name></cpp:macro>        <cpp:value>1 &lt;&lt; 6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_COPY</name></cpp:macro>           <cpp:value>1 &lt;&lt; 7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_COLOR</name></cpp:macro>          <cpp:value>1 &lt;&lt; 8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS</name></cpp:macro>   <cpp:value>1 &lt;&lt; 9</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_OPT_GETFRIENDS</name></cpp:macro>  <cpp:value>1 &lt;&lt; 0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_OPT_COLD</name></cpp:macro>        <cpp:value>1 &lt;&lt; 1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_OPT_UPDATE</name></cpp:macro>      <cpp:value>1 &lt;&lt; 2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_OPT_QUIET</name></cpp:macro>       <cpp:value>1 &lt;&lt; 6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_OPT_VERBOSE</name></cpp:macro>     <cpp:value>1 &lt;&lt; 7</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_LOG_LVL_INFO</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_LOG_LVL_WARN</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_LOG_LVL_ERR</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MANAGER_LOG_LVL_SUCCESS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_COLOR_BOLD</name></cpp:macro>      <cpp:value>"29;1m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_COLOR_RED</name></cpp:macro>       <cpp:value>"31;1m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_COLOR_GREEN</name></cpp:macro>     <cpp:value>"32;1m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_COLOR_YELLOW</name></cpp:macro>    <cpp:value>"33;1m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_COLOR_RESET</name></cpp:macro>     <cpp:value>"0m"</cpp:value></cpp:define>

<comment type="block">/* cliConnect() flags. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CC_FORCE</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>         <comment type="block">/* Re-connect if already connected. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CC_QUIET</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>         <comment type="block">/* Don't log connecting errors. */</comment>

<comment type="block">/* --latency-dist palettes. */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>spectrum_palette_color_size</name> <init>= <expr><literal type="number">19</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>spectrum_palette_color</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">239</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">247</literal></expr>,<expr><literal type="number">144</literal></expr>,<expr><literal type="number">143</literal></expr>,<expr><literal type="number">142</literal></expr>,<expr><literal type="number">184</literal></expr>,<expr><literal type="number">226</literal></expr>,<expr><literal type="number">214</literal></expr>,<expr><literal type="number">208</literal></expr>,<expr><literal type="number">202</literal></expr>,<expr><literal type="number">196</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>spectrum_palette_mono_size</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>spectrum_palette_mono</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">239</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">247</literal></expr>,<expr><literal type="number">249</literal></expr>,<expr><literal type="number">251</literal></expr>,<expr><literal type="number">253</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The actual palette in use. */</comment>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>spectrum_palette</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>spectrum_palette_size</name></decl>;</decl_stmt>

<comment type="block">/* Dict Helpers */</comment>

<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>dictSdsHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>dictSdsKeyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dictSdsDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dictListDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Cluster Manager Command Info */</comment>
<typedef>typedef <type><struct>struct <name>clusterManagerCommand</name> <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>replicas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>weight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>weight_argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>master_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pipeline</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>threshold</name></decl>;</decl_stmt>
}</block></struct></type> <name>clusterManagerCommand</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createClusterManagerCommand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <name>redisContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
<struct><specifier>static</specifier> struct <name>config</name> <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hostip</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hostport</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hostsocket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>repeat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>interval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dbnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>interactive</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shutdown</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>monitor_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pubsub_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>latency_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>latency_dist_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>latency_history</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lru_test_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>lru_test_sample_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cluster_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cluster_reissue_command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slave_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pipe_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pipe_timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>getrdb_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stat_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scan_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>intrinsic_latency_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>intrinsic_latency_duration</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rdb_filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bigkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>memkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>memkeys_samples</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hotkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stdinarg</name></decl>;</decl_stmt> <comment type="block">/* get last arg from stdin. (-x option) */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>auth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>output</name></decl>;</decl_stmt> <comment type="block">/* output mode, see OUTPUT_* defines */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>mb_delim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>prompt</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eval_ldb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eval_ldb_sync</name></decl>;</decl_stmt>  <comment type="block">/* Ask for synchronous mode of the Lua debugger. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eval_ldb_end</name></decl>;</decl_stmt>   <comment type="block">/* Lua debugging session ended. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>enable_ldb_on_eval</name></decl>;</decl_stmt> <comment type="block">/* Handle manual SCRIPT DEBUG + EVAL commands. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>last_cmd_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>verbose</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerCommand</name></type> <name>cluster_manager_command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>no_auth_warning</name></decl>;</decl_stmt>
}</block> <decl><name>config</name></decl>;</struct>

<comment type="block">/* User preferences. */</comment>
<struct><specifier>static</specifier> struct <name>pref</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hints</name></decl>;</decl_stmt>
}</block> <decl><name>pref</name></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>force_cancel_loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>slaveMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>redisGitSHA1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>redisGitDirty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cliConnect</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getInfoField</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PORT_LONG</name></type> <name>getLongInfoField</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>pthread_mutex_t</name></type> <name>used_memory_mutex</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*------------------------------------------------------------------------------
 * Utility functions
 *--------------------------------------------------------------------------- */</comment>

<function_decl><type><name>uint16_t</name></type> <name>crc16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PORT_LONGLONG</name></type> <name>ustime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <return>return <expr><call><name>GetHighResRelativeTime</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ust</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ust</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ust</name> <operator>+=</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
    <return>return <expr><name>ust</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PORT_LONGLONG</name></type> <name>mstime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>ustime</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">1000</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cliRefreshPrompt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>sds</name></type> <name>prompt</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>prompt</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>,<argument><expr><literal type="string">"redis %s"</literal></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>addr</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>anetFormatAddr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>hostport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>prompt</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Add [dbnum] if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>dbnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>prompt</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>,<argument><expr><literal type="string">"[%i]"</literal></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>dbnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Copy the prompt in the static buffer. */</comment>
    <expr_stmt><expr><name>prompt</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>,<argument><expr><literal type="string">"&gt; "</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>prompt</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>prompt</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the name of the dotfile for the specified 'dotfilename'.
 * Normally it just concatenates user $HOME to the file specified
 * in 'dotfilename'. However if the environment varialbe 'envoverride'
 * is set, its value is taken as the path.
 *
 * The function returns NULL (if the file is /dev/null or cannot be
 * obtained for some error), or an SDS string that must be freed by
 * the user. */</comment>
<function><type><specifier>static</specifier> <name>sds</name></type> <name>getDotfilePath</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>envoverride</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dotfilename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>dotPath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check the env for a dotfile override. */</comment>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>envoverride</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>path</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"/dev/null"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the env is set, return it. */</comment>
        <expr_stmt><expr><name>dotPath</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>homeDrive</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOMEDRIVE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>homePath</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOMEPATH"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>homeDrive</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>homeDrive</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><name>homePath</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>homePath</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>dotPath</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s%s\\%s"</literal></expr></argument>, <argument><expr><name>homeDrive</name></expr></argument>, <argument><expr><name>homePath</name></expr></argument>, <argument><expr><name>dotfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>home</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>home</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>home</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If no override is set use $HOME/&lt;dotfilename&gt;. */</comment>
            <expr_stmt><expr><name>dotPath</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>dotfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>dotPath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* URL-style percent decoding. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isHexChar</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isdigit(c) || (c &gt;= 'a' &amp;&amp; c &lt;= 'f'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>decodeHexChar</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isdigit(c) ? c - '0' : c - 'a' + 10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>decodeHex</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((decodeHexChar(h) &lt;&lt; 4) + decodeHexChar(l))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>percentDecode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>pe</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>ret</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><name>pe</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>curr</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>end</name> <operator>-</operator> <name>curr</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Incomplete URI encoding\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>char</name></type> <name>h</name> <init>= <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>++</operator><name>curr</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>l</name> <init>= <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>++</operator><name>curr</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isHexChar</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>isHexChar</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Illegal character in URI encoding\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name>decodeHex</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>curr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>curr</name><operator>++</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse a URI and extract the server connection information.
 * URI scheme is based on the the provisional specification[1] excluding support
 * for query parameters. Valid URIs are:
 *   scheme:    "redis://"
 *   authority: [&lt;username&gt; ":"] &lt;password&gt; "@"] [&lt;hostname&gt; [":" &lt;port&gt;]]
 *   path:      ["/" [&lt;db&gt;]]
 *
 *  [1]: https://www.iana.org/assignments/uri-schemes/prov/redis */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parseRedisUri</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scheme</name> <init>= <expr><literal type="string">"redis://"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><name>uri</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>uri</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userinfo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>username</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>port</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>host</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <comment type="block">/* URI must start with a valid scheme. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Invalid URI scheme\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>curr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Extract user info. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>userinfo</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>curr</name></expr></argument>,<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>username</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>curr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>username</name> <operator>&lt;</operator> <name>userinfo</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If provided, username is ignored. */</comment>
            <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>username</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>auth</name></name> <operator>=</operator> <call><name>percentDecode</name><argument_list>(<argument><expr><name>curr</name></expr></argument>, <argument><expr><name>userinfo</name> <operator>-</operator> <name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>userinfo</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Extract host and port. */</comment>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>curr</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>host</name> <operator>=</operator> <ternary><condition><expr><name>path</name></expr> ?</condition><then> <expr><name>path</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>end</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>port</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>curr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostport</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>port</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>host</name> <operator>=</operator> <name>port</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostip</name></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>curr</name></expr></argument>, <argument><expr><name>host</name> <operator>-</operator> <name>curr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>curr</name> <operator>=</operator> <ternary><condition><expr><name>path</name></expr> ?</condition><then> <expr><name>path</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>end</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Extract database number. */</comment>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>dbnum</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>dictSdsHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictGenHashFunction</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>key</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dictSdsKeyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>,<decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DICT_NOTUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>key1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>l1</name> <operator>!=</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dictSdsDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DICT_NOTUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dictListDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>DICT_NOTUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><operator>(</operator><name>list</name><operator>*</operator><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* _serverAssert is needed by dict */</comment>
<function><type><name>void</name></type> <name>_serverAssert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>estr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"=== ASSERTION FAILED ==="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"==&gt; %s:%d '%s' is not true"</literal></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>line</name></expr></argument>,<argument><expr><name>estr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Help functions
 *--------------------------------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLI_HELP_COMMAND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLI_HELP_GROUP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>full</name></decl>;</decl_stmt>

    <comment type="block">/* Only used for help on commands */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>commandHelp</name></name> <modifier>*</modifier></type><name>org</name></decl>;</decl_stmt>
}</block></struct></type> <name>helpEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>helpEntry</name> <modifier>*</modifier></type><name>helpEntries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>helpEntriesLen</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>cliVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>version</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>REDIS_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add git commit and working tree status when available */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strtoll</name><argument_list>(<argument><expr><call><name>redisGitSHA1</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">" (git:%s"</literal></expr></argument>, <argument><expr><call><name>redisGitSHA1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strtoll</name><argument_list>(<argument><expr><call><name>redisGitDirty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"-dirty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>version</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cliInitHelp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>commandslen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>commandHelp</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>commandHelp</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>groupslen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>commandGroups</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>helpEntry</name></type> <name>tmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>helpEntriesLen</name> <operator>=</operator> <name>len</name> <operator>=</operator> <name>commandslen</name><operator>+</operator><name>groupslen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>helpEntries</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>helpEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>groupslen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"@%s"</literal></expr></argument>,<argument><expr><name><name>commandGroups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>full</name></name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>CLI_HELP_GROUP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>org</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>helpEntries</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>commandslen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <call><name>sdssplitargs</name><argument_list>(<argument><expr><name><name>commandHelp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>tmp</name><operator>.</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>full</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>commandHelp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>CLI_HELP_COMMAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>org</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>commandHelp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>helpEntries</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* cliInitHelp() setups the helpEntries array with the command and group
 * names from the help.h file. However the Redis instance we are connecting
 * to may support more commands, so this function integrates the previous
 * entries with additional entries obtained using the COMMAND command
 * available in recent versions of Redis. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cliIntegrateHelp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><name>CC_QUIET</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"COMMAND"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_ARRAY</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Scan the array reported by COMMAND and fill only the entries that
     * don't already match what we have. */</comment>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_ARRAY</name> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>elements</name></name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>||</operator>
            <name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>REDIS_REPLY_STRING</name> <operator>||</operator>
            <name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>REDIS_REPLY_INTEGER</name> <operator>||</operator>
            <name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdname</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>helpEntriesLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>helpEntry</name> <modifier>*</modifier></type><name>he</name> <init>= <expr><name>helpEntries</name><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>he</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>helpEntriesLen</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>helpEntriesLen</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>helpEntries</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>helpEntries</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>helpEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>helpEntriesLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>helpEntry</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><name>helpEntries</name><operator>+</operator><operator>(</operator><name>helpEntriesLen</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>full</name></name> <operator>=</operator> <name><name>new</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CLI_HELP_COMMAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdstoupper</name><argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>struct</name> <name>commandHelp</name></name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>new</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>args</name> <init>= <expr><call><name>llabs</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>integer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>args</name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* Remove the command name itself. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>integer</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,<argument><expr><literal type="string">"key "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>args</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <while>while<condition>(<expr><name>args</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,<argument><expr><literal type="string">"arg "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>integer</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,<argument><expr><literal type="string">"...options..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>summary</name></name> <operator>=</operator> <literal type="string">"Help not available"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>since</name></name> <operator>=</operator> <literal type="string">"not known"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>org</name></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Output command help to stdout. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cliOutputCommandHelp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commandHelp</name></name> <modifier>*</modifier></type><name>help</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>group</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n"</literal></expr></argument>, <argument><expr><name><name>help</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>help</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  \x1b[33msummary:\x1b[0m %s\r\n"</literal></expr></argument>, <argument><expr><name><name>help</name><operator>-&gt;</operator><name>summary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  \x1b[33msince:\x1b[0m %s\r\n"</literal></expr></argument>, <argument><expr><name><name>help</name><operator>-&gt;</operator><name>since</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>group</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  \x1b[33mgroup:\x1b[0m %s\r\n"</literal></expr></argument>, <argument><expr><name><name>commandGroups</name><index>[<expr><name><name>help</name><operator>-&gt;</operator><name>group</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Print generic help. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cliOutputGenericHelp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>version</name> <init>= <expr><call><name>cliVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(
        <argument><expr><literal type="string">"redis-cli %s\n"</literal>
        <literal type="string">"To get help about Redis commands type:\n"</literal>
        <literal type="string">"      \"help @&lt;group&gt;\" to get a list of commands in &lt;group&gt;\n"</literal>
        <literal type="string">"      \"help &lt;command&gt;\" for help on &lt;command&gt;\n"</literal>
        <literal type="string">"      \"help &lt;tab&gt;\" to get a list of possible help topics\n"</literal>
        <literal type="string">"      \"quit\" to exit\n"</literal>
        <literal type="string">"\n"</literal>
        <literal type="string">"To set redis-cli preferences:\n"</literal>
        <literal type="string">"      \":set hints\" enable online hints\n"</literal>
        <literal type="string">"      \":set nohints\" disable online hints\n"</literal>
        <literal type="string">"Set your preferences in ~/.redisclirc\n"</literal></expr></argument>,
        <argument><expr><name>version</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Output all command help, filtering by group or command name. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cliOutputHelp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>group</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>helpEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>commandHelp</name></name> <modifier>*</modifier></type><name>help</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>cliOutputGenericHelp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>commandGroups</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>commandGroups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>group</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>helpEntriesLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>CLI_HELP_COMMAND</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>help</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>org</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Compare all arguments */</comment>
            <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>cliOutputCommandHelp</name><argument_list>(<argument><expr><name>help</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name><name>help</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>cliOutputCommandHelp</name><argument_list>(<argument><expr><name>help</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Linenoise completion callback. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>completionCallback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>linenoiseCompletions</name> <modifier>*</modifier></type><name>lc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>startpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>tmp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"help "</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>startpos</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>startpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>startpos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>CLI_HELP_COMMAND</name> <operator>|</operator> <name>CLI_HELP_GROUP</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>CLI_HELP_COMMAND</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>helpEntriesLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>matchlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>startpos</name></expr></argument>,<argument><expr><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>full</name></expr></argument>,<argument><expr><name>matchlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>,<argument><expr><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>full</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>linenoiseAddCompletion</name><argument_list>(<argument><expr><name>lc</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Linenoise hints callback. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hintsCallback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>color</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bold</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pref</name><operator>.</operator><name>hints</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>, <decl><type ref="prev"/><name>buflen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                                     <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast int */</comment>
    <name>sds</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>sdssplitargs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>endspace</name> <init>= <expr><name>buflen</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>buflen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check if the argument list is empty and return ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>helpEntriesLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>&amp;</operator> <name>CLI_HELP_COMMAND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>full</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>color</name> <operator>=</operator> <literal type="number">90</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>bold</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>hint</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name><name>helpEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>org</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Remove arguments from the returned hint to show only the
             * ones the user did not yet typed. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>toremove</name> <init>= <expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><name>toremove</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>hint</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>hint</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>toremove</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name>hint</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* Add an initial space if needed. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>endspace</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>newhint</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>newhint</name> <operator>=</operator> <call><name>sdscatsds</name><argument_list>(<argument><expr><name>newhint</name></expr></argument>,<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>hint</name> <operator>=</operator> <name>newhint</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>hint</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeHintsCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Networking / parsing
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* Send AUTH command to the server */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cliAuth</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>auth</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDIS_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"AUTH %s"</literal></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>auth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>REDIS_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDIS_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send SELECT dbnum to the server */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cliSelect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>dbnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDIS_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"SELECT %d"</literal></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>dbnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>REDIS_OK</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <name>REDIS_ERR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDIS_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Connect to the server. It is possible to pass certain flags to the function:
 *      CC_FORCE: The connection is performed even if there is already
 *                a connected socket.
 *      CC_QUIET: Don't print errors if connection fails. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cliConnect</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>flags</name> <operator>&amp;</operator> <name>CC_FORCE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>redisConnect</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>hostport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>redisConnectUnix</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CC_QUIET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Could not connect to Redis at "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s:%d: %s\n"</literal></expr></argument>,
                        <argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>hostport</name></name></expr></argument>,<argument><expr><name><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>,
                        <argument><expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name></expr></argument>,<argument><expr><name><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>REDIS_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Set aggressive KEEP_ALIVE socket option in the Redis context socket
         * in order to prevent timeouts caused by the execution of long
         * commands. At the same time this improves the detection of real
         * errors. */</comment>
        <expr_stmt><expr><call><name>anetKeepAlive</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>REDIS_CLI_KEEPALIVE_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Do AUTH and select the right DB. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cliAuth</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>cliSelect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cliPrintContextError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>,<argument><expr><name><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>cliFormatReplyTTY</name><parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>out</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>REDIS_REPLY_ERROR</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"(error) %s\n"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_STATUS</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"(integer) %lld\n"</literal></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>integer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_STRING</name></expr>:</case>
        <comment type="block">/* If you are producing output for the standard output we want
        * a more interesting output with quoted characters and so forth */</comment>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatrepr</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_NIL</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"(nil)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_ARRAY</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"(empty list or set)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>idxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>_prefixlen</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>_prefixfmt</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>_prefix</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>tmp</name></decl>;</decl_stmt>

            <comment type="block">/* Calculate chars needed to represent the largest index */</comment>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
            <do>do <block>{<block_content>
                <expr_stmt><expr><name>idxlen</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            </block_content>}</block> while<condition>(<expr><name>i</name></expr>)</condition>;</do>

            <comment type="block">/* Prefix for nested multi bulks should grow with idxlen+2 spaces */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>_prefixlen</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>,<argument><expr><name>idxlen</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>_prefixlen</name><index>[<expr><name>idxlen</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>_prefix</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>_prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Setup prefix format for every entry */</comment>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>_prefixfmt</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_prefixfmt</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%%s%%%ud) "</literal></expr></argument>,<argument><expr><name>idxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <comment type="block">/* Don't use the prefix for the first element, as the parent
                 * caller already prepended the index number. */</comment>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>_prefixfmt</name></expr></argument>,<argument><expr><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name>prefix</name></expr></else></ternary></expr></argument>,<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Format the multi bulk entry */</comment>
                <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>cliFormatReplyTTY</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Unknown reply type: %d\n"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>isColorTerm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>t</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"xterm"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper  function for sdsCatColorizedLdbReply() appending colorize strings
 * to an SDS string. */</comment>
<function><type><name>sds</name></type> <name>sdscatcolor</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>color</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isColorTerm</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>sdscatlen</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>bold</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"bold"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ccode</name> <init>= <expr><literal type="number">37</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Defaults to white. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"red"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"green"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"yellow"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">33</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"blue"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"magenta"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"cyan"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">36</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>color</name></expr></argument>,<argument><expr><literal type="string">"white"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccode</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"\033[%i;%i;49m"</literal></expr></argument>,<argument><expr><name>bold</name></expr></argument>,<argument><expr><name>ccode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"\033[0m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Colorize Lua debugger status replies according to the prefix they
 * have. */</comment>
<function><type><name>sds</name></type> <name>sdsCatColorizedLdbReply</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><literal type="string">"white"</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;debug&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"bold"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;redis&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"green"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;reply&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"cyan"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;error&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"red"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;hint&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"bold"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;value&gt;"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"&lt;retval&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"magenta"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"yellow"</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* Current line. */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="string">"bold"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Break point. */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>sdscatcolor</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>cliFormatReplyRaw</name><parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>out</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>REDIS_REPLY_NIL</name></expr>:</case>
        <comment type="block">/* Nothing... */</comment>
        <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_ERROR</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_STATUS</name></expr>:</case>
    <case>case <expr><name>REDIS_REPLY_STRING</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_STATUS</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>eval_ldb</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* The Lua debugger replies with arrays of simple (status)
             * strings. We colorize the output for more fun if this
             * is a debugging session. */</comment>

            <comment type="block">/* Detect the end of a debugging session. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;endsession&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>enable_ldb_on_eval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb_end</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Signal the caller session ended. */</comment>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_STANDARD</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cliRefreshPrompt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdsCatColorizedLdbReply</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%I64d"</literal></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>integer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* %lld -&gt; %I64d */</comment>
        <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_ARRAY</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>mb_delim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>cliFormatReplyRaw</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Unknown reply type: %d\n"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>cliFormatReplyCSV</name><parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>sds</name></type> <name>out</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>REDIS_REPLY_ERROR</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"ERROR,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatrepr</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_STATUS</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatrepr</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%I64d"</literal></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>integer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* %lld -&gt; %I64d */</comment>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_STRING</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatrepr</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_NIL</name></expr>:</case>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"NIL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    <case>case <expr><name>REDIS_REPLY_ARRAY</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>tmp</name> <init>= <expr><call><name>cliFormatReplyCSV</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>r</name><operator>-&gt;</operator><name>elements</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Unknown reply type: %d\n"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cliReadReply</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>output_raw_strings</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>_reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>output</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>_reply</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>shutdown</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>REDIS_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>interactive</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Filter cases where we should reconnect */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <name>REDIS_ERR_IO</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>errno</name> <operator>==</operator> <name>ECONNRESET</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EPIPE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <name>REDIS_ERR_EOF</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>cliPrintContextError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>REDIS_ERR</name></expr>;</return> <comment type="block">/* avoid compiler warning */</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>reply</name> <operator>=</operator> <operator>(</operator><name>redisReply</name><operator>*</operator><operator>)</operator><name>_reply</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>last_cmd_type</name></name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

    <comment type="block">/* Check if we need to connect to a different node and reissue the
     * request. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_mode</name></name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"MOVED"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"ASK"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>output</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Comments show the position of the pointer as:
         *
         * [S] for pointer 's'
         * [P] for pointer 'p'
         */</comment>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* MOVED[S]3999 127.0.0.1:6381 */</comment>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* MOVED[S]3999[P]127.0.0.1:6381 */</comment>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* MOVED 3999[P]127.0.0.1[S]6381 */</comment>
        <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostip</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostport</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>interactive</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-&gt; Redirected to slot [%d] located at %s:%d\n"</literal></expr></argument>,
                <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>hostport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_reissue_command</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cliRefreshPrompt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>output</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>output_raw_strings</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>cliFormatReplyRaw</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_RAW</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>cliFormatReplyRaw</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_STANDARD</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>cliFormatReplyTTY</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_CSV</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>cliFormatReplyCSV</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <comment type="block">/* if size is too large, fwrite fails. Use fprintf */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cliSendCommand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>repeat</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>argvlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>output_raw</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>&amp;&amp;</operator> <comment type="block">/* In debugging mode, let's pass "help" to Redis. */</comment>
        <operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>cliOutputHelp</name><argument_list>(<argument><expr><operator>--</operator><name>argc</name></expr></argument>, <argument><expr><operator>++</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>REDIS_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDIS_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>output_raw</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"lolwut"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"htstats"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"htstats-key"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"memory"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                      <operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"malloc-stats"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"doctor"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"cluster"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                      <operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"nodes"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"client"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"latency"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"graph"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"latency"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"doctor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>output_raw</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"shutdown"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>config</name><operator>.</operator><name>shutdown</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"monitor"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>config</name><operator>.</operator><name>monitor_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"subscribe"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"psubscribe"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pubsub_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"sync"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"psync"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* When the user manually calls SCRIPT DEBUG, setup the activation of
     * debugging mode on the next eval if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"script"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                     <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"sync"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>enable_ldb_on_eval</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>enable_ldb_on_eval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Actually activate LDB on EVAL if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"eval"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>enable_ldb_on_eval</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_RAW</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Setup argument length */</comment>
    <expr_stmt><expr><name>argvlen</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>argc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>argvlen</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <while>while<condition>(<expr><name><name>repeat</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>repeat</name><operator>--</operator></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>redisAppendCommandArgv</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>,<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>config</name><operator>.</operator><name>monitor_mode</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>cliReadReply</name><argument_list>(<argument><expr><name>output_raw</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>pubsub_mode</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>!=</operator> <name>OUTPUT_RAW</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Reading messages... (press Ctrl-C to quit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>cliReadReply</name><argument_list>(<argument><expr><name>output_raw</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entering replica output mode...  (press Ctrl-C to quit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>slaveMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>REDIS_ERR</name></expr>;</return>  <comment type="block">/* Error = slaveMode lost connection to master */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cliReadReply</name><argument_list>(<argument><expr><name>output_raw</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>REDIS_ERR</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Store database number when SELECT was successfully executed. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>last_cmd_type</name></name> <operator>!=</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>dbnum</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cliRefreshPrompt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>command</name></expr></argument>,<argument><expr><literal type="string">"auth"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>cliSelect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_reissue_command</name></name></expr>)</condition><block>{<block_content>
            <comment type="block">/* If we need to reissue the command, break to prevent a
               further 'repeat' number of dud interations */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Make it grep friendly */</comment>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send a command reconnecting the link if needed. */</comment>
<function><type><specifier>static</specifier> <name>redisReply</name> <modifier>*</modifier></type><name>reconnectingRedisCommand</name><parameter_list>(<parameter><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <while>while <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>err</name></name> <operator>&amp;</operator> <operator>(</operator><name>REDIS_ERR_IO</name> <operator>|</operator> <name>REDIS_ERR_EOF</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\x1b[0K"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cursor to left edge + clear line. */</comment>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Reconnecting... %d\r"</literal></expr></argument>, <argument><expr><operator>++</operator><name>tries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>redisConnect</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>hostport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>redisvCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>err</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>err</name></name> <operator>&amp;</operator> <operator>(</operator><name>REDIS_ERR_IO</name> <operator>|</operator> <name>REDIS_ERR_EOF</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\x1b[0K"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cursor to left edge + clear line. */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>context</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <return>return <expr><name>reply</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * User interface
 *--------------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parseOptions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>lastarg</name> <init>= <expr><name>i</name><operator>==</operator><name>argc</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostip</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-x"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>stdinarg</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-p"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostport</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-s"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-r"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><call><name>strtoll</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type> <name>seconds</name> <init>= <expr><call><name>atof</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><operator>(</operator><name>seconds</name><operator>*</operator><literal type="number">1000000</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-n"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>dbnum</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--no-auth-warning"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>no_auth_warning</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>auth</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-u"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>parseRedisUri</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--raw"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_RAW</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--no-raw"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_STANDARD</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--csv"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_CSV</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--latency"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--latency-dist"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_dist_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--mono"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>spectrum_palette</name> <operator>=</operator> <name>spectrum_palette_mono</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>spectrum_palette_size</name> <operator>=</operator> <name>spectrum_palette_mono_size</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--latency-history"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_history</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--lru-test"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>lru_test_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>lru_test_sample_size</name></name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--slave"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--replica"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--stat"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>stat_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--scan"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>scan_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--pattern"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pattern</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--intrinsic-latency"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>intrinsic_latency_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>intrinsic_latency_duration</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--rdb"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>getrdb_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>rdb_filename</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--pipe"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pipe_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--pipe-timeout"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pipe_timeout</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--bigkeys"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>bigkeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--memkeys"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>memkeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>memkeys_samples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* use redis default */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--memkeys-samples"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>memkeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>memkeys_samples</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--hotkeys"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hotkeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--eval"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--ldb"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_RAW</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--ldb-sync-mode"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb_sync</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_RAW</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-c"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_mode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>mb_delim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>mb_delim</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--verbose"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>verbose</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>CLUSTER_MANAGER_MODE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>createClusterManagerCommand</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-replicas"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>replicas</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-master-id"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>master_id</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-from"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>from</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-to"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-weight"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: you cannot use --cluster-weight "</literal>
                                <literal type="string">"more than once.\n"</literal>
                                <literal type="string">"You can set more weights by adding them "</literal>
                                <literal type="string">"as a space-separated list, ie:\n"</literal>
                                <literal type="string">"--cluster-weight n1=w n2=w\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>widx</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>weight</name> <init>= <expr><name>argv</name> <operator>+</operator> <name>widx</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>wargc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init>;</init> <condition><expr><name>widx</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>widx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>widx</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>argv</name><index>[<expr><name>widx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>widx</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>wargc</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>wargc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight_argc</name></name> <operator>=</operator> <name>wargc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>wargc</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-slots"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>slots</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-timeout"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-pipeline"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>pipeline</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-threshold"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lastarg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <call><name>atof</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-yes"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_YES</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-simulate"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_SIMULATE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-replace"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_REPLACE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-copy"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_COPY</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-slave"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_SLAVE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-use-empty-masters"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--cluster-search-multiple-owners"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator>
                <name>CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"-v"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>version</name> <init>= <expr><call><name>cliVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"redis-cli %s\n"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>CLUSTER_MANAGER_MODE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
                <decl_stmt><decl><type><name>int</name></type> <name>cmd_argc</name> <init>= <expr><name>j</name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>cmd_argc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>argv</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cmd_argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"Unrecognized option or bad number of args for: '%s'\n"</literal></expr></argument>,
                    <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* Likely the command name, stop here. */</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* --ldb requires --eval. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>eval</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Options --ldb and --ldb-sync-mode require --eval.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Try %s --help for more information.\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>no_auth_warning</name></name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>auth</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Warning: Using a password with '-a' or '-u' option on the command"</literal>
              <literal type="string">" line interface may not be safe.\n"</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parseEnv</name><parameter_list>()</parameter_list> <block>{<block_content>
    <comment type="block">/* Set auth from env, but do not overwrite CLI arguments if passed */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>auth</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>REDIS_CLI_AUTH_ENV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>auth</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>auth</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>auth</name></name> <operator>=</operator> <name>auth</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cluster_yes</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>REDIS_CLI_CLUSTER_YES_ENV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cluster_yes</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>cluster_yes</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_CMD_FLAG_YES</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>readArgFromStdin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>arg</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                          <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>

        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"Reading from standard input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>arg</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>version</name> <init>= <expr><call><name>cliVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"redis-cli %s\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n"</literal>
<literal type="string">"  -h &lt;hostname&gt;      Server hostname (default: 127.0.0.1).\n"</literal>
<literal type="string">"  -p &lt;port&gt;          Server port (default: 6379).\n"</literal>
<literal type="string">"  -s &lt;socket&gt;        Server socket (overrides hostname and port).\n"</literal>
<literal type="string">"  -a &lt;password&gt;      Password to use when connecting to the server.\n"</literal>
<literal type="string">"                     You can also use the "</literal> <name>REDIS_CLI_AUTH_ENV</name> <literal type="string">" environment\n"</literal>
<literal type="string">"                     variable to pass this password more safely\n"</literal>
<literal type="string">"                     (if both are used, this argument takes predecence).\n"</literal>
<literal type="string">"  -u &lt;uri&gt;           Server URI.\n"</literal>
<literal type="string">"  -r &lt;repeat&gt;        Execute specified command N times.\n"</literal>
<literal type="string">"  -i &lt;interval&gt;      When -r is used, waits &lt;interval&gt; seconds per command.\n"</literal>
<literal type="string">"                     It is possible to specify sub-second times like -i 0.1.\n"</literal>
<literal type="string">"  -n &lt;db&gt;            Database number.\n"</literal>
<literal type="string">"  -x                 Read last argument from STDIN.\n"</literal>
<literal type="string">"  -d &lt;delimiter&gt;     Multi-bulk delimiter in for raw formatting (default: \\n).\n"</literal>
<literal type="string">"  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\n"</literal>
<literal type="string">"  --raw              Use raw formatting for replies (default when STDOUT is\n"</literal>
<literal type="string">"                     not a tty).\n"</literal>
<literal type="string">"  --no-raw           Force formatted output even when STDOUT is not a tty.\n"</literal>
<literal type="string">"  --csv              Output in CSV format.\n"</literal>
<literal type="string">"  --stat             Print rolling stats about server: mem, clients, ...\n"</literal>
<literal type="string">"  --latency          Enter a special mode continuously sampling latency.\n"</literal>
<literal type="string">"                     If you use this mode in an interactive session it runs\n"</literal>
<literal type="string">"                     forever displaying real-time stats. Otherwise if --raw or\n"</literal>
<literal type="string">"                     --csv is specified, or if you redirect the output to a non\n"</literal>
<literal type="string">"                     TTY, it samples the latency for 1 second (you can use\n"</literal>
<literal type="string">"                     -i to change the interval), then produces a single output\n"</literal>
<literal type="string">"                     and exits.\n"</literal>
<literal type="string">"  --latency-history  Like --latency but tracking latency changes over time.\n"</literal>
<literal type="string">"                     Default time interval is 15 sec. Change it using -i.\n"</literal>
<literal type="string">"  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\n"</literal>
<literal type="string">"                     Default time interval is 1 sec. Change it using -i.\n"</literal>
<literal type="string">"  --lru-test &lt;keys&gt;  Simulate a cache workload with an 80-20 distribution.\n"</literal>
<literal type="string">"  --replica          Simulate a replica showing commands received from the master.\n"</literal>
<literal type="string">"  --rdb &lt;filename&gt;   Transfer an RDB dump from remote server to local file.\n"</literal>
<literal type="string">"  --pipe             Transfer raw Redis protocol from stdin to server.\n"</literal>
<literal type="string">"  --pipe-timeout &lt;n&gt; In --pipe mode, abort with error if after sending all data.\n"</literal>
<literal type="string">"                     no reply is received within &lt;n&gt; seconds.\n"</literal>
<literal type="string">"                     Default timeout: %d. Use 0 to wait forever.\n"</literal>
<literal type="string">"  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).\n"</literal>
<literal type="string">"  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.\n"</literal>
<literal type="string">"  --memkeys-samples &lt;n&gt; Sample Redis keys looking for keys consuming a lot of memory.\n"</literal>
<literal type="string">"                     And define number of key elements to sample\n"</literal>
<literal type="string">"  --hotkeys          Sample Redis keys looking for hot keys.\n"</literal>
<literal type="string">"                     only works when maxmemory-policy is *lfu.\n"</literal>
<literal type="string">"  --scan             List all keys using the SCAN command.\n"</literal>
<literal type="string">"  --pattern &lt;pat&gt;    Useful with --scan to specify a SCAN pattern.\n"</literal>
<literal type="string">"  --intrinsic-latency &lt;sec&gt; Run a test to measure intrinsic system latency.\n"</literal>
<literal type="string">"                     The test will run for the specified amount of seconds.\n"</literal>
<literal type="string">"  --eval &lt;file&gt;      Send an EVAL command using the Lua script at &lt;file&gt;.\n"</literal>
<literal type="string">"  --ldb              Used with --eval enable the Redis Lua debugger.\n"</literal>
<literal type="string">"  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\n"</literal>
<literal type="string">"                     this mode the server is blocked and script changes are\n"</literal>
<literal type="string">"                     not rolled back from the server memory.\n"</literal>
<literal type="string">"  --cluster &lt;command&gt; [args...] [opts...]\n"</literal>
<literal type="string">"                     Cluster Manager command and arguments (see below).\n"</literal>
<literal type="string">"  --verbose          Verbose mode.\n"</literal>
<literal type="string">"  --no-auth-warning  Don't show warning message when using password on command\n"</literal>
<literal type="string">"                     line interface.\n"</literal>
<literal type="string">"  --help             Output this help and exit.\n"</literal>
<literal type="string">"  --version          Output version and exit.\n"</literal>
<literal type="string">"\n"</literal></expr></argument>,
    <argument><expr><name>version</name></expr></argument>, <argument><expr><name>REDIS_CLI_DEFAULT_PIPE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Using another fprintf call to avoid -Woverlength-strings compile warning */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"Cluster Manager Commands:\n"</literal>
<literal type="string">"  Use --cluster help to list all available cluster manager commands.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"Examples:\n"</literal>
<literal type="string">"  cat /etc/passwd | redis-cli -x set mypasswd\n"</literal>
<literal type="string">"  redis-cli get mypasswd\n"</literal>
<literal type="string">"  redis-cli -r 100 lpush mylist x\n"</literal>
<literal type="string">"  redis-cli -r 100 -i 1 info | grep used_memory_human:\n"</literal>
<literal type="string">"  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n"</literal>
<literal type="string">"  redis-cli --scan --pattern '*:12345*'\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"When no command is given, redis-cli starts in interactive mode.\n"</literal>
<literal type="string">"Type \"help\" in interactive mode for information on available commands\n"</literal>
<literal type="string">"and settings.\n"</literal>
<literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>confirmWithYes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_CMD_FLAG_YES</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (type 'yes' to accept): "</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>nread</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Turn the plain C strings into Sds strings */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>convertToSds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sds</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>sds</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <return>return <expr><name>sds</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>issueCommandRepeat</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>repeat</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_reissue_command</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>cliSendCommand</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>repeat</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
            <name>cliConnect</name><argument_list>(<argument><expr><name>CC_FORCE</name></expr></argument>)</argument_list></decl>;</decl_stmt>

            <comment type="block">/* If we still cannot send the command print error.
             * We'll try to reconnect the next time. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cliSendCommand</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>repeat</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content> <function_decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
                <name>cliPrintContextError</name><parameter_list>()</parameter_list>;</function_decl>
                <return>return <expr><name>REDIS_ERR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
         </block_content>}</block></if></if_stmt>
         <comment type="block">/* Issue the command again if we got redirected in cluster mode */</comment>
         <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_mode</name></name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>cluster_reissue_command</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>cliConnect</name><argument_list>(<argument><expr><name>CC_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if> <else>else <block>{<block_content>
             <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>REDIS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>issueCommand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>issueCommandRepeat</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>repeat</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Split the user provided command into multiple SDS arguments.
 * This function normally uses sdssplitargs() from sds.c which is able
 * to understand "quoted strings", escapes and so forth. However when
 * we are in Lua debugging mode and the "eval" command is used, we want
 * the remaining Lua script (after "e " or "eval ") to be passed verbatim
 * as a single big argument. */</comment>
<function><type><specifier>static</specifier> <name>sds</name> <modifier>*</modifier></type><name>cliSplitArgs</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><literal type="string">"eval "</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>line</name> <operator>||</operator>
                            <call><name>strstr</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><literal type="string">"e "</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>line</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>sds_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>argc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                                            <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast int */</comment>
        <name>int</name></type> <name>elen</name> <init>= <expr><ternary><condition><expr><name><name>line</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">5</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="block">/* "e " or "eval "? */</comment>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>elen</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>line</name><operator>+</operator><name>elen</name></expr></argument>,<argument><expr><name>len</name><operator>-</operator><name>elen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>argv</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>sdssplitargs</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Set the CLI preferences. This function is invoked when an interactive
 * ":command" is called, or when reading ~/.redisclirc file, in order to
 * set user preferences. */</comment>
<function><type><name>void</name></type> <name>cliSetPreferences</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>interactive</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">":set"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"hints"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pref</name><operator>.</operator><name>hints</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"nohints"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pref</name><operator>.</operator><name>hints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%sunknown redis-cli preference '%s'\n"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><name>interactive</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">".redisclirc: "</literal></expr></else></ternary></expr></argument>,
                <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%sunknown redis-cli internal command '%s'\n"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>interactive</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">".redisclirc: "</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Load the ~/.redisclirc file if any. */</comment>
<function><type><name>void</name></type> <name>cliLoadPreferences</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>rcfile</name> <init>= <expr><call><name>getDotfilePath</name><argument_list>(<argument><expr><name>REDIS_CLI_RCFILE_ENV</name></expr></argument>,<argument><expr><name>REDIS_CLI_RCFILE_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rcfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>rcfile</name></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fp</name></expr>)</condition> <block>{<block_content>
        <while>while<condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>sdssplitargs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cliSetPreferences</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>rcfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>repl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>historyfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>history</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>

    <comment type="block">/* Initialize the help and, if possible, use the COMMAND command in order
     * to retrieve missing entries. */</comment>
    <expr_stmt><expr><call><name>cliInitHelp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cliIntegrateHelp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interactive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>linenoiseSetMultiLine</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>linenoiseSetCompletionCallback</name><argument_list>(<argument><expr><name>completionCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>linenoiseSetHintsCallback</name><argument_list>(<argument><expr><name>hintsCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>linenoiseSetFreeHintsCallback</name><argument_list>(<argument><expr><name>freeHintsCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Only use history and load the rc file when stdin is a tty. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>historyfile</name> <operator>=</operator> <call><name>getDotfilePath</name><argument_list>(<argument><expr><name>REDIS_CLI_HISTFILE_ENV</name></expr></argument>,<argument><expr><name>REDIS_CLI_HISTFILE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//keep in-memory history always regardless if history file can be determined</comment>
        <expr_stmt><expr><name>history</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>historyfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>linenoiseHistoryLoad</name><argument_list>(<argument><expr><name>historyfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>cliLoadPreferences</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>cliRefreshPrompt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>line</name> <operator>=</operator> <call><name>linenoise</name><argument_list>(<argument><expr><ternary><condition><expr><name>context</name></expr> ?</condition><then> <expr><name><name>config</name><operator>.</operator><name>prompt</name></name></expr> </then><else>: <expr><literal type="string">"not connected&gt; "</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>repeat</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>skipargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>cliSplitArgs</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* check if we have a repeat command option and
             * need to skip the first arg */</comment>
            <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>repeat</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name> <operator>||</operator> <name>repeat</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Invalid redis-cli repeat command option value.\n"</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>linenoiseFree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>skipargs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>repeat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Won't save auth command in history file */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>argv</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal><operator>+</operator><name>skipargs</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"auth"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>history</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>linenoiseHistoryAdd</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>historyfile</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>linenoiseHistorySave</name><argument_list>(<argument><expr><name>historyfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Invalid argument(s)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>linenoiseFree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"quit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"exit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>cliSetPreferences</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>linenoiseFree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"restart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_RAW</name></expr>;</expr_stmt>
                        <return>return;</return> <comment type="block">/* Return to evalMode to restart the session. */</comment>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Use 'restart' only in Lua debugging mode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"connect"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostip</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostport</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>cliRefreshPrompt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>cliConnect</name><argument_list>(<argument><expr><name>CC_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"clear"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>linenoiseClearScreen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start_time</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>elapsed</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>issueCommandRepeat</name><argument_list>(<argument><expr><name>argc</name><operator>-</operator><name>skipargs</name></expr></argument>, <argument><expr><name>argv</name><operator>+</operator><name>skipargs</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* If our debugging session ended, show the EVAL final
                     * reply. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval_ldb_end</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>cliReadReply</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n(Lua debugging session ended%s)\n\n"</literal></expr></argument>,
                            <argument><expr><ternary><condition><expr><name><name>config</name><operator>.</operator><name>eval_ldb_sync</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>:
                            <expr><literal type="string">" -- dataset changes rolled back"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>start_time</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&gt;=</operator> <literal type="number">500</literal> <operator>&amp;&amp;</operator>
                        <name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_STANDARD</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(%.2fs)\n"</literal></expr></argument>,<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>elapsed</name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Free the argument vector */</comment>
            <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* linenoise() returns malloc-ed lines like readline() */</comment>
        <expr_stmt><expr><call><name>linenoiseFree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>noninteractive</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>stdinarg</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>(</operator><name>argc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name> <operator>=</operator> <call><name>readArgFromStdin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>issueCommand</name><argument_list>(<argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>issueCommand</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Eval mode
 *--------------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>evalMode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>got_comma</name></decl>, <decl><type ref="prev"/><name>keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>REDIS_OK</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(
            <argument><expr><literal type="string">"Lua debugging session started, please use:\n"</literal>
            <literal type="string">"quit    -- End the session.\n"</literal>
            <literal type="string">"restart -- Restart the script in debug mode again.\n"</literal>
            <literal type="string">"help    -- Show Lua script debugging commands.\n\n"</literal></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>got_comma</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>keys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Load the script from the file, as an sds string. */</comment>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>eval</name></name></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><literal type="string">"Can't open file '%s': %s\n"</literal></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>eval</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>nread</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>script</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we are debugging a script, enable the Lua debugger. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name><name>config</name><operator>.</operator><name>eval_ldb_sync</name></name></expr> ?</condition><then>
                    <expr><literal type="string">"SCRIPT DEBUG sync"</literal></expr></then><else>: <expr><literal type="string">"SCRIPT DEBUG yes"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Create our argument vector */</comment>
        <expr_stmt><expr><name>argv2</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>argc</name><operator>+</operator><literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"EVAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>script</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_comma</name> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>got_comma</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>argv2</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">3</literal><operator>-</operator><name>got_comma</name></expr>]</index></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_comma</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>keys</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>argv2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%d"</literal></expr></argument>,<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Call it */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>eval_ldb</name> <init>= <expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Save it, may be reverteed. */</comment>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>issueCommand</name><argument_list>(<argument><expr><name>argc</name><operator>+</operator><literal type="number">3</literal><operator>-</operator><name>got_comma</name></expr></argument>, <argument><expr><name>argv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>eval_ldb</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>eval_ldb</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If the debugging session ended immediately, there was an
                 * error compiling the script. Show it and they don't enter
                 * the REPL at all. */</comment>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Eval debugging session can't start:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cliReadReply</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break> <comment type="block">/* Return to the caller. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>prompt</name></name></expr></argument>,<argument><expr><literal type="string">"lua debugger&gt; "</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>prompt</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>repl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Restart the session if repl() returned. */</comment>
                <expr_stmt><expr><call><name>cliConnect</name><argument_list>(<argument><expr><name>CC_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <break>break;</break> <comment type="block">/* Return to the caller. */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Cluster Manager
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* The Cluster Manager global structure */</comment>
<struct><specifier>static</specifier> struct <name>clusterManager</name> <block>{
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>    <comment type="block">/* List of nodes in the configuration. */</comment>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>errors</name></decl>;</decl_stmt>
}</block> <decl><name>cluster_manager</name></decl>;</struct>

<comment type="block">/* Used by clusterManagerFixSlotsCoverage */</comment>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>clusterManagerUncoveredSlots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>clusterManagerNode</name> <block>{
    <decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>current_epoch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>ping_sent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>ping_recv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>flags_str</name></decl>;</decl_stmt> <comment type="block">/* Flags string representations */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>replicate</name></decl>;</decl_stmt>  <comment type="block">/* Master ID if node is a slave */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dirty</name></decl>;</decl_stmt>      <comment type="block">/* Node has changes that can be flushed */</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>slots</name><index>[<expr><name>CLUSTER_MANAGER_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slots_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>replicas_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>friends</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>migrating</name></decl>;</decl_stmt> <comment type="block">/* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */</comment>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>importing</name></decl>;</decl_stmt> <comment type="block">/* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>migrating_count</name></decl>;</decl_stmt> <comment type="block">/* Length of the migrating array (migrating slots*2) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>importing_count</name></decl>;</decl_stmt> <comment type="block">/* Length of the importing array (importing slots*2) */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>weight</name></decl>;</decl_stmt>   <comment type="block">/* Weight used by rebalance */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>balance</name></decl>;</decl_stmt>    <comment type="block">/* Used by rebalance */</comment>
}</block></struct></type> <name>clusterManagerNode</name>;</typedef>

<comment type="block">/* Data structure used to represent a sequence of cluster nodes. */</comment>
<typedef>typedef <type><struct>struct <name>clusterManagerNodeArray</name> <block>{
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt> <comment type="block">/* Actual nodes array */</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>alloc</name></decl>;</decl_stmt> <comment type="block">/* Pointer to the allocated memory */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>                    <comment type="block">/* Actual length of the array */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>                  <comment type="block">/* Non-NULL nodes count */</comment>
}</block></struct></type> <name>clusterManagerNodeArray</name>;</typedef>

<comment type="block">/* Used for the reshard table. */</comment>
<typedef>typedef <type><struct>struct <name>clusterManagerReshardTableItem</name> <block>{
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>
}</block></struct></type> <name>clusterManagerReshardTableItem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>dictType</name></type> <name>clusterManagerDictType</name> <init>= <expr><block>{
    <expr><name>dictSdsHash</name></expr>,               <comment type="block">/* hash function */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key dup */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* val dup */</comment>
    <expr><name>dictSdsKeyCompare</name></expr>,         <comment type="block">/* key compare */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key destructor */</comment>
    <expr><name>dictSdsDestructor</name></expr>          <comment type="block">/* val destructor */</comment>
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <function_decl><type><name>int</name></type> <name>clusterManagerCommandProc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>clusterManagerOnReplyError</name>)<parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bulk_idx</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Cluster Manager helper functions */</comment>

<function_decl><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNewNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNodeByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNodeByAbbreviatedName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeResetSlots</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeIsCluster</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerPrintNotClusterNodeError</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                                   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeLoadInfo</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>,
                                      <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerLoadInfoFromNode</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeIsEmpty</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerGetAntiAffinityScore</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>ipnodes</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>ip_count</name></decl></parameter>, <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>offending</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offending_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerOptimizeAntiAffinity</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>ipnodes</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>ip_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>sds</name></type> <name>clusterManagerNodeInfo</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerShowNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerShowClusterInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerFlushNodeConfig</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerWaitForClusterJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCheckCluster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>quiet</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerLog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerIsConfigConsistent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerOnError</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayInit</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                        <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayReset</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayShift</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                         <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodeptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayAdd</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                       <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Cluster Manager commands. */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandAddNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandDeleteNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandCheck</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandFix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandReshard</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandRebalance</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandSetTimeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandImport</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandCall</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandHelp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>clusterManagerCommandDef</name> <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerCommandProc</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>arity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
}</block></struct></type> <name>clusterManagerCommandDef</name>;</typedef>

<decl_stmt><decl><type><name>clusterManagerCommandDef</name></type> <name><name>clusterManagerCommands</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"create"</literal></expr>, <expr><name>clusterManagerCommandCreate</name></expr>, <expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><literal type="string">"host1:port1 ... hostN:portN"</literal></expr>,
     <expr><literal type="string">"replicas &lt;arg&gt;"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"check"</literal></expr>, <expr><name>clusterManagerCommandCheck</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">"host:port"</literal></expr>,
     <expr><literal type="string">"search-multiple-owners"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>clusterManagerCommandInfo</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">"host:port"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"fix"</literal></expr>, <expr><name>clusterManagerCommandFix</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">"host:port"</literal></expr>,
     <expr><literal type="string">"search-multiple-owners"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"reshard"</literal></expr>, <expr><name>clusterManagerCommandReshard</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">"host:port"</literal></expr>,
     <expr><literal type="string">"from &lt;arg&gt;,to &lt;arg&gt;,slots &lt;arg&gt;,yes,timeout &lt;arg&gt;,pipeline &lt;arg&gt;,"</literal>
     <literal type="string">"replace"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"rebalance"</literal></expr>, <expr><name>clusterManagerCommandRebalance</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">"host:port"</literal></expr>,
     <expr><literal type="string">"weight &lt;node1=w1...nodeN=wN&gt;,use-empty-masters,"</literal>
     <literal type="string">"timeout &lt;arg&gt;,simulate,pipeline &lt;arg&gt;,threshold &lt;arg&gt;,replace"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"add-node"</literal></expr>, <expr><name>clusterManagerCommandAddNode</name></expr>, <expr><literal type="number">2</literal></expr>,
     <expr><literal type="string">"new_host:new_port existing_host:existing_port"</literal></expr>, <expr><literal type="string">"slave,master-id &lt;arg&gt;"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"del-node"</literal></expr>, <expr><name>clusterManagerCommandDeleteNode</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="string">"host:port node_id"</literal></expr>,<expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"call"</literal></expr>, <expr><name>clusterManagerCommandCall</name></expr>, <expr><operator>-</operator><literal type="number">2</literal></expr>,
        <expr><literal type="string">"host:port command arg arg .. arg"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"set-timeout"</literal></expr>, <expr><name>clusterManagerCommandSetTimeout</name></expr>, <expr><literal type="number">2</literal></expr>,
     <expr><literal type="string">"host:port milliseconds"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"import"</literal></expr>, <expr><name>clusterManagerCommandImport</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"host:port"</literal></expr>,
     <expr><literal type="string">"from &lt;arg&gt;,copy,replace"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>clusterManagerCommandHelp</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>createClusterManagerCommand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerCommand</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>cluster_manager_command</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>cmdname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <ternary><condition><expr><name>argc</name></expr> ?</condition><then> <expr><name>argv</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isColorTerm</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_CMD_FLAG_COLOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>clusterManagerCommandProc</name> <modifier>*</modifier></type><name>validateClusterManagerCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>commands_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerCommands</name></expr></argument>)</argument_list></sizeof> <operator>/</operator>
                            <sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerCommandDef</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerCommandProc</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdname</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>commands_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerCommandDef</name></type> <name>cmddef</name> <init>= <expr><name><name>clusterManagerCommands</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cmddef</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cmddef</name><operator>.</operator><name>arity</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argc</name> <operator>!=</operator> <name><name>cmddef</name><operator>.</operator><name>arity</name></name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>cmddef</name><operator>.</operator><name>arity</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&lt;</operator> <operator>(</operator><name><name>cmddef</name><operator>.</operator><name>arity</name></name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[ERR] Wrong number of arguments for "</literal>
                                <literal type="string">"specified --cluster sub command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>cmddef</name><operator>.</operator><name>proc</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown --cluster subcommand\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>proc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get host ip and port from command arguments. If only one argument has
 * been provided it must be in the form of 'ip:port', elsewhere
 * the first argument must be the ip and the second one the port.
 * If host and port can be detected, it returns 1 and it stores host and
 * port into variables referenced by'ip_ptr' and 'port_ptr' pointers,
 * elsewhere it returns 0. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getClusterHostFromCmdArgs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
                                     <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ip_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>port_ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ip</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>++</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ip</name> <operator>||</operator> <operator>!</operator><name>port</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ip_ptr</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>port_ptr</name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeClusterManagerNodeFlags</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>flag</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeClusterManagerNode</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_FRIEND</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>migrating_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>importing</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>importing_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags_str</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeClusterManagerNodeFlags</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>flags_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeClusterManager</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>err</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>clusterManagerUncoveredSlots</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>clusterManagerUncoveredSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNewNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>current_epoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ping_recv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>migrating_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>importing_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>replicas_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">1.0f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>balance</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterManagerNodeResetSlots</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether reply is NULL or its type is REDIS_REPLY_ERROR. In the
 * latest case, if the 'err' arg is not NULL, it gets allocated with a copy
 * of reply error (it's up to the caller function to free it), elsewhere
 * the error is directly printed. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCheckRedisReply</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
                                         <parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>is_err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name> <operator>||</operator> <operator>(</operator><name>is_err</name> <operator>=</operator> <operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>is_err</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Execute MULTI command on a cluster node. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerStartTransaction</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"MULTI"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Execute EXEC command on a cluster node. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerExecTransaction</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                         <parameter><decl><type><name>clusterManagerOnReplyError</name></type> <name>onerror</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"EXEC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_ARRAY</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>onerror</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>onerror</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeConnect</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>redisConnect</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Could not connect to Redis at "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s:%d: %s\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Set aggressive KEEP_ALIVE socket option in the Redis context socket
     * in order to prevent timeouts caused by the execution of long
     * commands. At the same time this improves the detection of real
     * errors. */</comment>
    <expr_stmt><expr><call><name>anetKeepAlive</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>REDIS_CLI_KEEPALIVE_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>auth</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>redisCommand</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,<argument><expr><literal type="string">"AUTH %s"</literal></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>auth</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerRemoveNodeFromList</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>nodelist</name></decl></parameter>,
                                             <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Return the node with the specified name (ID) or NULL. */</comment>
<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNodeByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>lcname</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>lcname</name> <operator>=</operator> <call><name>sdscpy</name><argument_list>(<argument><expr><name>lcname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdstolower</name><argument_list>(<argument><expr><name>lcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sdscmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lcname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>lcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like clusterManagerNodeByName but the specified name can be just the first
 * part of the node ID as long as the prefix in unique across the
 * cluster.
 */</comment>
<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNodeByAbbreviatedName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>lcname</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>lcname</name> <operator>=</operator> <call><name>sdscpy</name><argument_list>(<argument><expr><name>lcname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdstolower</name><argument_list>(<argument><expr><name>lcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator>
            <call><name>strstr</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>lcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeResetSlots</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Call "INFO" redis command on the specified node and return the reply. */</comment>
<function><type><specifier>static</specifier> <name>redisReply</name> <modifier>*</modifier></type><name>clusterManagerGetNodeRedisInfo</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                                  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return  <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeIsCluster</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>clusterManagerGetNodeRedisInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_cluster</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"cluster_enabled"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>is_cluster</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Checks whether the node is empty. Node is considered not-empty if it has
 * some key or if it already knows other nodes */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeIsEmpty</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>clusterManagerGetNodeRedisInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_empty</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"db0:"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_empty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>result</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_empty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>result</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>known_nodes</name> <init>= <expr><call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"cluster_known_nodes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>is_empty</name> <operator>=</operator> <operator>(</operator><name>known_nodes</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<label><name>result</name>:</label>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>is_empty</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the anti-affinity score, which is a measure of the amount of
 * violations of anti-affinity in the current cluster layout, that is, how
 * badly the masters and slaves are distributed in the different IP
 * addresses so that slaves of the same master are not in the master
 * host and are also in different hosts.
 *
 * The score is calculated as follows:
 *
 * SAME_AS_MASTER = 10000 * each slave in the same IP of its master.
 * SAME_AS_SLAVE  = 1 * each slave having the same IP as another slave
                      of the same master.
 * FINAL_SCORE = SAME_AS_MASTER + SAME_AS_SLAVE
 *
 * So a greater score means a worse anti-affinity level, while zero
 * means perfect anti-affinity.
 *
 * The anti affinity optimizator will try to get a score as low as
 * possible. Since we do not want to sacrifice the fact that slaves should
 * not be in the same host as the master, we assign 10000 times the score
 * to this violation, so that we'll optimize for the second factor only
 * if it does not impact the first one.
 *
 * The ipnodes argument is an array of clusterManagerNodeArray, one for
 * each IP, while ip_count is the total number of IPs in the configuration.
 *
 * The function returns the above score, and the list of
 * offending slaves can be stored into the 'offending' argument,
 * so that the optimizer can try changing the configuration of the
 * slaves violating the anti-affinity goals. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerGetAntiAffinityScore</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>ipnodes</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>ip_count</name></decl></parameter>, <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>offending</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offending_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>node_len</name> <init>= <expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>offending_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>offending</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>offending</name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><name>node_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offending_p</name> <operator>=</operator> <operator>*</operator><name>offending</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* For each set of nodes in the same host, split by
     * related nodes (masters and slaves which are involved in
     * replication of each other) */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ip_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>node_array</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ipnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>related</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clusterManagerDictType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>node_array</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>node_array</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ip</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>types</name></decl>;</decl_stmt>
            <comment type="block">/* We always use the Master ID as key. */</comment>
            <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>related</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/* Master type 'm' is always set as the first character of the
             * types string. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"m%s"</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>dictReplace</name><argument_list>(<argument><expr><name>related</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* Now it's trivial to check, for each related group having the
         * same host, what is their local score. */</comment>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>related</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>types</name> <init>= <expr><operator>(</operator><name>sds</name><operator>)</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>name</name> <init>= <expr><operator>(</operator><name>sds</name><operator>)</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>typeslen</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>typeslen</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>+=</operator> <operator>(</operator><literal type="number">10000</literal> <operator>*</operator> <operator>(</operator><name>typeslen</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal> <operator>*</operator> <name>typeslen</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>offending</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <comment type="block">/* Populate the list of offending nodes. */</comment>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>offending_p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>offending_len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>offending_len</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></while>
        <comment type="line">//if (offending_len != NULL) *offending_len = offending_p - *offending;</comment>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>related</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerOptimizeAntiAffinity</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>ipnodes</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>ip_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>offenders</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><call><name>clusterManagerGetAntiAffinityScore</name><argument_list>(<argument><expr><name>ipnodes</name></expr></argument>, <argument><expr><name>ip_count</name></expr></argument>,
                                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>score</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Trying to optimize slaves allocation "</literal>
                          <literal type="string">"for anti-affinity\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>node_len</name> <init>= <expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxiter</name> <init>= <expr><literal type="number">500</literal> <operator>*</operator> <name>node_len</name></expr></init></decl>;</decl_stmt> <comment type="line">// Effort is proportional to cluster size...</comment>
    <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>maxiter</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>offending_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>offenders</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>offenders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offenders</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>clusterManagerGetAntiAffinityScore</name><argument_list>(<argument><expr><name>ipnodes</name></expr></argument>,
                                                   <argument><expr><name>ip_count</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>offenders</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>offending_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>score</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="line">// Optimal anti affinity reached</comment>
        <comment type="block">/* We'll try to randomly swap a slave's assigned master causing
         * an affinity problem with another random slave, to see if we
         * can improve the affinity. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>rand_idx</name> <init>= <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>offending_len</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><name><name>offenders</name><index>[<expr><name>rand_idx</name></expr>]</index></name></expr></init></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>second</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>other_replicas</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><operator>(</operator><name>node_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
                                                      <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>other_replicas</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>other_replicas_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name>first</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>replicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>other_replicas</name><index>[<expr><name>other_replicas_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>other_replicas_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>other_replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rand_idx</name> <operator>=</operator> <call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>other_replicas_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>second</name> <operator>=</operator> <name><name>other_replicas</name><index>[<expr><name>rand_idx</name></expr>]</index></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>first_master</name> <init>= <expr><name><name>first</name><operator>-&gt;</operator><name>replicate</name></name></expr></init></decl>,
             <decl><type ref="prev"><modifier>*</modifier></type><name>second_master</name> <init>= <expr><name><name>second</name><operator>-&gt;</operator><name>replicate</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>first</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <name>second_master</name></expr><operator>,</operator> <expr><name><name>first</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>second</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <name>first_master</name></expr><operator>,</operator> <expr><name><name>second</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>new_score</name> <init>= <expr><call><name>clusterManagerGetAntiAffinityScore</name><argument_list>(<argument><expr><name>ipnodes</name></expr></argument>,
                                                           <argument><expr><name>ip_count</name></expr></argument>,
                                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* If the change actually makes thing worse, revert. Otherwise
         * leave as it is because the best solution may need a few
         * combined swaps. */</comment>
        <if_stmt><if>if <condition>(<expr><name>new_score</name> <operator>&gt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>first</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <name>first_master</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>second</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <name>second_master</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>other_replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxiter</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>clusterManagerGetAntiAffinityScore</name><argument_list>(<argument><expr><name>ipnodes</name></expr></argument>, <argument><expr><name>ip_count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>perfect</name> <init>= <expr><operator>(</operator><name>score</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>log_level</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>perfect</name></expr> ?</condition><then> <expr><name>CLUSTER_MANAGER_LOG_LVL_SUCCESS</name></expr> </then><else>:
                               <expr><name>CLUSTER_MANAGER_LOG_LVL_WARN</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>perfect</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"[OK] Perfect anti-affinity obtained!"</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>score</name> <operator>&gt;=</operator> <literal type="number">10000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>(</operator><literal type="string">"[WARNING] Some slaves are in the same host as their master"</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>msg</name><operator>=</operator><operator>(</operator><literal type="string">"[WARNING] Some slaves of the same master are in the same host"</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLog</name><argument_list>(<argument><expr><name>log_level</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>offenders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return a representable string of the node's flags */</comment>
<function><type><specifier>static</specifier> <name>sds</name></type> <name>clusterManagerNodeFlagString</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>flags</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>flags_str</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>flags</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>empty</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>flags_str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>flag</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><literal type="string">"myself"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="string">"%S"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>empty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a representable string of the node's slots */</comment>
<function><type><specifier>static</specifier> <name>sds</name></type> <name>clusterManagerNodeSlotsString</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>slots</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>first_range_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>last_slot_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>has_slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>has_slot</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>first_range_idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>first_range_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="string">"[%u"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>last_slot_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>last_slot_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>first_range_idx</name> <operator>==</operator> <name>last_slot_idx</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="string">"-%u]"</literal></expr></argument>, <argument><expr><name>last_slot_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>last_slot_idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>first_range_idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>last_slot_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>first_range_idx</name> <operator>==</operator> <name>last_slot_idx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="string">"-%u]"</literal></expr></argument>, <argument><expr><name>last_slot_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>slots</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------------
 * Key space handling
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* We have 16384 hash slots. The hash slot of a given key is obtained
 * as the least significant 14 bits of the crc16 of the key.
 *
 * However if the key contains the {...} pattern, only the part between
 * { and } is hashed. This may be useful in the future to force certain
 * keys to be in the same node (assuming no resharding is in progress). */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>clusterManagerKeyHashSlot</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt> <comment type="block">/* start-end indexes of { and } */</comment>

    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>keylen</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* No '{' ? Hash the whole key. This is the base case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>keylen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>crc16</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* '{' found? Check if we have the corresponding '}'. */</comment>
    <for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>s</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>e</name> <operator>&lt;</operator> <name>keylen</name></expr>;</condition> <incr><expr><name>e</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>e</name></expr>]</index></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* No '}' or nothing between {} ? Hash the whole key. */</comment>
    <if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>keylen</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>s</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>crc16</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */</comment>
    <return>return <expr><call><name>crc16</name><argument_list>(<argument><expr><name>key</name><operator>+</operator><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>s</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a string representation of the cluster node. */</comment>
<function><type><specifier>static</specifier> <name>sds</name></type> <name>clusterManagerNodeInfo</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>info</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>spaces</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>spaces</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>indent</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>spaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_master</name> <init>= <expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>role</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>is_master</name></expr> ?</condition><then> <expr><literal type="string">"M"</literal></expr> </then><else>: <expr><literal type="string">"S"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>slots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>dirty</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>replicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">"S: %S %s:%u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>clusterManagerNodeSlotsString</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>flags</name> <init>= <expr><call><name>clusterManagerNodeFlagString</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">"%s: %S %s:%u\n"</literal>
                               <literal type="string">"%s   slots:%S (%u slots) "</literal>
                               <literal type="string">"%S"</literal></expr></argument>,
                               <argument><expr><name>role</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>spaces</name></expr></argument>,
                               <argument><expr><name>slots</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">"\n%s   replicates %S"</literal></expr></argument>, <argument><expr><name>spaces</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>replicas_count</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">"\n%s   %U additional replica(s)"</literal></expr></argument>,
                         <argument><expr><name>spaces</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>replicas_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerShowNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>info</name> <init>= <expr><call><name>clusterManagerNodeInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerShowClusterInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>masters</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>replicas</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dbsize</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>listIter</name></type> <name>ri</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>rn</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>rn</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>rn</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>node</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>replicas</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></while>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"DBSIZE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>dbsize</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>integer</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>dbsize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>err</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
            <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d (%s...) -&gt; %d keys | %d slots | %d slaves.\n"</literal></expr></argument>,
                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>dbsize</name></expr></argument>,
                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>masters</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>keys</name> <operator>+=</operator> <name>dbsize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>clusterManagerLogOk</name><argument_list>(<argument><expr><literal type="string">"[OK] %d keys in %d masters.\n"</literal></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>masters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>keys_per_slot</name> <init>= <expr><name>keys</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%.2f keys per slot on average.\n"</literal></expr></argument>, <argument><expr><name>keys_per_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Flush dirty slots configuration of the node by calling CLUSTER ADDSLOTS */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerAddSlots</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>_reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* First two args are used for the command itself. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>argv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>argvlen</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>argvlen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"CLUSTER"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"ADDSLOTS"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argvlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argvlen</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argv_idx</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>argv_idx</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argv_idx</name></expr>]</index></name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>argvlen</name><index>[<expr><name>argv_idx</name></expr>]</index></name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argv_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>argv_idx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>argv_idx</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>redisAppendCommandArgv</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>,<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_reply</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>reply</name> <operator>=</operator> <operator>(</operator><name>redisReply</name><operator>*</operator><operator>)</operator> <name>_reply</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set slot status to "importing" or "migrating" */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerSetSlot</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node1</name></decl></parameter>,
                                 <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node2</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node1</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER "</literal>
                                                <literal type="string">"SETSLOT %d %s %s"</literal></expr></argument>,
                                                <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>status</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>node2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node1</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerClearSlotStatus</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
        <argument><expr><literal type="string">"CLUSTER SETSLOT %d %s"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"STABLE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerDelSlot</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>ignore_unassigned_err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
        <argument><expr><literal type="string">"CLUSTER DELSLOTS %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>reply</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name> <operator>&amp;&amp;</operator>
        <name>ignore_unassigned_err</name> <operator>&amp;&amp;</operator>
        <call><name>strstr</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"already unassigned"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerAddSlot</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
        <argument><expr><literal type="string">"CLUSTER ADDSLOTS %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>signed</name> <name>int</name></type> <name>clusterManagerCountKeysInSlot</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                                <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
        <argument><expr><literal type="string">"CLUSTER COUNTKEYSINSLOT %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>integer</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerBumpEpoch</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER BUMPEPOCH"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerIgnoreUnassignedErr</name><parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bulk_idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>bulk_idx</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>reply</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"already unassigned"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerSetSlotOwner</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>do_clear</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerStartTransaction</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Ensure the slot is not already assigned. */</comment>
    <expr_stmt><expr><call><name>clusterManagerDelSlot</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Add the slot and bump epoch. */</comment>
    <expr_stmt><expr><call><name>clusterManagerAddSlot</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>do_clear</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerBumpEpoch</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerExecTransaction</name><argument_list>(<argument><expr><name>owner</name></expr></argument>,
        <argument><expr><name>clusterManagerIgnoreUnassignedErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Migrate keys taken from reply-&gt;elements. It returns the reply from the
 * MIGRATE command, or NULL if something goes wrong. If the argument 'dots'
 * is not NULL, a dot will be printed for every migrated key. */</comment>
<function><type><specifier>static</specifier> <name>redisReply</name> <modifier>*</modifier></type><name>clusterManagerMigrateKeysInReply</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>source</name></decl></parameter>,
                                                    <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                                                    <parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>,
                                                    <parameter><decl><type><name>int</name></type> <name>replace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>,
                                                    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>migrate_reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>argv_len</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>replace</name></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">7</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>auth</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>argc</name> <init>= <expr><name>c</name> <operator>+</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Keys Offset</comment>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv_len</name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>portstr</name><index>[<expr><literal type="number">255</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>timeoutstr</name><index>[<expr><literal type="number">255</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>timeoutstr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"MIGRATE"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>ip</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>portstr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"0"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>timeoutstr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>timeoutstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="string">"REPLACE"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv_len</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>auth</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="string">"AUTH"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv_len</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <name><name>config</name><operator>.</operator><name>auth</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv_len</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>auth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="string">"KEYS"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv_len</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><name>i</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv_len</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dots</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dots</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>dots</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dots</name><index>[<expr><name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>_reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>redisAppendCommandArgv</name><argument_list>(<argument><expr><name><name>source</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,
                           <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>,<argument><expr><name>argv_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><operator>(</operator><call><name>redisGetReply</name><argument_list>(<argument><expr><name><name>source</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_reply</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_OK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name> <operator>+</operator> <name>offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>migrate_reply</name> <operator>=</operator> <operator>(</operator><name>redisReply</name> <operator>*</operator><operator>)</operator> <name>_reply</name></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>migrate_reply</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Migrate all keys in the given slot from source to target.*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerMigrateKeysInSlot</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>source</name></decl></parameter>,
                                           <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                                           <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>,
                                           <parameter><decl><type><name>int</name></type> <name>pipeline</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>,
                                           <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>replace_existing_keys</name> <init>= <expr><operator>(</operator><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator>
            <operator>(</operator><name>CLUSTER_MANAGER_CMD_FLAG_FIX</name> <operator>|</operator> <name>CLUSTER_MANAGER_CMD_FLAG_REPLACE</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>migrate_reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER "</literal>
                                        <literal type="string">"GETKEYSINSLOT %d %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                        <argument><expr><name>pipeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <operator>(</operator><name>reply</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><operator>*</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>next</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>elements</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dots</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name>count</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Calling MIGRATE command. */</comment>
        <expr_stmt><expr><name>migrate_reply</name> <operator>=</operator> <call><name>clusterManagerMigrateKeysInReply</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                                         <argument><expr><name>reply</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>,
                                                         <argument><expr><name>dots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>migrate_reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>migrate_reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>is_busy</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>migrate_reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"BUSYKEY"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>not_served</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>migrate_reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"slot not served"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>replace_existing_keys</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>is_busy</name> <operator>||</operator> <name>not_served</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If the key already exists, try to migrate keys
                 * adding REPLACE option.
                 * If the key's slot is not served, try to assign slot
                 * to the target node. */</comment>
                <if_stmt><if>if <condition>(<expr><name>not_served</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"node"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** Target key exists. "</literal>
                                      <literal type="string">"Replacing it for FIX.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>migrate_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>migrate_reply</name> <operator>=</operator> <call><name>clusterManagerMigrateKeysInReply</name><argument_list>(<argument><expr><name>source</name></expr></argument>,
                                                                 <argument><expr><name>target</name></expr></argument>,
                                                                 <argument><expr><name>reply</name></expr></argument>,
                                                                 <argument><expr><name>is_busy</name></expr></argument>,
                                                                 <argument><expr><name>timeout</name></expr></argument>,
                                                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <operator>(</operator><name>migrate_reply</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                           <name><name>migrate_reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_ERROR</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>migrate_reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>migrate_reply</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>migrate_reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>source</name></expr></argument>,
                                                      <argument><expr><name><name>migrate_reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <goto>goto <name>next</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>dots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<label><name>next</name>:</label>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>migrate_reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>migrate_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>dots</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>dots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Move slots between source and target nodes using MIGRATE.
 *
 * Options:
 * CLUSTER_MANAGER_OPT_VERBOSE -- Print a dot for every moved key.
 * CLUSTER_MANAGER_OPT_COLD    -- Move keys without opening slots /
 *                                reconfiguring the nodes.
 * CLUSTER_MANAGER_OPT_UPDATE  -- Update node-&gt;slots for source/target nodes.
 * CLUSTER_MANAGER_OPT_QUIET   -- Don't print info messages.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerMoveSlot</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>source</name></decl></parameter>,
                                  <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                                  <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>,  <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_OPT_QUIET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Moving slot %d from %s:%d to %s:%d: "</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
               <argument><expr><name><name>source</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pipeline</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>pipeline</name></name></expr></init></decl>,
        <decl><type ref="prev"/><name>timeout</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>timeout</name></name></expr></init></decl>,
        <decl><type ref="prev"/><name>print_dots</name> <init>= <expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_OPT_VERBOSE</name><operator>)</operator></expr></init></decl>,
        <decl><type ref="prev"/><name>option_cold</name> <init>= <expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_OPT_COLD</name><operator>)</operator></expr></init></decl>,
        <decl><type ref="prev"/><name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>option_cold</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                        <argument><expr><literal type="string">"importing"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                        <argument><expr><literal type="string">"migrating"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerMigrateKeysInSlot</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>,
                                              <argument><expr><name>pipeline</name></expr></argument>, <argument><expr><name>print_dots</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_OPT_QUIET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Set the new node as the owner of the slot in all the known nodes. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>option_cold</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER "</literal>
                                                    <literal type="string">"SETSLOT %d %s %s"</literal></expr></argument>,
                                                    <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"node"</literal></expr></argument>,
                                                    <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <operator>(</operator><name>r</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>*</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Update the node logical config */</comment>
    <if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_OPT_UPDATE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>source</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Flush the dirty node configuration by calling replicate for slaves or
 * adding the slots defined in the masters. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerFlushNodeConfig</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER REPLICATE %s"</literal></expr></argument>,
                                        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>is_err</name> <operator>=</operator> <operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>is_err</name> <operator>&amp;&amp;</operator> <name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* If the cluster did not already joined it is possible that
             * the slave does not know the master node yet. So on errors
             * we return ASAP leaving the dirty flag set, to flush the
             * config later. */</comment>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>added</name> <init>= <expr><call><name>clusterManagerAddSlots</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>added</name> <operator>||</operator> <operator>*</operator><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wait until the cluster configuration is consistent. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerWaitForClusterJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Waiting for the cluster to join\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>!</operator><call><name>clusterManagerIsConfigConsistent</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Load node's cluster configuration by calling "CLUSTER NODES" command.
 * Node's configuration (name, replicate, slots, ...) is then updated.
 * If CLUSTER_MANAGER_OPT_GETFRIENDS flag is set into 'opts' argument,
 * and node already knows other nodes, the node's friends list is populated
 * with the other nodes info. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerNodeLoadInfo</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>,
                                      <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER NODES"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>getfriends</name> <init>= <expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_OPT_GETFRIENDS</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lines</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lines</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flags</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>master_id</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"><modifier>*</modifier></type><name>ping_sent</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ping_recv</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>config_epoch</name> <init>= <expr><name>NULL</name></expr></init></decl>,
             <decl><type ref="prev"><modifier>*</modifier></type><name>link_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>link_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>i</name><operator>++</operator></expr>)</condition><block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>name</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>addr</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>master_id</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>ping_recv</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>config_epoch</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>link_status</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <break>break;</break>
            </block_content>}</block></switch>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="line">// Slots</comment>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>flags</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>myself</name> <init>= <expr><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="string">"myself"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>myself</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_FLAG_MYSELF</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>currentNode</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterManagerNodeResetSlots</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>remaining</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slotsdef</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>slotsdef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>slotsdef</name><operator>++</operator></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>, <argument><expr><literal type="string">"-&gt;-"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <comment type="line">// Migrating</comment>
                            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>closing_bracket</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><name>closing_bracket</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>closing_bracket</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>sds</name></type> <name>dst</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>migrating_count</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name></name></expr></argument>,
                                <argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>migrating_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>migrating_count</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator>
                                <name>slot</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>migrating_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                                <name>dst</name></expr>;</expr_stmt>
                        </block_content>}</block></if>  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>, <argument><expr><literal type="string">"-&lt;-"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content><comment type="line">//Importing</comment>
                            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>closing_bracket</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><name>closing_bracket</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>closing_bracket</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>sds</name></type> <name>src</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>importing_count</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name></name></expr></argument>,
                                <argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>importing_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>importing_count</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator>
                                <name>slot</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>importing</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>importing_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                                <name>src</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>dash</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>dash</name></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>;</decl_stmt>
                        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>stop</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>+=</operator> <operator>(</operator><name>stop</name> <operator>-</operator> <operator>(</operator><name>start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                        <while>while <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>stop</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>start</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>slotsdef</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><call><name>atoi</name><argument_list>(<argument><expr><name>slotsdef</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>getfriends</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_MYSELF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: invalid CLUSTER NODES reply\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: invalid CLUSTER NODES reply\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><operator>++</operator><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>currentNode</name> <operator>=</operator> <call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_FLAG_FRIEND</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name></expr></argument>, <argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>currentNode</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags_str</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>freeClusterManagerNodeFlags</name><argument_list>(<argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags_str</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>flag_len</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>flag_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>flag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fp</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>fp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>fp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>flags</name> <operator>+=</operator> <name>flag_len</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><literal type="string">"noaddr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_FLAG_NOADDR</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><literal type="string">"disconnected"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_FLAG_DISCONNECT</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><literal type="string">"fail"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_FLAG_FAIL</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><literal type="string">"slave"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>master_id</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>currentNode</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>flags_str</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>config_epoch</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>current_epoch</name></name> <operator>=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>config_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ping_sent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>ping_sent</name></name> <operator>=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>ping_sent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ping_recv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>currentNode</name><operator>-&gt;</operator><name>ping_recv</name></name> <operator>=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>ping_recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>getfriends</name> <operator>&amp;&amp;</operator> <name>myself</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Retrieves info about the cluster using argument 'node' as the starting
 * point. All nodes will be loaded inside the cluster_manager.nodes list.
 * Warning: if something goes wrong, it will free the starting node before
 * returning 0. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerLoadInfoFromNode</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>clusterManagerNodeConnect</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>opts</name> <operator>|=</operator> <name>CLUSTER_MANAGER_OPT_GETFRIENDS</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeIsCluster</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerPrintNotClusterNodeError</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>e</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeLoadInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><operator>(</operator><name>clusterManagerNode</name> <operator>*</operator><operator>)</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>friend</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>friend</name><operator>-&gt;</operator><name>ip</name></name> <operator>||</operator> <operator>!</operator><name><name>friend</name><operator>-&gt;</operator><name>port</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_friend</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>friend</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>clusterManagerNodeConnect</name><argument_list>(<argument><expr><name>friend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>invalid_friend</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>e</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>clusterManagerNodeLoadInfo</name><argument_list>(<argument><expr><name>friend</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>friend</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_MANAGER_FLAG_NOADDR</name> <operator>|</operator>
                                     <name>CLUSTER_MANAGER_FLAG_DISCONNECT</name> <operator>|</operator>
                                     <name>CLUSTER_MANAGER_FLAG_FAIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>invalid_friend</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>friend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Unable to load info for "</literal>
                                     <literal type="string">"node %s:%d\n"</literal></expr></argument>,
                                     <argument><expr><name><name>friend</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>friend</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>invalid_friend</name>;</goto>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
<label><name>invalid_friend</name>:</label>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>friend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>friends</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Count replicas for each node</comment>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>master</name> <init>= <expr><call><name>clusterManagerNodeByName</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>master</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** WARNING: %s:%d claims to be "</literal>
                                      <literal type="string">"slave of unknown node ID %s.\n"</literal></expr></argument>,
                                      <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>replicas_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare functions used by various sorting operations. */</comment>
<function><type><name>int</name></type> <name>clusterManagerSlotCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>slot1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>slot2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>i1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>slot1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>i2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>slot2</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>i1</name></expr></argument>, <argument><expr><operator>*</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>clusterManagerSlotCountCompareDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>clusterManagerNode</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>n1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>clusterManagerNode</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>n2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>node2</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>-</operator> <name><name>node1</name><operator>-&gt;</operator><name>slots_count</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>clusterManagerCompareNodeBalance</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>clusterManagerNode</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>n1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>clusterManagerNode</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>n2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>node1</name><operator>-&gt;</operator><name>balance</name></name> <operator>-</operator> <name><name>node2</name><operator>-&gt;</operator><name>balance</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sds</name></type> <name>clusterManagerGetConfigSignature</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>signature</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>node_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>node_configs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER NODES"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lines</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lines</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nodename</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tot_size</name> <operator>=</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>token</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>name_len</name> <operator>=</operator> <name>tot_size</name><operator>++</operator></expr>;</expr_stmt> <comment type="line">// Make room for ':' in tot_size</comment>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nodename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>remaining</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tot_size</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slotsdef</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slotsdef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><operator>(</operator><name>c</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slots</name><index>[<expr><name>c</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>slotsdef</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>clusterManagerSlotCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>node_count</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>node_configs</name> <operator>=</operator>
                <call><name>zrealloc</name><argument_list>(<argument><expr><name>node_configs</name></expr></argument>, <argument><expr><operator>(</operator><name>node_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Make room for '|' separators. */</comment>
            <expr_stmt><expr><name>tot_size</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>tot_size</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>name_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name>cfg</name> <operator>+</operator> <name>name_len</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sp</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sp</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>slen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sp</name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sp</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node_configs</name><index>[<expr><name>node_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cfg</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>node_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>node_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>node_configs</name></expr></argument>, <argument><expr><name>node_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr><name>clusterManagerSlotCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>signature</name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>signature</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>signature</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>signature</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>signature</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>node_configs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>node_configs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node_configs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node_configs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>signature</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerIsConfigConsistent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>consistent</name> <init>= <expr><operator>(</operator><call><name>listLength</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <comment type="line">// If the Cluster has only one node, it's always consistent</comment>
    <if_stmt><if>if <condition>(<expr><name>consistent</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>first_cfg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>cfg</name> <init>= <expr><call><name>clusterManagerGetConfigSignature</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cfg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>consistent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>first_cfg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_cfg</name> <operator>=</operator> <name>cfg</name></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><name>consistent</name> <operator>=</operator> <operator>!</operator><call><name>sdscmp</name><argument_list>(<argument><expr><name>first_cfg</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>consistent</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>first_cfg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>first_cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>consistent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add the error string to cluster_manager.errors and print it. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerOnError</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check the slots coverage of the cluster. The 'all_slots' argument must be
 * and array of 16384 bytes. Every covered slot will be set to 1 in the
 * 'all_slots' array. The function returns the total number if covered slots.*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerGetCoveredSlots</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>all_slots</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>totslots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>all_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>all_slots</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>totslots</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
    <return>return <expr><name>totslots</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerPrintSlotsList</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>slots</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the node, among 'nodes' with the greatest number of keys
 * in the specified slot. */</comment>
<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type> <name>clusterManagerGetNodeWithMostKeysInSlot</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>,
                                                                    <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>,
                                                                    <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numkeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>=
            <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER COUNTKEYSINSLOT %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>integer</name></name> <operator>&gt;</operator> <name>numkeys</name> <operator>||</operator> <name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>numkeys</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>integer</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* If the reply contains errors */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function returns the master that has the least number of replicas
 * in the cluster. If there are multiple masters with the same smaller
 * number of replicas, one at random is returned. */</comment>

<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNodeWithLeastReplicas</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lowest_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>replicas_count</name></name> <operator>&lt;</operator> <name>lowest_count</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lowest_count</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>replicas_count</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This fucntion returns a random master node, return NULL if none */</comment>

<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterManagerNodeMasterRandom</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>master_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>master_count</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>master_count</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>idx</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>n</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <comment type="block">/* Can not be reached */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerFixSlotsCoverage</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>all_slots</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>fixed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>none</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>single</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>multi</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Fixing slots coverage...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"List of not covered slots: \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>uncovered_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>log</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>covered</name> <init>= <expr><name><name>all_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>covered</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>uncovered_count</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>slot_nodes</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>slot_nodes_str</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>,
                    <argument><expr><literal type="string">"CLUSTER GETKEYSINSLOT %d %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>slot_nodes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>slot_nodes</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>slot_nodes_str</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>slot_nodes_str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>slot_nodes_str</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>slot_nodes_str</name></expr></argument>,
                                               <argument><expr><literal type="string">"%s:%u"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>log</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"\nSlot %S has keys in %u nodes: %S"</literal></expr></argument>,
                            <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>slot_nodes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slot_nodes_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>slot_nodes_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>clusterManagerUncoveredSlots</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* For every slot, take action depending on the actual condition:
     * 1) No node has keys for this slot.
     * 2) A single node has keys for this slot.
     * 3) Multiple nodes have keys for this slot. */</comment>
    <expr_stmt><expr><name>none</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>single</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>multi</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>clusterManagerUncoveredSlots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><operator>(</operator><name>sds</name><operator>)</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><operator>(</operator><name>list</name> <operator>*</operator><operator>)</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>none</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>single</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <default>default:</default> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*  Handle case "1": keys in no node. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>none</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The following uncovered slots have no keys "</literal>
               <literal type="string">"across the cluster:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerPrintSlotsList</name><argument_list>(<argument><expr><name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>confirmWithYes</name><argument_list>(<argument><expr><literal type="string">"Fix these slots by covering with a random node?"</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>none</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterManagerNodeMasterRandom</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Covering slot %s with %s:%d\n"</literal></expr></argument>,
                                      <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlotOwner</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Since CLUSTER ADDSLOTS succeeded, we also update the slot
                 * info into the node struct, in order to keep it synced */</comment>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>fixed</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*  Handle case "2": keys only in one node. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The following uncovered slots have keys in just one node:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerPrintSlotsList</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>confirmWithYes</name><argument_list>(<argument><expr><literal type="string">"Fix these slots by covering with those nodes?"</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>single</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>clusterManagerUncoveredSlots</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><operator>(</operator><name>list</name> <operator>*</operator><operator>)</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>fn</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Covering slot %s with %s:%d\n"</literal></expr></argument>,
                                      <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlotOwner</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Since CLUSTER ADDSLOTS succeeded, we also update the slot
                 * info into the node struct, in order to keep it synced */</comment>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name><index>[<expr><call><name>atoi</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>fixed</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle case "3": keys in multiple nodes. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The following uncovered slots have keys in multiple nodes:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerPrintSlotsList</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>confirmWithYes</name><argument_list>(<argument><expr><literal type="string">"Fix these slots by moving keys "</literal>
                           <literal type="string">"into a single node?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>clusterManagerUncoveredSlots</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><operator>(</operator><name>list</name> <operator>*</operator><operator>)</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name> <init>=
                    <expr><call><name>clusterManagerGetNodeWithMostKeysInSlot</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Covering slot %s moving keys "</literal>
                                      <literal type="string">"to %s:%d\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                      <argument><expr><name><name>target</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlotOwner</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Since CLUSTER ADDSLOTS succeeded, we also update the slot
                 * info into the node struct, in order to keep it synced */</comment>
                <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>slots</name><index>[<expr><call><name>atoi</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>listIter</name></type> <name>nli</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>nln</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>nln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nli</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>nln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <comment type="block">/* Assign the slot to target node in the source node. */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"NODE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fixed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
                    <comment type="block">/* Set the source node in 'importing' state
                     * (even if we will actually migrate keys away)
                     * in order to avoid receiving redirections
                     * for MIGRATE. */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>s</name></expr></argument>,
                                               <argument><expr><literal type="string">"IMPORTING"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fixed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>opts</name> <init>= <expr><name>CLUSTER_MANAGER_OPT_VERBOSE</name> <operator>|</operator>
                               <name>CLUSTER_MANAGER_OPT_COLD</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                        <goto>goto <name>cleanup</name>;</goto>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>fixed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fixed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>fixed</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>none</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>single</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>multi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>fixed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Slot 'slot' was found to be in importing or migrating state in one or
 * more nodes. This function fixes this condition by migrating keys where
 * it seems more sensible. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerFixOpenSlot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Fixing open slot %d\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Try to obtain the current slot owner, according to the current
     * nodes configuration. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>owners</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>migrating</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>importing</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>migrating_str</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>importing_str</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>owner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>owners</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>,
                <argument><expr><literal type="string">"CLUSTER COUNTKEYSINSLOT %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>integer</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** Found keys about slot %d "</literal>
                                      <literal type="string">"in non-owner node %s:%d!\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                      <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>owners</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>owner</name> <operator>=</operator> <call><name>listFirst</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>is_migrating</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_importing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>migrating</name></name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>migrating_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>migrating_slot</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name>migrating_slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>slot</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>listLength</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>migrating_str</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>migrating_str</name></expr></argument>, <argument><expr><literal type="string">"%s%s:%u"</literal></expr></argument>,
                                              <argument><expr><name>sep</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>is_migrating</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_migrating</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>importing</name></name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>importing_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>importing_slot</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>importing</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name>importing_slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>slot</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>listLength</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>importing_str</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>importing_str</name></expr></argument>, <argument><expr><literal type="string">"%s%s:%u"</literal></expr></argument>,
                                              <argument><expr><name>sep</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>is_importing</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* If the node is neither migrating nor importing and it's not
         * the owner, then is added to the importing list in case
         * it has keys in the slot. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_migrating</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_importing</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>!=</operator> <name>owner</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>,
                <argument><expr><literal type="string">"CLUSTER COUNTKEYSINSLOT %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>integer</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** Found keys about slot %d "</literal>
                                      <literal type="string">"in node %s:%d!\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                                      <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>listLength</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>importing_str</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>importing_str</name></expr></argument>, <argument><expr><literal type="string">"%s%S:%u"</literal></expr></argument>,
                                          <argument><expr><name>sep</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>migrating_str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Set as migrating in: %s\n"</literal></expr></argument>, <argument><expr><name>migrating_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>importing_str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Set as importing in: %s\n"</literal></expr></argument>, <argument><expr><name>importing_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* If there is no slot owner, set as owner the node with the biggest
     * number of keys, among the set of migrating / importing nodes. */</comment>
    <if_stmt><if>if <condition>(<expr><name>owner</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Nobody claims ownership, "</literal>
                              <literal type="string">"selecting an owner...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>owner</name> <operator>=</operator> <call><name>clusterManagerGetNodeWithMostKeysInSlot</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>,
                                                        <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// If we still don't have an owner, we can't fix it.</comment>
        <if_stmt><if>if <condition>(<expr><name>owner</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Can't select a slot owner. "</literal>
                                 <literal type="string">"Impossible to fix.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Use ADDSLOTS to assign the slot.</comment>
        <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** Configuring %s:%d as the slot owner\n"</literal></expr></argument>,
                              <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerSetSlotOwner</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        <comment type="block">/* Since CLUSTER ADDSLOTS succeeded, we also update the slot
         * info into the node struct, in order to keep it synced */</comment>
        <expr_stmt><expr><name><name>owner</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <comment type="block">/* Make sure this information will propagate. Not strictly needed
         * since there is no past owner, so all the other nodes will accept
         * whatever epoch this node will claim the slot with. */</comment>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerBumpEpoch</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        <comment type="block">/* Remove the owner from the list of migrating/importing
         * nodes. */</comment>
        <expr_stmt><expr><call><name>clusterManagerRemoveNodeFromList</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerRemoveNodeFromList</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* If there are multiple owners of the slot, we need to fix it
     * so that a single node is the owner and all the other nodes
     * are in importing state. Later the fix can be handled by one
     * of the base cases above.
     *
     * Note that this case also covers multiple nodes having the slot
     * in migrating state, since migrating is a valid state only for
     * slot owners. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Owner cannot be NULL at this point, since if there are more owners,
         * the owner has been set in the previous condition (owner == NULL). */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>owners</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerDelSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* Assign the slot to the owner in the node 'n' configuration.' */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"node"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"importing"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <comment type="block">/* Avoid duplicates. */</comment>
            <expr_stmt><expr><call><name>clusterManagerRemoveNodeFromList</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Ensure that the node is not in the migrating list. */</comment>
            <expr_stmt><expr><call><name>clusterManagerRemoveNodeFromList</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>move_opts</name> <init>= <expr><name>CLUSTER_MANAGER_OPT_VERBOSE</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Case 1: The slot is in migrating state in one node, and in
     *         importing state in 1 node. That's trivial to address. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Case 1: Moving slot %d from "</literal>
                              <literal type="string">"%s:%d to %s:%d\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                              <argument><expr><name><name>src</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>move_opts</name> <operator>|=</operator> <name>CLUSTER_MANAGER_OPT_UPDATE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>move_opts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Case 2: There are multiple nodes that claim the slot as importing,
     * they probably got keys about the slot after a restart so opened
     * the slot. In this case we just move all the keys to the owner
     * according to the configuration. */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Case 2: Moving all the %d slot keys to its "</literal>
                              <literal type="string">"owner %s:%d\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>move_opts</name> <operator>|=</operator> <name>CLUSTER_MANAGER_OPT_COLD</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>move_opts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Setting %d as STABLE in "</literal>
                                  <literal type="string">"%s:%d\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Since the slot has been moved in "cold" mode, ensure that all the
         * other nodes update their own configuration about the slot itself. */</comment>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"NODE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <comment type="block">/* Case 3: The slot is in migrating state in one node but multiple
     * other nodes claim to be in importing state and don't have any key in
     * the slot. We search for the importing node having the same ID as
     * the destination node of the migrating node.
     * In that case we move the slot from the migrating node to this node and
     * we close the importing states on all the other importing nodes.
     * If no importing node has the same ID as the destination node of the
     * migrating node, the slot's state is closed on both the migrating node
     * and the importing nodes. */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>try_to_fix</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>target_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>src</name><operator>-&gt;</operator><name>migrating_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>migrating_slot</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name>migrating_slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>slot</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>target_id</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target_id</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>clusterManagerCountKeysInSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>try_to_fix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dst</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_to_fix</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>unhandled_case</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Case 3: Moving slot %d from %s:%d to "</literal>
                                  <literal type="string">"%s:%d and closing it on all the other "</literal>
                                  <literal type="string">"importing nodes.\n"</literal></expr></argument>,
                                  <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
                                  <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Move the slot to the destination node. */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>move_opts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <comment type="block">/* Close slot on all the other importing nodes. */</comment>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Case 3: Closing slot %d on both "</literal>
                                  <literal type="string">"migrating and importing nodes.\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Close the slot on both the migrating node and the importing
             * nodes. */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>importing</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerClearSlotStatus</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>try_to_close_slot</name> <init>= <expr><operator>(</operator><call><name>listLength</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                                 <call><name>listLength</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>try_to_close_slot</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>owner</name> <operator>||</operator> <name>owner</name> <operator>!=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>,
                    <argument><expr><literal type="string">"CLUSTER GETKEYSINSLOT %d %d"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>try_to_close_slot</name> <operator>=</operator> <operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Case 4: There are no slots claiming to be in importing state, but
         * there is a migrating node that actually don't have any key or is the
         * slot owner. We can just close the slot, probably a reshard
         * interrupted in the middle. */</comment>
        <if_stmt><if>if <condition>(<expr><name>try_to_close_slot</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Case 4: Closing slot %d on %s:%d\n"</literal></expr></argument>,
                                  <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER SETSLOT %d %s"</literal></expr></argument>,
                                                    <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"STABLE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
<label><name>unhandled_case</name>:</label>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Sorry, redis-cli can't fix this slot "</literal>
                                 <literal type="string">"yet (work in progress). Slot is set as "</literal>
                                 <literal type="string">"migrating in %s, as importing in %s, "</literal>
                                 <literal type="string">"owner is %s:%d\n"</literal></expr></argument>, <argument><expr><name>migrating_str</name></expr></argument>,
                                 <argument><expr><name>importing_str</name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>migrating</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>importing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>migrating_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>importing_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerFixMultipleSlotOwners</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>owners</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Fixing multiple owners for slot %d...\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>owner</name> <init>= <expr><call><name>clusterManagerGetNodeWithMostKeysInSlot</name><argument_list>(<argument><expr><name>owners</name></expr></argument>,
                                                                        <argument><expr><name>slot</name></expr></argument>,
                                                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>owner</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>owner</name> <operator>=</operator> <call><name>listFirst</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Setting slot %d owner: %s:%d\n"</literal></expr></argument>,
                          <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>owner</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Set the slot owner. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlotOwner</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Update configuration in all the other master nodes by assigning the slot
     * itself to the new owner, and by eventually migrating keys if the node
     * has keys for the slot. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>clusterManagerCountKeysInSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <operator>(</operator><name>count</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterManagerDelSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerSetSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="string">"node"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>opts</name> <init>= <expr><name>CLUSTER_MANAGER_OPT_VERBOSE</name> <operator>|</operator>
                       <name>CLUSTER_MANAGER_OPT_COLD</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCheckCluster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>quiet</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ln</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Performing Cluster Check (using node %s:%d)\n"</literal></expr></argument>,
                          <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>consistent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>do_fix</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator>
                 <name>CLUSTER_MANAGER_CMD_FLAG_FIX</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clusterManagerShowNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>consistent</name> <operator>=</operator> <call><name>clusterManagerIsConfigConsistent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>consistent</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>err</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"[ERR] Nodes don't agree about configuration!"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>clusterManagerOnError</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogOk</name><argument_list>(<argument><expr><literal type="string">"[OK] All nodes agree about slots "</literal>
                            <literal type="string">"configuration.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Check open slots */</comment>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Check for open slots...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>open_slots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>migrating</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>open_slots</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>open_slots</name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clusterManagerDictType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>errstr</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>,
                                <argument><expr><literal type="string">"[WARNING] Node %s:%d has slots in "</literal>
                                <literal type="string">"migrating state "</literal></expr></argument>,
                                <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                                <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>migrating_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>open_slots</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>migrating</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">",%S"</literal></expr> </then><else>: <expr><literal type="string">"%S"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterManagerOnError</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>importing</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>open_slots</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>open_slots</name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clusterManagerDictType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>errstr</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>,
                                <argument><expr><literal type="string">"[WARNING] Node %s:%d has slots in "</literal>
                                <literal type="string">"importing state "</literal></expr></argument>,
                                <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                                <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>importing_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>importing</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>open_slots</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>importing</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">",%S"</literal></expr> </then><else>: <expr><literal type="string">"%S"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterManagerOnError</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>open_slots</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>open_slots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>errstr</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"[WARNING] The following slots are open: "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><operator>(</operator><name>sds</name><operator>)</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>i</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">",%S"</literal></expr> </then><else>: <expr><literal type="string">"%S"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>sdscatfmt</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"%s.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>do_fix</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Fix open slots. */</comment>
            <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>open_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>slot</name> <init>= <expr><operator>(</operator><name>sds</name><operator>)</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>clusterManagerFixOpenSlot</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>open_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Check slots coverage...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>slots</name><index>[<expr><name>CLUSTER_MANAGER_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>coverage</name> <init>= <expr><call><name>clusterManagerGetCoveredSlots</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>coverage</name> <operator>==</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogOk</name><argument_list>(<argument><expr><literal type="string">"[OK] All %d slots covered.\n"</literal></expr></argument>,
                            <argument><expr><name>CLUSTER_MANAGER_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>err</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"[ERR] Not all %d slots are "</literal>
                                <literal type="string">"covered by nodes.\n"</literal></expr></argument>,
                                <argument><expr><name>CLUSTER_MANAGER_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerOnError</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>do_fix</name></expr><comment type="block">/* &amp;&amp; result*/</comment>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>dictType</name></type> <name>dtype</name> <init>= <expr><name>clusterManagerDictType</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>dtype</name><operator>.</operator><name>keyDestructor</name></name> <operator>=</operator> <name>dictSdsDestructor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dtype</name><operator>.</operator><name>valDestructor</name></name> <operator>=</operator> <name>dictListDestructor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>clusterManagerUncoveredSlots</name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fixed</name> <init>= <expr><call><name>clusterManagerFixSlotsCoverage</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fixed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>search_multiple_owners</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator>
                                 <name>CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>search_multiple_owners</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Check whether there are multiple owners, even when slots are
         * fully covered and there are no open slots. */</comment>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Check for multiple slot owners...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>slot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>slot</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>owners</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>owners</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else <block>{<block_content>
                    <comment type="block">/* Nodes having keys for the slot will be considered
                     * owners too. */</comment>
                    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>clusterManagerCountKeysInSlot</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>owners</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[WARNING] Slot %d has %d owners:\n"</literal></expr></argument>,
                                     <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>owners</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"    %s:%d\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>
                <if_stmt><if>if <condition>(<expr><name>do_fix</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>clusterManagerFixMultipleSlotOwners</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>owners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"Failed to fix multiple owners "</literal>
                                             <literal type="string">"for slot %d\n"</literal></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>owners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>clusterManagerNode</name> <modifier>*</modifier></type><name>clusterNodeForResharding</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,
                                                    <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                                                    <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>raise_err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>invalid_node_msg</name> <init>= <expr><literal type="string">"*** The specified node (%s) is not known "</literal>
                                   <literal type="string">"or not a master, please retry.\n"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>clusterManagerNodeByName</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>raise_err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><name>invalid_node_msg</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>raise_err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>target</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>( <argument><expr><literal type="string">"*** It is not possible to use "</literal>
                                  <literal type="string">"the target node as "</literal>
                                  <literal type="string">"source node.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>list</name> <modifier>*</modifier></type><name>clusterManagerComputeReshardTable</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>sources</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numslots</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>moved</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>src_count</name> <init>= <expr><call><name>listLength</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tot_slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>src_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sorted</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tot_slots</name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sorted</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sorted</name></expr></argument>, <argument><expr><name>src_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
          <argument><expr><name>clusterManagerSlotCountCompareDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>src_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name>n</name> <init>= <expr><operator>(</operator><operator>(</operator><name>float</name><operator>)</operator> <name>numslots</name> <operator>/</operator> <name>tot_slots</name> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>n</name></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slot</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>max</name> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>listLength</name><argument_list>(<argument><expr><name>moved</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>numslots</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>clusterManagerReshardTableItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>moved</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>moved</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerShowReshardTable</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerReshardTableItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>source</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"    Moving slot %d from %s\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerReleaseReshardTable</name><parameter_list>(<parameter><decl><type><name>list</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>table</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerReshardTableItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerLog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>use_colors</name> <init>=
        <expr><operator>(</operator><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_CMD_FLAG_COLOR</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>level</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>CLUSTER_MANAGER_LOG_LVL_INFO</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>LOG_COLOR_BOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>CLUSTER_MANAGER_LOG_LVL_WARN</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>LOG_COLOR_YELLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>CLUSTER_MANAGER_LOG_LVL_ERR</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>LOG_COLOR_RED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>CLUSTER_MANAGER_LOG_LVL_SUCCESS</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>LOG_COLOR_GREEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <default>default:</default> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>LOG_COLOR_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033["</literal> <name>LOG_COLOR_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayInit</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                        <parameter><decl><type><name>int</name></type> <name>alloc_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><name>alloc_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name><name>array</name><operator>-&gt;</operator><name>nodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>alloc_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reset array-&gt;nodes to the original array allocation and re-count non-NULL
 * nodes. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayReset</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>&gt;</operator> <name><name>array</name><operator>-&gt;</operator><name>alloc</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>-</operator> <name><name>array</name><operator>-&gt;</operator><name>alloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name><name>array</name><operator>-&gt;</operator><name>alloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Shift array-&gt;nodes and store the shifted node into 'nodeptr'. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayShift</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                         <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodeptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>+</operator> <name><name>array</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If the first node to be shifted is not NULL, decrement count. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Store the first node to be shifted into 'nodeptr'. */</comment>
    <expr_stmt><expr><operator>*</operator><name>nodeptr</name> <operator>=</operator> <operator>*</operator><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name></expr>;</expr_stmt>
    <comment type="block">/* Shift the nodes array and decrement length. */</comment>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerNodeArrayAdd</name><parameter_list>(<parameter><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                       <parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>+</operator> <name><name>array</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerPrintNotEmptyNodeError</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                                 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>msg</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"is not empty. Either the node already knows other "</literal>
              <literal type="string">"nodes (check with CLUSTER NODES) or contains some "</literal>
              <literal type="string">"key in database 0."</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Node %s:%d %s\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerPrintNotClusterNodeError</name><parameter_list>(<parameter><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                                   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>err</name></expr> ?</condition><then> <expr><name>err</name></expr> </then><else>: <expr><literal type="string">"is not configured as a cluster node."</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Node %s:%d %s\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Execute redis-cli in Cluster Manager mode */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clusterManagerMode</name><parameter_list>(<parameter><decl><type><name>clusterManagerCommandProc</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argv</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>proc</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cluster_manager_err</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>freeClusterManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cluster_manager_err</name>:</label>
    <expr_stmt><expr><call><name>freeClusterManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>mb_delim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Cluster Manager Commands */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Invalid address format: %s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><operator>++</operator><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeConnect</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeIsCluster</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterManagerPrintNotClusterNodeError</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeLoadInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeIsEmpty</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>clusterManagerPrintNotEmptyNodeError</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>int</name></type> <name>node_len</name> <init>= <expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>replicas</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>replicas</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>masters_count</name> <init>= <expr><call><name>CLUSTER_MANAGER_MASTERS_COUNT</name><argument_list>(<argument><expr><name>node_len</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>masters_count</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(
            <argument><expr><literal type="string">"*** ERROR: Invalid configuration for cluster creation.\n"</literal>
            <literal type="string">"*** Redis Cluster requires at least 3 master nodes.\n"</literal>
            <literal type="string">"*** This is not possible with %d nodes and %d replicas per node."</literal></expr></argument>,
            <argument><expr><name>node_len</name></expr></argument>, <argument><expr><name>replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"\n*** At least %d nodes are required.\n"</literal></expr></argument>,
                             <argument><expr><literal type="number">3</literal> <operator>*</operator> <operator>(</operator><name>replicas</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Performing hash slots allocation "</literal>
                          <literal type="string">"on %d nodes...\n"</literal></expr></argument>, <argument><expr><name>node_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>interleaved_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ip_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>interleaved</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><name>node_len</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>interleaved</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ips</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><name>node_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>ip_nodes</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><name>node_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ip_nodes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ip_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name><name>ips</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>ips</name><index>[<expr><name>ip_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>node_array</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ip_nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node_array</name><operator>-&gt;</operator><name>nodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>clusterManagerNodeArrayInit</name><argument_list>(<argument><expr><name>node_array</name></expr></argument>, <argument><expr><name>node_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterManagerNodeArrayAdd</name><argument_list>(<argument><expr><name>node_array</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while <condition>(<expr><name>interleaved_len</name> <operator>&lt;</operator> <name>node_len</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ip_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>node_array</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>ip_nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node_array</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>clusterManagerNodeArrayShift</name><argument_list>(<argument><expr><name>node_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>interleaved</name><index>[<expr><name>interleaved_len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>masters</name> <init>= <expr><name>interleaved</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>interleaved</name> <operator>+=</operator> <name>masters_count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>interleaved_len</name> <operator>-=</operator> <name>masters_count</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>slots_per_node</name> <init>= <expr><name>CLUSTER_MANAGER_SLOTS</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>masters_count</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>cursor</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>masters_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>master</name> <init>= <expr><name><name>masters</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>last</name> <init>= <expr><call><name>lround</name><argument_list>(<argument><expr><name>cursor</name> <operator>+</operator> <name>slots_per_node</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>last</name> <operator>&gt;</operator> <name>CLUSTER_MANAGER_SLOTS</name> <operator>||</operator> <name>i</name> <operator>==</operator> <operator>(</operator><name>masters_count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>last</name> <operator>=</operator> <name>CLUSTER_MANAGER_SLOTS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>last</name> <operator>&lt;</operator> <name>first</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>last</name> <operator>=</operator> <name>first</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Master[%d] -&gt; Slots %lu - %lu\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>slots_count</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>master</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <name>last</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name>slots_per_node</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Rotating the list sometimes helps to get better initial
     * anti-affinity before the optimizer runs. */</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>first_node</name> <init>= <expr><name><name>interleaved</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>interleaved_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>interleaved</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>interleaved</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>interleaved</name><index>[<expr><name>interleaved_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>first_node</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>assign_unused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>available_count</name> <init>= <expr><name>interleaved_len</name></expr></init></decl>;</decl_stmt>
<label><name>assign_replicas</name>:</label>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>masters_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>master</name> <init>= <expr><name><name>masters</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>assigned_replicas</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>assigned_replicas</name> <operator>&lt;</operator> <name>replicas</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>available_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>slave</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>firstNodeIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>interleaved_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>interleaved</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>master</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>interleaved</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>firstNodeIdx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstNodeIdx</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>slave</name> <operator>=</operator> <name>found</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>firstNodeIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>slave</name> <operator>=</operator> <name><name>interleaved</name><index>[<expr><name>firstNodeIdx</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>interleaved_len</name> <operator>-=</operator> <operator>(</operator><name>interleaved</name> <operator>-</operator> <operator>(</operator><name>interleaved</name> <operator>+</operator> <name>firstNodeIdx</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>interleaved</name> <operator>+=</operator> <operator>(</operator><name>firstNodeIdx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>slave</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>assigned_replicas</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>available_count</name><operator>--</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>slave</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>slave</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>replicate</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>master</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>slave</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Adding replica %s:%d to %s:%d\n"</literal></expr></argument>, <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>slave</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
                   <argument><expr><name><name>master</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>master</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>assign_unused</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>assign_unused</name> <operator>&amp;&amp;</operator> <name>available_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>assign_unused</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Adding extra replicas...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>assign_replicas</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ip_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>node_array</name> <init>= <expr><name>ip_nodes</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>clusterManagerNodeArrayReset</name><argument_list>(<argument><expr><name>node_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>clusterManagerOptimizeAntiAffinity</name><argument_list>(<argument><expr><name>ip_nodes</name></expr></argument>, <argument><expr><name>ip_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterManagerShowNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>confirmWithYes</name><argument_list>(<argument><expr><literal type="string">"Can I set the above configuration?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>flushed</name> <init>= <expr><call><name>clusterManagerFlushNodeConfig</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>flushed</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>dirty</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Nodes configuration updated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Assign a different config epoch to "</literal>
                              <literal type="string">"each node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>config_epoch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                            <argument><expr><literal type="string">"cluster set-config-epoch %d"</literal></expr></argument>,
                                            <argument><expr><name>config_epoch</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Sending CLUSTER MEET messages to join "</literal>
                              <literal type="string">"the cluster\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"cluster meet %s %d"</literal></expr></argument>,
                                            <argument><expr><name><name>first</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>first</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>is_err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_err</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>is_err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to send CLUSTER MEET command.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>is_err</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Give one second for the join to start, in order to avoid that
         * waiting for cluster join will find all the nodes agree about
         * the config as they are still empty with unassigned slots. */</comment>
        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerWaitForClusterJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Useful for the replicas */</comment>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>flushed</name> <init>= <expr><call><name>clusterManagerFlushNodeConfig</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>flushed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <comment type="line">// Reset Nodes</comment>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>first_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_node</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listEmpty</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>first_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterManagerCheckCluster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<label><name>cleanup</name>:</label>
    <comment type="block">/* Free everything */</comment>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>masters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNodeArray</name> <modifier>*</modifier></type><name>node_array</name> <init>= <expr><name>ip_nodes</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CLUSTER_MANAGER_NODE_ARRAY_FREE</name><argument_list>(<argument><expr><name>node_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ip_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandAddNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ref_ip</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ref_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Adding node %s:%d to cluster %s:%d\n"</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>,
                          <argument><expr><name>ref_ip</name></expr></argument>, <argument><expr><name>ref_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Check the existing cluster</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>refnode</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ref_ip</name></expr></argument>, <argument><expr><name>ref_port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>refnode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerCheckCluster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If --cluster-master-id was specified, try to resolve it now so that we
     * abort before starting with the node configuration. */</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>master_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_CMD_FLAG_SLAVE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>master_id</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>master_id</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>master_id</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>master_node</name> <operator>=</operator> <call><name>clusterManagerNodeByName</name><argument_list>(<argument><expr><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>master_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] No such master ID %s\n"</literal></expr></argument>, <argument><expr><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>master_node</name> <operator>=</operator> <call><name>clusterManagerNodeWithLeastReplicas</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>master_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Automatically selected master %s:%d\n"</literal></expr></argument>, <argument><expr><name><name>master_node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                   <argument><expr><name><name>master_node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Add the new node</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeConnect</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Sorry, can't connect to node %s:%d\n"</literal></expr></argument>,
                             <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>success</name> <operator>=</operator> <call><name>clusterManagerNodeIsCluster</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerPrintNotClusterNodeError</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerNodeLoadInfo</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>CLUSTER_MANAGER_PRINT_REPLY_ERROR</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>success</name> <operator>=</operator> <call><name>clusterManagerNodeIsEmpty</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerPrintNotEmptyNodeError</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>added</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="line">// Send CLUSTER MEET command to the new node</comment>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Send CLUSTER MEET to node %s:%d to make it "</literal>
                          <literal type="string">"join the cluster.\n"</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER MEET %s %d"</literal></expr></argument>,
                                    <argument><expr><name><name>first</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>first</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Additional configuration is needed if the node is added as a slave. */</comment>
    <if_stmt><if>if <condition>(<expr><name>master_node</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerWaitForClusterJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Configure node as replica of %s:%d.\n"</literal></expr></argument>,
                              <argument><expr><name><name>master_node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>master_node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER REPLICATE %s"</literal></expr></argument>,
                                        <argument><expr><name><name>master_node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogOk</name><argument_list>(<argument><expr><literal type="string">"[OK] New node added correctly.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>added</name> <operator>&amp;&amp;</operator> <name>new_node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClusterManagerNode</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandDeleteNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>node_id</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Removing node %s from cluster %s:%d\n"</literal></expr></argument>,
                          <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>ref_node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Load cluster information</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>ref_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Check if the node exists and is not empty</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>clusterManagerNodeByName</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] No such node ID %s\n"</literal></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] Node %s:%d is not empty! Reshard data "</literal>
                             <literal type="string">"away and try again.\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Send CLUSTER FORGET to all the nodes but the node to remove</comment>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Sending CLUSTER FORGET messages to the "</literal>
                          <literal type="string">"cluster...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Reconfigure the slave to replicate with some other node</comment>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>master</name> <init>= <expr><call><name>clusterManagerNodeWithLeastReplicas</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>master</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; %s:%d as replica of %s:%d\n"</literal></expr></argument>,
                                  <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>master</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>master</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER REPLICATE %s"</literal></expr></argument>,
                                                    <argument><expr><name><name>master</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER FORGET %s"</literal></expr></argument>,
                                                <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="line">// Finally shutdown the node</comment>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; SHUTDOWN the node.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>redisCommand</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><literal type="string">"SHUTDOWN"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerShowClusterInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandCheck</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerShowClusterInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>clusterManagerCheckCluster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandFix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>CLUSTER_MANAGER_CMD_FLAG_FIX</name></expr>;</expr_stmt>
    <return>return <expr><call><name>clusterManagerCommandCheck</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandReshard</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerCheckCluster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><literal type="string">"*** Please fix your cluster problems before resharding\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slots</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>slots</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slots</name></expr>)</condition> <block>{<block_content>
        <while>while <condition>(<expr><name>slots</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>slots</name> <operator>&gt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"How many slots do you want to move (from 1 to %d)? "</literal></expr></argument>,
                   <argument><expr><name>CLUSTER_MANAGER_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>last_idx</name> <init>= <expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>last_idx</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getchar</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content/>}</block></while>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>last_idx</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">255</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>to</name></name></expr></init></decl>,
         <decl><type ref="prev"><modifier>*</modifier></type><name>from</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>from</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>to</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"What is the receiving node ID? "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>last_idx</name> <init>= <expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>last_idx</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getchar</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content/>}</block></while>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>last_idx</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>to</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><name>int</name></type> <name>raise_err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>clusterNodeForResharding</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raise_err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>all</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Please enter all the source node IDs.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Type 'all' to use all the nodes as source nodes for "</literal>
               <literal type="string">"the hash slots.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Type 'done' once you entered all the source nodes IDs.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Source node #%lu: "</literal></expr></argument>, <argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>last_idx</name> <init>= <expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>last_idx</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getchar</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content/>}</block></while>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>last_idx</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"done"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>all</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>=
                    <expr><call><name>clusterNodeForResharding</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raise_err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>raise_err</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>all</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>=
                    <expr><call><name>clusterNodeForResharding</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raise_err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>raise_err</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>from</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Check if there's still another source to process. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>all</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>=
                    <expr><call><name>clusterNodeForResharding</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raise_err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>raise_err</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <goto>goto <name>cleanup</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>all</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listEmpty</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sdscmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*** No source nodes given, operation aborted.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nReady to move %d slots.\n"</literal></expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Source nodes:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>info</name> <init>= <expr><call><name>clusterManagerNodeInfo</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Destination node:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>info</name> <init>= <expr><call><name>clusterManagerNodeInfo</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>clusterManagerComputeReshardTable</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Resharding plan:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterManagerShowReshardTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator>
          <name>CLUSTER_MANAGER_CMD_FLAG_YES</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Do you want to proceed with the proposed "</literal>
               <literal type="string">"reshard plan (yes/no)? "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>opts</name> <init>= <expr><name>CLUSTER_MANAGER_OPT_VERBOSE</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerReshardTableItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>,
                                        <argument><expr><name>opts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <comment type="line">//clusterManagerLogErr("\n%s\n", err);</comment>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterManagerReleaseReshardTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandRebalance</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>weightedNodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>involved</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight_argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>w</name> <init>= <expr><call><name>atof</name><argument_list>(<argument><expr><operator>++</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>clusterManagerNodeByAbbreviatedName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"*** No such master node %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>total_weight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodes_involved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>use_empty</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator>
                    <name>CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>involved</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Compute the total cluster weight. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_empty</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>total_weight</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodes_involved</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>involved</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>weightedNodes</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>nodes_involved</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>weightedNodes</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* Check cluster, only proceed if it looks sane. */</comment>
    <expr_stmt><expr><call><name>clusterManagerCheckCluster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name> <operator>&amp;&amp;</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>errors</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"*** Please fix your cluster problems "</literal>
                             <literal type="string">"before rebalancing\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Calculate the slots balance for each node. It's the number of
     * slots the node should lose (if positive) or gain (if negative)
     * in order to be balanced. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>threshold_reached</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>total_balance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>threshold</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>threshold</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>involved</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>weightedNodes</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>expected</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>CLUSTER_MANAGER_SLOTS</name> <operator>/</operator> <name>total_weight</name><operator>)</operator> <operator>*</operator>
                        <name><name>n</name><operator>-&gt;</operator><name>weight</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>balance</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>-</operator> <name>expected</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>total_balance</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>balance</name></name></expr>;</expr_stmt>
        <comment type="block">/* Compute the percentage of difference between the
         * expected number of slots and the real one, to see
         * if it's over the threshold specified by the user. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>over_threshold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>threshold</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>float</name></type> <name>err_perc</name> <init>= <expr><call><name>fabs</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">100</literal><operator>-</operator><operator>(</operator><literal type="number">100.0</literal><operator>*</operator><name>expected</name><operator>/</operator><name><name>n</name><operator>-&gt;</operator><name>slots_count</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>err_perc</name> <operator>&gt;</operator> <name>threshold</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>over_threshold</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>expected</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>over_threshold</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>over_threshold</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>threshold_reached</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>threshold_reached</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** No rebalancing needed! "</literal>
                             <literal type="string">"All nodes are within the %.2f%% threshold.\n"</literal></expr></argument>,
                             <argument><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Because of rounding, it is possible that the balance of all nodes
     * summed does not give 0. Make sure that nodes that have to provide
     * slots are always matched by nodes receiving slots. */</comment>
    <while>while <condition>(<expr><name>total_balance</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>involved</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>balance</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>total_balance</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>balance</name></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>total_balance</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
    <comment type="block">/* Sort nodes by their slots balance. */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>weightedNodes</name></expr></argument>, <argument><expr><name>nodes_involved</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
          <argument><expr><name>clusterManagerCompareNodeBalance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Rebalancing across %d nodes. "</literal>
                          <literal type="string">"Total weight = %.2f\n"</literal></expr></argument>,
                          <argument><expr><name>nodes_involved</name></expr></argument>, <argument><expr><name>total_weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodes_involved</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>weightedNodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d balance is %d slots\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>balance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Now we have at the start of the 'sn' array nodes that should get
     * slots, at the end nodes that must give slots.
     * We take two indexes, one at the start, and one at the end,
     * incrementing or decrementing the indexes accordingly til we
     * find nodes that need to get/provide slots. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dst_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>src_idx</name> <init>= <expr><name>nodes_involved</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>simulate</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator>
                   <name>CLUSTER_MANAGER_CMD_FLAG_SIMULATE</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>dst_idx</name> <operator>&lt;</operator> <name>src_idx</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name><name>weightedNodes</name><index>[<expr><name>dst_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>weightedNodes</name><index>[<expr><name>src_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>db</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>balance</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sb</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>balance</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>numslots</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>db</name> <operator>&lt;</operator> <name>sb</name></expr> ?</condition><then> <expr><name>db</name></expr> </then><else>: <expr><name>sb</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>numslots</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Moving %d slots from %s:%d to %s:%d\n"</literal></expr></argument>, <argument><expr><name>numslots</name></expr></argument>,
                                                            <argument><expr><name><name>src</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                                                            <argument><expr><name><name>src</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
                                                            <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                                                            <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Actually move the slots. */</comment>
            <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>lsrc</name> <init>= <expr><call><name>listCreate</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>lsrc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>clusterManagerComputeReshardTable</name><argument_list>(<argument><expr><name>lsrc</name></expr></argument>, <argument><expr><name>numslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>lsrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>table_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>listLength</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>table</name> <operator>||</operator> <name>table_len</name> <operator>!=</operator> <name>numslots</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"*** Assertion failed: Reshard table "</literal>
                                     <literal type="string">"!= number of slots"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>end_move</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>simulate</name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>table_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"#"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>opts</name> <init>= <expr><name>CLUSTER_MANAGER_OPT_QUIET</name> <operator>|</operator>
                           <name>CLUSTER_MANAGER_OPT_UPDATE</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>clusterManagerReshardTableItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>clusterManagerMoveSlot</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>source</name></name></expr></argument>,
                                                    <argument><expr><name>dst</name></expr></argument>,
                                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>,
                                                    <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end_move</name>;</goto></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"#"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>

            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end_move</name>:</label>
            <expr_stmt><expr><call><name>clusterManagerReleaseReshardTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Update nodes balance. */</comment>
        <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>balance</name></name> <operator>+=</operator> <name>numslots</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>balance</name></name> <operator>-=</operator> <name>numslots</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>-&gt;</operator><name>balance</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dst_idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>balance</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>src_idx</name> <operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>involved</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>involved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>weightedNodes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>weightedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandSetTimeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Setting a node timeout of less than 100 "</literal>
                <literal type="string">"milliseconds is a bad idea.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Load cluster information</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>err_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Reconfiguring node timeout in every "</literal>
                          <literal type="string">"cluster node...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CONFIG %s %s %d"</literal></expr></argument>,
                                                    <argument><expr><literal type="string">"SET"</literal></expr></argument>,
                                                    <argument><expr><literal type="string">"cluster-node-timeout"</literal></expr></argument>,
                                                    <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>reply_err</name>;</goto></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>reply_err</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>CLUSTER_MANAGER_COMMAND</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"CONFIG %s"</literal></expr></argument>, <argument><expr><literal type="string">"REWRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>reply_err</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>clusterManagerCheckRedisReply</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>reply_err</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** New timeout set for %s:%d\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                              <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok_count</name><operator>++</operator></expr>;</expr_stmt>
        <continue>continue;</continue>
<label><name>reply_err</name>:</label><empty_stmt>;</empty_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>need_free</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>need_free</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"ERR setting node-timeot for %s:%d: %s\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,
                             <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_free</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>err_count</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; New node timeout set. %d OK, %d ERR.\n"</literal></expr></argument>,
                          <argument><expr><name>ok_count</name></expr></argument>, <argument><expr><name>err_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandImport</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>src_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>src_ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>invalid_args_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>invalid_args_msg</name> <operator>=</operator> <name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr>;</expr_stmt>
        <goto>goto <name>invalid_args</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>from</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>invalid_args_msg</name> <operator>=</operator> <literal type="string">"[ERR] Option '--cluster-from' is required for "</literal>
                           <literal type="string">"subcommand 'import'.\n"</literal></expr>;</expr_stmt>
        <goto>goto <name>invalid_args</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>src_host</name><index>[]</index></name> <init>= <expr><block>{<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>from</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>src_host</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_port</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>invalid_args_msg</name> <operator>=</operator> <literal type="string">"[ERR] Invalid --cluster-from host. You need to "</literal>
                           <literal type="string">"pass a valid address (ie. 120.0.0.1:7000).\n"</literal></expr>;</expr_stmt>
        <goto>goto <name>invalid_args</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Importing data from %s:%d to cluster %s:%d\n"</literal></expr></argument>,
                          <argument><expr><name>src_ip</name></expr></argument>, <argument><expr><name>src_port</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>refnode</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>refnode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerCheckCluster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reply_err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>src_reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Connect to the source node.</comment>
    <decl_stmt><decl><type><name>redisContext</name> <modifier>*</modifier></type><name>src_ctx</name> <init>= <expr><call><name>redisConnect</name><argument_list>(<argument><expr><name>src_ip</name></expr></argument>, <argument><expr><name>src_port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>src_ctx</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Could not connect to Redis at %s:%d: %s.\n"</literal></expr></argument>, <argument><expr><name>src_ip</name></expr></argument>,
                <argument><expr><name>src_port</name></expr></argument>, <argument><expr><name><name>src_ctx</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>src_reply</name> <operator>=</operator> <call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>src_ctx</name></expr></argument>, <argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>src_reply</name> <operator>||</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>src_reply</name> <operator>&amp;&amp;</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reply_err</name> <operator>=</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"cluster_enabled"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"[ERR] The source node should not be a "</literal>
                             <literal type="string">"cluster node.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>src_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>src_reply</name> <operator>=</operator> <call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>src_ctx</name></expr></argument>, <argument><expr><literal type="string">"DBSIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>src_reply</name> <operator>||</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>src_reply</name> <operator>&amp;&amp;</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reply_err</name> <operator>=</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>src_reply</name><operator>-&gt;</operator><name>integer</name></name></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogWarn</name><argument_list>(<argument><expr><literal type="string">"*** Importing %d keys from DB 0\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Build a slot -&gt; node map</comment>
    <decl_stmt><decl><type><name>clusterManagerNode</name>  <modifier>*</modifier></type><name><name>slots_map</name><index>[<expr><name>CLUSTER_MANAGER_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>slots_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slots_map</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CLUSTER_MANAGER_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_FLAG_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>slots_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>slots_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>char</name></type> <name><name>cmdfmt</name><index>[<expr><literal type="number">50</literal></expr>]</index></name> <init>= <expr><literal type="string">"MIGRATE %s %d %s %d %d"</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_CMD_FLAG_COPY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cmdfmt</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_MANAGER_CMD_FLAG_REPLACE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cmdfmt</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Use SCAN to iterate over the keys, migrating to the
     * right node as needed. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>cursor</name> <init>= <expr><operator>-</operator><literal type="number">999</literal></expr></init></decl>, <decl><type ref="prev"/><name>timeout</name> <init>= <expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>timeout</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>cursor</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cursor</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>src_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>src_reply</name> <operator>=</operator> <call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>src_ctx</name></expr></argument>, <argument><expr><literal type="string">"SCAN %d COUNT %d"</literal></expr></argument>,
                                             <argument><expr><name>cursor</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>src_reply</name> <operator>||</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>src_reply</name> <operator>&amp;&amp;</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reply_err</name> <operator>=</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>src_reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>src_reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cursor</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>integer</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>keycount</name> <init>= <expr><name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>elements</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keycount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>kr</name> <init>= <expr><name><name>src_reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>element</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>kr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>kr</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint16_t</name></type> <name>slot</name> <init>= <expr><call><name>clusterManagerKeyHashSlot</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>kr</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>slots_map</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Migrating %s to %s:%d: "</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>src_ctx</name></expr></argument>, <argument><expr><name>cmdfmt</name></expr></argument>,
                                                     <argument><expr><name><name>target</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
                                                     <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>,
                                                     <argument><expr><literal type="string">"COPY"</literal></expr></argument>, <argument><expr><literal type="string">"REPLACE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name> <operator>||</operator> <name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"Source %s:%d replied with "</literal>
                                         <literal type="string">"error:\n%s\n"</literal></expr></argument>, <argument><expr><name>src_ip</name></expr></argument>, <argument><expr><name>src_port</name></expr></argument>,
                                         <argument><expr><name><name>r</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>clusterManagerLogOk</name><argument_list>(<argument><expr><literal type="string">"OK\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>reply_err</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>clusterManagerLogErr</name><argument_list>(<argument><expr><literal type="string">"Source %s:%d replied with error:\n%s\n"</literal></expr></argument>,
                             <argument><expr><name>src_ip</name></expr></argument>, <argument><expr><name>src_port</name></expr></argument>, <argument><expr><name>reply_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>src_ctx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>redisFree</name><argument_list>(<argument><expr><name>src_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>src_reply</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>src_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>invalid_args_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandCall</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getClusterHostFromCmdArgs</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_args</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>refnode</name> <init>= <expr><call><name>clusterManagerNewNode</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clusterManagerLoadInfoFromNode</name><argument_list>(<argument><expr><name>refnode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>argvlen</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>argc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>clusterManagerLogInfo</name><argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt; Calling"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>argvlen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>cluster_manager</name><operator>.</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>clusterManagerNodeConnect</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>redisAppendCommandArgv</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>argv</name></expr></argument>, <argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>reply</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REDIS_OK</name> <operator>||</operator> <name>reply</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: Failed!\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>formatted_reply</name> <init>= <expr><call><name>cliFormatReplyRaw</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: %s\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>formatted_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>formatted_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<label><name>invalid_args</name>:</label>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>CLUSTER_MANAGER_INVALID_HOST_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clusterManagerCommandHelp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>commands_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerCommands</name></expr></argument>)</argument_list></sizeof> <operator>/</operator>
                         <sizeof>sizeof<argument_list>(<argument><expr><name>clusterManagerCommandDef</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Cluster Manager Commands:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>padding</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>commands_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerCommandDef</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>clusterManagerCommands</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>padlen</name> <init>= <expr><name>padding</name> <operator>-</operator> <name>namelen</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  %s"</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>padlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>def</name><operator>-&gt;</operator><name>args</name></name></expr> ?</condition><then> <expr><name><name>def</name><operator>-&gt;</operator><name>args</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>options</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>optslen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eos</name> <init>= <expr><name>p</name> <operator>+</operator> <name>optslen</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>comma</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>deflen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>comma</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">255</literal></expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>deflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>buf</name><index>[<expr><name>deflen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>padding</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  --cluster-%s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> <operator>=</operator> <name>comma</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>eos</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>eos</name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>padding</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  --cluster-%s\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\nFor check, fix, reshard, del-node, set-timeout you "</literal>
                    <literal type="string">"can specify the host and port of any working node in "</literal>
                    <literal type="string">"the cluster.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Latency and latency history modes
 *--------------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>latencyModePrint</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>avg</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_STANDARD</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"min: %lld, max: %lld, avg: %.2f (%lld samples)"</literal></expr></argument>,
                <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>avg</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_CSV</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld,%lld,%.2f,%lld\n"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>avg</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_RAW</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld %lld %.2f %lld\n"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>avg</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LATENCY_SAMPLE_RATE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> <comment type="block">/* milliseconds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LATENCY_HISTORY_DEFAULT_INTERVAL</name></cpp:macro> <cpp:value>15000</cpp:value></cpp:define> <comment type="block">/* milliseconds. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>latencyMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>latency</name></decl>, <decl><type ref="prev"/><name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>history_interval</name> <init>=
        <expr><ternary><condition><expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>config</name><operator>.</operator><name>interval</name></name><operator>/</operator><literal type="number">1000</literal></expr> </then><else>:
                          <expr><name>LATENCY_HISTORY_DEFAULT_INTERVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>avg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>history_start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Set a default for the interval in case of --latency option
     * with --raw, --csv or when it is redirected to non tty. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>/=</operator> <literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* We need to convert to milliseconds. */</comment>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>context</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"PING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"\nI/O error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>latency</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>min</name> <operator>=</operator> <name>max</name> <operator>=</operator> <name>tot</name> <operator>=</operator> <name>latency</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>avg</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>latency</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>latency</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>latency</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name>latency</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tot</name> <operator>+=</operator> <name>latency</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>avg</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>tot</name><operator>/</operator><name>count</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>==</operator> <name>OUTPUT_STANDARD</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\x1b[0G\x1b[2K"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Clear the line. */</comment>
            <expr_stmt><expr><call><name>latencyModePrint</name><argument_list>(<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><name>avg</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>latency_history</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>latencyModePrint</name><argument_list>(<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><name>avg</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>history_start</name> <operator>&gt;</operator> <name><name>config</name><operator>.</operator><name>interval</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>latencyModePrint</name><argument_list>(<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><name>avg</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>latency_history</name></name> <operator>&amp;&amp;</operator> <call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>history_start</name> <operator>&gt;</operator> <name>history_interval</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -- %.2f seconds range\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>history_start</name><operator>)</operator><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>history_start</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>min</name> <operator>=</operator> <name>max</name> <operator>=</operator> <name>tot</name> <operator>=</operator> <name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>LATENCY_SAMPLE_RATE</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Latency distribution mode -- requires 256 colors xterm
 *--------------------------------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LATENCY_DIST_DEFAULT_INTERVAL</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define> <comment type="block">/* milliseconds. */</comment>

<comment type="block">/* Structure to store samples distribution. */</comment>
<struct>struct <name>distsamples</name> <block>{
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>max</name></decl>;</decl_stmt>   <comment type="block">/* Max latency to fit into this interval (usec). */</comment>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name></decl>;</decl_stmt> <comment type="block">/* Number of samples in this interval. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>character</name></decl>;</decl_stmt>   <comment type="block">/* Associated character in visualization. */</comment>
}</block>;</struct>

<comment type="block">/* Helper function for latencyDistMode(). Performs the spectrum visualization
 * of the collected samples targeting an xterm 256 terminal.
 *
 * Takes an array of distsamples structures, ordered from smaller to bigger
 * 'max' value. Last sample max must be 0, to mean that it olds all the
 * samples greater than the previous one, and is also the stop sentinel.
 *
 * "tot' is the total number of samples in the different buckets, so it
 * is the SUM(samples[i].conut) for i to 0 up to the max sample.
 *
 * As a side effect the function sets all the buckets count to 0. */</comment>
<function><type><name>void</name></type> <name>showLatencyDistSamples</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>distsamples</name></name> <modifier>*</modifier></type><name>samples</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>tot</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

     <comment type="block">/* We convert samples into a index inside the palette
     * proportional to the percentage a given bucket represents.
     * This way intensity of the different parts of the spectrum
     * don't change relative to the number of requests, which avoids to
     * pollute the visualization with non-latency related info. */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033[38;5;0m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Set foreground color to black. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>coloridx</name> <init>=
            <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>float</name><operator>)</operator> <name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <name>tot</name> <operator>*</operator> <operator>(</operator><name>spectrum_palette_size</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
        <name>int</name></type> <name>color</name> <init>= <expr><name><name>spectrum_palette</name><index>[<expr><name>coloridx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033[48;5;%dm%c"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>color</name></expr></argument>, <argument><expr><name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>character</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Last sample. */</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033[0m\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Show the legend: different buckets values and colors meaning, so
 * that the spectrum is more easily readable. */</comment>
<function><type><name>void</name></type> <name>showLatencyDistLegend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"---------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">". - * #          .01 .125 .25 .5 milliseconds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"1,2,3,...,9      from 1 to 9     milliseconds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"A,B,C,D,E        10,20,30,40,50  milliseconds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,&gt;60 seconds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"From 0 to 100%%: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>spectrum_palette_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033[48;5;%dm "</literal></expr></argument>, <argument><expr><name><name>spectrum_palette</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033[0m\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"---------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>latencyDistMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>latency</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>history_interval</name> <init>=
        <expr><ternary><condition><expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>config</name><operator>.</operator><name>interval</name></name><operator>/</operator><literal type="number">1000</literal></expr> </then><else>:
                          <expr><name>LATENCY_DIST_DEFAULT_INTERVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>history_start</name> <init>= <expr><call><name>ustime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>outputs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>distsamples</name></name></type> <name><name>samples</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/* We use a mostly logarithmic scale, with certain linear intervals
         * which are more interesting than others, like 1-10 milliseconds
         * range. */</comment>
        <expr><block>{<expr><literal type="number">10</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'.'</literal></expr>}</block></expr>,         <comment type="block">/* 0.01 ms */</comment>
        <expr><block>{<expr><literal type="number">125</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'-'</literal></expr>}</block></expr>,        <comment type="block">/* 0.125 ms */</comment>
        <expr><block>{<expr><literal type="number">250</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'*'</literal></expr>}</block></expr>,        <comment type="block">/* 0.25 ms */</comment>
        <expr><block>{<expr><literal type="number">500</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'#'</literal></expr>}</block></expr>,        <comment type="block">/* 0.5 ms */</comment>
        <expr><block>{<expr><literal type="number">1000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'1'</literal></expr>}</block></expr>,       <comment type="block">/* 1 ms */</comment>
        <expr><block>{<expr><literal type="number">2000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'2'</literal></expr>}</block></expr>,       <comment type="block">/* 2 ms */</comment>
        <expr><block>{<expr><literal type="number">3000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'3'</literal></expr>}</block></expr>,       <comment type="block">/* 3 ms */</comment>
        <expr><block>{<expr><literal type="number">4000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'4'</literal></expr>}</block></expr>,       <comment type="block">/* 4 ms */</comment>
        <expr><block>{<expr><literal type="number">5000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'5'</literal></expr>}</block></expr>,       <comment type="block">/* 5 ms */</comment>
        <expr><block>{<expr><literal type="number">6000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'6'</literal></expr>}</block></expr>,       <comment type="block">/* 6 ms */</comment>
        <expr><block>{<expr><literal type="number">7000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'7'</literal></expr>}</block></expr>,       <comment type="block">/* 7 ms */</comment>
        <expr><block>{<expr><literal type="number">8000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'8'</literal></expr>}</block></expr>,       <comment type="block">/* 8 ms */</comment>
        <expr><block>{<expr><literal type="number">9000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'9'</literal></expr>}</block></expr>,       <comment type="block">/* 9 ms */</comment>
        <expr><block>{<expr><literal type="number">10000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'A'</literal></expr>}</block></expr>,      <comment type="block">/* 10 ms */</comment>
        <expr><block>{<expr><literal type="number">20000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'B'</literal></expr>}</block></expr>,      <comment type="block">/* 20 ms */</comment>
        <expr><block>{<expr><literal type="number">30000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'C'</literal></expr>}</block></expr>,      <comment type="block">/* 30 ms */</comment>
        <expr><block>{<expr><literal type="number">40000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'D'</literal></expr>}</block></expr>,      <comment type="block">/* 40 ms */</comment>
        <expr><block>{<expr><literal type="number">50000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'E'</literal></expr>}</block></expr>,      <comment type="block">/* 50 ms */</comment>
        <expr><block>{<expr><literal type="number">100000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'F'</literal></expr>}</block></expr>,     <comment type="block">/* 0.1 s */</comment>
        <expr><block>{<expr><literal type="number">200000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'G'</literal></expr>}</block></expr>,     <comment type="block">/* 0.2 s */</comment>
        <expr><block>{<expr><literal type="number">300000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'H'</literal></expr>}</block></expr>,     <comment type="block">/* 0.3 s */</comment>
        <expr><block>{<expr><literal type="number">400000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'I'</literal></expr>}</block></expr>,     <comment type="block">/* 0.4 s */</comment>
        <expr><block>{<expr><literal type="number">500000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'J'</literal></expr>}</block></expr>,     <comment type="block">/* 0.5 s */</comment>
        <expr><block>{<expr><literal type="number">1000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'K'</literal></expr>}</block></expr>,    <comment type="block">/* 1 s */</comment>
        <expr><block>{<expr><literal type="number">2000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'L'</literal></expr>}</block></expr>,    <comment type="block">/* 2 s */</comment>
        <expr><block>{<expr><literal type="number">4000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'M'</literal></expr>}</block></expr>,    <comment type="block">/* 4 s */</comment>
        <expr><block>{<expr><literal type="number">8000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'N'</literal></expr>}</block></expr>,    <comment type="block">/* 8 s */</comment>
        <expr><block>{<expr><literal type="number">16000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'O'</literal></expr>}</block></expr>,   <comment type="block">/* 16 s */</comment>
        <expr><block>{<expr><literal type="number">30000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'P'</literal></expr>}</block></expr>,   <comment type="block">/* 30 s */</comment>
        <expr><block>{<expr><literal type="number">60000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'Q'</literal></expr>}</block></expr>,   <comment type="block">/* 1 minute */</comment>
        <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="char">'?'</literal></expr>}</block></expr>,          <comment type="block">/* &gt; 1 minute */</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>context</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"PING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"\nI/O error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>latency</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Populate the relevant bucket. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>max</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>latency</name> <operator>&lt;=</operator> <name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>max</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* From time to time show the spectrum. */</comment>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ustime</name><argument_list>()</argument_list></call><operator>-</operator><name>history_start</name><operator>)</operator><operator>/</operator><literal type="number">1000</literal> <operator>&gt;</operator> <name>history_interval</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputs</name><operator>++</operator> <operator>%</operator> <literal type="number">20</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>showLatencyDistLegend</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>showLatencyDistSamples</name><argument_list>(<argument><expr><name>samples</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>history_start</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>LATENCY_SAMPLE_RATE</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Slave mode
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* Sends SYNC and reads the number of bytes in the payload. Used both by
 * slaveMode() and getRDB(). */</comment>
<function><type><name>PORT_ULONGLONG</name></type> <name>sendSync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* To start we need to send the SYNC command and return the payload.
     * The hiredis client lib does not understand this part of the protocol
     * and we don't want to mess with its buffers, so everything is performed
     * using direct low-level I/O. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>

    <comment type="block">/* Send the SYNC command. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="string">"SYNC\r\n"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error writing to master\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read $&lt;payload&gt;\r\n, making sure to read just up to "\n" */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error reading bulk length while SYNCing\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>!=</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SYNC with master failed: %s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>strtoull</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>slaveMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>payload</name> <init>= <expr><call><name>sendSync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>original_output</name> <init>= <expr><name><name>config</name><operator>.</operator><name>output</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"SYNC with master, discarding %llu "</literal>
                   <literal type="string">"bytes of bulk transfer...\n"</literal></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Discard the payload. */</comment>
    <while>while<condition>(<expr><name>payload</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><ternary><condition><expr><operator>(</operator><name>payload</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><name>payload</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error reading RDB payload while SYNCing\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>payload</name> <operator>-=</operator> <name>nread</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"SYNC done. Logging commands from master.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now we can use hiredis to read the incoming protocol. */</comment>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_CSV</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>cliReadReply</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>original_output</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * RDB transfer mode
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* This function implements --rdb, so it uses the replication protocol in order
 * to fetch the RDB file from a remote server. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>getRDB</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>payload</name> <init>= <expr><call><name>sendSync</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"SYNC sent to master, writing %llu bytes to '%s'\n"</literal></expr></argument>,
        <argument><expr><name>payload</name></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write to file. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>,<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <name>STDOUT_FILENO</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>, <argument><expr><name>O_CREAT</name><operator>|</operator><name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error opening '%s': %s\n"</literal></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>rdb_filename</name></name></expr></argument>,
                <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <while>while<condition>(<expr><name>payload</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>, <decl><type ref="prev"/><name>nwritten</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><ternary><condition><expr><operator>(</operator><name>payload</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><name>payload</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"I/O Error reading RDB payload from socket\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>!=</operator> <name>nread</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error writing data to file: %s\n"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>(</operator><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"short write"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>payload</name> <operator>-=</operator> <name>nread</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close the file descriptor ASAP as fsync() may take time. */</comment>
    <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Transfer finished with success.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Bulk import (pipe) mode
 *--------------------------------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPEMODE_WRITE_LOOP_MAX_BYTES</name></cpp:macro> <cpp:value>(128*1024)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pipeMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>context</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>replies</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>obuf_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>obuf_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ibuf</name><index>[<expr><literal type="number">1024</literal><operator>*</operator><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>obuf</name><index>[<expr><literal type="number">1024</literal><operator>*</operator><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Input and output buffers */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>aneterr</name><index>[<expr><name>ANET_ERR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReader</name> <modifier>*</modifier></type><name>reader</name> <init>= <expr><call><name>redisReaderCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True once we consumed all the standard input. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Special reply we recognize. */</comment>
    <decl_stmt><decl><type><name>time_t</name></type> <name>last_read_time</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <comment type="block">/* Prevent translation or CRLF sequences. */</comment>
    <expr_stmt><expr><call><name>setmode</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                            <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast unsigned int */</comment>

    <comment type="block">/* Use non blocking I/O. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>aneterr</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ANET_ERR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Can't set the socket in non blocking mode: %s\n"</literal></expr></argument>,
            <argument><expr><name>aneterr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Transfer raw protocol and read replies from the server at the same
     * time. */</comment>
    <while>while<condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><name>AE_READABLE</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>eof</name> <operator>||</operator> <name>obuf_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>AE_WRITABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>aeWait</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>mask</name></expr></argument>,<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Handle the readable state: we can read replies from the server. */</comment>
        <if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <name>AE_READABLE</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>read_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Read from socket and feed the hiredis reader. */</comment>
            <do>do <block>{<block_content>
                <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>ibuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ibuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EAGAIN</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error reading from the server: %s\n"</literal></expr></argument>,
                        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>read_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>redisReaderFeed</name><argument_list>(<argument><expr><name>reader</name></expr></argument>,<argument><expr><name>ibuf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>last_read_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> while<condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

            <comment type="block">/* Consume replies. */</comment>
            <do>do <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>redisReaderGetReply</name><argument_list>(<argument><expr><name>reader</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error reading replies from server\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eof</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_STRING</name> <operator>&amp;&amp;</operator>
                                      <name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* Check if this is the reply to our final ECHO
                         * command. If so everything was received
                         * from the server. */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name>magic</name></expr></argument>,<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Last reply received from server.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>replies</name><operator>--</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>replies</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block> while<condition>(<expr><name>reply</name></expr>)</condition>;</do>

            <comment type="block">/* Abort on read errors. We abort here because it is important
             * to consume replies even after a read error: this way we can
             * show a potential problem to the user. */</comment>
            <if_stmt><if>if <condition>(<expr><name>read_error</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Handle the writable state: we can send protocol to the server. */</comment>
        <if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <name>AE_WRITABLE</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ssize_t</name></type> <name>loop_nwritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Transfer current buffer to server. */</comment>
                <if_stmt><if>if <condition>(<expr><name>obuf_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>obuf</name><operator>+</operator><name>obuf_pos</name></expr></argument>,<argument><expr><name>obuf_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EAGAIN</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error writing to the server: %s\n"</literal></expr></argument>,
                                <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>obuf_len</name> <operator>-=</operator> <name>nwritten</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>obuf_pos</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>loop_nwritten</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>obuf_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Can't accept more data. */</comment>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* If buffer is empty, load from stdin. */</comment>
                <if_stmt><if>if <condition>(<expr><name>obuf_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>eof</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>,<argument><expr><name>obuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <comment type="block">/* The ECHO sequence starts with a "\r\n" so that if there
                         * is garbage in the protocol we read from stdin, the ECHO
                         * will likely still be properly formatted.
                         * CRLF is ignored by Redis, so it has no effects. */</comment>
                        <decl_stmt><decl><type><name>char</name></type> <name><name>echo</name><index>[]</index></name> <init>=
                        <expr><literal type="string">"\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n"</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>eof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <comment type="block">/* Everything transferred, so we queue a special
                         * ECHO command that we can match in the replies
                         * to make sure everything was read from the server. */</comment>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>magic</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>rand</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></for>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>echo</name><operator>+</operator><literal type="number">21</literal></expr></argument>,<argument><expr><name>magic</name></expr></argument>,<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>,<argument><expr><name>echo</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>echo</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>obuf_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>echo</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>obuf_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"All data transferred. Waiting for the last reply...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error reading from stdin: %s\n"</literal></expr></argument>,
                            <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>obuf_len</name> <operator>=</operator> <name>nread</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>obuf_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>obuf_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eof</name><operator>)</operator> <operator>||</operator>
                    <name>loop_nwritten</name> <operator>&gt;</operator> <name>PIPEMODE_WRITE_LOOP_MAX_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Handle timeout, that is, we reached EOF, and we are not getting
         * replies from the server for a few seconds, nor the final ECHO is
         * received. */</comment>
        <if_stmt><if>if <condition>(<expr><name>eof</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>pipe_timeout</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>-</operator><name>last_read_time</name> <operator>&gt;</operator> <name><name>config</name><operator>.</operator><name>pipe_timeout</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"No replies for %d seconds: exiting.\n"</literal></expr></argument>,
                <argument><expr><name><name>config</name><operator>.</operator><name>pipe_timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>redisReaderFree</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"errors: %lld, replies: %lld\n"</literal></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>replies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errors</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Find big keys
 *--------------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>redisReply</name> <modifier>*</modifier></type><name>sendScan</name><parameter_list>(<parameter><decl><type><name>PORT_ULONGLONG</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"SCAN %llu"</literal></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Handle any error conditions */</comment>
    <if_stmt><if>if<condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\nI/O error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SCAN error: %s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_ARRAY</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Non ARRAY response from SCAN!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>elements</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Invalid element count from SCAN!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Validate our types are correct */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>REDIS_REPLY_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update iterator */</comment>
    <expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>reply</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getDbSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"DBSIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Couldn't determine DBSIZE!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Grab the number of keys and free our reply */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>integer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sizecmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sizeunit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>biggest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>totalsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>biggest_key</name></decl>;</decl_stmt>
}</block></struct></type> <name>typeinfo</name>;</typedef>

<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_string</name> <init>= <expr><block>{ <expr><literal type="string">"string"</literal></expr>, <expr><literal type="string">"STRLEN"</literal></expr>, <expr><literal type="string">"bytes"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_list</name> <init>= <expr><block>{ <expr><literal type="string">"list"</literal></expr>, <expr><literal type="string">"LLEN"</literal></expr>, <expr><literal type="string">"items"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_set</name> <init>= <expr><block>{ <expr><literal type="string">"set"</literal></expr>, <expr><literal type="string">"SCARD"</literal></expr>, <expr><literal type="string">"members"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_hash</name> <init>= <expr><block>{ <expr><literal type="string">"hash"</literal></expr>, <expr><literal type="string">"HLEN"</literal></expr>, <expr><literal type="string">"fields"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_zset</name> <init>= <expr><block>{ <expr><literal type="string">"zset"</literal></expr>, <expr><literal type="string">"ZCARD"</literal></expr>, <expr><literal type="string">"members"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_stream</name> <init>= <expr><block>{ <expr><literal type="string">"stream"</literal></expr>, <expr><literal type="string">"XLEN"</literal></expr>, <expr><literal type="string">"entries"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typeinfo</name></type> <name>type_other</name> <init>= <expr><block>{ <expr><literal type="string">"other"</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"?"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>typeinfo</name><modifier>*</modifier></type> <name>typeinfo_add</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>types</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>typeinfo</name><modifier>*</modifier></type> <name>type_template</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>typeinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>info</name> <operator>=</operator> <operator>*</operator><name>type_template</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>type_free</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>priv_data</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>priv_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>biggest_key</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>biggest_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>dictType</name></type> <name>typeinfoDictType</name> <init>= <expr><block>{
    <expr><name>dictSdsHash</name></expr>,               <comment type="block">/* hash function */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key dup */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* val dup */</comment>
    <expr><name>dictSdsKeyCompare</name></expr>,         <comment type="block">/* key compare */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key destructor (owned by the value)*/</comment>
    <expr><name>type_free</name></expr>                  <comment type="block">/* val destructor */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>getKeyTypes</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>types_dict</name></decl></parameter>, <parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>typeinfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Pipeline TYPE commands */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"TYPE %s"</literal></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Retrieve types */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call><operator>!=</operator><name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error getting type for key '%s' (%d: %s)\n"</literal></expr></argument>,
                <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_STATUS</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"TYPE returned an error: %s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"Invalid reply type (%d) for TYPE on key '%s'!\n"</literal></expr></argument>,
                    <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>sds</name></type> <name>typereply</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><name>typereply</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>typereply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>de</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* create new types for modules, (but not for deleted keys) */</comment>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>getKeySizes</name><parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>typeinfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name></decl></parameter>,
                        <parameter><decl><type><name>PORT_ULONGLONG</name> <modifier>*</modifier></type><name>sizes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>memkeys</name></decl></parameter>,
                        <parameter><decl><type><name>unsigned</name></type> <name>memkeys_samples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Pipeline size commands */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Skip keys that disappeared between SCAN and TYPE (or unknown types when not in memkeys mode) */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sizecmd</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>memkeys</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>memkeys</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
                <argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sizecmd</name></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>memkeys_samples</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"%s %s %s"</literal></expr></argument>,
                <argument><expr><literal type="string">"MEMORY"</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"%s %s %s SAMPLES %u"</literal></expr></argument>,
                <argument><expr><literal type="string">"MEMORY"</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name>memkeys_samples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Retrieve sizes */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Skip keys that disappeared between SCAN and TYPE (or unknown types when not in memkeys mode) */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sizecmd</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>memkeys</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Retrieve size */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call><operator>!=</operator><name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error getting size for key '%s' (%d: %s)\n"</literal></expr></argument>,
                <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Theoretically the key could have been removed and
             * added as a different type between TYPE and SIZE */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr><literal type="string">"Warning:  %s on '%s' failed (may have changed type)\n"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><operator>!</operator><name>memkeys</name></expr>?</condition><then> <expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sizecmd</name></expr></then><else>: <expr><literal type="string">"MEMORY USAGE"</literal></expr></else></ternary></expr></argument>,
                <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>integer</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>findBigKeys</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memkeys</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>memkeys_samples</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>sampled</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>total_keys</name></decl>, <decl><type ref="prev"/><name>totlen</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sizes</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>it</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>arrsize</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>pct</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>types_dict</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typeinfoDictType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><literal type="string">"zset"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_zset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>typeinfo_add</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><literal type="string">"stream"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Total keys pre scanning */</comment>
    <expr_stmt><expr><name>total_keys</name> <operator>=</operator> <call><name>getDbSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Status message */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n# Scanning the entire keyspace to find biggest keys as well as\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"# per 100 SCAN commands (not usually needed).\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* SCAN loop */</comment>
    <do>do <block>{<block_content>
        <comment type="block">/* Calculate approximate percentage completion */</comment>
        <expr_stmt><expr><name>pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>sampled</name><operator>/</operator><name>total_keys</name></expr>;</expr_stmt>

        <comment type="block">/* Grab some keys and point to the keys array */</comment>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>sendScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>keys</name>  <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Reallocate our type and size array if we need to */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name> <operator>&gt;</operator> <name>arrsize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>typeinfo</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sizes</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>sizes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PORT_ULONGLONG</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>types</name> <operator>||</operator> <operator>!</operator><name>sizes</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate storage for keys!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>arrsize</name> <operator>=</operator> <name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Retrieve types and then sizes */</comment>
        <expr_stmt><expr><call><name>getKeyTypes</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getKeySizes</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>sizes</name></expr></argument>, <argument><expr><name>memkeys</name></expr></argument>, <argument><expr><name>memkeys_samples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now update our stats */</comment>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Skip keys that disappeared between SCAN and TYPE */</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>type</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>totalsize</name></name> <operator>+=</operator> <name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>totlen</name> <operator>+=</operator> <name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sampled</name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>biggest</name></name><operator>&lt;</operator><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(
                   <argument><expr><literal type="string">"[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\n"</literal></expr></argument>,
                   <argument><expr><name>pct</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                   <argument><expr><ternary><condition><expr><operator>!</operator><name>memkeys</name></expr>?</condition><then> <expr><name><name>type</name><operator>-&gt;</operator><name>sizeunit</name></name></expr></then><else>: <expr><literal type="string">"bytes"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Keep track of biggest key name for this type */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>biggest_key</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>biggest_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>biggest_key</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>type</name><operator>-&gt;</operator><name>biggest_key</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate memory for key!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Keep track of the biggest size for this type */</comment>
                <expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>biggest</name></name> <operator>=</operator> <name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Update overall progress */</comment>
            <if_stmt><if>if<condition>(<expr><name>sampled</name> <operator>%</operator> <literal type="number">1000000</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%05.2f%%] Sampled %llu keys so far\n"</literal></expr></argument>, <argument><expr><name>pct</name></expr></argument>, <argument><expr><name>sampled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Sleep if we've been directed to do so */</comment>
        <if_stmt><if>if<condition>(<expr><name>sampled</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sampled</name> <operator>%</operator><literal type="number">100</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>interval</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><name>it</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <if_stmt><if>if<condition>(<expr><name>types</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>sizes</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We're done */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n-------- summary -------\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Sampled %llu keys in the keyspace!\n"</literal></expr></argument>, <argument><expr><name>sampled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Total key length in bytes is %llu (avg len %.2f)\n\n"</literal></expr></argument>,
       <argument><expr><name>totlen</name></expr></argument>, <argument><expr><ternary><condition><expr><name>totlen</name></expr> ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator><name>totlen</name><operator>/</operator><name>sampled</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Output the biggest keys we found, for types we did find */</comment>
    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>biggest_key</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Biggest %6s found '%s' has %llu %s\n"</literal></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>biggest_key</name></name></expr></argument>,
               <argument><expr><name><name>type</name><operator>-&gt;</operator><name>biggest</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>memkeys</name></expr>?</condition><then> <expr><name><name>type</name><operator>-&gt;</operator><name>sizeunit</name></name></expr></then><else>: <expr><literal type="string">"bytes"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>typeinfo</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\n"</literal></expr></argument>,
           <argument><expr><name><name>type</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>totalsize</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>memkeys</name></expr>?</condition><then> <expr><name><name>type</name><operator>-&gt;</operator><name>sizeunit</name></name></expr></then><else>: <expr><literal type="string">"bytes"</literal></expr></else></ternary></expr></argument>,
           <argument><expr><ternary><condition><expr><name>sampled</name></expr> ?</condition><then> <expr><literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>type</name><operator>-&gt;</operator><name>count</name></name><operator>/</operator><name>sampled</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>type</name><operator>-&gt;</operator><name>count</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator><name><name>type</name><operator>-&gt;</operator><name>totalsize</name></name><operator>/</operator><name><name>type</name><operator>-&gt;</operator><name>count</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>types_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Success! */</comment>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>getKeyFreqs</name><parameter_list>(<parameter><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONGLONG</name> <modifier>*</modifier></type><name>freqs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Pipeline OBJECT freq commands */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"OBJECT freq %s"</literal></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Retrieve freqs */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call><operator>!=</operator><name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error getting freq for key '%s' (%d: %s)\n"</literal></expr></argument>,
                <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>errstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDIS_REPLY_INTEGER</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Warning: OBJECT freq on '%s' failed (may have been deleted)\n"</literal></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>integer</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOTKEYS_SAMPLE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>findHotKeys</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>keys</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name><name>counters</name><index>[<expr><name>HOTKEYS_SAMPLE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name><name>hotkeys</name><index>[<expr><name>HOTKEYS_SAMPLE</name></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>sampled</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>total_keys</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>freqs</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>it</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>arrsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>pct</name></decl>;</decl_stmt>

    <comment type="block">/* Total keys pre scanning */</comment>
    <expr_stmt><expr><name>total_keys</name> <operator>=</operator> <call><name>getDbSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Status message */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n# Scanning the entire keyspace to find hot keys as well as\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"# per 100 SCAN commands (not usually needed).\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* SCAN loop */</comment>
    <do>do <block>{<block_content>
        <comment type="block">/* Calculate approximate percentage completion */</comment>
        <expr_stmt><expr><name>pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>sampled</name><operator>/</operator><name>total_keys</name></expr>;</expr_stmt>

        <comment type="block">/* Grab some keys and point to the keys array */</comment>
        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>sendScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>keys</name>  <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Reallocate our freqs array if we need to */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name> <operator>&gt;</operator> <name>arrsize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>freqs</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>freqs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PORT_ULONGLONG</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>freqs</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate storage for keys!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>arrsize</name> <operator>=</operator> <name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>getKeyFreqs</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>freqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now update our stats */</comment>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>keys</name><operator>-&gt;</operator><name>elements</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>sampled</name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* Update overall progress */</comment>
            <if_stmt><if>if<condition>(<expr><name>sampled</name> <operator>%</operator> <literal type="number">1000000</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%05.2f%%] Sampled %llu keys so far\n"</literal></expr></argument>, <argument><expr><name>pct</name></expr></argument>, <argument><expr><name>sampled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Use eviction pool here */</comment>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>k</name> <argument_list type="generic">&lt; <argument><expr><name>HOTKEYS_SAMPLE</name> <operator>&amp;&amp;</operator> <name><name>freqs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> &gt;</argument_list></name> <name><name>counters</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>counters</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>hotkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>hotkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>counters</name></expr></argument>,<argument><expr><name>counters</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>counters</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>hotkeys</name></expr></argument>,<argument><expr><name>hotkeys</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hotkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>counters</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>freqs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hotkeys</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(
               <argument><expr><literal type="string">"[%05.2f%%] Hot key '%s' found so far with counter %llu\n"</literal></expr></argument>,
               <argument><expr><name>pct</name></expr></argument>, <argument><expr><name><name>keys</name><operator>-&gt;</operator><name>element</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name><name>freqs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Sleep if we've been directed to do so */</comment>
        <if_stmt><if>if<condition>(<expr><name>sampled</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sampled</name> <operator>%</operator><literal type="number">100</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>interval</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><name>it</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><name>freqs</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>freqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We're done */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n-------- summary -------\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Sampled %llu keys in the keyspace!\n"</literal></expr></argument>, <argument><expr><name>sampled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator> <name>HOTKEYS_SAMPLE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name>HOTKEYS_SAMPLE</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>counters</name><index>[<expr><name>k</name></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"hot key found with counter: %llu\tkeyname: %s\n"</literal></expr></argument>, <argument><expr><name><name>counters</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>hotkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>hotkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Stats mode
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return the specified INFO field from the INFO command output "info".
 * A new buffer is allocated for the result, that needs to be free'd.
 * If the field is not found NULL is returned. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getInfoField</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>info</name></expr></argument>,<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n2</name> <operator>&amp;&amp;</operator> <name>n2</name> <operator>&lt;</operator> <name>n1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n1</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>n1</name><operator>-</operator><name>p</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>n1</name><operator>-</operator><name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>n1</name><operator>-</operator><name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like the above function but automatically convert the result into
 * a long. On error (missing field) LONG_MIN is returned. */</comment>
<function><type><specifier>static</specifier> <name>PORT_LONG</name></type> <name>getLongInfoField</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>getInfoField</name><argument_list>(<argument><expr><name>info</name></expr></argument>,<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>l</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PORT_LONG_MIN</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert number of bytes into a human readable string of the form:
 * 100B, 2G, 100M, 4K, and so forth. */</comment>
<function><type><name>void</name></type> <name>bytesToHuman</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Bytes */</comment>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"%lldB"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>n</name><operator>/</operator><operator>(</operator><literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"%.2fK"</literal></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1024LL</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>n</name><operator>/</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"%.2fM"</literal></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1024LL</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>n</name><operator>/</operator><operator>(</operator><literal type="number">1024LL</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">"%.2fG"</literal></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>statMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>aux</name></decl>, <decl><type ref="prev"/><name>requests</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>reconnectingRedisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: %s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name><operator>++</operator> <operator>%</operator> <literal type="number">20</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"------- data ------ --------------------- load -------------------- - child -\n"</literal>
<literal type="string">"keys       mem      clients blocked requests            connections          \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Keys */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>k</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"db%d:keys"</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <name>PORT_LONG_MIN</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>aux</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%Id"</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                      <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* %ld -&gt; %Id */</comment>
        <name>printf</name><argument_list>(<argument><expr><literal type="string">"%-11s"</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="block">/* Used memory */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"used_memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bytesToHuman</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-8s"</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clients */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"connected_clients"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%Id"</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                      <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* %ld -&gt; %Id */</comment>
        <name>printf</name><argument_list>(<argument><expr><literal type="string">" %-8s"</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="block">/* Blocked (BLPOPPING) Clients */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"blocked_clients"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%Id"</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                      <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* %ld -&gt; %Id */</comment>
        <name>printf</name><argument_list>(<argument><expr><literal type="string">"%-8s"</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="block">/* Requests */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"total_commands_processed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%Id (+%Id)"</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>,<argument><expr><ternary><condition><expr><name>requests</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>aux</name><operator>-</operator><name>requests</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* %ld -&gt; %Id */</comment>
        <name>printf</name><argument_list>(<argument><expr><literal type="string">"%-19s"</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>requests</name> <operator>=</operator> <name>aux</name></expr>;</expr_stmt>

        <comment type="block">/* Connections */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"total_connections_received"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%Id"</literal></expr></argument>,<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                       <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* %ld -&gt; %Id */</comment>
        <name>printf</name><argument_list>(<argument><expr><literal type="string">" %-12s"</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="block">/* Children */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"bgsave_in_progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aux</name> <operator>|=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"aof_rewrite_in_progress"</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>aux</name> <operator>|=</operator> <call><name>getLongInfoField</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,<argument><expr><literal type="string">"loading"</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>aux</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case> <break>break;</break>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SAVE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"AOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">3</literal></expr>:</case>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SAVE+AOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">4</literal></expr>:</case>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"LOAD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>

        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Scan mode
 *--------------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>scanMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>cur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>pattern</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"SCAN %llu MATCH %s"</literal></expr></argument>,
                <argument><expr><name>cur</name></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>redisCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"SCAN %llu"</literal></expr></argument>,<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"I/O error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDIS_REPLY_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: %s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>elements</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>element</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>element</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>freeReplyObject</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><name>cur</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * LRU test mode
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return an integer from min to max (both inclusive) using a power-law
 * distribution, depending on the value of alpha: the greater the alpha
 * the more bias towards lower values.
 *
 * With alpha = 6.2 the output follows the 80-20 rule where 20% of
 * the returned numbers will account for 80% of the frequency. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>powerLawRand</name><parameter_list>(<parameter><decl><type><name>PORT_LONGLONG</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>alpha</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>pl</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>max</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>/</operator> <name>RAND_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pl</name> <operator>=</operator> <call><name>pow</name><argument_list>(
        <argument><expr><operator>(</operator><operator>(</operator><call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>max</name></expr></argument>,<argument><expr><name>alpha</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>min</name></expr></argument>,<argument><expr><name>alpha</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>*</operator><name>r</name> <operator>+</operator> <call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>min</name></expr></argument>,<argument><expr><name>alpha</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><call><name>WIN_PORT_FIX</name> <comment type="block">/* cast (double) */</comment>
        <argument_list>(<argument><expr><literal type="number">1.0</literal><operator>/</operator><operator>(</operator><name>alpha</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>max</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name>pl</name><operator>)</operator><operator>+</operator><name>min</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generates a key name among a set of lru_test_sample_size keys, using
 * an 80-20 distribution. */</comment>
<function><type><name>void</name></type> <name>LRUTestGenKey</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"lru:%lld"</literal></expr></argument>,
        <argument><expr><call><name>powerLawRand</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>lru_test_sample_size</name></name></expr></argument>, <argument><expr><literal type="number">6.2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LRU_CYCLE_PERIOD</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define> <comment type="block">/* 1000 milliseconds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LRU_CYCLE_PIPELINE_SIZE</name></cpp:macro> <cpp:value>250</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LRUTestMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisReply</name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start_cycle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>^</operator><call><name>getpid</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                   <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (unsigned int) */</comment>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Perform cycles of 1 second with 50% writes and 50% reads.
         * We use pipelining batching writes / reads N times per cycle in order
         * to fill the target instance easily. */</comment>
        <expr_stmt><expr><name>start_cycle</name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>misses</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start_cycle</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Write cycle. */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LRU_CYCLE_PIPELINE_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name><name>val</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>val</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'A'</literal><operator>+</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>%</operator><operator>(</operator><literal type="char">'z'</literal><operator>-</operator><literal type="char">'A'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
                <expr_stmt><expr><call><name>LRUTestGenKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"SET %s %s"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LRU_CYCLE_PIPELINE_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <comment type="block">/* Read cycle. */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LRU_CYCLE_PIPELINE_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>LRUTestGenKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>redisAppendCommand</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"GET %s"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LRU_CYCLE_PIPELINE_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>redisGetReply</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>reply</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_OK</name></expr>)</condition> <block>{<block_content>
                    <switch>switch<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
                        <case>case <expr><name>REDIS_REPLY_ERROR</name></expr>:</case>
                            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>REDIS_REPLY_NIL</name></expr>:</case>
                            <expr_stmt><expr><name>misses</name><operator>++</operator></expr>;</expr_stmt>
                            <break>break;</break>
                        <default>default:</default>
                            <expr_stmt><expr><name>hits</name><operator>++</operator></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"I/O error during LRU test\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Print stats. */</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(
            <argument><expr><literal type="string">"%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\n"</literal></expr></argument>,
            <argument><expr><name>hits</name><operator>+</operator><name>misses</name></expr></argument>,
            <argument><expr><name>hits</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>hits</name><operator>/</operator><operator>(</operator><name>hits</name><operator>+</operator><name>misses</name><operator>)</operator><operator>*</operator><literal type="number">100</literal></expr></argument>,
            <argument><expr><name>misses</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>misses</name><operator>/</operator><operator>(</operator><name>hits</name><operator>+</operator><name>misses</name><operator>)</operator><operator>*</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Intrisic latency mode.
 *
 * Measure max latency of a running process that does not result from
 * syscalls. Basically this software should provide an hint about how much
 * time the kernel leaves the process without a chance to run.
 *--------------------------------------------------------------------------- */</comment>

<comment type="block">/* This is just some computation the compiler can't optimize out.
 * Should run in less than 100-200 microseconds even using very
 * slow hardware. Runs in less than 10 microseconds in modern HW. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>compute_something_fast</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>s</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>output</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>j</name> <operator>+</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>output</name> <operator>+=</operator> <name><name>s</name><index>[<expr><operator>(</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>&amp;</operator><literal type="number">255</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>output</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>intrinsicLatencyModeStop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>force_cancel_loop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>intrinsicLatencyMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>test_end</name></decl>, <decl><type ref="prev"/><name>run_time</name></decl>, <decl><type ref="prev"/><name>max_latency</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>run_time</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name><name>config</name><operator>.</operator><name>intrinsic_latency_duration</name></name><operator>)</operator><operator>*</operator><literal type="number">1000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>test_end</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call> <operator>+</operator> <name>run_time</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>intrinsicLatencyModeStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>latency</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>compute_something_fast</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>latency</name> <operator>=</operator> <name>end</name><operator>-</operator><name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>runs</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>latency</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Reporting */</comment>
        <if_stmt><if>if <condition>(<expr><name>latency</name> <operator>&gt;</operator> <name>max_latency</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>max_latency</name> <operator>=</operator> <name>latency</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Max latency so far: %lld microseconds.\n"</literal></expr></argument>, <argument><expr><name>max_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>avg_us</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>run_time</name><operator>/</operator><name>runs</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>avg_ns</name> <init>= <expr><name>avg_us</name> <operator>*</operator> <literal type="number">1e3</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>force_cancel_loop</name> <operator>||</operator> <name>end</name> <operator>&gt;</operator> <name>test_end</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%lld total runs "</literal>
                <literal type="string">"(avg latency: "</literal>
                <literal type="string">"%.4f microseconds / %.2f nanoseconds per run).\n"</literal></expr></argument>,
                <argument><expr><name>runs</name></expr></argument>, <argument><expr><name>avg_us</name></expr></argument>, <argument><expr><name>avg_ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Worst run took %.0fx longer than the average latency.\n"</literal></expr></argument>,
                <argument><expr><name>max_latency</name> <operator>/</operator> <name>avg_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------------
 * Program main()
 *--------------------------------------------------------------------------- */</comment>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>firstarg</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>used_memory_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostip</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostport</name></name> <operator>=</operator> <literal type="number">6379</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hostsocket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>dbnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interactive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>shutdown</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>monitor_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pubsub_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_dist_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>latency_history</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>lru_test_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>lru_test_sample_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>getrdb_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>stat_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>scan_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>intrinsic_latency_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pattern</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>rdb_filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pipe_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>pipe_timeout</name></name> <operator>=</operator> <name>REDIS_CLI_DEFAULT_PIPE_TIMEOUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>bigkeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>hotkeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>stdinarg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>auth</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>eval_ldb_sync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>enable_ldb_on_eval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>last_cmd_type</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>verbose</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>no_auth_warning</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>replicas</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>from</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>weight_argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>slots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name>CLUSTER_MANAGER_MIGRATE_TIMEOUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>pipeline</name></name> <operator>=</operator> <name>CLUSTER_MANAGER_MIGRATE_PIPELINE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>cluster_manager_command</name><operator>.</operator><name>threshold</name></name> <operator>=</operator>
        <name>CLUSTER_MANAGER_REBALANCE_THRESHOLD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pref</name><operator>.</operator><name>hints</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>spectrum_palette</name> <operator>=</operator> <name>spectrum_palette_color</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spectrum_palette_size</name> <operator>=</operator> <name>spectrum_palette_color_size</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"FAKETTY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_RAW</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>config</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>OUTPUT_STANDARD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>config</name><operator>.</operator><name>mb_delim</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>firstarg</name> <operator>=</operator> <call><name>parseOptions</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>firstarg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>firstarg</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>parseEnv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Cluster Manager mode */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CLUSTER_MANAGER_MODE</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterManagerCommandProc</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>validateClusterManagerCommand</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>mb_delim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>clusterManagerMode</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Latency mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>latency_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>latencyMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Latency distribution mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>latency_dist_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>latencyDistMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Slave mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>slave_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>slaveMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get RDB mode. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>getrdb_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>getRDB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Pipe mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>pipe_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pipeMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find big keys */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>bigkeys</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>findBigKeys</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find large keys */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>memkeys</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>findBigKeys</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>memkeys_samples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find hot keys */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>hotkeys</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>findHotKeys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Stat mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>stat_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>config</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>statMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Scan mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>scan_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>scanMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* LRU test mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>lru_test_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDIS_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>LRUTestMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Intrinsic latency mode */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>intrinsic_latency_mode</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>intrinsicLatencyMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Start interactive mode when no command is provided */</comment>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>config</name><operator>.</operator><name>eval</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Ignore SIGPIPE in interactive mode to force a reconnect */</comment>
        <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note that in repl mode we don't abort on connection error.
         * A new attempt will be performed for every command send. */</comment>
        <expr_stmt><expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>repl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise, we have some arguments to execute */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cliConnect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDIS_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>eval</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>evalMode</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>noninteractive</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><call><name>convertToSds</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
