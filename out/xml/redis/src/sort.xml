<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/sort.c"><comment type="block">/* SORT command and helper functions.
 *
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqsort.h"</cpp:file></cpp:include> <comment type="block">/* Partial qsort for SORT+LIMIT */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include> <comment type="block">/* isnan() */</comment>

<function_decl><type><name>zskiplistNode</name><modifier>*</modifier></type> <name>zslGetElementByRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name></type> <name>rank</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>redisSortOperation</name> <modifier>*</modifier></type><name>createSortOperation</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>redisSortOperation</name> <modifier>*</modifier></type><name>so</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>so</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
    <return>return <expr><name>so</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the value associated to the key with a name obtained using
 * the following rules:
 *
 * 1) The first occurrence of '*' in 'pattern' is substituted with 'subst'.
 *
 * 2) If 'pattern' matches the "-&gt;" string, everything on the left of
 *    the arrow is treated as the name of a hash field, and the part on the
 *    left as the key name containing a hash. The value of the specified
 *    field is returned.
 *
 * 3) If 'pattern' equals "#", the function simply returns 'subst' itself so
 *    that the SORT command can be used like: SORT key GET # to retrieve
 *    the Set/List elements directly.
 *
 * The returned object will always have its refcount increased by 1
 * when it is non-NULL. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>lookupKeyByPattern</name><parameter_list>(<parameter><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>subst</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>f</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>spat</name></decl>, <decl><type ref="prev"/><name>ssub</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>keyobj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fieldobj</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>prefixlen</name></decl>, <decl><type ref="prev"/><name>sublen</name></decl>, <decl><type ref="prev"/><name>postfixlen</name></decl>, <decl><type ref="prev"/><name>fieldlen</name></decl>;</decl_stmt>

    <comment type="block">/* If the pattern is "#" return the substitution object itself in order
     * to implement the "SORT ... GET #" feature. */</comment>
    <expr_stmt><expr><name>spat</name> <operator>=</operator> <name><name>pattern</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>spat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>spat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>subst</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The substitution object may be specially encoded. If so we create
     * a decoded object on the fly. Otherwise getDecodedObject will just
     * increment the ref count, that we'll decrement later. */</comment>
    <expr_stmt><expr><name>subst</name> <operator>=</operator> <call><name>getDecodedObject</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ssub</name> <operator>=</operator> <name><name>subst</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <comment type="block">/* If we can't find '*' in the pattern we return NULL as to GET a
     * fixed key does not make sense. */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>spat</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find out if we're dealing with a hash dereference. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"-&gt;"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>f</name><operator>+</operator><literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fieldlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call><operator>-</operator><operator>(</operator><name>f</name><operator>-</operator><name>spat</name><operator>)</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>                              <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
        <name>fieldobj</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>f</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>fieldlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>fieldlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Perform the '*' substitution. */</comment>
    <expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>spat</name><operator>)</operator></expr>;</expr_stmt>                                                  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
    <name>sublen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>ssub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                                                 <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
    <name>postfixlen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call><operator>-</operator><operator>(</operator><name>prefixlen</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><operator>(</operator><ternary><condition><expr><name>fieldlen</name></expr> ?</condition><then> <expr><name>fieldlen</name><operator>+</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (int) */</comment>
    <name>keyobj</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>prefixlen</name><operator>+</operator><name>sublen</name><operator>+</operator><name>postfixlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>keyobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>k</name></expr></argument>,<argument><expr><name>spat</name></expr></argument>,<argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>k</name><operator>+</operator><name>prefixlen</name></expr></argument>,<argument><expr><name>ssub</name></expr></argument>,<argument><expr><name>sublen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>k</name><operator>+</operator><name>prefixlen</name><operator>+</operator><name>sublen</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>postfixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Incremented by decodeObject() */</comment>

    <comment type="block">/* Lookup substituted key */</comment>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>noobj</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fieldobj</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_HASH</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>noobj</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Retrieve value from hash by the field name. The returend object
         * is a new object with refcount already incremented. */</comment>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>hashTypeGetValueObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>fieldobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_STRING</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>noobj</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Every object that this function returns needs to have its refcount
         * increased. sortCommand decreases it again. */</comment>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fieldobj</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>fieldobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>

<label><name>noobj</name>:</label>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fieldlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>fieldobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* sortCompare() is used by qsort in sortCommand(). Given that qsort_r with
 * the additional parameter is not standard but a BSD-specific we have to
 * pass sorting parameters via the global 'server' structure */</comment>
<function><type><name>int</name></type> <name>sortCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>redisSortObject</name> <modifier>*</modifier></type><name>so1</name> <init>= <expr><name>s1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>so2</name> <init>= <expr><name>s2</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>sort_alpha</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Numeric sorting. Here it's trivial as we precomputed scores */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>score</name></name> <operator>&gt;</operator> <name><name>so2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>score</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>score</name></name> <operator>&lt;</operator> <name><name>so2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>score</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Objects have the same score, but we don't want the comparison
             * to be undefined, so we compare objects lexicographically.
             * This way the result of SORT is deterministic. */</comment>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compareStringObjects</name><argument_list>(<argument><expr><name><name>so1</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>,<argument><expr><name><name>so2</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Alphanumeric sorting */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>sort_bypattern</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>||</operator> <operator>!</operator><name><name>so2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* At least one compare object is NULL */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>==</operator> <name><name>so2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* We have both the objects, compare them. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>sort_store</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compareStringObjects</name><argument_list>(<argument><expr><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name></expr></argument>,<argument><expr><name><name>so2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* Here we can use strcoll() directly as we are sure that
                     * the objects are decoded string objects. */</comment>
                    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>strcoll</name><argument_list>(<argument><expr><name><name>so1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>so2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>cmpobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Compare elements directly. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>sort_store</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compareStringObjects</name><argument_list>(<argument><expr><name><name>so1</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>,<argument><expr><name><name>so2</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>collateStringObjects</name><argument_list>(<argument><expr><name><name>so1</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>,<argument><expr><name><name>so2</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>sort_desc</name></name></expr> ?</condition><then> <expr><operator>-</operator><name>cmp</name></expr> </then><else>: <expr><name>cmp</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The SORT command is the most complex command in Redis. Warning: this code
 * is optimized for speed and a bit less for readability */</comment>
<function><type><name>void</name></type> <name>sortCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>operations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>outputlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>desc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>alpha</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>limit_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>limit_count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>dontsort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>vectorlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>getop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* GET operation counter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>int_conversion_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>syntax_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>sortval</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sortby</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>storekey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisSortObject</name> <modifier>*</modifier></type><name>vector</name></decl>;</decl_stmt> <comment type="block">/* Resulting vector to sort */</comment>

    <comment type="block">/* Lookup the key to sort. It must be of the right types */</comment>
    <expr_stmt><expr><name>sortval</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sortval</name> <operator>&amp;&amp;</operator> <name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_SET</name> <operator>&amp;&amp;</operator>
                   <name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_LIST</name> <operator>&amp;&amp;</operator>
                   <name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a list of operations to perform for every sorted element.
     * Operations can be GET */</comment>
    <expr_stmt><expr><name>operations</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name>operations</name></expr></argument>,<argument><expr><name>zfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* options start at argv[2] */</comment>

    <comment type="block">/* Now we need to protect sortval incrementing its count, in the future
     * SORT may have options able to overwrite/delete keys during the sorting
     * and the sorted key itself may get destroyed */</comment>
    <if_stmt><if>if <condition>(<expr><name>sortval</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>sortval</name> <operator>=</operator> <call><name>createQuicklistObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* The SORT command has an SQL-alike syntax, parse it */</comment>
    <while>while<condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>leftargs</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"asc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"desc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"alpha"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>alpha</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>leftargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                 <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit_count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                 <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>syntax_error</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>j</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"store"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>leftargs</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>storekey</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"by"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>leftargs</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sortby</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <comment type="block">/* If the BY pattern does not contain '*', i.e. it is constant,
             * we don't need to sort nor to lookup the weight keys. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>dontsort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* If BY is specified with a real patter, we can't accept
                 * it in cluster mode. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"BY option of SORT denied in Cluster mode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>syntax_error</name><operator>++</operator></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"get"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>leftargs</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"GET option of SORT denied in Cluster mode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>syntax_error</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>operations</name></expr></argument>,<argument><expr><call><name>createSortOperation</name><argument_list>(
                <argument><expr><name>SORT_OP_GET</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>getop</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>syntax_error</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Handle syntax errors set during options parsing. */</comment>
    <if_stmt><if>if <condition>(<expr><name>syntax_error</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>operations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* When sorting a set with no sort specified, we must sort the output
     * so the result is consistent across scripting and replication.
     *
     * The other types (list, sorted set) will retain their native order
     * even if no sort order is requested, so they remain stable across
     * scripting and replication. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dontsort</name> <operator>&amp;&amp;</operator>
        <name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>storekey</name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_LUA</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Force ALPHA sorting */</comment>
        <expr_stmt><expr><name>dontsort</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>alpha</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>sortby</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Destructively convert encoded sorted sets for SORT. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>zsetConvert</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>, <argument><expr><name>OBJ_ENCODING_SKIPLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Objtain the length of the object to sort. */</comment>
    <switch>switch<condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_LIST</name></expr>:</case> <expr_stmt><expr><name>vectorlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>listTypeLength</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>           <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <case>case <expr><name>OBJ_SET</name></expr>:</case> <expr_stmt><expr><name>vectorlen</name> <operator>=</operator>  <operator>(</operator><name>int</name><operator>)</operator><call><name>setTypeSize</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>              <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <case>case <expr><name>OBJ_ZSET</name></expr>:</case> <expr_stmt><expr><name>vectorlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dictSize</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>zset</name><operator>*</operator><operator>)</operator><name><name>sortval</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
    <default>default:</default> <expr_stmt><expr><name>vectorlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Bad SORT type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Avoid GCC warning */</comment>
    </block_content>}</block></switch>

    <comment type="block">/* Perform LIMIT start,count sanity checking. */</comment>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>limit_start</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>limit_start</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>limit_count</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>vectorlen</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>start</name><operator>+</operator><name>limit_count</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <name>vectorlen</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>vectorlen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <name>vectorlen</name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>vectorlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>vectorlen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Whenever possible, we load elements into the output array in a more
     * direct way. This is possible if:
     *
     * 1) The object to sort is a sorted set or a list (internally sorted).
     * 2) There is nothing to sort as dontsort is true (BY &lt;constant string&gt;).
     *
     * In this special case, if we have a LIMIT option that actually reduces
     * the number of elements to fetch, we also optimize to just load the
     * range we are interested in and allocating a vector that is big enough
     * for the selected range length. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name> <operator>||</operator> <name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name>dontsort</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>start</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>end</name> <operator>!=</operator> <name>vectorlen</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>vectorlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end</name><operator>-</operator><name>start</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>                                         <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Load the sorting vector with all the objects to sort */</comment>
    <expr_stmt><expr><name>vector</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redisSortObject</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>vectorlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name> <operator>&amp;&amp;</operator> <name>dontsort</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Special handling for a list, if 'dontsort' is true.
         * This makes sure we return elements in the list original
         * ordering, accordingly to DESC / ASC options.
         *
         * Note that in this case we also handle LIMIT here in a direct
         * way, just getting the required range, as an optimization. */</comment>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>start</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>listTypeIterator</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listTypeEntry</name></type> <name>entry</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>li</name> <operator>=</operator> <call><name>listTypeInitIterator</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>desc</name></expr> ?</condition><then> <expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><operator>(</operator><call><name>listTypeLength</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>start</name></expr></else></ternary></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>desc</name></expr> ?</condition><then> <expr><name>LIST_HEAD</name></expr> </then><else>: <expr><name>LIST_TAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while<condition>(<expr><name>j</name> <operator>&lt;</operator> <name>vectorlen</name> <operator>&amp;&amp;</operator> <call><name>listTypeNext</name><argument_list>(<argument><expr><name>li</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name> <operator>=</operator> <call><name>listTypeGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>listTypeReleaseIterator</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Fix start/end: output code is not aware of this optimization. */</comment>
            <expr_stmt><expr><name>end</name> <operator>-=</operator> <name>start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listTypeIterator</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><call><name>listTypeInitIterator</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>LIST_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listTypeEntry</name></type> <name>entry</name></decl>;</decl_stmt>
        <while>while<condition>(<expr><call><name>listTypeNext</name><argument_list>(<argument><expr><name>li</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name> <operator>=</operator> <call><name>listTypeGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>listTypeReleaseIterator</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>setTypeIterator</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>setTypeInitIterator</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdsele</name></decl>;</decl_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>sdsele</name> <operator>=</operator> <call><name>setTypeNextObject</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>setTypeReleaseIterator</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name> <operator>&amp;&amp;</operator> <name>dontsort</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Special handling for a sorted set, if 'dontsort' is true.
         * This makes sure we return elements in the sorted set original
         * ordering, accordingly to DESC / ASC options.
         *
         * Note that in this case we also handle LIMIT here in a direct
         * way, just getting the required range, as an optimization. */</comment>

        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>sortval</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdsele</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rangelen</name> <init>= <expr><name>vectorlen</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Check if starting point is trivial, before doing log(N) lookup. */</comment>
        <if_stmt><if>if <condition>(<expr><name>desc</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>zsetlen</name> <init>= <expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator> <call><name>dictSize</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>zset</name><operator>*</operator><operator>)</operator><name><name>sortval</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name>dict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_LONG) */</comment>

            <name>ln</name> <init>= <expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslGetElementByRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>zsetlen</name><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslGetElementByRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <while>while<condition>(<expr><name>rangelen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sortval</name></expr></argument>,<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sdsele</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <ternary><condition><expr><name>desc</name></expr> ?</condition><then> <expr><name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr> </then><else>: <expr><name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Fix start/end: output code is not aware of this optimization. */</comment>
        <expr_stmt><expr><name>end</name> <operator>-=</operator> <name>start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sortval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>set</name> <init>= <expr><operator>(</operator><operator>(</operator><name>zset</name><operator>*</operator><operator>)</operator><name><name>sortval</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name>dict</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>setele</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>sdsele</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>setele</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sdsele</name> <operator>=</operator>  <call><name>dictGetKey</name><argument_list>(<argument><expr><name>setele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>sdsele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sortval</name></expr></argument>,<argument><expr><name>j</name> <operator>==</operator> <name>vectorlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now it's time to load the right scores in the sorting vector */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dontsort</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>vectorlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>byval</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>sortby</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* lookup value to sort by */</comment>
                <expr_stmt><expr><name>byval</name> <operator>=</operator> <call><name>lookupKeyByPattern</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>sortby</name></expr></argument>,<argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>byval</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* use object itself to sort by */</comment>
                <expr_stmt><expr><name>byval</name> <operator>=</operator> <name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>alpha</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>sortby</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name> <operator>=</operator> <call><name>getDecodedObject</name><argument_list>(<argument><expr><name>byval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>byval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>byval</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator>
                        <call><name>isnan</name><argument_list>(<argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>int_conversion_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>byval</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Don't need to decode the object if it's
                     * integer-encoded (the only encoding supported) so
                     * far. We can just cast it */</comment>
                    <expr_stmt><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>score</name></name> <operator>=</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>byval</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sortval</name></expr></argument>,<argument><expr><literal type="number">1</literal> <operator>!=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* when the object was retrieved using lookupKeyByPattern,
             * its refcount needs to be decreased. */</comment>
            <if_stmt><if>if <condition>(<expr><name>sortby</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>byval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>sort_desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>sort_alpha</name></name> <operator>=</operator> <name>alpha</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>sort_bypattern</name></name> <operator>=</operator> <ternary><condition><expr><name>sortby</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>sort_store</name></name> <operator>=</operator> <ternary><condition><expr><name>storekey</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sortby</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>start</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>end</name> <operator>!=</operator> <name>vectorlen</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pqsort</name><argument_list>(<argument><expr><name>vector</name></expr></argument>,<argument><expr><name>vectorlen</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redisSortObject</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>sortCompare</name></expr></argument>, <argument><expr><name>start</name></expr></argument>,<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>vector</name></expr></argument>,<argument><expr><name>vectorlen</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redisSortObject</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>sortCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send command output to the output buffer, performing the specified
     * GET/DEL/INCR/DECR operations if any. */</comment>
    <expr_stmt><expr><name>outputlen</name> <operator>=</operator> <ternary><condition><expr><name>getop</name></expr> ?</condition><then> <expr><name>getop</name><operator>*</operator><operator>(</operator><name>end</name><operator>-</operator><name>start</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>end</name><operator>-</operator><name>start</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>int_conversion_error</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"One or more scores can't be converted into double"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>storekey</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* STORE option not specified, sent the sorting result to client */</comment>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>outputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>getop</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>operations</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>redisSortOperation</name> <modifier>*</modifier></type><name>sop</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>lookupKeyByPattern</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>,
                    <argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>sop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SORT_OP_GET</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="block">/* Always fails */</comment>
                    <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sortval</name></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SORT_OP_GET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>sobj</name> <init>= <expr><call><name>createQuicklistObject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* STORE option specified, set the sorting result as a List object */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>getop</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>listTypePush</name><argument_list>(<argument><expr><name>sobj</name></expr></argument>,<argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr></argument>,<argument><expr><name>LIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>operations</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>redisSortOperation</name> <modifier>*</modifier></type><name>sop</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>lookupKeyByPattern</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>,
                        <argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>sop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SORT_OP_GET</name></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="block">/* listTypePush does an incrRefCount, so we should take care
                         * care of the incremented refcount caused by either
                         * lookupKeyByPattern or createStringObject("",0) */</comment>
                        <expr_stmt><expr><call><name>listTypePush</name><argument_list>(<argument><expr><name>sobj</name></expr></argument>,<argument><expr><name>val</name></expr></argument>,<argument><expr><name>LIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="block">/* Always fails */</comment>
                        <expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>sortval</name></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SORT_OP_GET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>outputlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>storekey</name></expr></argument>,<argument><expr><name>sobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_LIST</name></expr></argument>,<argument><expr><literal type="string">"sortstore"</literal></expr></argument>,<argument><expr><name>storekey</name></expr></argument>,
                                <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>outputlen</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>storekey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>storekey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>storekey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>sobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>outputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Cleanup */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>vectorlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>sortval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>operations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>vectorlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>alpha</name> <operator>&amp;&amp;</operator> <name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>vector</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>cmpobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
