<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/module.c"><comment type="block">/*
 * Copyright (c) 2016, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rdb.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/dlfcn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_PThread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Error.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"redismodule.h"</cpp:file></cpp:include>

<comment type="block">/* --------------------------------------------------------------------------
 * Private data structures used by the modules system. Those are data
 * structures that are never exposed to Redis Modules, if not as void
 * pointers that have an API the module can call with them)
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This structure represents a module inside the system. */</comment>
<struct>struct <name>RedisModule</name> <block>{
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>   <comment type="block">/* Module dlopen() handle. */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>     <comment type="block">/* Module name. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ver</name></decl>;</decl_stmt>        <comment type="block">/* Module version. We use just progressive integers. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>apiver</name></decl>;</decl_stmt>     <comment type="block">/* Module API version as requested during initialization.*/</comment>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>    <comment type="block">/* Module data types. */</comment>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>usedby</name></decl>;</decl_stmt>   <comment type="block">/* List of modules using APIs from this one. */</comment>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>using</name></decl>;</decl_stmt>    <comment type="block">/* List of modules we use some APIs of. */</comment>
    <decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>filters</name></decl>;</decl_stmt>  <comment type="block">/* List of filters the module has registered. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>in_call</name></decl>;</decl_stmt>    <comment type="block">/* RM_Call() nesting level */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>RedisModule</name></name></type> <name>RedisModule</name>;</typedef>

<comment type="block">/* This represents a shared API. Shared APIs will be used to populate
 * the server.sharedapi dictionary, mapping names of APIs exported by
 * modules for other modules to use, to their structure specifying the
 * function pointer that can be called. */</comment>
<struct>struct <name>RedisModuleSharedAPI</name> <block>{
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>RedisModuleSharedAPI</name></name></type> <name>RedisModuleSharedAPI</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>dict</name> <modifier>*</modifier></type><name>modules</name></decl>;</decl_stmt> <comment type="block">/* Hash table of modules. SDS -&gt; RedisModule ptr.*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Entries in the context-&gt;amqueue array, representing objects to free
 * when the callback returns. */</comment>
<struct>struct <name>AutoMemEntry</name> <block>{
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* AutMemEntry type field values. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_AM_KEY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_AM_STRING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_AM_REPLY</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_AM_FREED</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> <comment type="block">/* Explicitly freed by user already. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_AM_DICT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/* The pool allocator block. Redis Modules can allocate memory via this special
 * allocator that will automatically release it all once the callback returns.
 * This means that it can only be used for ephemeral allocations. However
 * there are two advantages for modules to use this API:
 *
 * 1) The memory is automatically released when the callback returns.
 * 2) This allocator is faster for many small allocations since whole blocks
 *    are allocated, and small pieces returned to the caller just advancing
 *    the index of the allocation.
 *
 * Allocations are always rounded to the size of the void pointer in order
 * to always return aligned memory chunks. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_POOL_ALLOC_MIN_SIZE</name></cpp:macro> <cpp:value>(1024*8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_POOL_ALLOC_ALIGN</name></cpp:macro> <cpp:value>(sizeof(void*))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>RedisModulePoolAllocBlock</name> <block>{
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>used</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModulePoolAllocBlock</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>memory</name><index>[]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RedisModulePoolAllocBlock</name>;</typedef>

<comment type="block">/* This structure represents the context in which Redis modules operate.
 * Most APIs module can access, get a pointer to the context, so that the API
 * implementation can hold state across calls, or remember what to free after
 * the call and so forth.
 *
 * Note that not all the context structure is always filled with actual values
 * but only the fields needed in a given context. */</comment>

<struct_decl>struct <name>RedisModuleBlockedClient</name>;</struct_decl>

<struct>struct <name>RedisModuleCtx</name> <block>{
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>getapifuncptr</name></decl>;</decl_stmt>            <comment type="block">/* NOTE: Must be the first field. */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>     <comment type="block">/* Module reference. */</comment>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>                 <comment type="block">/* Client calling a command. */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModuleBlockedClient</name></name> <modifier>*</modifier></type><name>blocked_client</name></decl>;</decl_stmt> <comment type="block">/* Blocked client for
                                                        thread safe context. */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>AutoMemEntry</name></name> <modifier>*</modifier></type><name>amqueue</name></decl>;</decl_stmt>   <comment type="block">/* Auto memory queue of objects to free. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>amqueue_len</name></decl>;</decl_stmt>                <comment type="block">/* Number of slots in amqueue. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>amqueue_used</name></decl>;</decl_stmt>               <comment type="block">/* Number of used slots in amqueue. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                      <comment type="block">/* REDISMODULE_CTX_... flags. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>postponed_arrays</name></decl>;</decl_stmt>        <comment type="block">/* To set with RM_ReplySetArrayLength(). */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>postponed_arrays_count</name></decl>;</decl_stmt>     <comment type="block">/* Number of entries in postponed_arrays. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>blocked_privdata</name></decl>;</decl_stmt>         <comment type="block">/* Privdata set when unblocking a client. */</comment>

    <comment type="block">/* Used if there is the REDISMODULE_CTX_KEYS_POS_REQUEST flag set. */</comment>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>keys_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keys_count</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModulePoolAllocBlock</name></name> <modifier>*</modifier></type><name>pa_head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisOpArray</name></type> <name>saved_oparray</name></decl>;</decl_stmt>    <comment type="block">/* When propagating commands in a callback
                                      we reallocate the "also propagate" op
                                      array. Here we save the old one to
                                      restore it later. */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>RedisModuleCtx</name></name></type> <name>RedisModuleCtx</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_INIT</name></cpp:macro> <cpp:value>{(void*)(PORT_ULONG)&amp;RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL, {0}}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_MULTI_EMITTED</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_AUTO_MEMORY</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_KEYS_POS_REQUEST</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_BLOCKED_REPLY</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_BLOCKED_TIMEOUT</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_THREAD_SAFE</name></cpp:macro> <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_BLOCKED_DISCONNECTED</name></cpp:macro> <cpp:value>(1&lt;&lt;6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_CTX_MODULE_COMMAND_CALL</name></cpp:macro> <cpp:value>(1&lt;&lt;7)</cpp:value></cpp:define>

<comment type="block">/* This represents a Redis key opened with RM_OpenKey(). */</comment>
<struct>struct <name>RedisModuleKey</name> <block>{
    <decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>      <comment type="block">/* Key name object. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>    <comment type="block">/* Value object, or NULL if the key was not found. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>     <comment type="block">/* Iterator. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>       <comment type="block">/* Opening mode. */</comment>

    <comment type="block">/* Zset iterator. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ztype</name></decl>;</decl_stmt>         <comment type="block">/* REDISMODULE_ZSET_RANGE_* */</comment>
    <decl_stmt><decl><type><name>zrangespec</name></type> <name>zrs</name></decl>;</decl_stmt>         <comment type="block">/* Score range. */</comment>
    <decl_stmt><decl><type><name>zlexrangespec</name></type> <name>zlrs</name></decl>;</decl_stmt>     <comment type="block">/* Lex range. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>zstart</name></decl>;</decl_stmt>        <comment type="block">/* Start pos for positional ranges. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>zend</name></decl>;</decl_stmt>          <comment type="block">/* End pos for positional ranges. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zcurrent</name></decl>;</decl_stmt>         <comment type="block">/* Zset iterator current node. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>zer</name></decl>;</decl_stmt>                <comment type="block">/* Zset iterator end reached flag
                               (true if end was reached). */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>RedisModuleKey</name></name></type> <name>RedisModuleKey</name>;</typedef>

<comment type="block">/* RedisModuleKey 'ztype' values. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ZSET_RANGE_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>       <comment type="block">/* This must always be 0. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ZSET_RANGE_LEX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ZSET_RANGE_SCORE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ZSET_RANGE_POS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Function pointer type of a function representing a command inside
 * a Redis module. */</comment>
<struct_decl>struct <name>RedisModuleBlockedClient</name>;</struct_decl>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>RedisModuleCmdFunc</name>) <parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>RedisModuleDisconnectFunc</name>) <parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>RedisModuleBlockedClient</name></name> <modifier>*</modifier></type><name>bc</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* This struct holds the information about a command registered by a module.*/</comment>
<struct>struct <name>RedisModuleCommandProxy</name> <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCmdFunc</name></type> <name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>rediscmd</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>RedisModuleCommandProxy</name></name></type> <name>RedisModuleCommandProxy</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_REPLYFLAG_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_REPLYFLAG_TOPARSE</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define> <comment type="block">/* Protocol must be parsed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_REPLYFLAG_NESTED</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>  <comment type="block">/* Nested reply object. No proto
                                                or struct free. */</comment>

<comment type="block">/* Reply of RM_Call() function. The function is filled in a lazy
 * way depending on the function called on the reply structure. By default
 * only the type, proto and protolen are filled. */</comment>
<typedef>typedef <type><struct>struct <name>RedisModuleCallReply</name> <block>{
    <decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>       <comment type="block">/* REDISMODULE_REPLY_... */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>      <comment type="block">/* REDISMODULE_REPLYFLAG_...  */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>     <comment type="block">/* Len of strings or num of elements of arrays. */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>proto</name></decl>;</decl_stmt>    <comment type="block">/* Raw reply protocol. An SDS string at top-level object. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>protolen</name></decl>;</decl_stmt><comment type="block">/* Length of protocol. */</comment>
    <union>union <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt> <comment type="block">/* String pointer for string and error replies. This
                            does not need to be freed, always points inside
                            a reply-&gt;proto buffer of the reply object or, in
                            case of array elements, of parent reply objects. */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl>;</decl_stmt>    <comment type="block">/* Reply value for integer reply. */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>RedisModuleCallReply</name></name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt> <comment type="block">/* Array of sub-reply elements. */</comment>
    }</block> <decl><name>val</name></decl>;</union>
}</block></struct></type> <name>RedisModuleCallReply</name>;</typedef>

<comment type="block">/* Structure representing a blocked client. We get a pointer to such
 * an object when blocking from modules. */</comment>
<typedef>typedef <type><struct>struct <name>RedisModuleBlockedClient</name> <block>{
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>  <comment type="block">/* Pointer to the blocked client. or NULL if the client
                        was destroyed during the life of this object. */</comment>
    <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>    <comment type="block">/* Module blocking the client. */</comment>
    <decl_stmt><decl><type><name>RedisModuleCmdFunc</name></type> <name>reply_callback</name></decl>;</decl_stmt> <comment type="block">/* Reply callback on normal completion.*/</comment>
    <decl_stmt><decl><type><name>RedisModuleCmdFunc</name></type> <name>timeout_callback</name></decl>;</decl_stmt> <comment type="block">/* Reply callback on timeout. */</comment>
    <decl_stmt><decl><type><name>RedisModuleDisconnectFunc</name></type> <name>disconnect_callback</name></decl>;</decl_stmt> <comment type="block">/* Called on disconnection.*/</comment>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>free_privdata</name>)<parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl><comment type="block">/* privdata cleanup callback.*/</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl>;</decl_stmt>     <comment type="block">/* Module private data that may be used by the reply
                           or timeout callback. It is set via the
                           RedisModule_UnblockClient() API. */</comment>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>reply_client</name></decl>;</decl_stmt>           <comment type="block">/* Fake client used to accumulate replies
                                       in thread safe contexts. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dbid</name></decl>;</decl_stmt>           <comment type="block">/* Database number selected by the original client. */</comment>
}</block></struct></type> <name>RedisModuleBlockedClient</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>moduleUnblockedClientsMutex</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>moduleUnblockedClientsMutex</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>list</name> <modifier>*</modifier></type><name>moduleUnblockedClients</name></decl>;</decl_stmt>

<comment type="block">/* We need a mutex that is unlocked / relocked in beforeSleep() in order to
 * allow thread safe contexts to execute commands at a safe moment. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>moduleGIL</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>moduleGIL</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Function pointer type for keyspace event notification subscriptions from modules. */</comment>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>RedisModuleNotificationFunc</name>) <parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Keyspace notification subscriber information.
 * See RM_SubscribeToKeyspaceEvents() for more information. */</comment>
<typedef>typedef <type><struct>struct <name>RedisModuleKeyspaceSubscriber</name> <block>{
    <comment type="block">/* The module subscribed to the event */</comment>
    <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>
    <comment type="block">/* Notification callback in the module*/</comment>
    <decl_stmt><decl><type><name>RedisModuleNotificationFunc</name></type> <name>notify_callback</name></decl>;</decl_stmt>
    <comment type="block">/* A bit mask of the events the module is interested in */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>event_mask</name></decl>;</decl_stmt>
    <comment type="block">/* Active flag set on entry, to avoid reentrant subscribers
     * calling themselves */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name></decl>;</decl_stmt>
}</block></struct></type> <name>RedisModuleKeyspaceSubscriber</name>;</typedef>

<comment type="block">/* The module keyspace notification subscribers list */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>list</name> <modifier>*</modifier></type><name>moduleKeyspaceSubscribers</name></decl>;</decl_stmt>

<comment type="block">/* Static client recycled for when we need to provide a context with a client
 * in a situation where there is no client to provide. This avoidsallocating
 * a new client per round. For instance this is used in the keyspace
 * notifications, timers and cluster messages callbacks. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>client</name> <modifier>*</modifier></type><name>moduleFreeContextReusedClient</name></decl>;</decl_stmt>

<comment type="block">/* Data structures related to the exported dictionary data structure. */</comment>
<typedef>typedef <type><struct>struct <name>RedisModuleDict</name> <block>{
    <decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>rax</name></decl>;</decl_stmt>                       <comment type="block">/* The radix tree. */</comment>
}</block></struct></type> <name>RedisModuleDict</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RedisModuleDictIter</name> <block>{
    <decl_stmt><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
}</block></struct></type> <name>RedisModuleDictIter</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RedisModuleCommandFilterCtx</name> <block>{
    <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
}</block></struct></type> <name>RedisModuleCommandFilterCtx</name>;</typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>RedisModuleCommandFilterFunc</name>) <parameter_list>(<parameter><decl><type><name>RedisModuleCommandFilterCtx</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>RedisModuleCommandFilter</name> <block>{
    <comment type="block">/* The module that registered the filter */</comment>
    <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>
    <comment type="block">/* Filter callback function */</comment>
    <decl_stmt><decl><type><name>RedisModuleCommandFilterFunc</name></type> <name>callback</name></decl>;</decl_stmt>
    <comment type="block">/* REDISMODULE_CMDFILTER_* flags */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>RedisModuleCommandFilter</name>;</typedef>

<comment type="block">/* Registered filters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>list</name> <modifier>*</modifier></type><name>moduleCommandFilters</name></decl>;</decl_stmt>

<comment type="block">/* Flags for moduleCreateArgvFromUserFormat(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ARGV_REPLICATE</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ARGV_NO_AOF</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDISMODULE_ARGV_NO_REPLICAS</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>

<comment type="block">/* --------------------------------------------------------------------------
 * Prototypes
 * -------------------------------------------------------------------------- */</comment>

<function_decl><type><name>void</name></type> <name>RM_FreeCallReply</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RM_CloseKey</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>autoMemoryCollect</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>moduleCreateArgvFromUserFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argcp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>moduleReplicateMultiIfNeeded</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RM_ZsetRangeStop</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>kp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>zsetKeyReset</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RM_FreeDict</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* --------------------------------------------------------------------------
 * Heap allocation raw functions
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Use like malloc(). Memory allocated with this function is reported in
 * Redis INFO memory, used for keys eviction according to maxmemory settings
 * and in general is taken into account as memory allocated by Redis.
 * You should avoid using malloc(). */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_Alloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Use like calloc(). Memory allocated with this function is reported in
 * Redis INFO memory, used for keys eviction according to maxmemory settings
 * and in general is taken into account as memory allocated by Redis.
 * You should avoid using calloc() directly. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_Calloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zcalloc</name><argument_list>(<argument><expr><name>nmemb</name><operator>*</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Use like realloc() for memory obtained with RedisModule_Alloc(). */</comment>
<function><type><name>void</name><modifier>*</modifier></type> <name>RM_Realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zrealloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Use like free() for memory obtained by RedisModule_Alloc() and
 * RedisModule_Realloc(). However you should never try to free with
 * RedisModule_Free() memory allocated with malloc() inside your module. */</comment>
<function><type><name>void</name></type> <name>RM_Free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Like strdup() but returns memory allocated with RedisModule_Alloc(). */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>RM_Strdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Pool allocator
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Release the chain of blocks used for pool allocations. */</comment>
<function><type><name>void</name></type> <name>poolAllocRelease</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModulePoolAllocBlock</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>pa_head</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pa_head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return heap allocated memory that will be freed automatically when the
 * module callback function returns. Mostly suitable for small allocations
 * that are short living and must be released when the callback returns
 * anyway. The returned memory is aligned to the architecture word size
 * if at least word size bytes are requested, otherwise it is just
 * aligned to the next power of two, so for example a 3 bytes request is
 * 4 bytes aligned while a 2 bytes request is 2 bytes aligned.
 *
 * There is no realloc style function since when this is needed to use the
 * pool allocator is not a good idea.
 *
 * The function returns NULL if `bytes` is 0. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_PoolAlloc</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>RedisModulePoolAllocBlock</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>pa_head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>left</name> <init>= <expr><ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>used</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Fix alignment. */</comment>
    <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;=</operator> <name>bytes</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>alignment</name> <init>= <expr><name>REDISMODULE_POOL_ALLOC_ALIGN</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>bytes</name> <operator>&lt;</operator> <name>alignment</name> <operator>&amp;&amp;</operator> <name>alignment</name><operator>/</operator><literal type="number">2</literal> <operator>&gt;=</operator> <name>bytes</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>alignment</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>used</name></name> <operator>%</operator> <name>alignment</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>alignment</name> <operator>-</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>used</name></name> <operator>%</operator> <name>alignment</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>left</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>used</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>used</name></name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a new block if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>bytes</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>blocksize</name> <init>= <expr><name>REDISMODULE_POOL_ALLOC_MIN_SIZE</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>blocksize</name> <operator>&lt;</operator> <name>bytes</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>blocksize</name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>b</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>blocksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>blocksize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>pa_head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pa_head</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>memory</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>used</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Helpers for modules API implementation
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Create an empty key of the specified type. 'kp' must point to a key object
 * opened for writing where the .value member is set to NULL because the
 * key was found to be non existing.
 *
 * On success REDISMODULE_OK is returned and the key is populated with
 * the value of the specified type. The function fails and returns
 * REDISMODULE_ERR if:
 *
 * 1) The key is not open for writing.
 * 2) The key is not empty.
 * 3) The specified type is unknown.
 */</comment>
<function><type><name>int</name></type> <name>moduleCreateEmptyKey</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

    <comment type="block">/* The key must be open for writing and non existing to proceed. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>REDISMODULE_KEYTYPE_LIST</name></expr>:</case>
        <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>createQuicklistObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quicklistSetOptions</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>list_max_ziplist_size</name></name></expr></argument>,
                            <argument><expr><name><name>server</name><operator>.</operator><name>list_compress_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>REDISMODULE_KEYTYPE_ZSET</name></expr>:</case>
        <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>createZsetZiplistObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>REDISMODULE_KEYTYPE_HASH</name></expr>:</case>
        <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>createHashObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called in low-level API implementation functions in order
 * to check if the value associated with the key remained empty after an
 * operation that removed elements from an aggregate data type.
 *
 * If this happens, the key is deleted from the DB and the key object state
 * is set to the right one in order to be targeted again by write operations
 * possibly recreating the key if needed.
 *
 * The function returns 1 if the key value object is found empty and is
 * deleted, otherwise 0 is returned. */</comment>
<function><type><name>int</name></type> <name>moduleDelKeyIfEmpty</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isempty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_LIST</name></expr>:</case> <expr_stmt><expr><name>isempty</name> <operator>=</operator> <call><name>listTypeLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>OBJ_SET</name></expr>:</case> <expr_stmt><expr><name>isempty</name> <operator>=</operator> <call><name>setTypeSize</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>OBJ_ZSET</name></expr>:</case> <expr_stmt><expr><name>isempty</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>OBJ_HASH</name></expr>:</case> <expr_stmt><expr><name>isempty</name> <operator>=</operator> <call><name>hashTypeLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>OBJ_STREAM</name></expr>:</case> <expr_stmt><expr><name>isempty</name> <operator>=</operator> <call><name>streamLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><name>isempty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>isempty</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Service API exported to modules
 *
 * Note that all the exported APIs are called RM_&lt;funcname&gt; in the core
 * and RedisModule_&lt;funcname&gt; in the module side (defined as function
 * pointers in redismodule.h). In this way the dynamic linker does not
 * mess with our global function pointers, overriding it with the symbols
 * defined in the main executable having the same names.
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Lookup the requested module API and store the function pointer into the
 * target pointer. The function returns REDISMODULE_ERR if there is no such
 * named API, otherwise REDISMODULE_OK.
 *
 * This function is not meant to be used by modules developer, it is only
 * used implicitly by including redismodule.h. */</comment>
<function><type><name>int</name></type> <name>RM_GetApi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetPtrPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>he</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>moduleapi</name></name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>he</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>targetPtrPtr</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function for when a command callback is called, in order to handle
 * details needed to correctly replicate commands. */</comment>
<function><type><name>void</name></type> <name>moduleHandlePropagationAfterCommandCallback</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We don't need to do anything here if the context was never used
     * in order to propagate commands. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_MULTI_EMITTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_LUA</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Handle the replication of the final EXEC, since whatever a command
     * emits is always wrapped around MULTI/EXEC. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>propargv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>propargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"EXEC"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>execCommand</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>propargv</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,
        <argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>propargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this is not a module command context (but is instead a simple
     * callback context), we have to handle directly the "also propagate"
     * array and emit it. In a module command call this will be handled
     * directly by call(). */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_MODULE_COMMAND_CALL</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name><name>server</name><operator>.</operator><name>also_propagate</name><operator>.</operator><name>numops</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>also_propagate</name><operator>.</operator><name>numops</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>redisOp</name> <modifier>*</modifier></type><name>rop</name> <init>= <expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>also_propagate</name><operator>.</operator><name>ops</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>target</name> <init>= <expr><name><name>rop</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>target</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>propagate</name><argument_list>(<argument><expr><name><name>rop</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>,<argument><expr><name><name>rop</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>,<argument><expr><name><name>rop</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>rop</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>redisOpArrayFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>also_propagate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Restore the previous oparray in case of nexted use of the API. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>also_propagate</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>saved_oparray</name></name></expr>;</expr_stmt>
        <comment type="block">/* We're done with saved_oparray, let's invalidate it. */</comment>
        <expr_stmt><expr><call><name>redisOpArrayInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>saved_oparray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the context after the user function was called. */</comment>
<function><type><name>void</name></type> <name>moduleFreeContext</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleHandlePropagationAfterCommandCallback</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>autoMemoryCollect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>poolAllocRelease</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"API misuse detected in module %s: "</literal>
            <literal type="string">"RedisModule_ReplyWithArray(REDISMODULE_POSTPONED_ARRAY_LEN) "</literal>
            <literal type="string">"not matched by the same number of RedisModule_SetReplyArrayLen() "</literal>
            <literal type="string">"calls."</literal></expr></argument>,
            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_THREAD_SAFE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This Redis command binds the normal Redis command invocation with commands
 * exported by modules. */</comment>
<function><type><name>void</name></type> <name>RedisModuleCommandDispatcher</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleCommandProxy</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>getkeys_proc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_MODULE_COMMAND_CALL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cp</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* In some cases processMultibulkBuffer uses sdsMakeRoomFor to
     * expand the query buffer, and in order to avoid a big object copy
     * the query buffer SDS may be used directly as the SDS string backing
     * the client argument vectors: sometimes this will result in the SDS
     * string having unused space at the end. Later if a module takes ownership
     * of the RedisString, such space will be wasted forever. Inside the
     * Redis core this is not a problem because tryObjectEncoding() is called
     * before storing strings in the key space. Here we need to do it
     * for the module. */</comment>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Only do the work if the module took ownership of the object:
         * in that case the refcount is no longer 1. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>refcount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>trimStringObjectIfNeeded</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* This function returns the list of keys, with the same interface as the
 * 'getkeys' function of the native commands, for module commands that exported
 * the "getkeys-api" flag during the registration. This is done when the
 * list of keys are not at fixed positions, so that first/last/step cannot
 * be used.
 *
 * In order to accomplish its work, the module command is called, flagging
 * the context in a way that the command can recognize this is a special
 * "get keys" call by calling RedisModule_IsKeysPositionRequest(ctx). */</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>moduleGetCommandKeysViaAPI</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numkeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleCommandProxy</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>getkeys_proc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_KEYS_POS_REQUEST</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cp</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name><name>ctx</name><operator>.</operator><name>keys_pos</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>numkeys</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>numkeys</name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>keys_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if a module command, that was declared with the
 * flag "getkeys-api", is called in a special way to get the keys positions
 * and not to get executed. Otherwise zero is returned. */</comment>
<function><type><name>int</name></type> <name>RM_IsKeysPositionRequest</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_KEYS_POS_REQUEST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* When a module command is called in order to obtain the position of
 * keys, since it was flagged as "getkeys-api" during the registration,
 * the command implementation checks for this special call using the
 * RedisModule_IsKeysPositionRequest() API and uses this function in
 * order to report keys, like in the following example:
 *
 *     if (RedisModule_IsKeysPositionRequest(ctx)) {
 *         RedisModule_KeyAtPos(ctx,1);
 *         RedisModule_KeyAtPos(ctx,2);
 *     }
 *
 *  Note: in the example below the get keys API would not be needed since
 *  keys are at fixed positions. This interface is only used for commands
 *  with a more complex structure. */</comment>
<function><type><name>void</name></type> <name>RM_KeyAtPos</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_KEYS_POS_REQUEST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys_pos</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys_pos</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys_count</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_ULONG) */</comment>
    <name><name>ctx</name><operator>-&gt;</operator><name>keys_pos</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>keys_count</name></name><operator>++</operator></expr>]</index></name> <init>= <expr><name>pos</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper for RM_CreateCommand(). Turns a string representing command
 * flags into the command flags used by the Redis core.
 *
 * It returns the set of flags, or -1 if unknown flags are found. */</comment>
<function><type><name>int64_t</name></type> <name>commandFlagsFromString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name> <modifier>*</modifier></type><name>tokens</name> <init>= <expr><call><name>sdssplitlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="string">" "</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>tokens</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_WRITE</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"readonly"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_READONLY</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"admin"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_ADMIN</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"deny-oom"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_DENYOOM</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"deny-script"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_NOSCRIPT</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"allow-loading"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_LOADING</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"pubsub"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_PUBSUB</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"random"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_RANDOM</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"allow-stale"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_STALE</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"no-monitor"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_SKIP_MONITOR</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_FAST</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"getkeys-api"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_MODULE_GETKEYS</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"no-cluster"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CMD_MODULE_NO_CLUSTER</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sdsfreesplitres</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Some token not processed correctly. */</comment>
    <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Register a new command in the Redis server, that will be handled by
 * calling the function pointer 'func' using the RedisModule calling
 * convention. The function returns REDISMODULE_ERR if the specified command
 * name is already busy or a set of invalid flags were passed, otherwise
 * REDISMODULE_OK is returned and the new command is registered.
 *
 * This function must be called during the initialization of the module
 * inside the RedisModule_OnLoad() function. Calling this function outside
 * of the initialization function is not defined.
 *
 * The command function type is the following:
 *
 *      int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);
 *
 * And is supposed to always return REDISMODULE_OK.
 *
 * The set of flags 'strflags' specify the behavior of the command, and should
 * be passed as a C string composed of space separated words, like for
 * example "write deny-oom". The set of flags are:
 *
 * * **"write"**:     The command may modify the data set (it may also read
 *                    from it).
 * * **"readonly"**:  The command returns data from keys but never writes.
 * * **"admin"**:     The command is an administrative command (may change
 *                    replication or perform similar tasks).
 * * **"deny-oom"**:  The command may use additional memory and should be
 *                    denied during out of memory conditions.
 * * **"deny-script"**:   Don't allow this command in Lua scripts.
 * * **"allow-loading"**: Allow this command while the server is loading data.
 *                        Only commands not interacting with the data set
 *                        should be allowed to run in this mode. If not sure
 *                        don't use this flag.
 * * **"pubsub"**:    The command publishes things on Pub/Sub channels.
 * * **"random"**:    The command may have different outputs even starting
 *                    from the same input arguments and key values.
 * * **"allow-stale"**: The command is allowed to run on slaves that don't
 *                      serve stale data. Don't use if you don't know what
 *                      this means.
 * * **"no-monitor"**: Don't propagate the command on monitor. Use this if
 *                     the command has sensible data among the arguments.
 * * **"fast"**:      The command time complexity is not greater
 *                    than O(log(N)) where N is the size of the collection or
 *                    anything else representing the normal scalability
 *                    issue with the command.
 * * **"getkeys-api"**: The command implements the interface to return
 *                      the arguments that are keys. Used when start/stop/step
 *                      is not enough because of the command syntax.
 * * **"no-cluster"**: The command should not register in Redis Cluster
 *                     since is not designed to work with it because, for
 *                     example, is unable to report the position of the
 *                     keys, programmatically creates key names, or any
 *                     other reason.
 */</comment>
<function><type><name>int</name></type> <name>RM_CreateCommand</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>RedisModuleCmdFunc</name></type> <name>cmdfunc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lastkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keystep</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>flags</name> <init>= <expr><ternary><condition><expr><name>strflags</name></expr> ?</condition><then> <expr><call><name>commandFlagsFromString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>strflags</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CMD_MODULE_NO_CLUSTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>rediscmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCommandProxy</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>cmdname</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check if the command name is busy. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lookupCommand</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a command "proxy", which is a structure that is referenced
     * in the command table, so that the generic command that works as
     * binding between modules and Redis, can know what function to call
     * and what the module is.
     *
     * Note that we use the Redis command table 'getkeys_proc' in order to
     * pass a reference to the command proxy structure. */</comment>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>cmdfunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>rediscmd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>cmdname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>RedisModuleCommandDispatcher</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>arity</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name> <operator>|</operator> <name>CMD_MODULE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>getkeys_proc</name></name> <operator>=</operator> <operator>(</operator><name>redisGetKeysProc</name><operator>*</operator><operator>)</operator> <operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>firstkey</name></name> <operator>=</operator> <name>firstkey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>lastkey</name></name> <operator>=</operator> <name>lastkey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>keystep</name></name> <operator>=</operator> <name>keystep</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>microseconds</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>calls</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>commands</name></name></expr></argument>,<argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>orig_commands</name></name></expr></argument>,<argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Called by RM_Init() to setup the `ctx-&gt;module` structure.
 *
 * This is an internal function, Redis modules developers don't need
 * to use it. */</comment>
<function><type><name>void</name></type> <name>RM_SetModuleAttribs</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ver</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>apiver</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>module</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>module</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sdsnew</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>ver</name></name> <operator>=</operator> <name>ver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>apiver</name></name> <operator>=</operator> <name>apiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>types</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>usedby</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>using</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>filters</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>in_call</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name>module</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if the module name is busy.
 * Otherwise zero is returned. */</comment>
<function><type><name>int</name></type> <name>RM_IsModuleNameBusy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>modulename</name> <init>= <expr><call><name>sdsnew</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name>modules</name></expr></argument>,<argument><expr><name>modulename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current UNIX time in milliseconds. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>RM_Milliseconds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Automatic memory management for modules
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Enable automatic memory management. See API.md for more information.
 *
 * The function must be called as the first function of a command implementation
 * that wants to use automatic memory. */</comment>
<function><type><name>void</name></type> <name>RM_AutoMemory</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_AUTO_MEMORY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a new object to release automatically when the callback returns. */</comment>
<function><type><name>void</name></type> <name>autoMemoryAdd</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_AUTO_MEMORY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>amqueue_len</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_len</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_len</name></name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_len</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>AutoMemEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Mark an object as freed in the auto release queue, so that users can still
 * free things manually if they want.
 *
 * The function returns 1 if the object was actually found in the auto memory
 * pool, otherwise 0 is returned. */</comment>
<function><type><name>int</name></type> <name>autoMemoryFreed</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_AUTO_MEMORY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>side</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>side</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>side</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* For side = 0 check right side of the array, for
             * side = 1 check the left side instead (zig-zag scanning). */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>side</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>j</name><operator>)</operator></expr> </then><else>: <expr><name>j</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>type</name> <operator>&amp;&amp;</operator>
                <name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>==</operator> <name>ptr</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>REDISMODULE_AM_FREED</name></expr>;</expr_stmt>

                <comment type="block">/* Switch the freed element and the last element, to avoid growing
                 * the queue unnecessarily if we allocate/free in a loop */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Reduce the size of the queue because we either moved the top
                 * element elsewhere or freed it */</comment>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name><operator>--</operator></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release all the objects in queue. */</comment>
<function><type><name>void</name></type> <name>autoMemoryCollect</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_AUTO_MEMORY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Clear the AUTO_MEMORY flag from the context, otherwise the functions
     * we call to free the resources, will try to scan the auto release
     * queue to mark the entries as freed. */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REDISMODULE_CTX_AUTO_MEMORY</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>REDISMODULE_AM_STRING</name></expr>:</case> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>REDISMODULE_AM_REPLY</name></expr>:</case> <expr_stmt><expr><call><name>RM_FreeCallReply</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>REDISMODULE_AM_KEY</name></expr>:</case> <expr_stmt><expr><call><name>RM_CloseKey</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        <case>case <expr><name>REDISMODULE_AM_DICT</name></expr>:</case> <expr_stmt><expr><call><name>RM_FreeDict</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_AUTO_MEMORY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>amqueue_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * String objects APIs
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Create a new module string object. The returned string must be freed
 * with RedisModule_FreeString(), unless automatic memory is enabled.
 *
 * The string is created by copying the `len` bytes starting
 * at `ptr`. No reference is retained to the passed buffer.
 *
 * The module context 'ctx' is optional and may be NULL if you want to create
 * a string out of the context scope. However in that case, the automatic
 * memory management will not be available, and the string memory must be
 * managed manually. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_CreateString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new module string object from a printf format and arguments.
 * The returned string must be freed with RedisModule_FreeString(), unless
 * automatic memory is enabled.
 *
 * The string is created using the sds formatter function sdscatvprintf().
 *
 * The passed context 'ctx' may be NULL if necessary, see the
 * RedisModule_CreateString() documentation for more info. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_CreateStringPrintf</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdscatvprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Like RedisModule_CreatString(), but creates a string starting from a long long
 * integer instead of taking a buffer and its length.
 *
 * The returned string must be released with RedisModule_FreeString() or by
 * enabling automatic memory management.
 *
 * The passed context 'ctx' may be NULL if necessary, see the
 * RedisModule_CreateString() documentation for more info. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_CreateStringFromLongLong</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>RM_CreateString</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_CreatString(), but creates a string starting from another
 * RedisModuleString.
 *
 * The returned string must be released with RedisModule_FreeString() or by
 * enabling automatic memory management.
 *
 * The passed context 'ctx' may be NULL if necessary, see the
 * RedisModule_CreateString() documentation for more info. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_CreateStringFromString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>dupStringObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a module string object obtained with one of the Redis modules API calls
 * that return new string objects.
 *
 * It is possible to call this function even when automatic memory management
 * is enabled. In that case the string will be released ASAP and removed
 * from the pool of string to release at the end.
 *
 * If the string was created with a NULL context 'ctx', it is also possible to
 * pass ctx as NULL when releasing the string (but passing a context will not
 * create any issue). Strings created with a context should be freed also passing
 * the context, so if you want to free a string out of context later, make sure
 * to create it using a NULL context. */</comment>
<function><type><name>void</name></type> <name>RM_FreeString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoMemoryFreed</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Every call to this function, will make the string 'str' requiring
 * an additional call to RedisModule_FreeString() in order to really
 * free the string. Note that the automatic freeing of the string obtained
 * enabling modules automatic memory management counts for one
 * RedisModule_FreeString() call (it is just executed automatically).
 *
 * Normally you want to call this function when, at the same time
 * the following conditions are true:
 *
 * 1) You have automatic memory management enabled.
 * 2) You want to create string objects.
 * 3) Those string objects you create need to live *after* the callback
 *    function(for example a command implementation) creating them returns.
 *
 * Usually you want this in order to store the created string object
 * into your own data structure, for example when implementing a new data
 * type.
 *
 * Note that when memory management is turned off, you don't need
 * any call to RetainString() since creating a string will always result
 * into a string that lives after the callback function returns, if
 * no FreeString() call is performed.
 *
 * It is possible to call this function with a NULL context. */</comment>
<function><type><name>void</name></type> <name>RM_RetainString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>autoMemoryFreed</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Increment the string reference counting only if we can't
         * just remove the object from the list of objects that should
         * be reclaimed. Why we do that, instead of just incrementing
         * the refcount in any case, and let the automatic FreeString()
         * call at the end to bring the refcount back at the desired
         * value? Because this way we ensure that the object refcount
         * value is 1 (instead of going to 2 to be dropped later to 1)
         * after the call to this function. This is needed for functions
         * like RedisModule_StringAppendBuffer() to work. */</comment>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Given a string module object, this function returns the string pointer
 * and length of the string. The returned pointer and length should only
 * be used for read only accesses and never modified. */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>RM_StringPtrLen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name> <init>= <expr><literal type="string">"(NULL string reply referenced in module)"</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>errmsg</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Higher level string operations
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* Convert the string into a long long integer, storing it at `*ll`.
 * Returns REDISMODULE_OK on success. If the string can't be parsed
 * as a valid, strict long long (no spaces before/after), REDISMODULE_ERR
 * is returned. */</comment>
<function><type><name>int</name></type> <name>RM_StringToLongLong</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name> <modifier>*</modifier></type><name>ll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><call><name>string2ll</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>:
                                                     <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert the string into a double, storing it at `*d`.
 * Returns REDISMODULE_OK on success or REDISMODULE_ERR if the string is
 * not a valid string representation of a double value. */</comment>
<function><type><name>int</name></type> <name>RM_StringToDouble</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>getDoubleFromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>retval</name> <operator>==</operator> <name>C_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare two string objects, returning -1, 0 or 1 respectively if
 * a &lt; b, a == b, a &gt; b. Strings are compared byte by byte as two
 * binary blobs without any encoding care / collation attempt. */</comment>
<function><type><name>int</name></type> <name>RM_StringCompare</name><parameter_list>(<parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>compareStringObjects</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the (possibly modified in encoding) input 'str' object if
 * the string is unshared, otherwise NULL is returned. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>moduleAssertUnsharedString</name><parameter_list>(<parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>refcount</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Module attempted to use an in-place string modify operation "</literal>
            <literal type="string">"with a string referenced multiple times. Please check the code "</literal>
            <literal type="string">"for API usage correctness."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_EMBSTR</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Note: here we "leak" the additional allocation that was
         * used in order to store the embedded string in the object. */</comment>
        <expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_RAW</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Convert the string from integer to raw encoding. */</comment>
        <expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_RAW</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append the specified buffer to the string 'str'. The string must be a
 * string created by the user that is referenced only a single time, otherwise
 * REDISMODULE_ERR is returned and the operation is not performed. */</comment>
<function><type><name>int</name></type> <name>RM_StringAppendBuffer</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>moduleAssertUnsharedString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Reply APIs
 *
 * Most functions always return REDISMODULE_OK so you can use it with
 * 'return' in order to return from the command implementation with:
 *
 *     if (... some condition ...)
 *         return RM_ReplyWithLongLong(ctx,mycount);
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Send an error about the number of arguments given to the command,
 * citing the command name in the error message.
 *
 * Example:
 *
 *     if (argc != 3) return RedisModule_WrongArity(ctx);
 */</comment>
<function><type><name>int</name></type> <name>RM_WrongArity</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></argument>,
        <argument><expr><literal type="string">"wrong number of arguments for '%s' command"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the client object the `RM_Reply*` functions should target.
 * Normally this is just `ctx-&gt;client`, that is the client that called
 * the module command, however in the case of thread safe contexts there
 * is no directly associated client (since it would not be safe to access
 * the client from a thread), so instead the blocked client object referenced
 * in the thread safe context, has a fake client that we just use to accumulate
 * the replies. Later, when the client is unblocked, the accumulated replies
 * are appended to the actual client.
 *
 * The function returns the client pointer depending on the context, or
 * NULL if there is no potential client. This happens when we are in the
 * context of a thread safe context that was not initialized with a blocked
 * client object. Other contexts without associated clients are the ones
 * initialized to run the timers callbacks. */</comment>
<function><type><name>client</name> <modifier>*</modifier></type><name>moduleGetReplyClient</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_THREAD_SAFE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>blocked_client</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>blocked_client</name><operator>-&gt;</operator><name>reply_client</name></name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If this is a non thread safe context, just return the client
         * that is running the command if any. This may be NULL as well
         * in the case of contexts that are not executed with associated
         * clients, like timer contexts. */</comment>
        <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Send an integer reply to the client, with the specified long long value.
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithLongLong</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply with an error or simple string (status message). Used to implement
 * ReplyWithSimpleString() and ReplyWithError().
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>replyWithStatus</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>strmsg</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>strmsg</name> <operator>=</operator> <call><name>sdscat</name><argument_list>(<argument><expr><name>strmsg</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>strmsg</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>strmsg</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>strmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply with the error 'err'.
 *
 * Note that 'err' must contain all the error, including
 * the initial error code. The function only provides the initial "-", so
 * the usage is, for example:
 *
 *     RedisModule_ReplyWithError(ctx,"ERR Wrong Type");
 *
 * and not just:
 *
 *     RedisModule_ReplyWithError(ctx,"Wrong Type");
 *
 * The function always returns REDISMODULE_OK.
 */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithError</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>replyWithStatus</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply with a simple string (+... \r\n in RESP protocol). This replies
 * are suitable only when sending a small non-binary string with small
 * overhead, like "OK" or similar replies.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithSimpleString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>replyWithStatus</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>,<argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply with an array type of 'len' elements. However 'len' other calls
 * to `ReplyWith*` style functions must follow in order to emit the elements
 * of the array.
 *
 * When producing arrays with a number of element that is not known beforehand
 * the function can be called with the special count
 * REDISMODULE_POSTPONED_ARRAY_LEN, and the actual number of elements can be
 * later set with RedisModule_ReplySetArrayLength() (which will set the
 * latest "open" count if there are multiple ones).
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithArray</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>REDISMODULE_POSTPONED_ARRAY_LEN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator>
                <operator>(</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_ULONG) */</comment>
        <name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name></expr>]</index></name> <init>=
            <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* When RedisModule_ReplyWithArray() is used with the argument
 * REDISMODULE_POSTPONED_ARRAY_LEN, because we don't know beforehand the number
 * of items we are going to output as elements of the array, this function
 * will take care to set the array length.
 *
 * Since it is possible to have multiple array replies pending with unknown
 * length, this function guarantees to always set the latest array length
 * that was created in a postponed way.
 *
 * For example in order to output an array like [1,[10,20,30]] we
 * could write:
 *
 *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);
 *      RedisModule_ReplyWithLongLong(ctx,1);
 *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);
 *      RedisModule_ReplyWithLongLong(ctx,10);
 *      RedisModule_ReplyWithLongLong(ctx,20);
 *      RedisModule_ReplyWithLongLong(ctx,30);
 *      RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.
 *      RedisModule_ReplySetArrayLength(ctx,2); // Set len of top array
 *
 * Note that in the above example there is no reason to postpone the array
 * length, since we produce a fixed number of elements, but in the practice
 * the code may use an iterator or other ways of creating the output so
 * that is not easy to calculate in advance the number of elements.
 */</comment>
<function><type><name>void</name></type> <name>RM_ReplySetArrayLength</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PORT_LONG</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"API misuse detected in module %s: "</literal>
            <literal type="string">"RedisModule_ReplySetArrayLength() called without previous "</literal>
            <literal type="string">"RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) "</literal>
            <literal type="string">"call."</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name></expr>]</index></name></expr></argument>,
            <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>postponed_arrays</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reply with a bulk string, taking in input a C buffer pointer and length.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithStringBuffer</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply with a bulk string, taking in input a C buffer pointer that is
 * assumed to be null-terminated.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithCString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply with a bulk string, taking in input a RedisModuleString object.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply to the client with a NULL. In the RESP protocol a NULL is encoded
 * as the string "$-1\r\n".
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithNull</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reply exactly what a Redis command returned us with RedisModule_Call().
 * This function is useful when we use RedisModule_Call() in order to
 * execute some command, as we want to reply to the client exactly the
 * same reply we obtained by the command.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithCallReply</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>proto</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></argument>, <argument><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send a string reply obtained converting the double 'd' into a bulk string.
 * This function is basically equivalent to converting a double into
 * a string into a C buffer, and then calling the function
 * RedisModule_ReplyWithStringBuffer() with the buffer and length.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplyWithDouble</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>moduleGetReplyClient</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Commands replication API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Helper function to replicate MULTI the first time we replicate something
 * in the context of a command execution. EXEC will be handled by the
 * RedisModuleCommandDispatcher() function. */</comment>
<function><type><name>void</name></type> <name>moduleReplicateMultiIfNeeded</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Skip this if client explicitly wrap the command with MULTI, or if
     * the module command was called by a script. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_MULTI</name><operator>|</operator><name>CLIENT_LUA</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* If we already emitted MULTI return ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_MULTI_EMITTED</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* If this is a thread safe context, we do not want to wrap commands
     * executed into MULTI/EXEC, they are executed as single commands
     * from an external client in essence. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_THREAD_SAFE</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* If this is a callback context, and not a module command execution
     * context, we have to setup the op array for the "also propagate" API
     * so that RM_Replicate() will work. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_MODULE_COMMAND_CALL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>saved_oparray</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>also_propagate</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>redisOpArrayInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server</name><operator>.</operator><name>also_propagate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>execCommandPropagateMulti</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_MULTI_EMITTED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Replicate the specified command and arguments to slaves and AOF, as effect
 * of execution of the calling command implementation.
 *
 * The replicated commands are always wrapped into the MULTI/EXEC that
 * contains all the commands replicated in a given module command
 * execution. However the commands replicated with RedisModule_Call()
 * are the first items, the ones replicated with RedisModule_Replicate()
 * will all follow before the EXEC.
 *
 * Modules should try to use one interface or the other.
 *
 * This command follows exactly the same interface of RedisModule_Call(),
 * so a set of format specifiers must be passed, followed by arguments
 * matching the provided format specifiers.
 *
 * Please refer to RedisModule_Call() for more information.
 *
 * Using the special "A" and "R" modifiers, the caller can exclude either
 * the AOF or the replicas from the propagation of the specified command.
 * Otherwise, by default, the command will be propagated in both channels.
 *
 * ## Note about calling this function from a thread safe context:
 *
 * Normally when you call this function from the callback implementing a
 * module command, or any other callback provided by the Redis Module API,
 * Redis will accumulate all the calls to this function in the context of
 * the callback, and will propagate all the commands wrapped in a MULTI/EXEC
 * transaction. However when calling this function from a threaded safe context
 * that can live an undefined amount of time, and can be locked/unlocked in
 * at will, the behavior is different: MULTI/EXEC wrapper is not emitted
 * and the command specified is inserted in the AOF and replication stream
 * immediately.
 *
 * ## Return value
 *
 * The command returns REDISMODULE_ERR if the format specifiers are invalid
 * or the command name does not belong to a known command. */</comment>
<function><type><name>int</name></type> <name>RM_Replicate</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>lookupCommandByCString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Create the client and dispatch the command. */</comment>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>moduleCreateArgvFromUserFormat</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Select the propagation target. Usually is AOF + replicas, however
     * the caller can exclude one or the other using the "A" or "R"
     * modifiers. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>target</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ARGV_NO_AOF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>target</name> <operator>|=</operator> <name>PROPAGATE_AOF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ARGV_NO_REPLICAS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>target</name> <operator>|=</operator> <name>PROPAGATE_REPL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Replicate! When we are in a threaded context, we want to just insert
     * the replicated command ASAP, since it is not clear when the context
     * will stop being used, so accumulating stuff does not make much sense,
     * nor we could easily use the alsoPropagate() API from threads. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_THREAD_SAFE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>propagate</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>moduleReplicateMultiIfNeeded</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Release the argv. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function will replicate the command exactly as it was invoked
 * by the client. Note that this function will not wrap the command into
 * a MULTI/EXEC stanza, so it should not be mixed with other replication
 * commands.
 *
 * Basically this form of replication is useful when you want to propagate
 * the command to the slaves and AOF file exactly as it was called, since
 * the command can just be re-executed to deterministically re-create the
 * new state starting from the old one.
 *
 * The function always returns REDISMODULE_OK. */</comment>
<function><type><name>int</name></type> <name>RM_ReplicateVerbatim</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
        <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>,
        <argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * DB and Key APIs -- Generic API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return the ID of the current client calling the currently active module
 * command. The returned ID has a few guarantees:
 *
 * 1. The ID is different for each different client, so if the same client
 *    executes a module command multiple times, it can be recognized as
 *    having the same ID, otherwise the ID will be different.
 * 2. The ID increases monotonically. Clients connecting to the server later
 *    are guaranteed to get IDs greater than any past ID previously seen.
 *
 * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way
 * to fetch the ID in the context the function was currently called. */</comment>
<function><type><name>PORT_ULONGLONG</name></type> <name>RM_GetClientId</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>id</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the currently selected DB. */</comment>
<function><type><name>int</name></type> <name>RM_GetSelectedDb</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Return the current context's flags. The flags provide information on the
 * current request context (whether the client is a Lua script or in a MULTI),
 * and about the Redis instance in general, i.e replication and persistence.
 *
 * The available flags are:
 *
 *  * REDISMODULE_CTX_FLAGS_LUA: The command is running in a Lua script
 *
 *  * REDISMODULE_CTX_FLAGS_MULTI: The command is running inside a transaction
 *
 *  * REDISMODULE_CTX_FLAGS_REPLICATED: The command was sent over the replication
 *    link by the MASTER
 *
 *  * REDISMODULE_CTX_FLAGS_MASTER: The Redis instance is a master
 *
 *  * REDISMODULE_CTX_FLAGS_SLAVE: The Redis instance is a slave
 *
 *  * REDISMODULE_CTX_FLAGS_READONLY: The Redis instance is read-only
 *
 *  * REDISMODULE_CTX_FLAGS_CLUSTER: The Redis instance is in cluster mode
 *
 *  * REDISMODULE_CTX_FLAGS_AOF: The Redis instance has AOF enabled
 *
 *  * REDISMODULE_CTX_FLAGS_RDB: The instance has RDB enabled
 *
 *  * REDISMODULE_CTX_FLAGS_MAXMEMORY:  The instance has Maxmemory set
 *
 *  * REDISMODULE_CTX_FLAGS_EVICT:  Maxmemory is set and has an eviction
 *    policy that may delete keys
 *
 *  * REDISMODULE_CTX_FLAGS_OOM: Redis is out of memory according to the
 *    maxmemory setting.
 *
 *  * REDISMODULE_CTX_FLAGS_OOM_WARNING: Less than 25% of memory remains before
 *                                       reaching the maxmemory level.
 *
 *  * REDISMODULE_CTX_FLAGS_LOADING: Server is loading RDB/AOF
 *
 *  * REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE: No active link with the master.
 *
 *  * REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING: The replica is trying to
 *                                                 connect with the master.
 *
 *  * REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING: Master -&gt; Replica RDB
 *                                                   transfer is in progress.
 *
 *  * REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE: The replica has an active link
 *                                             with its master. This is the
 *                                             contrary of STALE state.
 *
 *  * REDISMODULE_CTX_FLAGS_ACTIVE_CHILD: There is currently some background
 *                                        process active (RDB, AUX or module).
 */</comment>
<function><type><name>int</name></type> <name>RM_GetContextFlags</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Client specific flags */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_LUA</name></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_LUA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_MULTI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Module command recieved from MASTER, is replicated. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_REPLICATED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_CLUSTER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_LOADING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Maxmemory and eviction policy */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_MAXMEMORY</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>!=</operator> <name>MAXMEMORY_NO_EVICTION</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_EVICT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Persistence flags */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>!=</operator> <name>AOF_OFF</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_AOF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>saveparamslen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_RDB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Replication flags */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_MASTER</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_SLAVE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_slave_ro</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_READONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Replica state flags. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECT</name> <operator>||</operator>
            <name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTING</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_TRANSFER</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>==</operator> <name>REPL_STATE_CONNECTED</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>repl_state</name></name> <operator>!=</operator> <name>REPL_STATE_CONNECTED</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* OOM flag. */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>getMaxmemoryState</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_OOM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0.75</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_OOM_WARNING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Presence of children processes. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hasActiveChildProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REDISMODULE_CTX_FLAGS_ACTIVE_CHILD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Change the currently selected DB. Returns an error if the id
 * is out of range.
 *
 * Note that the client will retain the currently selected DB even after
 * the Redis command implemented by the module calling this function
 * returns.
 *
 * If the module command wishes to change something in a different DB and
 * returns back to the original one, it should call RedisModule_GetSelectedDb()
 * before in order to restore the old DB number before returning. */</comment>
<function><type><name>int</name></type> <name>RM_SelectDb</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>selectDb</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></argument>,<argument><expr><name>newid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>retval</name> <operator>==</operator> <name>C_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return an handle representing a Redis key, so that it is possible
 * to call other APIs with the key handle as argument to perform
 * operations on the key.
 *
 * The return value is the handle representing the key, that must be
 * closed with RM_CloseKey().
 *
 * If the key does not exist and WRITE mode is requested, the handle
 * is still returned, since it is possible to perform operations on
 * a yet not existing key (that will be created, for example, after
 * a list push operation). If the mode is just READ instead, and the
 * key does not exist, NULL is returned. However it is still safe to
 * call RedisModule_CloseKey() and RedisModule_KeyType() on a NULL
 * value. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_OpenKey</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>kp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Setup the key handle. */</comment>
    <expr_stmt><expr><name>kp</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>kp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>kp</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>kp</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>kp</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>keyname</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>kp</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>kp</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>kp</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zsetKeyReset</name><argument_list>(<argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_KEY</name></expr></argument>,<argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>kp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Close a key handle. */</comment>
<function><type><name>void</name></type> <name>RM_CloseKey</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* TODO: if (key-&gt;iter) RM_KeyIteratorStop(kp); */</comment>
    <expr_stmt><expr><call><name>RM_ZsetRangeStop</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>autoMemoryFreed</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,<argument><expr><name>REDISMODULE_AM_KEY</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the type of the key. If the key pointer is NULL then
 * REDISMODULE_KEYTYPE_EMPTY is returned. */</comment>
<function><type><name>int</name></type> <name>RM_KeyType</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator>  <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_KEYTYPE_EMPTY</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* We map between defines so that we are free to change the internal
     * defines as desired. */</comment>
    <switch>switch<condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_STRING</name></expr>:</case> <return>return <expr><name>REDISMODULE_KEYTYPE_STRING</name></expr>;</return>
    <case>case <expr><name>OBJ_LIST</name></expr>:</case> <return>return <expr><name>REDISMODULE_KEYTYPE_LIST</name></expr>;</return>
    <case>case <expr><name>OBJ_SET</name></expr>:</case> <return>return <expr><name>REDISMODULE_KEYTYPE_SET</name></expr>;</return>
    <case>case <expr><name>OBJ_ZSET</name></expr>:</case> <return>return <expr><name>REDISMODULE_KEYTYPE_ZSET</name></expr>;</return>
    <case>case <expr><name>OBJ_HASH</name></expr>:</case> <return>return <expr><name>REDISMODULE_KEYTYPE_HASH</name></expr>;</return>
    <case>case <expr><name>OBJ_MODULE</name></expr>:</case> <return>return <expr><name>REDISMODULE_KEYTYPE_MODULE</name></expr>;</return>
    <comment type="block">/* case OBJ_STREAM: return REDISMODULE_KEYTYPE_STREAM; - don't wanna add new API to 5.0 */</comment>
    <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Return the length of the value associated with the key.
 * For strings this is the length of the string. For all the other types
 * is the number of elements (just counting keys for hashes).
 *
 * If the key pointer is NULL or the key is empty, zero is returned. */</comment>
<function><type><name>size_t</name></type> <name>RM_ValueLength</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <switch>switch<condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OBJ_STRING</name></expr>:</case> <return>return <expr><call><name>stringObjectLen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_LIST</name></expr>:</case> <return>return <expr><call><name>listTypeLength</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_SET</name></expr>:</case> <return>return <expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_ZSET</name></expr>:</case> <return>return <expr><call><name>zsetLength</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_HASH</name></expr>:</case> <return>return <expr><call><name>hashTypeLength</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>OBJ_STREAM</name></expr>:</case> <return>return <expr><call><name>streamLength</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* If the key is open for writing, remove it, and setup the key to
 * accept new writes as an empty key (that will be created on demand).
 * On success REDISMODULE_OK is returned. If the key is not open for
 * writing REDISMODULE_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>RM_DeleteKey</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If the key is open for writing, unlink it (that is delete it in a 
 * non-blocking way, not reclaiming memory immediately) and setup the key to
 * accept new writes as an empty key (that will be created on demand).
 * On success REDISMODULE_OK is returned. If the key is not open for
 * writing REDISMODULE_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>RM_UnlinkKey</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the key expire value, as milliseconds of remaining TTL.
 * If no TTL is associated with the key or if the key is empty,
 * REDISMODULE_NO_EXPIRE is returned. */</comment>
<function><type><name>mstime_t</name></type> <name>RM_GetExpire</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>expire</name> <init>= <expr><call><name>getExpire</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>expire</name> <operator>-=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>expire</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>expire</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set a new expire for the key. If the special expire
 * REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was
 * one (the same as the PERSIST command).
 *
 * Note that the expire must be provided as a positive integer representing
 * the number of milliseconds of TTL the key should have.
 *
 * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if
 * the key was not open for writing or is an empty key. */</comment>
<function><type><name>int</name></type> <name>RM_SetExpire</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>mstime_t</name></type> <name>expire</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>expire</name> <operator>!=</operator> <name>REDISMODULE_NO_EXPIRE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>expire</name> <operator>+=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setExpire</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>expire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>removeExpire</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Key API for String type
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* If the key is open for writing, set the specified string 'str' as the
 * value of the key, deleting the old value if any.
 * On success REDISMODULE_OK is returned. If the key is not open for
 * writing or there is an active iterator, REDISMODULE_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>RM_StringSet</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>RM_DeleteKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Prepare the key associated string value for DMA access, and returns
 * a pointer and size (by reference), that the user can use to read or
 * modify the string in-place accessing it directly via pointer.
 *
 * The 'mode' is composed by bitwise OR-ing the following flags:
 *
 *     REDISMODULE_READ -- Read access
 *     REDISMODULE_WRITE -- Write access
 *
 * If the DMA is not requested for writing, the pointer returned should
 * only be accessed in a read-only fashion.
 *
 * On error (wrong type) NULL is returned.
 *
 * DMA access rules:
 *
 * 1. No other key writing function should be called since the moment
 * the pointer is obtained, for all the time we want to use DMA access
 * to read or modify the string.
 *
 * 2. Each time RM_StringTruncate() is called, to continue with the DMA
 * access, RM_StringDMA() should be called again to re-obtain
 * a new pointer and length.
 *
 * 3. If the returned pointer is not NULL, but the length is zero, no
 * byte can be touched (the string is empty, or the key itself is empty)
 * so a RM_StringTruncate() call should be used if there is to enlarge
 * the string, and later call StringDMA() again to get the pointer.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>RM_StringDMA</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* We need to return *some* pointer for empty keys, we just return
     * a string literal pointer, that is the advantage to be mapped into
     * a read only memory page, so the module will segfault if a write
     * attempt is performed. */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>emptystring</name> <init>= <expr><literal type="string">"&lt;dma-empty-string&gt;"</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>emptystring</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_STRING</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* For write access, and even for read access if the object is encoded,
     * we unshare the string (that has the side effect of decoding it). */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>OBJ_ENCODING_RAW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If the string is open for writing and is of string type, resize it, padding
 * with zero bytes if the new length is greater than the old one.
 *
 * After this call, RM_StringDMA() must be called again to continue
 * DMA access with the new pointer.
 *
 * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on
 * error, that is, the key is not open for writing, is not a string
 * or resizing for more than 512 MB is requested.
 *
 * If the key is empty, a string key is created with the new string value
 * unless the new length value requested is zero. */</comment>
<function><type><name>int</name></type> <name>RM_StringTruncate</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_STRING</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>&gt;</operator> <literal type="number">512</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Empty key and new len set to 0. Just return REDISMODULE_OK without
     * doing anything. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>newlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Empty key: create it with the new size. */</comment>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Unshare and resize. */</comment>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>curlen</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>&gt;</operator> <name>curlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsgrowzero</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>newlen</name> <operator>&lt;</operator> <name>curlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>newlen</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If the string is too wasteful, reallocate it. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>sdsavail</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsRemoveFreeSpace</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Key API for List type
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Push an element into a list, on head or tail depending on 'where' argument.
 * If the key pointer is about an empty key opened for writing, the key
 * is created. On error (key opened for read-only operations or of the wrong
 * type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned. */</comment>
<function><type><name>int</name></type> <name>RM_ListPush</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_LIST</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>moduleCreateEmptyKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>REDISMODULE_KEYTYPE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listTypePush</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>ele</name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>REDISMODULE_LIST_HEAD</name><operator>)</operator></expr> ?</condition><then> <expr><name>QUICKLIST_HEAD</name></expr> </then><else>: <expr><name>QUICKLIST_TAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pop an element from the list, and returns it as a module string object
 * that the user should be free with RM_FreeString() or by enabling
 * automatic memory. 'where' specifies if the element should be popped from
 * head or tail. The command returns NULL if:
 * 1) The list is empty.
 * 2) The key was not open for writing.
 * 3) The key is not a list. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_ListPop</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator>
        <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_LIST</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>listTypePop</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>REDISMODULE_LIST_HEAD</name><operator>)</operator></expr> ?</condition><then> <expr><name>QUICKLIST_HEAD</name></expr> </then><else>: <expr><name>QUICKLIST_TAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>decoded</name> <init>= <expr><call><name>getDecodedObject</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleDelKeyIfEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>decoded</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Key API for Sorted Set type
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Conversion from/to public flags of the Modules API and our private flags,
 * so that we have everything decoupled. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetAddFlagsToCoreFlags</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ZADD_XX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retflags</name> <operator>|=</operator> <name>ZADD_XX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ZADD_NX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retflags</name> <operator>|=</operator> <name>ZADD_NX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>retflags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See previous function comment. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetAddFlagsFromCoreFlags</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ZADD_ADDED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retflags</name> <operator>|=</operator> <name>REDISMODULE_ZADD_ADDED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ZADD_UPDATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retflags</name> <operator>|=</operator> <name>REDISMODULE_ZADD_UPDATED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ZADD_NOP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retflags</name> <operator>|=</operator> <name>REDISMODULE_ZADD_NOP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>retflags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new element into a sorted set, with the specified 'score'.
 * If the element already exists, the score is updated.
 *
 * A new sorted set is created at value if the key is an empty open key
 * setup for writing.
 *
 * Additional flags can be passed to the function via a pointer, the flags
 * are both used to receive input and to communicate state when the function
 * returns. 'flagsptr' can be NULL if no special flags are used.
 *
 * The input flags are:
 *
 *     REDISMODULE_ZADD_XX: Element must already exist. Do nothing otherwise.
 *     REDISMODULE_ZADD_NX: Element must not exist. Do nothing otherwise.
 *
 * The output flags are:
 *
 *     REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.
 *     REDISMODULE_ZADD_UPDATED: The score of the element was updated.
 *     REDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.
 *
 * On success the function returns REDISMODULE_OK. On the following errors
 * REDISMODULE_ERR is returned:
 *
 * * The key was not opened for writing.
 * * The key is of the wrong type.
 * * 'score' double value is not a number (NaN).
 */</comment>
<function><type><name>int</name></type> <name>RM_ZsetAdd</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flagsptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>moduleCreateEmptyKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>REDISMODULE_KEYTYPE_ZSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flagsptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>RM_ZsetAddFlagsToCoreFlags</name><argument_list>(<argument><expr><operator>*</operator><name>flagsptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>zsetAdd</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>flagsptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flagsptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flagsptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flagsptr</name> <operator>=</operator> <call><name>RM_ZsetAddFlagsFromCoreFlags</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function works exactly like RM_ZsetAdd(), but instead of setting
 * a new score, the score of the existing element is incremented, or if the
 * element does not already exist, it is added assuming the old score was
 * zero.
 *
 * The input and output flags, and the return value, have the same exact
 * meaning, with the only difference that this function will return
 * REDISMODULE_ERR even when 'score' is a valid double number, but adding it
 * to the existing score results into a NaN (not a number) condition.
 *
 * This function has an additional field 'newscore', if not NULL is filled
 * with the new score of the element after the increment, if no error
 * is returned. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetIncrby</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flagsptr</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newscore</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>moduleCreateEmptyKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>REDISMODULE_KEYTYPE_ZSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flagsptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>RM_ZsetAddFlagsToCoreFlags</name><argument_list>(<argument><expr><operator>*</operator><name>flagsptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_INCR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>zsetAdd</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>,<argument><expr><name>newscore</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>flagsptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flagsptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* zsetAdd() may signal back that the resulting score is not a number. */</comment>
    <if_stmt><if>if <condition>(<expr><name>flagsptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>flagsptr</name> <operator>&amp;</operator> <name>ZADD_NAN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>flagsptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flagsptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flagsptr</name> <operator>=</operator> <call><name>RM_ZsetAddFlagsFromCoreFlags</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified element from the sorted set.
 * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR
 * on one of the following conditions:
 *
 * * The key was not opened for writing.
 * * The key is of the wrong type.
 *
 * The return value does NOT indicate the fact the element was really
 * removed (since it existed) or not, just if the function was executed
 * with success.
 *
 * In order to know if the element was removed, the additional argument
 * 'deleted' must be passed, that populates the integer by reference
 * setting it to 1 or 0 depending on the outcome of the operation.
 * The 'deleted' argument can be NULL if the caller is not interested
 * to know if the element was really removed.
 *
 * Empty keys will be handled correctly by doing nothing. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetRem</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>zsetDel</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* On success retrieve the double score associated at the sorted set element
 * 'ele' and returns REDISMODULE_OK. Otherwise REDISMODULE_ERR is returned
 * to signal one of the following conditions:
 *
 * * There is no such element 'ele' in the sorted set.
 * * The key is not a sorted set.
 * * The key is an open empty key.
 */</comment>
<function><type><name>int</name></type> <name>RM_ZsetScore</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>zsetScore</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Key API for Sorted Set iterator
 * -------------------------------------------------------------------------- */</comment>

<function><type><name>void</name></type> <name>zsetKeyReset</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>=</operator> <name>REDISMODULE_ZSET_RANGE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Stop a sorted set iteration. */</comment>
<function><type><name>void</name></type> <name>RM_ZsetRangeStop</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Free resources if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_LEX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zlrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Setup sensible values so that misused iteration API calls when an
     * iterator is not active will result into something more sensible
     * than crashing. */</comment>
    <expr_stmt><expr><call><name>zsetKeyReset</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the "End of range" flag value to signal the end of the iteration. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetRangeEndReached</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function for RM_ZsetFirstInScoreRange() and RM_ZsetLastInScoreRange().
 * Setup the sorted set iteration according to the specified score range
 * (see the functions calling it for more info). If 'first' is true the
 * first element in the range is used as a starting point for the iterator
 * otherwise the last. Return REDISMODULE_OK on success otherwise
 * REDISMODULE_ERR. */</comment>
<function><type><name>int</name></type> <name>zsetInitScoreRange</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>RM_ZsetRangeStop</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>=</operator> <name>REDISMODULE_ZSET_RANGE_SCORE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */</comment>
    <decl_stmt><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>zrs</name> <init>= <expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zrs</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zrs</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zrs</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zrs</name><operator>-&gt;</operator><name>minex</name></name> <operator>=</operator> <name>minex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zrs</name><operator>-&gt;</operator><name>maxex</name></name> <operator>=</operator> <name>maxex</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>zrs</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                <expr><call><name>zzlLastInRange</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>zrs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><call><name>zslFirstInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>zrs</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                <expr><call><name>zslLastInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>zrs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Setup a sorted set iterator seeking the first element in the specified
 * range. Returns REDISMODULE_OK if the iterator was correctly initialized
 * otherwise REDISMODULE_ERR is returned in the following conditions:
 *
 * 1. The value stored at key is not a sorted set or the key is empty.
 *
 * The range is specified according to the two double values 'min' and 'max'.
 * Both can be infinite using the following two macros:
 *
 * REDISMODULE_POSITIVE_INFINITE for positive infinite value
 * REDISMODULE_NEGATIVE_INFINITE for negative infinite value
 *
 * 'minex' and 'maxex' parameters, if true, respectively setup a range
 * where the min and max value are exclusive (not included) instead of
 * inclusive. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetFirstInScoreRange</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxex</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zsetInitScoreRange</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><name>minex</name></expr></argument>,<argument><expr><name>maxex</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of
 * the range is selected for the start of the iteration instead. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetLastInScoreRange</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxex</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zsetInitScoreRange</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><name>minex</name></expr></argument>,<argument><expr><name>maxex</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function for RM_ZsetFirstInLexRange() and RM_ZsetLastInLexRange().
 * Setup the sorted set iteration according to the specified lexicographical
 * range (see the functions calling it for more info). If 'first' is true the
 * first element in the range is used as a starting point for the iterator
 * otherwise the last. Return REDISMODULE_OK on success otherwise
 * REDISMODULE_ERR.
 *
 * Note that this function takes 'min' and 'max' in the same form of the
 * Redis ZRANGEBYLEX command. */</comment>
<function><type><name>int</name></type> <name>zsetInitLexRange</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>RM_ZsetRangeStop</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */</comment>
    <decl_stmt><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>zlrs</name> <init>= <expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zlrs</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>zlrs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Set the range type to lex only after successfully parsing the range,
     * otherwise we don't want the zlexrangespec to be freed. */</comment>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>=</operator> <name>REDISMODULE_ZSET_RANGE_LEX</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>zlrs</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                <expr><call><name>zzlLastInLexRange</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>zlrs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><call><name>zslFirstInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>zlrs</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                <expr><call><name>zslLastInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>zlrs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Setup a sorted set iterator seeking the first element in the specified
 * lexicographical range. Returns REDISMODULE_OK if the iterator was correctly
 * initialized otherwise REDISMODULE_ERR is returned in the
 * following conditions:
 *
 * 1. The value stored at key is not a sorted set or the key is empty.
 * 2. The lexicographical range 'min' and 'max' format is invalid.
 *
 * 'min' and 'max' should be provided as two RedisModuleString objects
 * in the same format as the parameters passed to the ZRANGEBYLEX command.
 * The function does not take ownership of the objects, so they can be released
 * ASAP after the iterator is setup. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetFirstInLexRange</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zsetInitLexRange</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Exactly like RedisModule_ZsetFirstInLexRange() but the last element of
 * the range is selected for the start of the iteration instead. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetLastInLexRange</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zsetInitLexRange</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>min</name></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current sorted set element of an active sorted set iterator
 * or NULL if the range specified in the iterator does not include any
 * element. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_ZsetRangeCurrentElement</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>ziplistGetObject</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>score</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>score</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Go to the next element of the sorted set iterator. Returns 1 if there was
 * a next element, 0 if we are already at the latest element or the range
 * does not include any item at all. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetRangeNext</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>||</operator> <operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* No active iterator. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip element. */</comment>
        <if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Skip score. */</comment>
        <if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Are we still within the range? */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_SCORE</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Fetch the next element score for the
                 * range check. */</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>saved_next</name> <init>= <expr><name>next</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip next element. */</comment>
                <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><call><name>zzlGetScore</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Obtain the next score. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zrs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>next</name> <operator>=</operator> <name>saved_next</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_LEX</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>next</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zlrs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Are we still within the range? */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_SCORE</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zrs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_LEX</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zlrs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Go to the previous element of the sorted set iterator. Returns 1 if there was
 * a previous element, 0 if we are already at the first element or the range
 * does not include any item at all. */</comment>
<function><type><name>int</name></type> <name>RM_ZsetRangePrev</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>||</operator> <operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* No active iterator. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Go back to previous score. */</comment>
        <if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Back to previous ele. */</comment>
        <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Are we still within the range? */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_SCORE</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Fetch the previous element score for the
                 * range check. */</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>saved_prev</name> <init>= <expr><name>prev</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip element to get the score.*/</comment>
                <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><call><name>zzlGetScore</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Obtain the prev score. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zrs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>saved_prev</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_LEX</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>prev</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zlrs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Are we still within the range? */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_SCORE</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zrs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>ztype</name></name> <operator>==</operator> <name>REDISMODULE_ZSET_RANGE_LEX</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>zlrs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zer</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>zcurrent</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Key API for Hash type
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Set the field of the specified hash field to the specified value.
 * If the key is an empty key open for writing, it is created with an empty
 * hash value, in order to set the specified field.
 *
 * The function is variadic and the user must specify pairs of field
 * names and values, both as RedisModuleString pointers (unless the
 * CFIELD option is set, see later). At the end of the field/value-ptr pairs, 
 * NULL must be specified as last argument to signal the end of the arguments 
 * in the variadic function.
 *
 * Example to set the hash argv[1] to the value argv[2]:
 *
 *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);
 *
 * The function can also be used in order to delete fields (if they exist)
 * by setting them to the specified value of REDISMODULE_HASH_DELETE:
 *
 *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],
 *                          REDISMODULE_HASH_DELETE,NULL);
 *
 * The behavior of the command changes with the specified flags, that can be
 * set to REDISMODULE_HASH_NONE if no special behavior is needed.
 *
 *     REDISMODULE_HASH_NX: The operation is performed only if the field was not
 *                          already existing in the hash.
 *     REDISMODULE_HASH_XX: The operation is performed only if the field was
 *                          already existing, so that a new value could be
 *                          associated to an existing filed, but no new fields
 *                          are created.
 *     REDISMODULE_HASH_CFIELDS: The field names passed are null terminated C
 *                               strings instead of RedisModuleString objects.
 *
 * Unless NX is specified, the command overwrites the old field value with
 * the new one.
 *
 * When using REDISMODULE_HASH_CFIELDS, field names are reported using
 * normal C strings, so for example to delete the field "foo" the following
 * code can be used:
 *
 *      RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,"foo",
 *                          REDISMODULE_HASH_DELETE,NULL);
 *
 * Return value:
 *
 * The number of fields updated (that may be less than the number of fields
 * specified because of the XX or NX options).
 *
 * In the following case the return value is always zero:
 *
 * * The key was not open for writing.
 * * The key was associated with a non Hash value.
 */</comment>
<function><type><name>int</name></type> <name>RM_HashSet</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_HASH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>moduleCreateEmptyKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>REDISMODULE_KEYTYPE_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>updated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>field</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
        <comment type="block">/* Get the field and value objects. */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cfield</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cfield</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>createRawStringObject</name><argument_list>(<argument><expr><name>cfield</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cfield</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>RedisModuleString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>RedisModuleString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Handle XX and NX */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>REDISMODULE_HASH_XX</name><operator>|</operator><name>REDISMODULE_HASH_NX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>exists</name> <init>= <expr><call><name>hashTypeExists</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_XX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>exists</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_NX</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>exists</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Handle deletion if value is REDISMODULE_HASH_DELETE. */</comment>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>REDISMODULE_HASH_DELETE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>updated</name> <operator>+=</operator> <call><name>hashTypeDelete</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>low_flags</name> <init>= <expr><name>HASH_SET_COPY</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* If CFIELDS is active, we can pass the ownership of the
         * SDS object to the low level function that sets the field
         * to avoid a useless copy. */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>low_flags</name> <operator>|=</operator> <name>HASH_SET_TAKE_FIELD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>field</name></expr>,<expr><name>value</name></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>hashTypeTryConversion</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>updated</name> <operator>+=</operator> <call><name>hashTypeSet</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>low_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If CFIELDS is active, SDS string ownership is now of hashTypeSet(),
         * however we still have to release the 'field' object shell. */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Prevent the SDS string from being freed. */</comment>
           <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleDelKeyIfEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>updated</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get fields from an hash value. This function is called using a variable
 * number of arguments, alternating a field name (as a StringRedisModule
 * pointer) with a pointer to a StringRedisModule pointer, that is set to the
 * value of the field if the field exist, or NULL if the field did not exist.
 * At the end of the field/value-ptr pairs, NULL must be specified as last
 * argument to signal the end of the arguments in the variadic function.
 *
 * This is an example usage:
 *
 *      RedisModuleString *first, *second;
 *      RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&amp;first,
 *                      argv[2],&amp;second,NULL);
 *
 * As with RedisModule_HashSet() the behavior of the command can be specified
 * passing flags different than REDISMODULE_HASH_NONE:
 *
 * REDISMODULE_HASH_CFIELD: field names as null terminated C strings.
 *
 * REDISMODULE_HASH_EXISTS: instead of setting the value of the field
 * expecting a RedisModuleString pointer to pointer, the function just
 * reports if the field esists or not and expects an integer pointer
 * as the second element of each pair.
 *
 * Example of REDISMODULE_HASH_CFIELD:
 *
 *      RedisModuleString *username, *hashedpass;
 *      RedisModule_HashGet(mykey,"username",&amp;username,"hp",&amp;hashedpass, NULL);
 *
 * Example of REDISMODULE_HASH_EXISTS:
 *
 *      int exists;
 *      RedisModule_HashGet(mykey,argv[1],&amp;exists,NULL);
 *
 * The function returns REDISMODULE_OK on success and REDISMODULE_ERR if
 * the key is not an hash value.
 *
 * Memory management:
 *
 * The returned RedisModuleString objects should be released with
 * RedisModule_FreeString(), or by enabling automatic memory management.
 */</comment>
<function><type><name>int</name></type> <name>RM_HashGet</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_HASH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>field</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>valueptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>existsptr</name></decl>;</decl_stmt>
        <comment type="block">/* Get the field object and the value pointer to pointer. */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cfield</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cfield</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>createRawStringObject</name><argument_list>(<argument><expr><name>cfield</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cfield</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>RedisModuleString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Query the hash for existence or value object. */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_EXISTS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>existsptr</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>existsptr</name> <operator>=</operator> <call><name>hashTypeExists</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name><name>field</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>existsptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>valueptr</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>RedisModuleString</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>valueptr</name> <operator>=</operator> <call><name>hashTypeGetValueObject</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,<argument><expr><name><name>field</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>valueptr</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>decoded</name> <init>= <expr><call><name>getDecodedObject</name><argument_list>(<argument><expr><operator>*</operator><name>valueptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><operator>*</operator><name>valueptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>valueptr</name> <operator>=</operator> <name>decoded</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>valueptr</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,<argument><expr><name>REDISMODULE_AM_STRING</name></expr></argument>,<argument><expr><operator>*</operator><name>valueptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>valueptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Cleanup */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_HASH_CFIELDS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Redis &lt;-&gt; Modules generic Call() API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Create a new RedisModuleCallReply object. The processing of the reply
 * is lazy, the object is just populated with the raw protocol and later
 * is processed as needed. Initially we just make sure to set the right
 * reply type, which is extremely cheap to do. */</comment>
<function><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>moduleCreateCallReplyFromProto</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>proto</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>reply</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name> <operator>=</operator> <name>proto</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>REDISMODULE_REPLYFLAG_TOPARSE</name></expr>;</expr_stmt> <comment type="block">/* Lazy parsing. */</comment>
    <switch>switch<condition>(<expr><name><name>proto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'$'</literal></expr>:</case>
    <case>case <expr><literal type="char">'+'</literal></expr>:</case> <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_STRING</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case> <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_ERROR</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">':'</literal></expr>:</case> <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_INTEGER</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'*'</literal></expr>:</case> <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_ARRAY</name></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_UNKNOWN</name></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>proto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name><name>proto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>proto</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>reply</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>moduleParseCallReply_Int</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>moduleParseCallReply_BulkString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>moduleParseCallReply_SimpleString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>moduleParseCallReply_Array</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Do nothing if REDISMODULE_REPLYFLAG_TOPARSE is false, otherwise
 * use the protcol of the reply in reply-&gt;proto in order to fill the
 * reply with parsed data according to the reply type. */</comment>
<function><type><name>void</name></type> <name>moduleParseCallReply</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_REPLYFLAG_TOPARSE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>REDISMODULE_REPLYFLAG_TOPARSE</name></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">':'</literal></expr>:</case> <expr_stmt><expr><call><name>moduleParseCallReply_Int</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'$'</literal></expr>:</case> <expr_stmt><expr><call><name>moduleParseCallReply_BulkString</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case> <comment type="block">/* handled by next item. */</comment>
    <case>case <expr><literal type="char">'+'</literal></expr>:</case> <expr_stmt><expr><call><name>moduleParseCallReply_SimpleString</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'*'</literal></expr>:</case> <expr_stmt><expr><call><name>moduleParseCallReply_Array</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleParseCallReply_Int</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>proto</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>string2ll</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p</name><operator>-</operator><name>proto</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ll</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_INTEGER</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleParseCallReply_BulkString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>proto</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>bulklen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>string2ll</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p</name><operator>-</operator><name>proto</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>bulklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bulklen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>p</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>bulklen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>bulklen</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_STRING</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleParseCallReply_SimpleString</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>proto</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>proto</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name><name>proto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr> ?</condition><then> <expr><name>REDISMODULE_REPLY_STRING</name></expr> </then><else>:
                                    <expr><name>REDISMODULE_REPLY_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleParseCallReply_Array</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>proto</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>arraylen</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>string2ll</name><argument_list>(<argument><expr><name>proto</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p</name><operator>-</operator><name>proto</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>arraylen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RedisModuleCallReply</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>arraylen</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>arraylen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name></name><operator>+</operator><name>j</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>REDISMODULE_REPLYFLAG_NESTED</name> <operator>|</operator>
                     <name>REDISMODULE_REPLYFLAG_TOPARSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>proto</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>ctx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>moduleParseCallReply</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>ele</name><operator>-&gt;</operator><name>protolen</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>protolen</name></name> <operator>=</operator> <name>p</name><operator>-</operator><name>proto</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>REDISMODULE_REPLY_ARRAY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a Call reply and all the nested replies it contains if it's an
 * array. */</comment>
<function><type><name>void</name></type> <name>RM_FreeCallReply_Rec</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freenested</name></decl></parameter>)</parameter_list><block>{<block_content>
    <comment type="block">/* Don't free nested replies by default: the user must always free the
     * toplevel reply. However be gentle and don't crash if the module
     * misuses the API. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>freenested</name> <operator>&amp;&amp;</operator> <name><name>reply</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_REPLYFLAG_NESTED</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_REPLYFLAG_TOPARSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>REDISMODULE_REPLY_ARRAY</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RM_FreeCallReply_Rec</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name></name><operator>+</operator><name>j</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* For nested replies, we don't free reply-&gt;proto (which if not NULL
     * references the parent reply-&gt;proto buffer), nor the structure
     * itself which is allocated as an array of structures, and is freed
     * when the array value is released. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>reply</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_REPLYFLAG_NESTED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Wrapper for the recursive free reply function. This is needed in order
 * to have the first level function to return on nested replies, but only
 * if called by the module API. */</comment>
<function><type><name>void</name></type> <name>RM_FreeCallReply</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>reply</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RM_FreeCallReply_Rec</name><argument_list>(<argument><expr><name>reply</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>autoMemoryFreed</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_REPLY</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the reply type. */</comment>
<function><type><name>int</name></type> <name>RM_CallReplyType</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>reply</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_REPLY_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the reply type length, where applicable. */</comment>
<function><type><name>size_t</name></type> <name>RM_CallReplyLength</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleParseCallReply</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>REDISMODULE_REPLY_STRING</name></expr>:</case>
    <case>case <expr><name>REDISMODULE_REPLY_ERROR</name></expr>:</case>
    <case>case <expr><name>REDISMODULE_REPLY_ARRAY</name></expr>:</case>
        <return>return <expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr>;</return>
    <default>default:</default>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Return the 'idx'-th nested call reply element of an array reply, or NULL
 * if the reply type is wrong or the index is out of range. */</comment>
<function><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>RM_CallReplyArrayElement</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleParseCallReply</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDISMODULE_REPLY_ARRAY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name></name><operator>+</operator><name>idx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the long long of an integer reply. */</comment>
<function><type><name>PORT_LONGLONG</name></type> <name>RM_CallReplyInteger</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleParseCallReply</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDISMODULE_REPLY_INTEGER</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>LLONG_MIN</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ll</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the pointer and length of a string or error reply. */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>RM_CallReplyStringPtr</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleParseCallReply</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDISMODULE_REPLY_STRING</name> <operator>&amp;&amp;</operator>
        <name><name>reply</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>REDISMODULE_REPLY_ERROR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a new string object from a call reply of type string, error or
 * integer. Otherwise (wrong reply type) return NULL. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_CreateStringFromCallReply</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleParseCallReply</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>REDISMODULE_REPLY_STRING</name></expr>:</case>
    <case>case <expr><name>REDISMODULE_REPLY_ERROR</name></expr>:</case>
        <return>return <expr><call><name>RM_CreateString</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>,<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>REDISMODULE_REPLY_INTEGER</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ll</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>RM_CreateString</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
    <default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Returns an array of robj pointers, and populates *argc with the number
 * of items, by parsing the format specifier "fmt" as described for
 * the RM_Call(), RM_Replicate() and other module APIs.
 *
 * The integer pointed by 'flags' is populated with flags according
 * to special modifiers in "fmt". For now only one exists:
 *
 *     "!" -&gt; REDISMODULE_ARGV_REPLICATE
 *     "A" -&gt; REDISMODULE_ARGV_NO_AOF
 *     "R" -&gt; REDISMODULE_ARGV_NO_REPLICAS
 *
 * On error (format specifier error) NULL is returned and nothing is
 * allocated. On success the argument vector is returned. */</comment>
<function><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>moduleCreateArgvFromUserFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argcp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>argv_size</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* As a first guess to avoid useless reallocations, size argv to
     * hold one argument for each char specifier in 'fmt'. */</comment>
    <expr_stmt><expr><name>argv_size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* +1 because of the command name. */</comment>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argv_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build the arguments vector based on the format specifier. */</comment>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Create the client and dispatch the command. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>fmt</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>ll</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>PORT_LONGLONG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition> <block>{<block_content>
             <comment type="block">/* A vector of strings */</comment>
             <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
             <decl_stmt><decl><type><name>size_t</name></type> <name>vlen</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

             <comment type="block">/* We need to grow argv to hold the vector's elements.
              * We resize by vector_len-1 elements, because we held
              * one element in argv for the vector already */</comment>
             <expr_stmt><expr><name>argv_size</name> <operator>+=</operator> <name>vlen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
             <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argv_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

             <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
             <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>vlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                 <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
             </block_content>}</block></for>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>flags</name><operator>)</operator> <operator>|=</operator> <name>REDISMODULE_ARGV_REPLICATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>flags</name><operator>)</operator> <operator>|=</operator> <name>REDISMODULE_ARGV_NO_AOF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>flags</name><operator>)</operator> <operator>|=</operator> <name>REDISMODULE_ARGV_NO_REPLICAS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <goto>goto <name>fmterr</name>;</goto>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>argcp</name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
    <return>return <expr><name>argv</name></expr>;</return>

<label><name>fmterr</name>:</label>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Exported API to call any Redis command from modules.
 * On success a RedisModuleCallReply object is returned, otherwise
 * NULL is returned and errno is set to the following values:
 *
 * EINVAL: command non existing, wrong arity, wrong format specifier.
 * EPERM:  operation in Cluster instance with key in non local slot.
 *
 * This API is documented here: https://redis.io/topics/modules-intro
 */</comment>
<function><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>RM_Call</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>replicate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Replicate this command? */</comment>

    <comment type="block">/* Create the client and dispatch the command. */</comment>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>createClient</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>moduleCreateArgvFromUserFormat</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>replicate</name> <operator>=</operator> <name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ARGV_REPLICATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Setup our fake client for command execution. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_MODULE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>in_call</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We handle the above format error only when the client is setup so that
     * we can free it normally. */</comment>
    <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Call command filters */</comment>
    <expr_stmt><expr><call><name>moduleCallCommandFilters</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Lookup command now, after filters had a chance to make modifications
     * if necessary.
     */</comment>
    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>lookupCommand</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>lastcmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>

    <comment type="block">/* Basic arity checks. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name> <operator>!=</operator> <name>argc</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>argc</name> <operator>&lt;</operator> <operator>-</operator><name><name>cmd</name><operator>-&gt;</operator><name>arity</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is a Redis Cluster node, we need to make sure the module is not
     * trying to access non-local keys, with the exception of commands
     * received from our master. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MASTER</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Duplicate relevant flags in the module client. */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CLIENT_READONLY</name><operator>|</operator><name>CLIENT_ASKING</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLIENT_READONLY</name><operator>|</operator><name>CLIENT_ASKING</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getNodeByQuery</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
                           <name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EPERM</name></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we are using single commands replication, we need to wrap what
     * we propagate into a MULTI/EXEC block, so that it will be atomic like
     * a Lua script in the context of AOF and slaves. */</comment>
    <if_stmt><if>if <condition>(<expr><name>replicate</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>moduleReplicateMultiIfNeeded</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Run the command */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>call_flags</name> <init>= <expr><name>CMD_CALL_SLOWLOG</name> <operator>|</operator> <name>CMD_CALL_STATS</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>replicate</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ARGV_NO_AOF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>call_flags</name> <operator>|=</operator> <name>CMD_CALL_PROPAGATE_AOF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_ARGV_NO_REPLICAS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>call_flags</name> <operator>|=</operator> <name>CMD_CALL_PROPAGATE_REPL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>call</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>call_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert the result of the Redis command into a suitable Lua type.
     * The first thing we need is to create a single string from the client
     * output buffers. */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>proto</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clientReplyBlock</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>proto</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>proto</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><call><name>listFirst</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>reply</name> <operator>=</operator> <call><name>moduleCreateCallReplyFromProto</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_REPLY</name></expr></argument>,<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>in_call</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>reply</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer, and a length, to the protocol returned by the command
 * that returned the reply object. */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>RM_CallReplyProto</name><parameter_list>(<parameter><decl><type><name>RedisModuleCallReply</name> <modifier>*</modifier></type><name>reply</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>reply</name><operator>-&gt;</operator><name>proto</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules data types
 *
 * When String DMA or using existing data structures is not enough, it is
 * possible to create new data types from scratch and export them to
 * Redis. The module must provide a set of callbacks for handling the
 * new values exported (for example in order to provide RDB saving/loading,
 * AOF rewrite, and so forth). In this section we define this API.
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Turn a 9 chars name in the specified charset and a 10 bit encver into
 * a single 64 bit unsigned integer that represents this exact module name
 * and version. This final number is called a "type ID" and is used when
 * writing module exported values to RDB files, in order to re-associate the
 * value to the right module to load them during RDB loading.
 *
 * If the string is not of the right length or the charset is wrong, or
 * if encver is outside the unsigned 10 bit integer range, 0 is returned,
 * otherwise the function returns the right type ID.
 *
 * The resulting 64 bit integer is composed as follows:
 *
 *     (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)
 *
 * The first 6 bits value is the first character, name[0], while the last
 * 6 bits value, immediately before the 10 bits integer, is name[8].
 * The last 10 bits are the encoding version.
 *
 * Note that a name and encver combo of "AAAAAAAAA" and 0, will produce
 * zero as return value, that is the same we use to signal errors, thus
 * this combination is invalid, and also useless since type names should
 * try to be vary to avoid collisions. */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ModuleTypeNameCharSet</name> <init>=
             <expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal>
             <literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
             <literal type="string">"0123456789-_"</literal></expr></init></decl>;</decl_stmt>

<function><type><name>uint64_t</name></type> <name>moduleTypeEncodeId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encver</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* We use 64 symbols so that we can map each character into 6 bits
     * of the final output. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cset</name> <init>= <expr><name>ModuleTypeNameCharSet</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>encver</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>encver</name></expr></argument> &gt;</argument_list></name> <literal type="number">1023</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>cset</name></expr></argument>,<argument><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>pos</name> <init>= <expr><name>p</name><operator>-</operator><name>cset</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>id</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <name>pos</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>id</name> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>|</operator> <name>encver</name></expr>;</expr_stmt>
    <return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search, in the list of exported data types of all the modules registered,
 * a type with the same name as the one given. Returns the moduleType
 * structure pointer if such a module is found, or NULL otherwise. */</comment>
<function><type><name>moduleType</name> <modifier>*</modifier></type><name>moduleTypeLookupModuleByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>mt</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Lookup a module by ID, with caching. This function is used during RDB
 * loading. Modules exporting data types should never be able to unload, so
 * our cache does not need to expire. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODULE_LOOKUP_CACHE_SIZE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<function><type><name>moduleType</name> <modifier>*</modifier></type><name>moduleTypeLookupModuleByID</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <struct><specifier>static</specifier> struct <block>{
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name></decl>;</decl_stmt>
    }</block> <decl><name><name>cache</name><index>[<expr><name>MODULE_LOOKUP_CACHE_SIZE</name></expr>]</index></name></decl>;</struct>

    <comment type="block">/* Search in cache to start. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>MODULE_LOOKUP_CACHE_SIZE</name> <operator>&amp;&amp;</operator> <name><name>cache</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mt</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cache</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>cache</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mt</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* Slow module by module lookup. */</comment>
    <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>mt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>this_mt</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Compare only the 54 bit module identifier and not the
             * encoding version. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>this_mt</name><operator>-&gt;</operator><name>id</name></name> <operator>&gt;&gt;</operator> <literal type="number">10</literal> <operator>==</operator> <name>id</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>mt</name> <operator>=</operator> <name>this_mt</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add to cache if possible. */</comment>
    <if_stmt><if>if <condition>(<expr><name>mt</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>MODULE_LOOKUP_CACHE_SIZE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cache</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cache</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mt</name> <operator>=</operator> <name>mt</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>mt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Turn an (unresolved) module ID into a type name, to show the user an
 * error when RDB files contain module data we can't load.
 * The buffer pointed by 'name' must be 10 bytes at least. The function will
 * fill it with a null terminated module name. */</comment>
<function><type><name>void</name></type> <name>moduleTypeNameByID</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>moduleid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cset</name> <init>= <expr><name>ModuleTypeNameCharSet</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>name</name><operator>+</operator><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>moduleid</name> <operator>&gt;&gt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>--</operator> <operator>=</operator> <name><name>cset</name><index>[<expr><name>moduleid</name> <operator>&amp;</operator> <literal type="number">63</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>moduleid</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Register a new data type exported by the module. The parameters are the
 * following. Please for in depth documentation check the modules API
 * documentation, especially the TYPES.md file.
 *
 * * **name**: A 9 characters data type name that MUST be unique in the Redis
 *   Modules ecosystem. Be creative... and there will be no collisions. Use
 *   the charset A-Z a-z 9-0, plus the two "-_" characters. A good
 *   idea is to use, for example `&lt;typename&gt;-&lt;vendor&gt;`. For example
 *   "tree-AntZ" may mean "Tree data structure by @antirez". To use both
 *   lower case and upper case letters helps in order to prevent collisions.
 * * **encver**: Encoding version, which is, the version of the serialization
 *   that a module used in order to persist data. As long as the "name"
 *   matches, the RDB loading will be dispatched to the type callbacks
 *   whatever 'encver' is used, however the module can understand if
 *   the encoding it must load are of an older version of the module.
 *   For example the module "tree-AntZ" initially used encver=0. Later
 *   after an upgrade, it started to serialize data in a different format
 *   and to register the type with encver=1. However this module may
 *   still load old data produced by an older version if the rdb_load
 *   callback is able to check the encver value and act accordingly.
 *   The encver must be a positive value between 0 and 1023.
 * * **typemethods_ptr** is a pointer to a RedisModuleTypeMethods structure
 *   that should be populated with the methods callbacks and structure
 *   version, like in the following example:
 *
 *      RedisModuleTypeMethods tm = {
 *          .version = REDISMODULE_TYPE_METHOD_VERSION,
 *          .rdb_load = myType_RDBLoadCallBack,
 *          .rdb_save = myType_RDBSaveCallBack,
 *          .aof_rewrite = myType_AOFRewriteCallBack,
 *          .free = myType_FreeCallBack,
 *
 *          // Optional fields
 *          .digest = myType_DigestCallBack,
 *          .mem_usage = myType_MemUsageCallBack,
 *      }
 *
 * * **rdb_load**: A callback function pointer that loads data from RDB files.
 * * **rdb_save**: A callback function pointer that saves data to RDB files.
 * * **aof_rewrite**: A callback function pointer that rewrites data as commands.
 * * **digest**: A callback function pointer that is used for `DEBUG DIGEST`.
 * * **free**: A callback function pointer that can free a type value.
 *
 * The **digest* and **mem_usage** methods should currently be omitted since
 * they are not yet implemented inside the Redis modules core.
 *
 * Note: the module name "AAAAAAAAA" is reserved and produces an error, it
 * happens to be pretty lame as well.
 *
 * If there is already a module registering a type with the same name,
 * and if the module name or encver is invalid, NULL is returned.
 * Otherwise the new type is registered into Redis, and a reference of
 * type RedisModuleType is returned: the caller of the function should store
 * this reference into a gobal variable to make future use of it in the
 * modules type API, since a single module may register multiple types.
 * Example code fragment:
 *
 *      static RedisModuleType *BalancedTreeType;
 *
 *      int RedisModule_OnLoad(RedisModuleCtx *ctx) {
 *          // some code here ...
 *          BalancedTreeType = RM_CreateDataType(...);
 *      }
 */</comment>
<function><type><name>moduleType</name> <modifier>*</modifier></type><name>RM_CreateDataType</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encver</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>typemethods_ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name> <init>= <expr><call><name>moduleTypeEncodeId</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name>encver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>moduleTypeLookupModuleByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>typemethods_version</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PORT_LONG</name><operator>*</operator><operator>)</operator><name>typemethods_ptr</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>typemethods_version</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <struct>struct <name>typemethods</name> <block>{
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>version</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleTypeLoadFunc</name></type> <name>rdb_load</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleTypeSaveFunc</name></type> <name>rdb_save</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleTypeRewriteFunc</name></type> <name>aof_rewrite</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleTypeMemUsageFunc</name></type> <name>mem_usage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleTypeDigestFunc</name></type> <name>digest</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>moduleTypeFreeFunc</name></type> <name>free</name></decl>;</decl_stmt>
        <struct>struct <block>{
            <decl_stmt><decl><type><name>moduleTypeAuxLoadFunc</name></type> <name>aux_load</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>moduleTypeAuxSaveFunc</name></type> <name>aux_save</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>aux_save_triggers</name></decl>;</decl_stmt>
        }</block> <decl><name>v2</name></decl>;</struct>
    }</block> <decl><modifier>*</modifier><name>tms</name> <init>= <expr><operator>(</operator>struct <name>typemethods</name><operator>*</operator><operator>)</operator> <name>typemethods_ptr</name></expr></init></decl>;</struct>

    <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>rdb_load</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>rdb_load</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>rdb_save</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>rdb_save</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>aof_rewrite</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>aof_rewrite</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>mem_usage</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>mem_usage</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>digest</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>digest</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>free</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tms</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>aux_load</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>v2</name><operator>.</operator><name>aux_load</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>aux_save</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>v2</name><operator>.</operator><name>aux_save</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>aux_save_triggers</name></name> <operator>=</operator> <name><name>tms</name><operator>-&gt;</operator><name>v2</name><operator>.</operator><name>aux_save_triggers</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If the key is open for writing, set the specified module type object
 * as the value of the key, deleting the old value if any.
 * On success REDISMODULE_OK is returned. If the key is not open for
 * writing or there is an active iterator, REDISMODULE_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>RM_ModuleTypeSetValue</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>REDISMODULE_WRITE</name><operator>)</operator> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>iter</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>RM_DeleteKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>createModuleObject</name><argument_list>(<argument><expr><name>mt</name></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on
 * the key, returns the module type pointer of the value stored at key.
 *
 * If the key is NULL, is not associated with a module type, or is empty,
 * then NULL is returned instead. */</comment>
<function><type><name>moduleType</name> <modifier>*</modifier></type><name>RM_ModuleTypeGetType</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>RM_KeyType</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDISMODULE_KEYTYPE_MODULE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>mv</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on
 * the key, returns the module type low-level value stored at key, as
 * it was set by the user via RedisModule_ModuleTypeSet().
 *
 * If the key is NULL, is not associated with a module type, or is empty,
 * then NULL is returned instead. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_ModuleTypeGetValue</name><parameter_list>(<parameter><decl><type><name>RedisModuleKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name><name>key</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>RM_KeyType</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>REDISMODULE_KEYTYPE_MODULE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>mv</name><operator>-&gt;</operator><name>value</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * RDB loading and saving functions
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Called when there is a load error in the context of a module. This cannot
 * be recovered like for the built-in types. */</comment>
<function><type><name>void</name></type> <name>moduleRDBLoadError</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
        <argument><expr><literal type="string">"Error loading data from RDB (short read or EOF). "</literal>
        <literal type="string">"Read performed by module '%s' about type '%s' "</literal>
        <literal type="string">"after reading '%llu' bytes of a value."</literal></expr></argument>,
        <argument><expr><name><name>io</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
        <argument><expr><name><name>io</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Save an unsigned 64 bit value into the RDB file. This function should only
 * be called in the context of the rdb_save method of modules implementing new
 * data types. */</comment>
<function><type><name>void</name></type> <name>RM_SaveUnsigned</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Save opcode. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>rdbSaveLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>RDB_MODULE_OPCODE_UINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <comment type="block">/* Save value. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <return>return;</return>

<label><name>saveerr</name>:</label>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Load an unsigned 64 bit value from the RDB file. This function should only
 * be called in the context of the rdb_load method of modules implementing
 * new data types. */</comment>
<function><type><name>uint64_t</name></type> <name>RM_LoadUnsigned</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>opcode</name> <init>= <expr><call><name>rdbLoadLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>RDB_MODULE_OPCODE_UINT</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>rdbLoadLenByRef</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    <return>return <expr><name>value</name></expr>;</return>

<label><name>loaderr</name>:</label>
    <expr_stmt><expr><call><name>moduleRDBLoadError</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Never reached. */</comment>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */</comment>
<function><type><name>void</name></type> <name>RM_SaveSigned</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <union>union <block>{<decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name></decl>;</decl_stmt>}</block> <decl><name>conv</name></decl>;</union>
    <expr_stmt><expr><name><name>conv</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RM_SaveUnsigned</name><argument_list>(<argument><expr><name>io</name></expr></argument>,<argument><expr><name><name>conv</name><operator>.</operator><name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */</comment>
<function><type><name>int64_t</name></type> <name>RM_LoadSigned</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <union>union <block>{<decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name></decl>;</decl_stmt>}</block> <decl><name>conv</name></decl>;</union>
    <expr_stmt><expr><name><name>conv</name><operator>.</operator><name>u</name></name> <operator>=</operator> <call><name>RM_LoadUnsigned</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>conv</name><operator>.</operator><name>i</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* In the context of the rdb_save method of a module type, saves a
 * string into the RDB file taking as input a RedisModuleString.
 *
 * The string can be later loaded with RedisModule_LoadString() or
 * other Load family functions expecting a serialized string inside
 * the RDB file. */</comment>
<function><type><name>void</name></type> <name>RM_SaveString</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Save opcode. */</comment>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>retval</name> <init>= <expr><call><name>rdbSaveLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>RDB_MODULE_OPCODE_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <comment type="block">/* Save value. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveStringObject</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <return>return;</return>

<label><name>saveerr</name>:</label>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_SaveString() but takes a raw C pointer and length
 * as input. */</comment>
<function><type><name>void</name></type> <name>RM_SaveStringBuffer</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Save opcode. */</comment>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>retval</name> <init>= <expr><call><name>rdbSaveLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>RDB_MODULE_OPCODE_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <comment type="block">/* Save value. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveRawString</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <return>return;</return>

<label><name>saveerr</name>:</label>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Implements RM_LoadString() and RM_LoadStringBuffer() */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>moduleLoadString</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plain</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>lenptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>opcode</name> <init>= <expr><call><name>rdbLoadLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>RDB_MODULE_OPCODE_STRING</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>rdbGenericLoadStringObject</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,
              <argument><expr><ternary><condition><expr><name>plain</name></expr> ?</condition><then> <expr><name>RDB_LOAD_PLAIN</name></expr> </then><else>: <expr><name>RDB_LOAD_NONE</name></expr></else></ternary></expr></argument>, <argument><expr><name>lenptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    <return>return <expr><name>s</name></expr>;</return>

<label><name>loaderr</name>:</label>
    <expr_stmt><expr><call><name>moduleRDBLoadError</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* Never reached. */</comment>
</block_content>}</block></function>

<comment type="block">/* In the context of the rdb_load method of a module data type, loads a string
 * from the RDB file, that was previously saved with RedisModule_SaveString()
 * functions family.
 *
 * The returned string is a newly allocated RedisModuleString object, and
 * the user should at some point free it with a call to RedisModule_FreeString().
 *
 * If the data structure does not store strings as RedisModuleString objects,
 * the similar function RedisModule_LoadStringBuffer() could be used instead. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_LoadString</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>moduleLoadString</name><argument_list>(<argument><expr><name>io</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_LoadString() but returns an heap allocated string that
 * was allocated with RedisModule_Alloc(), and can be resized or freed with
 * RedisModule_Realloc() or RedisModule_Free().
 *
 * The size of the string is stored at '*lenptr' if not NULL.
 * The returned string is not automatically NULL termianted, it is loaded
 * exactly as it was stored inisde the RDB file. */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>RM_LoadStringBuffer</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>lenptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>moduleLoadString</name><argument_list>(<argument><expr><name>io</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>lenptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* In the context of the rdb_save method of a module data type, saves a double
 * value to the RDB file. The double can be a valid number, a NaN or infinity.
 * It is possible to load back the value with RedisModule_LoadDouble(). */</comment>
<function><type><name>void</name></type> <name>RM_SaveDouble</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Save opcode. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>rdbSaveLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>RDB_MODULE_OPCODE_DOUBLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <comment type="block">/* Save value. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveBinaryDoubleValue</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <return>return;</return>

<label><name>saveerr</name>:</label>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* In the context of the rdb_save method of a module data type, loads back the
 * double value saved by RedisModule_SaveDouble(). */</comment>
<function><type><name>double</name></type> <name>RM_LoadDouble</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>opcode</name> <init>= <expr><call><name>rdbLoadLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>RDB_MODULE_OPCODE_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>rdbLoadBinaryDoubleValue</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    <return>return <expr><name>value</name></expr>;</return>

<label><name>loaderr</name>:</label>
    <expr_stmt><expr><call><name>moduleRDBLoadError</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Never reached. */</comment>
</block_content>}</block></function>

<comment type="block">/* In the context of the rdb_save method of a module data type, saves a float
 * value to the RDB file. The float can be a valid number, a NaN or infinity.
 * It is possible to load back the value with RedisModule_LoadFloat(). */</comment>
<function><type><name>void</name></type> <name>RM_SaveFloat</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Save opcode. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>rdbSaveLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>RDB_MODULE_OPCODE_FLOAT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <comment type="block">/* Save value. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rdbSaveBinaryFloatValue</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>saveerr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+=</operator> <name>retval</name></expr>;</expr_stmt>
    <return>return;</return>

<label><name>saveerr</name>:</label>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* In the context of the rdb_save method of a module data type, loads back the
 * float value saved by RedisModule_SaveFloat(). */</comment>
<function><type><name>float</name></type> <name>RM_LoadFloat</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>opcode</name> <init>= <expr><call><name>rdbLoadLen</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>RDB_MODULE_OPCODE_FLOAT</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>rdbLoadBinaryFloatValue</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>loaderr</name>;</goto></block_content></block></if></if_stmt>
    <return>return <expr><name>value</name></expr>;</return>

<label><name>loaderr</name>:</label>
    <expr_stmt><expr><call><name>moduleRDBLoadError</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Never reached. */</comment>
</block_content>}</block></function>

<comment type="block">/* Iterate over modules, and trigger rdb aux saving for the ones modules types
 * who asked for it. */</comment>
<function><type><name>ssize_t</name></type> <name>rdbSaveModulesAux</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>rdb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>when</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>total_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mt</name><operator>-&gt;</operator><name>aux_save</name></name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>mt</name><operator>-&gt;</operator><name>aux_save_triggers</name></name> <operator>&amp;</operator> <name>when</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name> <init>= <expr><call><name>rdbSaveSingleModuleAux</name><argument_list>(<argument><expr><name>rdb</name></expr></argument>, <argument><expr><name>when</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ret</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>total_written</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>total_written</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Key digest API (DEBUG DIGEST interface for modules types)
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Add a new element to the digest. This function can be called multiple times
 * one element after the other, for all the elements that constitute a given
 * data structure. The function call must be followed by the call to
 * `RedisModule_DigestEndSequence` eventually, when all the elements that are
 * always in a given order are added. See the Redis Modules data types
 * documentation for more info. However this is a quick example that uses Redis
 * data types as an example.
 *
 * To add a sequence of unordered elements (for example in the case of a Redis
 * Set), the pattern to use is:
 *
 *     foreach element {
 *         AddElement(element);
 *         EndSequence();
 *     }
 *
 * Because Sets are not ordered, so every element added has a position that
 * does not depend from the other. However if instead our elements are
 * ordered in pairs, like field-value pairs of an Hash, then one should
 * use:
 *
 *     foreach key,value {
 *         AddElement(key);
 *         AddElement(value);
 *         EndSquence();
 *     }
 *
 * Because the key and value will be always in the above order, while instead
 * the single key-value pairs, can appear in any position into a Redis hash.
 *
 * A list of ordered elements would be implemented with:
 *
 *     foreach element {
 *         AddElement(element);
 *     }
 *     EndSequence();
 *
 */</comment>
<function><type><name>void</name></type> <name>RM_DigestAddStringBuffer</name><parameter_list>(<parameter><decl><type><name>RedisModuleDigest</name> <modifier>*</modifier></type><name>md</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>mixDigest</name><argument_list>(<argument><expr><name><name>md</name><operator>-&gt;</operator><name>o</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input
 * that gets converted into a string before adding it to the digest. */</comment>
<function><type><name>void</name></type> <name>RM_DigestAddLongLong</name><parameter_list>(<parameter><decl><type><name>RedisModuleDigest</name> <modifier>*</modifier></type><name>md</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>mixDigest</name><argument_list>(<argument><expr><name><name>md</name><operator>-&gt;</operator><name>o</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* See the documentation for `RedisModule_DigestAddElement()`. */</comment>
<function><type><name>void</name></type> <name>RM_DigestEndSequence</name><parameter_list>(<parameter><decl><type><name>RedisModuleDigest</name> <modifier>*</modifier></type><name>md</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>xorDigest</name><argument_list>(<argument><expr><name><name>md</name><operator>-&gt;</operator><name>x</name></name></expr></argument>,<argument><expr><name><name>md</name><operator>-&gt;</operator><name>o</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>md</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>md</name><operator>-&gt;</operator><name>o</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>md</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * AOF API for modules data types
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Emits a command into the AOF during the AOF rewriting process. This function
 * is only called in the context of the aof_rewrite method of data types exported
 * by a module. The command works exactly like RedisModule_Call() in the way
 * the parameters are passed, but it does not return anything as the error
 * handling is performed by Redis itself. */</comment>
<function><type><name>void</name></type> <name>RM_EmitAOF</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>lookupCommandByCString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Fatal: AOF method for module data type '%s' tried to "</literal>
            <literal type="string">"emit unknown command '%s'"</literal></expr></argument>,
            <argument><expr><name><name>io</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Emit the arguments into the AOF in Redis protocol format. */</comment>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>moduleCreateArgvFromUserFormat</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Fatal: AOF method for module data type '%s' tried to "</literal>
            <literal type="string">"call RedisModule_EmitAOF() with wrong format specifiers '%s'"</literal></expr></argument>,
            <argument><expr><name><name>io</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Bulk count. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>&amp;&amp;</operator> <call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Arguments. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>&amp;&amp;</operator> <call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>rio</name></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * IO context handling
 * -------------------------------------------------------------------------- */</comment>

<function><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>RM_GetContextFromIO</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>ctx</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>io</name><operator>-&gt;</operator><name>ctx</name></name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Can't have more than one... */</comment>
    <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctxtemplate</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RedisModuleCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>io</name><operator>-&gt;</operator><name>ctx</name></name><operator>)</operator> <operator>=</operator> <name>ctxtemplate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>io</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name><name>io</name><operator>-&gt;</operator><name>ctx</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns a RedisModuleString with the name of the key currently saving or
 * loading, when an IO data type callback is called.  There is no guarantee
 * that the key name is always available, so this may return NULL.
 */</comment>
<function><type><specifier>const</specifier> <name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_GetKeyNameFromIO</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>io</name><operator>-&gt;</operator><name>key</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Logging
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This is the low level function implementing both:
 *
 *      RM_Log()
 *      RM_LogIOError()
 *
 */</comment>
<function><type><name>void</name></type> <name>RM_LogRaw</name><parameter_list>(<parameter><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>levelstr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><name>LOG_MAX_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>name_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>levelstr</name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <name>LL_DEBUG</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>levelstr</name></expr></argument>,<argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <name>LL_VERBOSE</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>levelstr</name></expr></argument>,<argument><expr><literal type="string">"notice"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <name>LL_NOTICE</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>levelstr</name></expr></argument>,<argument><expr><literal type="string">"warning"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <name>LL_WARNING</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <name>LL_VERBOSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* Default. */</comment>

    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>verbosity</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"&lt;%s&gt; "</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>module</name></expr>?</condition><then> <expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">"module"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>msg</name> <operator>+</operator> <name>name_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>name_len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLogRaw</name><argument_list>(<argument><expr><name>level</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Produces a log message to the standard Redis log, the format accepts
 * printf-alike specifiers, while level is a string describing the log
 * level to use when emitting the log, and must be one of the following:
 *
 * * "debug"
 * * "verbose"
 * * "notice"
 * * "warning"
 *
 * If the specified log level is invalid, verbose is used by default.
 * There is a fixed limit to the length of the log line this function is able
 * to emit, this limit is not specified but is guaranteed to be more than
 * a few lines of text.
 *
 * The ctx argument may be NULL if cannot be provided in the context of the
 * caller for instance threads or callbacks, in which case a generic "module"
 * will be used instead of the module name.
 */</comment>
<function><type><name>void</name></type> <name>RM_Log</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>levelstr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RM_LogRaw</name><argument_list>(<argument><expr><ternary><condition><expr><name>ctx</name></expr>?</condition><then> <expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,<argument><expr><name>levelstr</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Log errors from RDB / AOF serialization callbacks.
 *
 * This function should be used when a callback is returning a critical
 * error to the caller since cannot load or save the data for some
 * critical reason. */</comment>
<function><type><name>void</name></type> <name>RM_LogIOError</name><parameter_list>(<parameter><decl><type><name>RedisModuleIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>levelstr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RM_LogRaw</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>module</name></name></expr></argument>,<argument><expr><name>levelstr</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Blocking clients from modules
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Readable handler for the awake pipe. We do nothing here, the awake bytes
 * will be actually read in a more appropriate place in the
 * moduleHandleBlockedClients() function that is where clients are actually
 * served. */</comment>
<function><type><name>void</name></type> <name>moduleBlockedClientPipeReadable</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is called from blocked.c in order to unblock a client: may be called
 * for multiple reasons while the client is in the middle of being blocked
 * because the client is terminated, but is also called for cleanup when a
 * client is unblocked in a clean way after replaying.
 *
 * What we do here is just to set the client to NULL in the redis module
 * blocked client handle. This way if the client is terminated while there
 * is a pending threaded operation involving the blocked client, we'll know
 * that the client no longer exists and no reply callback should be called.
 *
 * The structure RedisModuleBlockedClient will be always deallocated when
 * running the list of clients blocked by a module that need to be unblocked. */</comment>
<function><type><name>void</name></type> <name>unblockClientFromModule</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>module_blocked_handle</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Call the disconnection callback if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>blocked_privdata</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>client</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* Reset the client for a new query since, for blocking commands implemented
     * into modules, we do not it immediately after the command returns (and
     * the client blocks) in order to be still able to access the argument
     * vector from callbacks. */</comment>
    <expr_stmt><expr><call><name>resetClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Block a client in the context of a blocking command, returning an handle
 * which will be used, later, in order to unblock the client with a call to
 * RedisModule_UnblockClient(). The arguments specify callback functions
 * and a timeout after which the client is unblocked.
 *
 * The callbacks are called in the following contexts:
 *
 *     reply_callback:  called after a successful RedisModule_UnblockClient()
 *                      call in order to reply to the client and unblock it.
 *
 *     reply_timeout:   called when the timeout is reached in order to send an
 *                      error to the client.
 *
 *     free_privdata:   called in order to free the private data that is passed
 *                      by RedisModule_UnblockClient() call.
 */</comment>
<function><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>RM_BlockClient</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleCmdFunc</name></type> <name>reply_callback</name></decl></parameter>, <parameter><decl><type><name>RedisModuleCmdFunc</name></type> <name>timeout_callback</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>free_privdata</name>)<parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>timeout_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>islua</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_LUA</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ismulti</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>module_blocked_handle</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RedisModuleBlockedClient</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>module_blocked_handle</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We need to handle the invalid operation of calling modules blocking
     * commands from Lua or MULTI. We actually create an already aborted
     * (client set to NULL) blocked client handle, and actually reply with
     * an error. */</comment>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>islua</name> <operator>||</operator> <name>ismulti</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>reply_callback</name></name> <operator>=</operator> <name>reply_callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>timeout_callback</name></name> <operator>=</operator> <name>timeout_callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Set by RM_SetDisconnectCallback() */</comment>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>free_privdata</name></name> <operator>=</operator> <name>free_privdata</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>reply_client</name></name> <operator>=</operator> <call><name>createClient</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>reply_client</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_MODULE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>dbid</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <ternary><condition><expr><name>timeout_ms</name></expr> ?</condition><then> <expr><operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call><operator>+</operator><name>timeout_ms</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>islua</name> <operator>||</operator> <name>ismulti</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>module_blocked_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name>islua</name></expr> ?</condition><then>
            <expr><literal type="string">"Blocking module command called from Lua script"</literal></expr> </then><else>:
            <expr><literal type="string">"Blocking module command called from transaction"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>blockClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>BLOCKED_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>bc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unblock a client blocked by `RedisModule_BlockedClient`. This will trigger
 * the reply callbacks to be called in order to reply to the client.
 * The 'privdata' argument will be accessible by the reply callback, so
 * the caller of this function can pass any value that is needed in order to
 * actually reply to the client.
 *
 * A common usage for 'privdata' is a thread that computes something that
 * needs to be passed to the client, included but not limited some slow
 * to compute reply or some reply obtained via networking.
 *
 * Note: this function can be called from threads spawned by the module. */</comment>
<function><type><name>int</name></type> <name>RM_UnblockClient</name><parameter_list>(<parameter><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleUnblockedClientsMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name> <operator>=</operator> <name>privdata</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>moduleUnblockedClients</name></expr></argument>,<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>module_blocked_pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"A"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Ignore the error, this is best-effort. */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleUnblockedClientsMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Abort a blocked client blocking operation: the client will be unblocked
 * without firing any callback. */</comment>
<function><type><name>int</name></type> <name>RM_AbortBlock</name><parameter_list>(<parameter><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>reply_callback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><call><name>RM_UnblockClient</name><argument_list>(<argument><expr><name>bc</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set a callback that will be called if a blocked client disconnects
 * before the module has a chance to call RedisModule_UnblockClient()
 *
 * Usually what you want to do there, is to cleanup your module state
 * so that you can call RedisModule_UnblockClient() safely, otherwise
 * the client will remain blocked forever if the timeout is large.
 *
 * Notes:
 *
 * 1. It is not safe to call Reply* family functions here, it is also
 *    useless since the client is gone.
 *
 * 2. This callback is not called if the client disconnects because of
 *    a timeout. In such a case, the client is unblocked automatically
 *    and the timeout callback is called.
 */</comment>
<function><type><name>void</name></type> <name>RM_SetDisconnectCallback</name><parameter_list>(<parameter><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>, <parameter><decl><type><name>RedisModuleDisconnectFunc</name></type> <name>callback</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function will check the moduleUnblockedClients queue in order to
 * call the reply callback and really unblock the client.
 *
 * Clients end into this list because of calls to RM_UnblockClient(),
 * however it is possible that while the module was doing work for the
 * blocked client, it was terminated by Redis (for timeout or other reasons).
 * When this happens the RedisModuleBlockedClient structure in the queue
 * will have the 'client' field set to NULL. */</comment>
<function><type><name>void</name></type> <name>moduleHandleBlockedClients</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleUnblockedClientsMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Here we unblock all the pending clients blocked in modules operations
     * so we can read every pending "awake byte" in the pipe. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>module_blocked_pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
    <while>while <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>moduleUnblockedClients</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listFirst</name><argument_list>(<argument><expr><name>moduleUnblockedClients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>bc</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>moduleUnblockedClients</name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleUnblockedClientsMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Release the lock during the loop, as long as we don't
         * touch the shared list. */</comment>

        <comment type="block">/* Call the reply callback if the client is valid and we have
         * any callback. */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;&amp;</operator> <name><name>bc</name><operator>-&gt;</operator><name>reply_callback</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_BLOCKED_REPLY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>blocked_privdata</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>client</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>blocked_client</name></name> <operator>=</operator> <name>bc</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>bc</name><operator>-&gt;</operator><name>reply_callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Free privdata if any. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name> <operator>&amp;&amp;</operator> <name><name>bc</name><operator>-&gt;</operator><name>free_privdata</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_BLOCKED_DISCONNECTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>blocked_privdata</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>client</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>bc</name><operator>-&gt;</operator><name>free_privdata</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><name><name>bc</name><operator>-&gt;</operator><name>privdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* It is possible that this blocked client object accumulated
         * replies to send to the client in a thread safe context.
         * We need to glue such replies to the client output buffer and
         * free the temporary client we just used for the replies. */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>AddReplyFromClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>bc</name><operator>-&gt;</operator><name>reply_client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>freeClient</name><argument_list>(<argument><expr><name><name>bc</name><operator>-&gt;</operator><name>reply_client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Before unblocking the client, set the disconnect callback
             * to NULL, because if we reached this point, the client was
             * properly unblocked by the module. */</comment>
            <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unblockClient</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Put the client in the list of clients that need to write
             * if there are pending replies here. This is needed since
             * during a non blocking command the client may receive output. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>clientHasPendingReplies</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_PENDING_WRITE</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_PENDING_WRITE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>listAddNodeHead</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>clients_pending_write</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Free 'bc' only after unblocking the client, since it is
         * referenced in the client blocking context, and must be valid
         * when calling unblockClient(). */</comment>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Lock again before to iterate the loop. */</comment>
        <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleUnblockedClientsMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleUnblockedClientsMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Called when our client timed out. After this function unblockClient()
 * is called, and it will invalidate the blocked client. So this function
 * does not need to do any cleanup. Eventually the module will call the
 * API to unblock the client and the memory will be released. */</comment>
<function><type><name>void</name></type> <name>moduleBlockedClientTimedOut</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>module_blocked_handle</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_BLOCKED_TIMEOUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>client</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>blocked_client</name></name> <operator>=</operator> <name>bc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bc</name><operator>-&gt;</operator><name>timeout_callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* For timeout events, we do not want to call the disconnect callback,
     * because the blocked client will be automatically disconnected in
     * this case, and the user can still hook using the timeout callback. */</comment>
    <expr_stmt><expr><name><name>bc</name><operator>-&gt;</operator><name>disconnect_callback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if a module command was called in order to fill the
 * reply for a blocked client. */</comment>
<function><type><name>int</name></type> <name>RM_IsBlockedReplyRequest</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_BLOCKED_REPLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return non-zero if a module command was called in order to fill the
 * reply for a blocked client that timed out. */</comment>
<function><type><name>int</name></type> <name>RM_IsBlockedTimeoutRequest</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_BLOCKED_TIMEOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the private data set by RedisModule_UnblockClient() */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_GetBlockedClientPrivateData</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>blocked_privdata</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the blocked client associated with a given context.
 * This is useful in the reply and timeout callbacks of blocked clients,
 * before sometimes the module has the blocked client handle references
 * around, and wants to cleanup it. */</comment>
<function><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>RM_GetBlockedClientHandle</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>blocked_client</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if when the free callback of a blocked client is called,
 * the reason for the client to be unblocked is that it disconnected
 * while it was blocked. */</comment>
<function><type><name>int</name></type> <name>RM_BlockedClientDisconnected</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CTX_BLOCKED_DISCONNECTED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Thread Safe Contexts
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return a context which can be used inside threads to make Redis context
 * calls with certain modules APIs. If 'bc' is not NULL then the module will
 * be bound to a blocked client, and it will be possible to use the
 * `RedisModule_Reply*` family of functions to accumulate a reply for when the
 * client will be unblocked. Otherwise the thread safe context will be
 * detached by a specific client.
 *
 * To call non-reply APIs, the thread safe context must be prepared with:
 *
 *     RedisModule_ThreadSafeContextLock(ctx);
 *     ... make your call here ...
 *     RedisModule_ThreadSafeContextUnlock(ctx);
 *
 * This is not needed when using `RedisModule_Reply*` functions, assuming
 * that a blocked client was used when the context was created, otherwise
 * no RedisModule_Reply* call should be made at all.
 *
 * TODO: thread safe contexts do not inherit the blocked client
 * selected database. */</comment>
<function><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>RM_GetThreadSafeContext</name><parameter_list>(<parameter><decl><type><name>RedisModuleBlockedClient</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>empty</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bc</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>blocked_client</name></name> <operator>=</operator> <name>bc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>REDISMODULE_CTX_THREAD_SAFE</name></expr>;</expr_stmt>
    <comment type="block">/* Even when the context is associated with a blocked client, we can't
     * access it safely from another thread, so we create a fake client here
     * in order to keep things like the currently selected database and similar
     * things. */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <call><name>createClient</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bc</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name></name></expr></argument>,<argument><expr><name><name>bc</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>bc</name><operator>-&gt;</operator><name>client</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release a thread safe context. */</comment>
<function><type><name>void</name></type> <name>RM_FreeThreadSafeContext</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Acquire the server lock before executing a thread safe API call.
 * This is not needed for `RedisModule_Reply*` calls when there is
 * a blocked client connected to the thread safe context. */</comment>
<function><type><name>void</name></type> <name>RM_ThreadSafeContextLock</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleAcquireGIL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Release the server lock after a thread safe API call was executed. */</comment>
<function><type><name>void</name></type> <name>RM_ThreadSafeContextUnlock</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleReleaseGIL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleAcquireGIL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleGIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleReleaseGIL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleGIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------------------------------------------------
 * Module Keyspace Notifications API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Subscribe to keyspace notifications. This is a low-level version of the
 * keyspace-notifications API. A module can register callbacks to be notified
 * when keyspce events occur.
 *
 * Notification events are filtered by their type (string events, set events,
 * etc), and the subscriber callback receives only events that match a specific
 * mask of event types.
 *
 * When subscribing to notifications with RedisModule_SubscribeToKeyspaceEvents 
 * the module must provide an event type-mask, denoting the events the subscriber
 * is interested in. This can be an ORed mask of any of the following flags:
 *
 *  - REDISMODULE_NOTIFY_GENERIC: Generic commands like DEL, EXPIRE, RENAME
 *  - REDISMODULE_NOTIFY_STRING: String events
 *  - REDISMODULE_NOTIFY_LIST: List events
 *  - REDISMODULE_NOTIFY_SET: Set events
 *  - REDISMODULE_NOTIFY_HASH: Hash events
 *  - REDISMODULE_NOTIFY_ZSET: Sorted Set events
 *  - REDISMODULE_NOTIFY_EXPIRED: Expiration events
 *  - REDISMODULE_NOTIFY_EVICTED: Eviction events
 *  - REDISMODULE_NOTIFY_STREAM: Stream events
 *  - REDISMODULE_NOTIFY_ALL: All events
 *
 * We do not distinguish between key events and keyspace events, and it is up
 * to the module to filter the actions taken based on the key.
 *
 * The subscriber signature is:
 *
 *   int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type,
 *                                       const char *event,
 *                                       RedisModuleString *key);
 *
 * `type` is the event type bit, that must match the mask given at registration
 * time. The event string is the actual command being executed, and key is the
 * relevant Redis key.
 *
 * Notification callback gets executed with a redis context that can not be
 * used to send anything to the client, and has the db number where the event
 * occurred as its selected db number.
 *
 * Notice that it is not necessary to enable notifications in redis.conf for
 * module notifications to work.
 *
 * Warning: the notification callbacks are performed in a synchronous manner,
 * so notification callbacks must to be fast, or they would slow Redis down.
 * If you need to take long actions, use threads to offload them.
 *
 * See https://redis.io/topics/notifications for more information.
 */</comment>
<function><type><name>int</name></type> <name>RM_SubscribeToKeyspaceEvents</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>types</name></decl></parameter>, <parameter><decl><type><name>RedisModuleNotificationFunc</name></type> <name>callback</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleKeyspaceSubscriber</name> <modifier>*</modifier></type><name>sub</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sub</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>event_mask</name></name> <operator>=</operator> <name>types</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>notify_callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>moduleKeyspaceSubscribers</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Dispatcher for keyspace notifications to module subscriber functions.
 * This gets called  only if at least one module requested to be notified on
 * keyspace notifications */</comment>
<function><type><name>void</name></type> <name>moduleNotifyKeyspaceEvent</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Don't do anything if there aren't any subscribers */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>moduleKeyspaceSubscribers</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>moduleKeyspaceSubscribers</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove irrelevant flags from the type mask */</comment>
    <expr_stmt><expr><name>type</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>NOTIFY_KEYEVENT</name> <operator>|</operator> <name>NOTIFY_KEYSPACE</name><operator>)</operator></expr>;</expr_stmt>

    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleKeyspaceSubscriber</name> <modifier>*</modifier></type><name>sub</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Only notify subscribers on events matching they registration,
         * and avoid subscribers triggering themselves */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sub</name><operator>-&gt;</operator><name>event_mask</name></name> <operator>&amp;</operator> <name>type</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>sub</name><operator>-&gt;</operator><name>active</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name>moduleFreeContextReusedClient</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>client</name></name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* mark the handler as active to avoid reentrant loops.
             * If the subscriber performs an action triggering itself,
             * it will not be notified about it. */</comment>
            <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sub</name><operator>-&gt;</operator><name>notify_callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Unsubscribe any notification subscribers this module has upon unloading */</comment>
<function><type><name>void</name></type> <name>moduleUnsubscribeNotifications</name><parameter_list>(<parameter><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>moduleKeyspaceSubscribers</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleKeyspaceSubscriber</name> <modifier>*</modifier></type><name>sub</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>module</name></name> <operator>==</operator> <name>module</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>moduleKeyspaceSubscribers</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules Cluster API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* The Cluster message callback function pointer type. */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>RedisModuleClusterMessageReceiver</name>)<parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sender_id</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* This structure identifies a registered caller: it must match a given module
 * ID, for a given message type. The callback function is just the function
 * that was registered as receiver. */</comment>
<typedef>typedef <type><struct>struct <name>moduleClusterReceiver</name> <block>{
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>module_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleClusterMessageReceiver</name></type> <name>callback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>moduleClusterReceiver</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>moduleClusterReceiver</name>;</typedef>

<typedef>typedef <type><struct>struct <name>moduleClusterNodeInfo</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>NET_IP_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>master_id</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Only if flags &amp; REDISMODULE_NODE_MASTER is true. */</comment>
}</block></struct></type> <name>mdouleClusterNodeInfo</name>;</typedef>

<comment type="block">/* We have an array of message types: each bucket is a linked list of
 * configured receivers. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>moduleClusterReceiver</name> <modifier>*</modifier></type><name><name>clusterReceivers</name><index>[<expr><name>UINT8_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Dispatch the message to the right module receiver. */</comment>
<function><type><name>void</name></type> <name>moduleCallClusterReceivers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sender_id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>module_id</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>moduleClusterReceiver</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>clusterReceivers</name><index>[<expr><name>type</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>module_id</name></name> <operator>==</operator> <name>module_id</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name>moduleFreeContextReusedClient</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>client</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>r</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><name>sender_id</name></expr></argument>,<argument><expr><name>type</name></expr></argument>,<argument><expr><name>payload</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Register a callback receiver for cluster messages of type 'type'. If there
 * was already a registered callback, this will replace the callback function
 * with the one provided, otherwise if the callback is set to NULL and there
 * is already a callback for this function, the callback is unregistered
 * (so this API call is also used in order to delete the receiver). */</comment>
<function><type><name>void</name></type> <name>RM_RegisterClusterMessageReceiver</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>RedisModuleClusterMessageReceiver</name></type> <name>callback</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>module_id</name> <init>= <expr><call><name>moduleTypeEncodeId</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>moduleClusterReceiver</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>clusterReceivers</name><index>[<expr><name>type</name></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>module_id</name></name> <operator>==</operator> <name>module_id</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Found! Set or delete. */</comment>
            <if_stmt><if>if <condition>(<expr><name>callback</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* Delete the receiver entry if the user is setting
                 * it to NULL. Just unlink the receiver node from the
                 * linked list. */</comment>
                <if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>clusterReceivers</name><index>[<expr><name>type</name></expr>]</index></name><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Not found, let's add it. */</comment>
    <if_stmt><if>if <condition>(<expr><name>callback</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>module_id</name></name> <operator>=</operator> <name>module_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>clusterReceivers</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>clusterReceivers</name><index>[<expr><name>type</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a message to all the nodes in the cluster if `target` is NULL, otherwise
 * at the specified target, which is a REDISMODULE_NODE_ID_LEN bytes node ID, as
 * returned by the receiver callback or by the nodes iteration functions.
 *
 * The function returns REDISMODULE_OK if the message was successfully sent,
 * otherwise if the node is not connected or such node ID does not map to any
 * known cluster node, REDISMODULE_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>RM_SendClusterMessage</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>target_id</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>module_id</name> <init>= <expr><call><name>moduleTypeEncodeId</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>clusterSendModuleMessageToTarget</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>,<argument><expr><name>module_id</name></expr></argument>,<argument><expr><name>type</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_OK</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return an array of string pointers, each string pointer points to a cluster
 * node ID of exactly REDISMODULE_NODE_ID_SIZE bytes (without any null term).
 * The number of returned node IDs is stored into `*numnodes`.
 * However if this function is called by a module not running an a Redis
 * instance with Redis Cluster enabled, NULL is returned instead.
 *
 * The IDs returned can be used with RedisModule_GetClusterNodeInfo() in order
 * to get more information about single nodes.
 *
 * The array returned by this function must be freed using the function
 * RedisModule_FreeClusterNodesList().
 *
 * Example:
 *
 *     size_t count, j;
 *     char **ids = RedisModule_GetClusterNodesList(ctx,&amp;count);
 *     for (j = 0; j &lt; count; j++) {
 *         RedisModule_Log("notice","Node %.*s",
 *             REDISMODULE_NODE_ID_LEN,ids[j]);
 *     }
 *     RedisModule_FreeClusterNodesList(ids);
 */</comment>
<function><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>RM_GetClusterNodesList</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>numnodes</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ids</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><operator>(</operator><name>count</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>REDISMODULE_NODE_ID_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_NOADDR</name><operator>|</operator><name>CLUSTER_NODE_HANDSHAKE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>REDISMODULE_NODE_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>REDISMODULE_NODE_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>numnodes</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Null term so that FreeClusterNodesList does not need
                    * to also get the count argument. */</comment>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free the node list obtained with RedisModule_GetClusterNodesList. */</comment>
<function><type><name>void</name></type> <name>RM_FreeClusterNodesList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ids</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster
 * is disabled. */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>RM_GetMyClusterID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>myself</name><operator>-&gt;</operator><name>name</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the number of nodes in the cluster, regardless of their state
 * (handshake, noaddress, ...) so that the number of active nodes may actually
 * be smaller, but not greater than this number. If the instance is not in
 * cluster mode, zero is returned. */</comment>
<function><type><name>size_t</name></type> <name>RM_GetClusterSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>cluster_enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>cluster</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Populate the specified info for the node having as ID the specified 'id',
 * then returns REDISMODULE_OK. Otherwise if the node ID does not exist from
 * the POV of this local node, REDISMODULE_ERR is returned.
 *
 * The arguments ip, master_id, port and flags can be NULL in case we don't
 * need to populate back certain info. If an ip and master_id (only populated
 * if the instance is a slave) are specified, they point to buffers holding
 * at least REDISMODULE_NODE_ID_LEN bytes. The strings written back as ip
 * and master_id are not null terminated.
 *
 * The list of flags reported is the following:
 *
 * * REDISMODULE_NODE_MYSELF        This node
 * * REDISMODULE_NODE_MASTER        The node is a master
 * * REDISMODULE_NODE_SLAVE         The node is a replica
 * * REDISMODULE_NODE_PFAIL         We see the node as failing
 * * REDISMODULE_NODE_FAIL          The cluster agrees the node is failing
 * * REDISMODULE_NODE_NOFAILOVER    The slave is configured to never failover
 */</comment>

<function_decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>clusterLookupNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* We need access to internals */</comment>

<function><type><name>int</name></type> <name>RM_GetClusterNodeInfo</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>master_id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>clusterNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>clusterLookupNode</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>CLUSTER_NODE_NOADDR</name><operator>|</operator><name>CLUSTER_NODE_HANDSHAKE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ip</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>,<argument><expr><name>NET_IP_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>master_id</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If the information is not available, the function will set the
         * field to zero bytes, so that when the field can't be populated the
         * function kinda remains predictable. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MASTER</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>slaveof</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>master_id</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>slaveof</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>REDISMODULE_NODE_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>master_id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>REDISMODULE_NODE_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>port</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>port</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>port</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* As usually we have to remap flags for modules, in order to ensure
     * we can provide binary compatibility. */</comment>
    <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MYSELF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>REDISMODULE_NODE_MYSELF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_MASTER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>REDISMODULE_NODE_MASTER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_SLAVE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>REDISMODULE_NODE_SLAVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_PFAIL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>REDISMODULE_NODE_PFAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_FAIL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>REDISMODULE_NODE_FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLUSTER_NODE_NOFAILOVER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>REDISMODULE_NODE_NOFAILOVER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set Redis Cluster flags in order to change the normal behavior of
 * Redis Cluster, especially with the goal of disabling certain functions.
 * This is useful for modules that use the Cluster API in order to create
 * a different distributed system, but still want to use the Redis Cluster
 * message bus. Flags that can be set:
 *
 *  CLUSTER_MODULE_FLAG_NO_FAILOVER
 *  CLUSTER_MODULE_FLAG_NO_REDIRECTION
 *
 * With the following effects:
 *
 *  NO_FAILOVER: prevent Redis Cluster slaves to failover a failing master.
 *               Also disables the replica migration feature.
 *
 *  NO_REDIRECTION: Every node will accept any key, without trying to perform
 *                  partitioning according to the user Redis Cluster algorithm.
 *                  Slots informations will still be propagated across the
 *                  cluster, but without effects. */</comment>
<function><type><name>void</name></type> <name>RM_SetClusterFlags</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_CLUSTER_FLAG_NO_FAILOVER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>|=</operator> <name>CLUSTER_MODULE_FLAG_NO_FAILOVER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>cluster_module_flags</name></name> <operator>|=</operator> <name>CLUSTER_MODULE_FLAG_NO_REDIRECTION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules Timers API
 *
 * Module timers are an high precision "green timers" abstraction where
 * every module can register even millions of timers without problems, even if
 * the actual event loop will just have a single timer that is used to awake the
 * module timers subsystem in order to process the next event.
 *
 * All the timers are stored into a radix tree, ordered by expire time, when
 * the main Redis event loop timer callback is called, we try to process all
 * the timers already expired one after the other. Then we re-enter the event
 * loop registering a timer that will expire when the next to process module
 * timer will expire.
 *
 * Every time the list of active timers drops to zero, we unregister the
 * main event loop timer, so that there is no overhead when such feature is
 * not used.
 * -------------------------------------------------------------------------- */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>rax</name> <modifier>*</modifier></type><name>Timers</name></decl>;</decl_stmt>     <comment type="block">/* The radix tree of all the timers sorted by expire. */</comment>
<decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>aeTimer</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Main event loop (ae.c) timer identifier. */</comment>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>RedisModuleTimerProc</name>)<parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* The timer descriptor, stored as value in the radix tree. */</comment>
<typedef>typedef <type><struct>struct <name>RedisModuleTimer</name> <block>{
    <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>                <comment type="block">/* Module reference. */</comment>
    <decl_stmt><decl><type><name>RedisModuleTimerProc</name></type> <name>callback</name></decl>;</decl_stmt>      <comment type="block">/* The callback to invoke on expire. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>                         <comment type="block">/* Private data for the callback. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dbid</name></decl>;</decl_stmt>                           <comment type="block">/* Database number selected by the original client. */</comment>
}</block></struct></type> <name>RedisModuleTimer</name>;</typedef>

<comment type="block">/* This is the timer handler that is called by the main event loop. We schedule
 * this timer to be called when the nearest of our module timers will expire. */</comment>
<function><type><name>int</name></type> <name>moduleTimerHandler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>aeEventLoop</name></name> <modifier>*</modifier></type><name>eventLoop</name></decl></parameter>, <parameter><decl><type><name>PORT_LONGLONG</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>clientData</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>eventLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* To start let's try to fire all the timers already expired. */</comment>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name>Timers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>now</name> <init>= <expr><call><name>ustime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>next_period</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>expiretime</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expiretime</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>expiretime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>expiretime</name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name>expiretime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>expiretime</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>RedisModuleTimer</name> <modifier>*</modifier></type><name>timer</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name></name> <operator>=</operator> <name><name>timer</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>client</name></name> <operator>=</operator> <name>moduleFreeContextReusedClient</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>client</name></name></expr></argument>, <argument><expr><name><name>timer</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>timer</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><name><name>timer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>next_period</name> <operator>=</operator> <operator>(</operator><name>expiretime</name><operator>-</operator><name>now</name><operator>)</operator><operator>/</operator><literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* Scale to milliseconds. */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reschedule the next timer or cancel it. */</comment>
    <if_stmt><if>if <condition>(<expr><name>next_period</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next_period</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>raxSize</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>next_period</name></expr> </then><else>: <expr><name>AE_NOMORE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new timer that will fire after `period` milliseconds, and will call
 * the specified function using `data` as argument. The returned timer ID can be
 * used to get information from the timer or to stop it before it fires. */</comment>
<function><type><name>RedisModuleTimerID</name></type> <name>RM_CreateTimer</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>mstime_t</name></type> <name>period</name></decl></parameter>, <parameter><decl><type><name>RedisModuleTimerProc</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleTimer</name> <modifier>*</modifier></type><name>timer</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>timer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>timer</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timer</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timer</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timer</name><operator>-&gt;</operator><name>dbid</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>expiretime</name> <init>= <expr><call><name>ustime</name><argument_list>()</argument_list></call><operator>+</operator><name>period</name><operator>*</operator><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>key</name></decl>;</decl_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name>expiretime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>timer</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>expiretime</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* We need to install the main event loop timer if it's not already
     * installed, or we may need to refresh its period if we just installed
     * a timer that will expire sooner than any other else. */</comment>
    <if_stmt><if>if <condition>(<expr><name>aeTimer</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name>Timers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* This is the first key, we need to re-install the timer according
             * to the just added event. */</comment>
            <expr_stmt><expr><call><name>aeDeleteTimeEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>aeTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>aeTimer</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we have no main timer (the old one was invalidated, or this is the
     * first module timer we have), install one. */</comment>
    <if_stmt><if>if <condition>(<expr><name>aeTimer</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>aeTimer</name> <operator>=</operator> <call><name>aeCreateTimeEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name>period</name></expr></argument>,<argument><expr><name>moduleTimerHandler</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>key</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Stop a timer, returns REDISMODULE_OK if the timer was found, belonged to the
 * calling module, and was stopped, otherwise REDISMODULE_ERR is returned.
 * If not NULL, the data pointer is set to the value of the data argument when
 * the timer was created. */</comment>
<function><type><name>int</name></type> <name>RM_StopTimer</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleTimerID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleTimer</name> <modifier>*</modifier></type><name>timer</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>timer</name> <operator>==</operator> <name>raxNotFound</name> <operator>||</operator> <name><name>timer</name><operator>-&gt;</operator><name>module</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name><name>timer</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Obtain information about a timer: its remaining time before firing
 * (in milliseconds), and the private data pointer associated with the timer.
 * If the timer specified does not exist or belongs to a different module
 * no information is returned and the function returns REDISMODULE_ERR, otherwise
 * REDISMODULE_OK is returned. The arguments remaining or data can be NULL if
 * the caller does not need certain information. */</comment>
<function><type><name>int</name></type> <name>RM_GetTimerInfo</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleTimerID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleTimer</name> <modifier>*</modifier></type><name>timer</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name>Timers</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>timer</name> <operator>==</operator> <name>raxNotFound</name> <operator>||</operator> <name><name>timer</name><operator>-&gt;</operator><name>module</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>rem</name> <init>= <expr><call><name>ntohu64</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-</operator><call><name>ustime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rem</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>remaining</name> <operator>=</operator> <name>rem</name><operator>/</operator><literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* Scale to milliseconds. */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name><name>timer</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules Dictionary API
 *
 * Implements a sorted dictionary (actually backed by a radix tree) with
 * the usual get / set / del / num-items API, together with an iterator
 * capable of going back and forth.
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Create a new dictionary. The 'ctx' pointer can be the current module context
 * or NULL, depending on what you want. Please follow the following rules:
 *
 * 1. Use a NULL context if you plan to retain a reference to this dictionary
 *    that will survive the time of the module callback where you created it.
 * 2. Use a NULL context if no context is available at the time you are creating
 *    the dictionary (of course...).
 * 3. However use the current callback context as 'ctx' argument if the
 *    dictionary time to live is just limited to the callback scope. In this
 *    case, if enabled, you can enjoy the automatic memory management that will
 *    reclaim the dictionary memory, as well as the strings returned by the
 *    Next / Prev dictionary iterator calls.
 */</comment>
<function><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>RM_CreateDict</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModuleDict</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoMemoryAdd</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_DICT</name></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a dictionary created with RM_CreateDict(). You need to pass the
 * context pointer 'ctx' only if the dictionary was created using the
 * context instead of passing NULL. */</comment>
<function><type><name>void</name></type> <name>RM_FreeDict</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoMemoryFreed</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>REDISMODULE_AM_DICT</name></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the size of the dictionary (number of keys). */</comment>
<function><type><name>uint64_t</name></type> <name>RM_DictSize</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Store the specified key into the dictionary, setting its value to the
 * pointer 'ptr'. If the key was added with success, since it did not
 * already exist, REDISMODULE_OK is returned. Otherwise if the key already
 * exists the function returns REDISMODULE_ERR. */</comment>
<function><type><name>int</name></type> <name>RM_DictSetC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>,<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>retval</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictSetC() but will replace the key with the new
 * value if the key already exists. */</comment>
<function><type><name>int</name></type> <name>RM_DictReplaceC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>,<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>retval</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictSetC() but takes the key as a RedisModuleString. */</comment>
<function><type><name>int</name></type> <name>RM_DictSet</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>RM_DictSetC</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictReplaceC() but takes the key as a RedisModuleString. */</comment>
<function><type><name>int</name></type> <name>RM_DictReplace</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>RM_DictReplaceC</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the value stored at the specified key. The function returns NULL
 * both in the case the key does not exist, or if you actually stored
 * NULL at key. So, optionally, if the 'nokey' pointer is not NULL, it will
 * be set by reference to 1 if the key does not exist, or to 0 if the key
 * exists. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_DictGetC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nokey</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nokey</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>nokey</name> <operator>=</operator> <operator>(</operator><name>res</name> <operator>==</operator> <name>raxNotFound</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>res</name> <operator>==</operator> <name>raxNotFound</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>res</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictGetC() but takes the key as a RedisModuleString. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_DictGet</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nokey</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>RM_DictGetC</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nokey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified key from the dictionary, returning REDISMODULE_OK if
 * the key was found and delted, or REDISMODULE_ERR if instead there was
 * no such key in the dictionary. When the operation is successful, if
 * 'oldval' is not NULL, then '*oldval' is set to the value stored at the
 * key before it was deleted. Using this feature it is possible to get
 * a pointer to the value (for instance in order to release it), without
 * having to call RedisModule_DictGet() before deleting the key. */</comment>
<function><type><name>int</name></type> <name>RM_DictDelC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldval</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>,<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>retval</name></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictDelC() but gets the key as a RedisModuleString. */</comment>
<function><type><name>int</name></type> <name>RM_DictDel</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldval</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>RM_DictDelC</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return an interator, setup in order to start iterating from the specified
 * key by applying the operator 'op', which is just a string specifying the
 * comparison operator to use in order to seek the first element. The
 * operators avalable are:
 *
 * "^"   -- Seek the first (lexicographically smaller) key.
 * "$"   -- Seek the last  (lexicographically biffer) key.
 * "&gt;"   -- Seek the first element greter than the specified key.
 * "&gt;="  -- Seek the first element greater or equal than the specified key.
 * "&lt;"   -- Seek the first element smaller than the specified key.
 * "&lt;="  -- Seek the first element smaller or equal than the specified key.
 * "=="  -- Seek the first element matching exactly the specified key.
 *
 * Note that for "^" and "$" the passed key is not used, and the user may
 * just pass NULL with a length of 0.
 *
 * If the element to start the iteration cannot be seeked based on the
 * key and operator passed, RedisModule_DictNext() / Prev() will just return
 * REDISMODULE_ERR at the first call, otherwise they'll produce elements.
 */</comment>
<function><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>RM_DictIteratorStartC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>di</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>di</name><operator>-&gt;</operator><name>dict</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name><name>d</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>di</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Exactly like RedisModule_DictIteratorStartC, but the key is passed as a
 * RedisModuleString. */</comment>
<function><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>RM_DictIteratorStart</name><parameter_list>(<parameter><decl><type><name>RedisModuleDict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>RM_DictIteratorStartC</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release the iterator created with RedisModule_DictIteratorStart(). This call
 * is mandatory otherwise a memory leak is introduced in the module. */</comment>
<function><type><name>void</name></type> <name>RM_DictIteratorStop</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* After its creation with RedisModule_DictIteratorStart(), it is possible to
 * change the currently selected element of the iterator by using this
 * API call. The result based on the operator and key is exactly like
 * the function RedisModule_DictIteratorStart(), however in this case the
 * return value is just REDISMODULE_OK in case the seeked element was found,
 * or REDISMODULE_ERR in case it was not possible to seek the specified
 * element. It is possible to reseek an iterator as many times as you want. */</comment>
<function><type><name>int</name></type> <name>RM_DictIteratorReseekC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictIteratorReseekC() but takes the key as as a
 * RedisModuleString. */</comment>
<function><type><name>int</name></type> <name>RM_DictIteratorReseek</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>RM_DictIteratorReseekC</name><argument_list>(<argument><expr><name>di</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current item of the dictionary iterator 'di' and steps to the
 * next element. If the iterator already yield the last element and there
 * are no other elements to return, NULL is returned, otherwise a pointer
 * to a string representing the key is provided, and the '*keylen' length
 * is set by reference (if keylen is not NULL). The '*dataptr', if not NULL
 * is set to the value of the pointer stored at the returned key as auxiliary
 * data (as set by the RedisModule_DictSet API).
 *
 * Usage example:
 *
 *      ... create the iterator here ...
 *      char *key;
 *      void *data;
 *      while((key = RedisModule_DictNextC(iter,&amp;keylen,&amp;data)) != NULL) {
 *          printf("%.*s %p\n", (int)keylen, key, data);
 *      }
 *
 * The returned pointer is of type void because sometimes it makes sense
 * to cast it to a char* sometimes to an unsigned char* depending on the
 * fact it contains or not binary data, so this API ends being more
 * comfortable to use.
 *
 * The validity of the returned pointer is until the next call to the
 * next/prev iterator step. Also the pointer is no longer valid once the
 * iterator is released. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_DictNextC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>keylen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>dataptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>keylen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>keylen</name> <operator>=</operator> <name><name>di</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dataptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>dataptr</name> <operator>=</operator> <name><name>di</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>di</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is exactly like RedisModule_DictNext() but after returning
 * the currently selected element in the iterator, it selects the previous
 * element (laxicographically smaller) instead of the next one. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_DictPrevC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>keylen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>dataptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>keylen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>keylen</name> <operator>=</operator> <name><name>di</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dataptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>dataptr</name> <operator>=</operator> <name><name>di</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>di</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModuleNextC(), but instead of returning an internally allocated
 * buffer and key length, it returns directly a module string object allocated
 * in the specified context 'ctx' (that may be NULL exactly like for the main
 * API RedisModule_CreateString).
 *
 * The returned string object should be deallocated after use, either manually
 * or by using a context that has automatic memory management active. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_DictNext</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>dataptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>keylen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RM_DictNextC</name><argument_list>(<argument><expr><name>di</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>keylen</name></expr></argument>,<argument><expr><name>dataptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>RM_CreateString</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictNext() but after returning the currently selected
 * element in the iterator, it selects the previous element (laxicographically
 * smaller) instead of the next one. */</comment>
<function><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_DictPrev</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>dataptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>keylen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RM_DictPrevC</name><argument_list>(<argument><expr><name>di</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>keylen</name></expr></argument>,<argument><expr><name>dataptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>RM_CreateString</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare the element currently pointed by the iterator to the specified
 * element given by key/keylen, according to the operator 'op' (the set of
 * valid operators are the same valid for RedisModule_DictIteratorStart).
 * If the comparision is successful the command returns REDISMODULE_OK
 * otherwise REDISMODULE_ERR is returned.
 *
 * This is useful when we want to just emit a lexicographical range, so
 * in the loop, as we iterate elements, we can also check if we are still
 * on range.
 *
 * The function returne REDISMODULE_ERR if the iterator reached the
 * end of elements condition as well. */</comment>
<function><type><name>int</name></type> <name>RM_DictCompareC</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>raxCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>res</name></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_DictCompareC but gets the key to compare with the current
 * iterator key as a RedisModuleString. */</comment>
<function><type><name>int</name></type> <name>RM_DictCompare</name><parameter_list>(<parameter><decl><type><name>RedisModuleDictIter</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>raxCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>res</name></expr> ?</condition><then> <expr><name>REDISMODULE_OK</name></expr> </then><else>: <expr><name>REDISMODULE_ERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules utility APIs
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return random bytes using SHA1 in counter mode with a /dev/urandom
 * initialized seed. This function is fast so can be used to generate
 * many bytes without any effect on the operating system entropy pool.
 * Currently this function is not thread safe. */</comment>
<function><type><name>void</name></type> <name>RM_GetRandomBytes</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>getRandomBytes</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Like RedisModule_GetRandomBytes() but instead of setting the string to
 * random bytes the string is set to random characters in the in the
 * hex charset [0-9a-f]. */</comment>
<function><type><name>void</name></type> <name>RM_GetRandomHexChars</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>getRandomHexChars</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules API exporting / importing
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This function is called by a module in order to export some API with a
 * given name. Other modules will be able to use this API by calling the
 * symmetrical function RM_GetSharedAPI() and casting the return value to
 * the right function pointer.
 *
 * The function will return REDISMODULE_OK if the name is not already taken,
 * otherwise REDISMODULE_ERR will be returned and no operation will be
 * performed.
 *
 * IMPORTANT: the apiname argument should be a string literal with static
 * lifetime. The API relies on the fact that it will always be valid in
 * the future. */</comment>
<function><type><name>int</name></type> <name>RM_ExportSharedAPI</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>apiname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleSharedAPI</name> <modifier>*</modifier></type><name>sapi</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sapi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>sapi</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sapi</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>sharedapi</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>apiname</name></expr></argument>, <argument><expr><name>sapi</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DICT_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sapi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Request an exported API pointer. The return value is just a void pointer
 * that the caller of this function will be required to cast to the right
 * function pointer, so this is a private contract between modules.
 *
 * If the requested API is not available then NULL is returned. Because
 * modules can be loaded at different times with different order, this
 * function calls should be put inside some module generic API registering
 * step, that is called every time a module attempts to execute a
 * command that requires external APIs: if some API cannot be resolved, the
 * command should return an error.
 *
 * Here is an exmaple:
 *
 *     int ... myCommandImplementation() {
 *        if (getExternalAPIs() == 0) {
 *             reply with an error here if we cannot have the APIs
 *        }
 *        // Use the API:
 *        myFunctionPointer(foo);
 *     }
 *
 * And the function registerAPI() is:
 *
 *     int getExternalAPIs(void) {
 *         static int api_loaded = 0;
 *         if (api_loaded != 0) return 1; // APIs already resolved.
 *
 *         myFunctionPointer = RedisModule_GetOtherModuleAPI("...");
 *         if (myFunctionPointer == NULL) return 0;
 *
 *         return 1;
 *     }
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>RM_GetSharedAPI</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>apiname</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>sharedapi</name></name></expr></argument>, <argument><expr><name>apiname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>RedisModuleSharedAPI</name> <modifier>*</modifier></type><name>sapi</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>sapi</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>usedby</name></name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>sapi</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>usedby</name></name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>using</name></name></expr></argument>,<argument><expr><name><name>sapi</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>sapi</name><operator>-&gt;</operator><name>func</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove all the APIs registered by the specified module. Usually you
 * want this when the module is going to be unloaded. This function
 * assumes that's caller responsibility to make sure the APIs are not
 * used by other modules.
 *
 * The number of unregistered APIs is returned. */</comment>
<function><type><name>int</name></type> <name>moduleUnregisterSharedAPI</name><parameter_list>(<parameter><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>sharedapi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>apiname</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RedisModuleSharedAPI</name> <modifier>*</modifier></type><name>sapi</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sapi</name><operator>-&gt;</operator><name>module</name></name> <operator>==</operator> <name>module</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>sharedapi</name></name></expr></argument>,<argument><expr><name>apiname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sapi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified module as an user of APIs of ever other module.
 * This is usually called when a module is unloaded.
 *
 * Returns the number of modules this module was using APIs from. */</comment>
<function><type><name>int</name></type> <name>moduleUnregisterUsedAPI</name><parameter_list>(<parameter><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>using</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>used</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>used</name><operator>-&gt;</operator><name>usedby</name></name></expr></argument>,<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ln</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>using</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unregister all filters registered by a module.
 * This is called when a module is being unloaded.
 * 
 * Returns the number of filters unregistered. */</comment>
<function><type><name>int</name></type> <name>moduleUnregisterFilters</name><parameter_list>(<parameter><decl><type><name>RedisModule</name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>filters</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleCommandFilter</name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listSearchKey</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>,<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ln</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Module Command Filter API
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* Register a new command filter function.
 *
 * Command filtering makes it possible for modules to extend Redis by plugging
 * into the execution flow of all commands.
 *
 * A registered filter gets called before Redis executes *any* command.  This
 * includes both core Redis commands and commands registered by any module.  The
 * filter applies in all execution paths including:
 *
 * 1. Invocation by a client.
 * 2. Invocation through `RedisModule_Call()` by any module.
 * 3. Invocation through Lua 'redis.call()`.
 * 4. Replication of a command from a master.
 *
 * The filter executes in a special filter context, which is different and more
 * limited than a RedisModuleCtx.  Because the filter affects any command, it
 * must be implemented in a very efficient way to reduce the performance impact
 * on Redis.  All Redis Module API calls that require a valid context (such as
 * `RedisModule_Call()`, `RedisModule_OpenKey()`, etc.) are not supported in a
 * filter context.
 *
 * The `RedisModuleCommandFilterCtx` can be used to inspect or modify the
 * executed command and its arguments.  As the filter executes before Redis
 * begins processing the command, any change will affect the way the command is
 * processed.  For example, a module can override Redis commands this way:
 *
 * 1. Register a `MODULE.SET` command which implements an extended version of
 *    the Redis `SET` command.
 * 2. Register a command filter which detects invocation of `SET` on a specific
 *    pattern of keys.  Once detected, the filter will replace the first
 *    argument from `SET` to `MODULE.SET`.
 * 3. When filter execution is complete, Redis considers the new command name
 *    and therefore executes the module's own command.
 *
 * Note that in the above use case, if `MODULE.SET` itself uses
 * `RedisModule_Call()` the filter will be applied on that call as well.  If
 * that is not desired, the `REDISMODULE_CMDFILTER_NOSELF` flag can be set when
 * registering the filter.
 *
 * The `REDISMODULE_CMDFILTER_NOSELF` flag prevents execution flows that
 * originate from the module's own `RM_Call()` from reaching the filter.  This
 * flag is effective for all execution flows, including nested ones, as long as
 * the execution begins from the module's command context or a thread-safe
 * context that is associated with a blocking command.
 *
 * Detached thread-safe contexts are *not* associated with the module and cannot
 * be protected by this flag.
 *
 * If multiple filters are registered (by the same or different modules), they
 * are executed in the order of registration.
 */</comment>

<function><type><name>RedisModuleCommandFilter</name> <modifier>*</modifier></type><name>RM_RegisterCommandFilter</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleCommandFilterFunc</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleCommandFilter</name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>filter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>filters</name></name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>filter</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unregister a command filter.
 */</comment>
<function><type><name>int</name></type> <name>RM_UnregisterCommandFilter</name><parameter_list>(<parameter><decl><type><name>RedisModuleCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RedisModuleCommandFilter</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <comment type="block">/* A module can only remove its own filters */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>module</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listSearchKey</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>,<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ln</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listSearchKey</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>filters</name></name></expr></argument>,<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ln</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* Shouldn't happen */</comment>
    <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>filters</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleCallCommandFilters</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name>moduleCommandFilters</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>RedisModuleCommandFilterCtx</name></type> <name>filter</name> <init>= <expr><block>{
        <expr><operator>.</operator><name>argv</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr>,
        <expr><operator>.</operator><name>argc</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>RedisModuleCommandFilter</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip filter if REDISMODULE_CMDFILTER_NOSELF is set and module is
         * currently processing a command.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REDISMODULE_CMDFILTER_NOSELF</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>module</name><operator>-&gt;</operator><name>in_call</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Call filter */</comment>
        <expr_stmt><expr><call><name><name>f</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name><name>filter</name><operator>.</operator><name>argv</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name><name>filter</name><operator>.</operator><name>argc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the number of arguments a filtered command has.  The number of
 * arguments include the command itself.
 */</comment>
<function><type><name>int</name></type> <name>RM_CommandFilterArgsCount</name><parameter_list>(<parameter><decl><type><name>RedisModuleCommandFilterCtx</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the specified command argument.  The first argument (position 0) is
 * the command itself, and the rest are user-provided args.
 */</comment>
<function><type><specifier>const</specifier> <name>RedisModuleString</name> <modifier>*</modifier></type><name>RM_CommandFilterArgGet</name><parameter_list>(<parameter><decl><type><name>RedisModuleCommandFilterCtx</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>pos</name> <operator>&gt;=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Modify the filtered command by inserting a new argument at the specified
 * position.  The specified RedisModuleString argument may be used by Redis
 * after the filter context is destroyed, so it must not be auto-memory
 * allocated, freed or used elsewhere.
 */</comment>

<function><type><name>int</name></type> <name>RM_CommandFilterArgInsert</name><parameter_list>(<parameter><decl><type><name>RedisModuleCommandFilterCtx</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pos</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>pos</name></expr></argument> &gt;</argument_list></name> <name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RedisModuleString</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name>pos</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Modify the filtered command by replacing an existing argument with a new one.
 * The specified RedisModuleString argument may be used by Redis after the
 * filter context is destroyed, so it must not be auto-memory allocated, freed
 * or used elsewhere.
 */</comment>

<function><type><name>int</name></type> <name>RM_CommandFilterArgReplace</name><parameter_list>(<parameter><decl><type><name>RedisModuleCommandFilterCtx</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>RedisModuleString</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>pos</name> <operator>&gt;=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Modify the filtered command by deleting an argument at the specified
 * position.
 */</comment>
<function><type><name>int</name></type> <name>RM_CommandFilterArgDelete</name><parameter_list>(<parameter><decl><type><name>RedisModuleCommandFilterCtx</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>pos</name> <operator>&gt;=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>pos</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>argc</name></name><operator>--</operator></expr>;</expr_stmt>

    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------
 * Modules API internals
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* server.moduleapi dictionary type. Only uses plain C strings since
 * this gets queries from modules. */</comment>

<function><type><name>uint64_t</name></type> <name>dictCStringKeyHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictGenHashFunction</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>dictCStringKeyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key1</name></expr></argument>,<argument><expr><name>key2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>dictType</name></type> <name>moduleAPIDictType</name> <init>= <expr><block>{
    <expr><name>dictCStringKeyHash</name></expr>,        <comment type="block">/* hash function */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key dup */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* val dup */</comment>
    <expr><name>dictCStringKeyCompare</name></expr>,     <comment type="block">/* key compare */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* key destructor */</comment>
    <expr><name>NULL</name></expr>                       <comment type="block">/* val destructor */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>moduleRegisterApi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>funcptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>moduleapi</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>funcname</name></expr></argument>, <argument><expr><name>funcptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTER_API</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>moduleRegisterApi("RedisModule_" #name, (void *)(PORT_ULONG)RM_ ## name)</cpp:value></cpp:define>

<comment type="block">/* Global initialization at Redis startup. */</comment>
<function_decl><type><name>void</name></type> <name>moduleRegisterCoreAPI</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>moduleInitModulesSystem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>moduleUnblockedClients</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>loadmodule_queue</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>modules</name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modulesDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up the keyspace notification susbscriber list and static client */</comment>
    <expr_stmt><expr><name>moduleKeyspaceSubscribers</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>moduleFreeContextReusedClient</name> <operator>=</operator> <call><name>createClient</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>moduleFreeContextReusedClient</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CLIENT_MODULE</name></expr>;</expr_stmt>

    <comment type="block">/* Set up filter list */</comment>
    <expr_stmt><expr><name>moduleCommandFilters</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>moduleRegisterCoreAPI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><call><name>IF_WIN32</name><argument_list>(<argument><expr><name>FDAPI_pipe_for_modules</name></expr></argument>,<argument><expr><name>pipe</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>module_blocked_pipe</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Can't create the pipe for module blocking commands: %s"</literal></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Make the pipe non blocking. This is just a best effort aware mechanism
     * and we do not want to block not in the read nor in the write half. */</comment>
    <expr_stmt><expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>module_blocked_pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>module_blocked_pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the timers radix tree. */</comment>
    <expr_stmt><expr><name>Timers</name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Our thread-safe contexts GIL must start with already locked:
     * it is just unlocked when it's safe. */</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleGIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Load all the modules in the server.loadmodule_queue list, which is
 * populated by `loadmodule` directives in the configuration file.
 * We can't load modules directly when processing the configuration file
 * because the server must be fully initialized before loading modules.
 *
 * The function aborts the server on errors, since to start with missing
 * modules is not considered sane: clients may rely on the existence of
 * given commands, loading AOF also may need some modules to exist, and
 * if this instance is a slave, it must understand commands from master. */</comment>
<function><type><name>void</name></type> <name>moduleLoadFromQueue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>loadmodule_queue</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>moduleLoadQueueEntry</name></name> <modifier>*</modifier></type><name>loadmod</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>moduleLoad</name><argument_list>(<argument><expr><name><name>loadmod</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>loadmod</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,<argument><expr><name><name>loadmod</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call>
            <operator>==</operator> <name>C_ERR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Can't load module from %s: server aborting"</literal></expr></argument>,
                <argument><expr><name><name>loadmod</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleFreeModuleStructure</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>filters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>moduleUnregisterCommands</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Unregister all the commands registered by this module. */</comment>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>RedisModuleCommandDispatcher</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>RedisModuleCommandProxy</name> <modifier>*</modifier></type><name>cp</name> <init>=
                <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>getkeys_proc</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sds</name></type> <name>cmdname</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>module</name></name> <operator>==</operator> <name>module</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>commands</name></name></expr></argument>,<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>orig_commands</name></name></expr></argument>,<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>rediscmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Load a module and initialize it. On success C_OK is returned, otherwise
 * C_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>moduleLoad</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>module_argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>module_argc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>onload</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RedisModuleCtx</name></type> <name>ctx</name> <init>= <expr><name>REDISMODULE_CTX_INIT</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>dlopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>RTLD_NOW</name><operator>|</operator><name>RTLD_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Module %s failed to load: %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>onload</name> <operator>=</operator> <operator>(</operator><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name>PORT_ULONG</name><operator>)</operator> <call><name>dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,<argument><expr><literal type="string">"RedisModule_OnLoad"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>onload</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Module %s does not export RedisModule_OnLoad() "</literal>
            <literal type="string">"symbol. Module not loaded."</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>onload</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ctx</name></expr></argument>,<argument><expr><name>module_argv</name></expr></argument>,<argument><expr><name>module_argc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REDISMODULE_ERR</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>module</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>moduleUnregisterCommands</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleUnregisterSharedAPI</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleUnregisterUsedAPI</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moduleFreeModuleStructure</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Module %s initialization failed. Module not loaded"</literal></expr></argument>,<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Redis module loaded! Register it. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>6011</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>modules</name></expr></argument>,<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>module</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Module '%s' loaded from %s"</literal></expr></argument>,<argument><expr><name><name>ctx</name><operator>.</operator><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Unload the module registered with the specified name. On success
 * C_OK is returned, otherwise C_ERR is returned and errno is set
 * to the following values depending on the type of error:
 *
 * * ENONET: No such module having the specified name.
 * * EBUSY: The module exports a new data type and can only be reloaded. */</comment>
<function><type><name>int</name></type> <name>moduleUnload</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name> <init>= <expr><call><name>dictFetchValue</name><argument_list>(<argument><expr><name>modules</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>module</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EBUSY</name></expr>;</expr_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>usedby</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EPERM</name></expr>;</expr_stmt>
        <return>return <expr><name>REDISMODULE_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>moduleUnregisterCommands</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleUnregisterSharedAPI</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleUnregisterUsedAPI</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>moduleUnregisterFilters</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove any notification subscribers this module might have */</comment>
    <expr_stmt><expr><call><name>moduleUnsubscribeNotifications</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unregister all the hooks. TODO: Yet no hooks support here. */</comment>

    <comment type="block">/* Unload the dynamic library. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dlclose</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="string">"Unknown error"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error when trying to close the %s module: %s"</literal></expr></argument>,
            <argument><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Remove from list of modules. */</comment>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Module %s unloaded"</literal></expr></argument>,<argument><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>modules</name></expr></argument>,<argument><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* The name was already freed by dictDelete(). */</comment>
    <expr_stmt><expr><call><name>moduleFreeModuleStructure</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>REDISMODULE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Redis MODULE command.
 *
 * MODULE LOAD &lt;path&gt; [args...] */</comment>
<function><type><name>void</name></type> <name>moduleCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>subcmd</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>subcmd</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"LIST -- Return a list of loaded modules."</literal></expr>,
<expr><literal type="string">"LOAD &lt;path&gt; [arg ...] -- Load a module library from &lt;path&gt;."</literal></expr>,
<expr><literal type="string">"UNLOAD &lt;name&gt; -- Unload a module."</literal></expr>,
<expr><name>NULL</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else
    if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>subcmd</name></expr></argument>,<argument><expr><literal type="string">"load"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>moduleLoad</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                <argument><expr><literal type="string">"Error loading the extension. Please check the server logs."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>subcmd</name></expr></argument>,<argument><expr><literal type="string">"unload"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>moduleUnload</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>
            <switch>switch<condition>(<expr><name>errno</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>ENOENT</name></expr>:</case>
                <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"no such module with that name"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EBUSY</name></expr>:</case>
                <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"the module exports one or more module-side data "</literal>
                         <literal type="string">"types, can't unload"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EPERM</name></expr>:</case>
                <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"the module exports APIs used by other modules. "</literal>
                         <literal type="string">"Please unload them first and try again"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"operation not possible."</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></switch>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Error unloading module: %s"</literal></expr></argument>,<argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>subcmd</name></expr></argument>,<argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>name</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>RedisModule</name></name> <modifier>*</modifier></type><name>module</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"ver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>module</name><operator>-&gt;</operator><name>ver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the number of registered modules. */</comment>
<function><type><name>size_t</name></type> <name>moduleCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>dictSize</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Register all the APIs we export. Keep this function at the end of the
 * file so that's easy to seek it to add new entries. */</comment>
<function><type><name>void</name></type> <name>moduleRegisterCoreAPI</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>moduleapi</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleAPIDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>sharedapi</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>moduleAPIDictType</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Calloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Realloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Strdup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SetModuleAttribs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>IsModuleNameBusy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>WrongArity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithLongLong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithSimpleString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplySetArrayLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithStringBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithCString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithCallReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplyWithDouble</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetSelectedDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SelectDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>OpenKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CloseKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>KeyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ValueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ListPush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ListPop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringToLongLong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringToDouble</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CallReplyProto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>FreeCallReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CallReplyInteger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CallReplyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CallReplyLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CallReplyArrayElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CallReplyStringPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateStringFromCallReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateStringFromLongLong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateStringFromString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateStringPrintf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>FreeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringPtrLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>AutoMemory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Replicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ReplicateVerbatim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DeleteKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>UnlinkKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringDMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SetExpire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetExpire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetAdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetIncrby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetScore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetRem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetRangeStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetFirstInScoreRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetLastInScoreRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetFirstInLexRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetLastInLexRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetRangeCurrentElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetRangeNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetRangePrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ZsetRangeEndReached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>HashSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>HashGet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>IsKeysPositionRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>KeyAtPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetClientId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetContextFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>PoolAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateDataType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ModuleTypeSetValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ModuleTypeGetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ModuleTypeGetValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SaveUnsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LoadUnsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SaveSigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LoadSigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SaveString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SaveStringBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LoadString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LoadStringBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SaveDouble</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LoadDouble</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SaveFloat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LoadFloat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>EmitAOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>LogIOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringAppendBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>RetainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StringCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetContextFromIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetKeyNameFromIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>BlockClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>UnblockClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>IsBlockedReplyRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>IsBlockedTimeoutRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetBlockedClientPrivateData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>AbortBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>Milliseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetThreadSafeContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>FreeThreadSafeContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ThreadSafeContextLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ThreadSafeContextUnlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DigestAddStringBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DigestAddLongLong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DigestEndSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SubscribeToKeyspaceEvents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>RegisterClusterMessageReceiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SendClusterMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetClusterNodeInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetClusterNodesList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>FreeClusterNodesList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>StopTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetTimerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetMyClusterID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetClusterSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetRandomBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetRandomHexChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>BlockedClientDisconnected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SetDisconnectCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetBlockedClientHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>SetClusterFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CreateDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>FreeDict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictSetC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictReplaceC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictGetC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictGet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictDelC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictIteratorStartC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictIteratorStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictIteratorStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictIteratorReseekC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictIteratorReseek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictNextC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictPrevC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictCompareC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>DictCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>ExportSharedAPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>GetSharedAPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>RegisterCommandFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>UnregisterCommandFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CommandFilterArgsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CommandFilterArgGet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CommandFilterArgInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CommandFilterArgReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_API</name><argument_list>(<argument><expr><name>CommandFilterArgDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
