<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/aof.c"><comment type="block">/*
 * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/win32_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Error.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rio.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_QFork.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>void</name></type> <name>aofUpdateCurrentSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>aofClosePipes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------------------
 * AOF rewrite buffer implementation.
 *
 * The following code implement a simple buffer used in order to accumulate
 * changes while the background process is rewriting the AOF file.
 *
 * We only need to append, but can't just use realloc with a large block
 * because 'huge' reallocs are not always handled as one could expect
 * (via remapping of pages at OS level) but may involve copying data.
 *
 * For this reason we use a list of blocks, every block is
 * AOF_RW_BUF_BLOCK_SIZE bytes.
 * ------------------------------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AOF_RW_BUF_BLOCK_SIZE</name></cpp:macro> <cpp:value>(1024*1024*10)</cpp:value></cpp:define>    <comment type="block">/* 10 MB per block */</comment>

<typedef>typedef <type><struct>struct <name>aofrwblock</name> <block>{
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>used</name></decl>, <name>free</name>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>AOF_RW_BUF_BLOCK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>aofrwblock</name>;</typedef>

<comment type="block">/* This function free the old AOF rewrite buffer if needed, and initialize
 * a fresh new one. It tests for server.aof_rewrite_buf_blocks equal to NULL
 * so can be used for the first initialization as well. */</comment>
<function><type><name>void</name></type> <name>aofRewriteBufferReset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>,<argument><expr><name>zfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the current size of the AOF rewrite buffer. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>aofRewriteBufferSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>aofrwblock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>block</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Event handler used to send data to the child process doing the AOF
 * rewrite. We send pieces of our AOF differences buffer so that the final
 * write when the child finishes the rewrite will be small. */</comment>
<function><type><name>void</name></type> <name>aofChildWriteDiffData</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>aofrwblock</name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>listFirst</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>block</name> <operator>=</operator> <ternary><condition><expr><name>ln</name></expr> ?</condition><then> <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_stop_sending_diff</name></name> <operator>||</operator> <operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
            <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>,
                              <argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>,
                             <argument><expr><name><name>block</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>block</name><operator>-&gt;</operator><name>buf</name></name><operator>+</operator><name>nwritten</name></expr></argument>,<argument><expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name><operator>-</operator><name>nwritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name> <operator>-=</operator> <name>nwritten</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>listDelNode</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>,<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Append data to the AOF rewrite buffer, allocating new blocks if needed. */</comment>
<function><type><name>void</name></type> <name>aofRewriteBufferAppend</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONG</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>listLast</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>aofrwblock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><ternary><condition><expr><name>ln</name></expr> ?</condition><then> <expr><name><name>ln</name><operator>-&gt;</operator><name>value</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we already got at least an allocated block, try appending
         * at least some piece into it. */</comment>
        <if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>thislen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>len</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>block</name><operator>-&gt;</operator><name>free</name></name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>thislen</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* The current block is not already full. */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>buf</name></name><operator>+</operator><name><name>block</name><operator>-&gt;</operator><name>used</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>thislen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>thislen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>thislen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>thislen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>thislen</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content> <comment type="block">/* First block to allocate, or need another block. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>numblocks</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>AOF_RW_BUF_BLOCK_SIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>,<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Log every time we cross more 10 or 100 blocks, respectively
             * as a notice or warning. */</comment>
            <expr_stmt><expr><name>numblocks</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>numblocks</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">10</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>numblocks</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>LL_WARNING</name></expr> </then><else>:
                                                         <expr><name>LL_NOTICE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <macro><name>serverLog</name><argument_list>(<argument>level</argument>,<argument><literal type="string">"Background AOF buffer size: %Iu MB"</literal></argument>, <argument>WIN_PORT_FIX <comment type="block">/* %lu -&gt; %Iu */</comment>
                    aofRewriteBufferSize()/(<literal type="number">1024</literal>*<literal type="number">1024</literal>)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <comment type="block">/* Install a file event to send data to the rewrite child if there is
     * not one already. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>aeGetFileEvents</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>,
            <argument><expr><name>AE_WRITABLE</name></expr></argument>, <argument><expr><name>aofChildWriteDiffData</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Write the buffer (possibly composed of multiple blocks) into the specified
 * fd. If a short write or any other error happens -1 is returned,
 * otherwise the number of bytes written is returned. */</comment>
<function><type><name>ssize_t</name></type> <name>aofRewriteBufferWrite</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_buf_blocks</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>aofrwblock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name><name>block</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,<argument><expr><name><name>block</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>!=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name><name>block</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * AOF file implementation
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* Return true if an AOf fsync is currently already in progress in a
 * BIO thread. */</comment>
<function><type><name>int</name></type> <name>aofFsyncInProgress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>bioPendingJobsOfType</name><argument_list>(<argument><expr><name>BIO_AOF_FSYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Starts a background task that performs fsync() against the specified
 * file descriptor (the one of the AOF file) in another thread. */</comment>
<function><type><name>void</name></type> <name>aof_background_fsync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>bioCreateBackgroundJob</name><argument_list>(<argument><expr><name>BIO_AOF_FSYNC</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>fd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Kills an AOFRW child process if exists */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>killAppendOnlyChild</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

    <macro><name>POSIX_ONLY</name><argument_list>(<argument>int statloc;</argument>)</argument_list></macro>

    <comment type="block">/* No AOFRW child? return. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Kill AOFRW child, wait for child exit. */</comment>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Killing running AOF rewrite child: %Id"</literal></expr></argument>, <argument><expr><macro><name>WIN_PORT_FIX</name> <comment type="block">/* %ld -&gt; %Id */</comment>
        <argument_list>(<argument>PORT_LONG</argument>)</argument_list></macro> <name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <expr_stmt><expr><call><name>AbortForkOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr></argument>,<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <while>while<condition>(<expr><call><name>wait3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statloc</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Reset the buffer accumulating changes while the child saves. */</comment>
    <expr_stmt><expr><call><name>aofRewriteBufferReset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aofRemoveTempFile</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_time_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Close pipes used for IPC between the two processes. */</comment>
    <expr_stmt><expr><call><name>aofClosePipes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Called when the user switches from "appendonly yes" to "appendonly no"
 * at runtime using the CONFIG command. */</comment>
<function><type><name>void</name></type> <name>stopAppendOnly</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>!=</operator> <name>AOF_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>flushAppendOnlyFile</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>redis_fsync</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_selected_db</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>=</operator> <name>AOF_OFF</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>killAppendOnlyChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Called when the user switches from "appendonly no" to "appendonly yes"
 * at runtime using the CONFIG command. */</comment>
<function><type><name>int</name></type> <name>startAppendOnly</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cwd</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Current working dir path for error messages. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>newfd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>newfd</name> <operator>=</operator> <macro><name>open</name><argument_list>(<argument>server.aof_filename</argument>,<argument>O_WRONLY|O_APPEND|O_CREAT WIN32_ONLY(|_O_BINARY)</argument>, <argument>IF_WIN32(_S_IREAD|_S_IWRITE, <literal type="number">0644</literal>)</argument>)</argument_list></macro></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>==</operator> <name>AOF_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cwdp</name> <init>= <expr><call><call><name>IF_WIN32</name><argument_list>(<argument><expr><name>_getcwd</name></expr></argument>, <argument><expr><name>getcwd</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Redis needs to enable the AOF but can't open the "</literal>
            <literal type="string">"append only file %s (in server root dir %s): %s"</literal></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>cwdp</name></expr> ?</condition><then> <expr><name>cwdp</name></expr> </then><else>: <expr><literal type="string">"unknown"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_scheduled</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"AOF was enabled but there is already a child process saving an RDB file on disk. An AOF background was scheduled to start when possible."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If there is a pending AOF rewrite, we need to switch it off and
         * start a new one: the old one cannot be reused because it is not
         * accumulating the AOF buffer. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"AOF was enabled but there is already an AOF rewriting in background. Stopping background AOF and starting a rewrite now."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>killAppendOnlyChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rewriteAppendOnlyFileBackground</name><argument_list>()</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Redis needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* We correctly switched on AOF, now wait for the rewrite to be complete
     * in order to append data on disk. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>=</operator> <name>AOF_WAIT_REWRITE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_fsync</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>=</operator> <name>newfd</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is a wrapper to the write syscall in order to retry on short writes
 * or if the syscall gets interrupted. It could look strange that we retry
 * on short writes given that we are writing to a block device: normally if
 * the first call is short, there is a end-of-space condition, so the next
 * is likely to fail. However apparently in modern systems this is no longer
 * true, and in general it looks just more resilient to retry the write. If
 * there is an actual error condition we'll get it at the next try. */</comment>
<function><type><name>ssize_t</name></type> <name>aofWrite</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totwritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><ternary><condition><expr><name>totwritten</name></expr> ?</condition><then> <expr><name>totwritten</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>nwritten</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totwritten</name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>totwritten</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write the append only file buffer on disk.
 *
 * Since we are required to write the AOF before replying to the client,
 * and the only way the client socket can get a write is entering when the
 * the event loop, we accumulate all the AOF writes in a memory
 * buffer and write it on disk using this function just before entering
 * the event loop again.
 *
 * About the 'force' argument:
 *
 * When the fsync policy is set to 'everysec' we may delay the flush if there
 * is still an fsync() going on in the background thread, since for instance
 * on Linux write(2) will be blocked by the background fsync anyway.
 * When this happens we remember that there is some aof buffer to be
 * flushed ASAP, and will try to do that in the serverCron() function.
 *
 * However if force is set to 1 we'll write regardless of the background
 * fsync. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AOF_WRITE_LOG_ERROR_RATE</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> <comment type="block">/* Seconds between errors logging. */</comment>
<function><type><name>void</name></type> <name>flushAppendOnlyFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nwritten</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sync_in_progress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>latency</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Check if we need to do fsync even the aof buffer is empty,
         * because previously in AOF_FSYNC_EVERYSEC mode, fsync is
         * called only when aof buffer is not empty, so if users
         * stop write commands before fsync called in one second,
         * the data in page cache cannot be flushed in time. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_EVERYSEC</name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>aof_fsync_offset</name></name> <operator>!=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name> <operator>&amp;&amp;</operator>
            <name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>aof_last_fsync</name></name> <operator>&amp;&amp;</operator>
            <operator>!</operator><operator>(</operator><name>sync_in_progress</name> <operator>=</operator> <call><name>aofFsyncInProgress</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>try_fsync</name>;</goto>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_EVERYSEC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sync_in_progress</name> <operator>=</operator> <call><name>aofFsyncInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_EVERYSEC</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* With this append fsync policy we do background fsyncing.
         * If the fsync is still in progress we can try to delay
         * the write for a couple of seconds. */</comment>
        <if_stmt><if>if <condition>(<expr><name>sync_in_progress</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_flush_postponed_start</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* No previous write postponing, remember that we are
                 * postponing the flush and return. */</comment>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_flush_postponed_start</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>aof_flush_postponed_start</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* We were already waiting for fsync to finish, but for less
                 * than two seconds this is still ok. Postpone again. */</comment>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Otherwise fall trough, and go write since we can't wait
             * over two seconds. */</comment>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_delayed_fsync</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* We want to perform a single write. This should be guaranteed atomic
     * at least if the filesystem we are writing is a real physical one.
     * While this will save us against the server being killed I don't think
     * there is much to do about the whole server stopping for power problems
     * or alike */</comment>

    <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <call><name>aofWrite</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We want to capture different events for delayed writes:
     * when the delay happens with a pending fsync, or with a saving child
     * active, and when the above two conditions are missing.
     * We also use an additional event name to save all samples which is
     * useful for graphing / monitoring purposes. */</comment>
    <if_stmt><if>if <condition>(<expr><name>sync_in_progress</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-write-pending-fsync"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-write-active-child"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-write-alone"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-write"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We performed the write so reset the postponed flush sentinel to zero. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_flush_postponed_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>!=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>last_write_error_log</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>can_log</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>-</operator> <name>last_write_error_log</name><operator>)</operator> <operator>&gt;</operator> <name>AOF_WRITE_LOG_ERROR_RATE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>can_log</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_write_error_log</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Log the AOF write error and record the error code. */</comment>
        <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>can_log</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error writing to the AOF file: %s"</literal></expr></argument>,
                    <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_write_errno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>can_log</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Short write while writing to "</literal>
                                       <literal type="string">"the AOF file: (nwritten=%lld, "</literal>
                                       <literal type="string">"expected=%lld)"</literal></expr></argument>,
                                       <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><name>nwritten</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ftruncate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>can_log</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Could not remove short write "</literal>
                             <literal type="string">"from the append-only file.  Redis may refuse "</literal>
                             <literal type="string">"to load the AOF the next time it starts.  "</literal>
                             <literal type="string">"ftruncate: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* If the ftruncate() succeeded we can set nwritten to
                 * -1 since there is no longer partial data into the AOF. */</comment>
                <expr_stmt><expr><name>nwritten</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_write_errno</name></name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Handle the AOF write error. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_ALWAYS</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We can't recover when the fsync policy is ALWAYS since the
             * reply for the client is already in the output buffers, and we
             * have the contract with the user that on acknowledged write data
             * is synced on disk. */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Recover from failed write leaving data into the buffer. However
             * set an error to stop accepting writes as long as the error
             * condition is not cleared. */</comment>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_write_status</name></name> <operator>=</operator> <name>C_ERR</name></expr>;</expr_stmt>

            <comment type="block">/* Trim the sds buffer if there was a partial write, and there
             * was no way to undo it with ftruncate(2). */</comment>
            <if_stmt><if>if <condition>(<expr><name>nwritten</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_current_size</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sdsrange</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nwritten</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
            </block_content>}</block></if></if_stmt>
            <return>return;</return> <comment type="block">/* We'll try again on the next call... */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Successful write(2). If AOF was in error state, restore the
         * OK state and log the event. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_last_write_status</name></name> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"AOF write error looks solved, Redis can write again."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_write_status</name></name> <operator>=</operator> <name>C_OK</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_current_size</name></name> <operator>+=</operator> <name>nwritten</name></expr>;</expr_stmt>

    <comment type="block">/* Re-use AOF buffer when it is small enough. The maximum comes from the
     * arena size of 4k minus some overhead (but is otherwise arbitrary). */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call><operator>+</operator><call><name>sdsavail</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">4000</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sdsclear</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>try_fsync</name>:</label>
    <comment type="block">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are
     * children doing I/O in the background. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_no_fsync_on_rewrite</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Perform the fsync if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_ALWAYS</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* redis_fsync is defined as fdatasync() for Linux in order to avoid
         * flushing metadata. */</comment>
        <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>redis_fsync</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Let's try to get this data on the disk */</comment>
        <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-fsync-always"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fsync_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_fsync</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_EVERYSEC</name> <operator>&amp;&amp;</operator>
                <name><name>server</name><operator>.</operator><name>unixtime</name></name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>aof_last_fsync</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sync_in_progress</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>aof_background_fsync</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fsync_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_last_fsync</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>unixtime</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>sds</name></type> <name>catAppendOnlyGenericCommand</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>getDecodedObject</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create the sds representation of an PEXPIREAT command, using
 * 'seconds' as time to live and 'cmd' to understand what command
 * we are translating into a PEXPIREAT.
 *
 * This command is used in order to translate EXPIRE and PEXPIRE commands
 * into PEXPIREAT command so that we retain precision in the append only
 * file, and the time is always absolute and not relative. */</comment>
<function><type><name>sds</name></type> <name>catAppendOnlyExpireAtCommand</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>seconds</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>when</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Make sure we can use strtoll */</comment>
    <expr_stmt><expr><name>seconds</name> <operator>=</operator> <call><name>getDecodedObject</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>when</name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name><name>seconds</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>expireCommand</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>setexCommand</name> <operator>||</operator>
        <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>expireatCommand</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>when</name> <operator>*=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>expireCommand</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>pexpireCommand</name> <operator>||</operator>
        <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>setexCommand</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>psetexCommand</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>when</name> <operator>+=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"PEXPIREAT"</literal></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyGenericCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>feedAppendOnlyFile</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dictid</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>buf</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>tmpargv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* The DB this command was targeting is not the same as the last command
     * we appended. To issue a SELECT command is needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dictid</name> <operator>!=</operator> <name><name>server</name><operator>.</operator><name>aof_selected_db</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>seldb</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seldb</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>seldb</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%d"</literal></expr></argument>,<argument><expr><name>dictid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>WIN32_ONLY</name><argument_list>(<argument>seldb[sizeof(seldb)-<literal type="number">1</literal>] = <literal type="number">0</literal>;</argument>)</argument_list></macro> <comment type="block">/*get rid of C6053 warning*/</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"*2\r\n$6\r\nSELECT\r\n$%Iu\r\n%s\r\n"</literal></expr></argument>, <argument><expr><macro><name>WIN_PORT_FIX</name> <comment type="block">/* %lu -&gt; %Iu */</comment>
            <argument_list>(<argument>PORT_ULONG</argument>)</argument_list></macro><call><name>strlen</name><argument_list>(<argument><expr><name>seldb</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>seldb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_selected_db</name></name> <operator>=</operator> <name>dictid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>expireCommand</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>pexpireCommand</name> <operator>||</operator>
        <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>expireatCommand</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyExpireAtCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>setexCommand</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>psetexCommand</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Translate SETEX/PSETEX to SET and PEXPIREAT */</comment>
        <expr_stmt><expr><name><name>tmpargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"SET"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmpargv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmpargv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyGenericCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>tmpargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>tmpargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyExpireAtCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>cmd</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>setCommand</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>exarg</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pxarg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyGenericCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"ex"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exarg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"px"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pxarg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>exarg</name> <operator>&amp;&amp;</operator> <name>pxarg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>exarg</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyExpireAtCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>expireCommand</name></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                               <argument><expr><name>exarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>pxarg</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyExpireAtCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>pexpireCommand</name></name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                               <argument><expr><name>pxarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* All the other commands don't need translation or need the
         * same translation already operated in the command vector
         * for the replication itself. */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>catAppendOnlyGenericCommand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Append to the AOF buffer. This will be flushed on disk just before
     * of re-entering the event loop, so before the client will get a
     * positive reply about the operation performed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>==</operator> <name>AOF_ON</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If a background append only file rewriting is in progress we want to
     * accumulate the differences between the child DB and the current one
     * in a buffer, so that when the child process will do its work we
     * can append the differences to the new append only file. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aofRewriteBufferAppend</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>,<argument><expr><operator>(</operator><name>PORT_ULONG</name><operator>)</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (PORT_ULONG) */</comment>

    <name>sdsfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * AOF loading
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* In Redis commands are always executed in the context of a client, so in
 * order to load the append only file we need to create a fake client. */</comment>
<function><type><name><name>struct</name> <name>client</name></name> <modifier>*</modifier></type><name>createFakeClient</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>client</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>selectDb</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf_peak</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>btype</name></name> <operator>=</operator> <name>BLOCKED_NONE</name></expr>;</expr_stmt>
    <comment type="block">/* We set the fake client as a slave waiting for the synchronization
     * so that Redis will not try to send replies to this client. */</comment>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>replstate</name></name> <operator>=</operator> <name>SLAVE_STATE_WAIT_BGSAVE_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>reply_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>obuf_soft_limit_reached_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>peerid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name>freeClientReplyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listSetDupMethod</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>,<argument><expr><name>dupClientReplyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initClientMultiState</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeFakeClientArgv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>client</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>freeFakeClient</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>client</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>querybuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>watched_keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeClientMultiState</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Replay the append log file. On success C_OK is returned. On non fatal
 * error (the append only file is zero-length) C_ERR is returned. On
 * fatal error an error message is logged and the program exists. */</comment>
<function><type><name>int</name></type> <name>loadAppendOnlyFile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>client</name></name> <modifier>*</modifier></type><name>fakeClient</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><literal type="string">"rb"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>redis_stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_aof_state</name> <init>= <expr><name><name>server</name><operator>.</operator><name>aof_state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>loops</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>off_t</name></type> <name>valid_up_to</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Offset of latest well-formed command loaded. */</comment>
    <decl_stmt><decl><type><name>off_t</name></type> <name>valid_before_multi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Offset before MULTI command loaded. */</comment>

    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Fatal error: can't open the append log file for reading: %s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle a zero-length AOF file as a special case. An empty AOF file
     * is a valid AOF because an empty server with AOF enabled will create
     * a zero length file at startup, that will remain like that if no write
     * operation is received. */</comment>
    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>&amp;&amp;</operator> <call><name>redis_fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_current_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fsync_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Temporarily disable AOF, to prevent EXEC from feeding a MULTI
     * to the same file we're about to read. */</comment>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>=</operator> <name>AOF_OFF</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>fakeClient</name> <operator>=</operator> <call><name>createFakeClient</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>startLoading</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if this AOF file has an RDB preamble. In that case we need to
     * load the RDB file and later continue loading the AOF tail. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>sig</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* "REDIS" */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>sig</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">5</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>sig</name></expr></argument>,<argument><expr><literal type="string">"REDIS"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No RDB preamble, seek back at 0 offset. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>readerr</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* RDB preamble. Pass loading the RDB functions. */</comment>
        <decl_stmt><decl><type><name>rio</name></type> <name>rdb</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Reading RDB preamble from AOF file..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>readerr</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>rioInitWithFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rdb</name></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rdbLoadRio</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rdb</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error reading the RDB preamble of the AOF file, AOF loading aborted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>readerr</name>;</goto>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Reading the remaining AOF tail..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Read the actual AOF file, in REPL format, command by command. */</comment>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>argsds</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>redisCommand</name></name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

        <comment type="block">/* Serve the clients from time to time */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>loops</name><operator>++</operator> <operator>%</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>loadingProgress</name><argument_list>(<argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <call><name>ftello</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                 <function_decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (off_t) */</comment>
            <name>processEventsWhileBlocked</name><parameter_list>()</parameter_list>;</function_decl>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <goto>goto <name>readerr</name>;</goto></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fmterr</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>readerr</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fmterr</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Load the next command in the AOF as our fake client
         * argv. */</comment>
        <expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="block">/* Parse the argument len. */</comment>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>readres</name> <init>= <expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>readres</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt> <comment type="block">/* Free up to j-1. */</comment>
                <expr_stmt><expr><call><name>freeFakeClientArgv</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>readres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>readerr</name>;</goto></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <goto>goto <name>fmterr</name>;</goto></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Read it into a string object. */</comment>
            <expr_stmt><expr><name>argsds</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>SDS_NOINIT</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <call><name>fread</name><argument_list>(<argument><expr><name>argsds</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>argsds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt> <comment type="block">/* Free up to j-1. */</comment>
                <expr_stmt><expr><call><name>freeFakeClientArgv</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>readerr</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>argsds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Discard CRLF. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Free up to j. */</comment>
                <expr_stmt><expr><call><name>freeFakeClientArgv</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>readerr</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Command lookup */</comment>
        <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>lookupCommand</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Unknown command '%s' reading the append only file"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name><name>server</name><operator>.</operator><name>multiCommand</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>valid_before_multi</name> <operator>=</operator> <name>valid_up_to</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Run the command in the context of a fake client */</comment>
        <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>fakeClient</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name> <operator>&amp;&amp;</operator>
            <name><name>fakeClient</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>!=</operator> <name>execCommand</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>queueMultiCommand</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>cmd</name><operator>-&gt;</operator><name>proc</name></name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* The fake client should not have a reply */</comment>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>bufpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                     <call><name>listLength</name><argument_list>(<argument><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The fake client should never get blocked */</comment>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name><name>fakeClient</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_BLOCKED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clean up. Command code may have changed argv/argc so we use the
         * argv/argc of the client instead of the local variables. */</comment>
        <expr_stmt><expr><call><name>freeFakeClientArgv</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fakeClient</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_load_truncated</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>valid_up_to</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* This point can only be reached when EOF is reached without errors.
     * If the client is in the middle of a MULTI/EXEC, handle it as it was
     * a short read, even if technically the protocol is correct: we want
     * to remove the unprocessed tail and continue. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fakeClient</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Revert incomplete MULTI/EXEC transaction in AOF file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>valid_up_to</name> <operator>=</operator> <name>valid_before_multi</name></expr>;</expr_stmt>
        <goto>goto <name>uxeof</name>;</goto>
    </block_content>}</block></if></if_stmt>

<label><name>loaded_ok</name>:</label> <comment type="block">/* DB loaded, cleanup and return C_OK to the caller. */</comment>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeFakeClient</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>=</operator> <name>old_aof_state</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stopLoading</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aofUpdateCurrentSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_base_size</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fsync_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>readerr</name>:</label> <comment type="block">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>feof</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fakeClient</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeFakeClient</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* avoid valgrind warning */</comment>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unrecoverable error reading the append only file: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>uxeof</name>:</label> <comment type="block">/* Unexpected AOF end of file. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_load_truncated</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"!!! Warning: short read while loading the AOF file !!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"!!! Truncating the AOF at offset %llu !!!"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>PORT_ULONGLONG</name><operator>)</operator> <name>valid_up_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>valid_up_to</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <call><name>truncate</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><name>valid_up_to</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>valid_up_to</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Last valid command offset is invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error truncating the AOF file: %s"</literal></expr></argument>,
                    <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Make sure the AOF file descriptor points to the end of the
             * file after the truncate call. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Can't seek the end of the AOF file: %s"</literal></expr></argument>,
                    <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"AOF loaded anyway because aof-load-truncated is enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>loaded_ok</name>;</goto>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fakeClient</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeFakeClient</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* avoid valgrind warning */</comment>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fmterr</name>:</label> <comment type="block">/* Format error. */</comment>
    <if_stmt><if>if <condition>(<expr><name>fakeClient</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeFakeClient</name><argument_list>(<argument><expr><name>fakeClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* avoid valgrind warning */</comment>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * AOF rewrite
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* Delegate writing an object to writing a bulk string or bulk long long.
 * This is not placed in rio.c since that adds the server.h dependency. */</comment>
<function><type><name>int</name></type> <name>rioWriteBulkObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Avoid using getDecodedObject to help copy-on-write (we are often
     * in a child process when this function is called). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>               <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>           <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown string encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit the commands needed to rebuild a list object.
 * The function returns 0 on error, 1 on success. */</comment>
<function><type><name>int</name></type> <name>rewriteListObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>items</name> <init>= <expr><call><name>listTypeLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_QUICKLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>li</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>cmd_items</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>items</name> <operator>&gt;</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name><operator>)</operator></expr> ?</condition><then>  <expr><name>WIN_PORT_FIX</name> <comment type="block">/* int -&gt; PORT_LONGLONG */</comment>
                    <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr> </then><else>: <expr><name>items</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">2</literal><operator>+</operator><name>cmd_items</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"RPUSH"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>,<argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>==</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>items</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown list encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit the commands needed to rebuild a set object.
 * The function returns 0 on error, 1 on success. */</comment>
<function><type><name>int</name></type> <name>rewriteSetObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>items</name> <init>= <expr><call><name>setTypeSize</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>llval</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><call><name>intsetGet</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ii</name><operator>++</operator></expr></argument>,<argument><expr><operator>&amp;</operator><name>llval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>cmd_items</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>items</name> <operator>&gt;</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name>AOF_REWRITE_ITEMS_PER_CMD</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><name>items</name></expr></else></ternary></expr></init></decl>;</decl_stmt>               <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><literal type="number">2</literal><operator>+</operator><name>cmd_items</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_LONG) */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"SADD"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>llval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>==</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>items</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>cmd_items</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>items</name> <operator>&gt;</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name>AOF_REWRITE_ITEMS_PER_CMD</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><name>items</name></expr></else></ternary></expr></init></decl>;</decl_stmt>               <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><operator>(</operator><name>PORT_LONG</name><operator>)</operator><literal type="number">2</literal><operator>+</operator><name>cmd_items</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_LONG) */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"SADD"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>==</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>items</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit the commands needed to rebuild a sorted set object.
 * The function returns 0 on error, 1 on success. */</comment>
<function><type><name>int</name></type> <name>rewriteSortedSetObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>items</name> <init>= <expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vll</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>cmd_items</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>items</name> <operator>&gt;</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name>AOF_REWRITE_ITEMS_PER_CMD</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><name>items</name></expr></else></ternary></expr></init></decl>;</decl_stmt>               <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">2</literal><operator>+</operator><operator>(</operator><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>cmd_items</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_LONG) */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"ZADD"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>vll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>==</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>items</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name> <init>= <expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>cmd_items</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>items</name> <operator>&gt;</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name>AOF_REWRITE_ITEMS_PER_CMD</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><name>items</name></expr></else></ternary></expr></init></decl>;</decl_stmt>               <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">2</literal><operator>+</operator><operator>(</operator><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>cmd_items</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_LONG) */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"ZADD"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>*</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>==</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>items</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write either the key or the value of the currently selected item of a hash.
 * The 'hi' argument passes a valid Redis hash iterator.
 * The 'what' filed specifies if to write a key or a value and can be
 * either OBJ_HASH_KEY or OBJ_HASH_VALUE.
 *
 * The function returns 0 on error, non-zero on success. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rioWriteHashIteratorCursor</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>hashTypeIterator</name> <modifier>*</modifier></type><name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name> <init>= <expr><name>UINT_MAX</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vll</name> <init>= <expr><name>LLONG_MAX</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>hashTypeCurrentFromZiplist</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>       <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (int) */</comment>
        <if_stmt><else>else<block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>vll</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>                   <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hi</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>value</name> <init>= <expr><call><name>hashTypeCurrentFromHashTable</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>        <expr_stmt><expr><name>WIN_PORT_FIX</name></expr></expr_stmt> <comment type="block">/* cast (int) */</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown hash encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit the commands needed to rebuild a hash object.
 * The function returns 0 on error, 1 on success. */</comment>
<function><type><name>int</name></type> <name>rewriteHashObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>hashTypeIterator</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>items</name> <init>= <expr><call><name>hashTypeLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hashTypeInitIterator</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>hashTypeNext</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>cmd_items</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>items</name> <operator>&gt;</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name><operator>)</operator></expr> ?</condition><then> <expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (int) */</comment>
                <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr> </then><else>: <expr><name>items</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">2</literal><operator>+</operator><operator>(</operator><operator>(</operator><name>PORT_LONG</name><operator>)</operator><name>cmd_items</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <macro><name>WIN_PORT_FIX</name></macro> <comment type="block">/* cast (PORT_LONG) */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"HMSET"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>rioWriteHashIteratorCursor</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>OBJ_HASH_KEY</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteHashIteratorCursor</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>OBJ_HASH_VALUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>==</operator> <name>AOF_REWRITE_ITEMS_PER_CMD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>items</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>hashTypeReleaseIterator</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper for rewriteStreamObject() that generates a bulk string into the
 * AOF representing the ID 'id'. */</comment>
<function><type><name>int</name></type> <name>rioWriteBulkStreamID</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>,<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>sds</name></type> <name>replyid</name> <init>= <expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%U-%U"</literal></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>replyid</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>replyid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>replyid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper for rewriteStreamObject(): emit the XCLAIM needed in order to
 * add the message described by 'nack' having the id 'rawid', into the pending
 * list of the specified consumer. All this in the context of the specified
 * key and group. */</comment>
<function><type><name>int</name></type> <name>rioWriteStreamPendingEntry</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>groupname_len</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>rawid</name></decl></parameter>, <parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name></decl></parameter>)</parameter_list> <block>{<block_content>
     <comment type="block">/* XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; 0 &lt;id&gt; TIME &lt;milliseconds-unix-time&gt;
               RETRYCOUNT &lt;count&gt; JUSTID FORCE. */</comment>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name>rawid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"XCLAIM"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>groupname</name></expr></argument>,<argument><expr><name>groupname_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"0"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkStreamID</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"TIME"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"RETRYCOUNT"</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"JUSTID"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"FORCE"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit the commands needed to rebuild a stream object.
 * The function returns 0 on error, 1 on success. */</comment>
<function><type><name>int</name></type> <name>rewriteStreamObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Reconstruct the stream data using XADD commands. */</comment>
        <while>while<condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Emit a two elements array for each item. The first is
             * the ID, the second is an array of field-value pairs. */</comment>

            <comment type="block">/* Emit the XADD &lt;key&gt; &lt;id&gt; ...fields... command. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">3</literal><operator>+</operator><name>numfields</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"XADD"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkStreamID</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <while>while<condition>(<expr><name>numfields</name><operator>--</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>field</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>field_len</name></decl>, <decl><type ref="prev"/><name>value_len</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>streamIteratorGetField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>field</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>field_len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>field</name></expr></argument>,<argument><expr><name>field_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>value</name></expr></argument>,<argument><expr><name>value_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Use the XADD MAXLEN 0 trick to generate an empty stream if
         * the key we are serializing is an empty string, which is possible
         * for the Stream type. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"XADD"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"MAXLEN"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"0"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkStreamID</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"x"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"y"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Append XSETID after XADD, make sure lastid is correct,
     * in case of XDEL lastid. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"XSETID"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkStreamID</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


    <comment type="block">/* Create all the stream consumer groups. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Emit the XGROUP CREATE in order to create the group. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkCount</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="char">'*'</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"XGROUP"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><literal type="string">"CREATE"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkString</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkStreamID</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* Generate XCLAIMs for each consumer that happens to
             * have pending entries. Empty consumers have no semantical
             * value so they are discarded. */</comment>
            <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cons</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cons</name></expr></argument>,<argument><expr><name><name>group</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cons</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cons</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri_cons</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
                <comment type="block">/* For the current consumer, iterate all the PEL entries
                 * to emit the XCLAIM protocol. */</comment>
                <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_pel</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_pel</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_pel</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_pel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri_pel</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>rioWriteStreamPendingEntry</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,
                                                   <argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>consumer</name></expr></argument>,
                                                   <argument><expr><name><name>ri_pel</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name>nack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_pel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call the module type callback in order to rewrite a data type
 * that is exported by a module and is not handled by Redis itself.
 * The function returns 0 on error, 1 on success. */</comment>
<function><type><name>int</name></type> <name>rewriteModuleObject</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RedisModuleIO</name></type> <name>io</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>moduleValue</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>moduleType</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><name><name>mv</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>moduleInitIOContext</name><argument_list>(<argument><expr><name>io</name></expr></argument>,<argument><expr><name>mt</name></expr></argument>,<argument><expr><name>r</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mt</name><operator>-&gt;</operator><name>aof_rewrite</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>io</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>mv</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>io</name><operator>.</operator><name>ctx</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>moduleFreeContext</name><argument_list>(<argument><expr><name><name>io</name><operator>.</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>io</name><operator>.</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name><name>io</name><operator>.</operator><name>error</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is called by the child rewriting the AOF file to read
 * the difference accumulated from the parent into a buffer, that is
 * concatenated at the end of the rewrite. */</comment>
<function><type><name>ssize_t</name></type> <name>aofReadDiffFromParent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">65536</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Default pipe buffer size on most Linux systems. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>buf</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><literal type="number">65536</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">//allocate dynamically and get rid of C6262 warning</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>, <decl><type ref="prev"/><name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>nread</name> <operator>=</operator>
            <call><name>read</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_data_from_parent</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><literal type="number">65536</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_child_diff</name></name> <operator>=</operator> <call><name>sdscatlen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_child_diff</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>total</name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>total</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rewriteAppendOnlyFileRio</name><parameter_list>(<parameter><decl><type><name>rio</name> <modifier>*</modifier></type><name>aof</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>selectcmd</name><index>[]</index></name> <init>= <expr><literal type="string">"*2\r\n$6\r\nSELECT\r\n"</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>j</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetSafeIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* SELECT the new DB */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>rioWrite</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><name>selectcmd</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>selectcmd</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Iterate this DB writing every entry */</comment>
        <while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>keystr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>robj</name></type> <name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>expiretime</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>keystr</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>initStaticStringObject</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>keystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>expiretime</name> <operator>=</operator> <call><name>getExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Save the key and associated value */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STRING</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Emit a SET command */</comment>
                <decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[]</index></name><init>=<expr><literal type="string">"*3\r\n$3\r\nSET\r\n"</literal></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWrite</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><name>cmd</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
                <comment type="block">/* Key and value */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_LIST</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rewriteListObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rewriteSetObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rewriteSortedSetObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_HASH</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rewriteHashObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STREAM</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rewriteStreamObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_MODULE</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rewriteModuleObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown object type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* Save the expire time */</comment>
            <if_stmt><if>if <condition>(<expr><name>expiretime</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[]</index></name><init>=<expr><literal type="string">"*3\r\n$9\r\nPEXPIREAT\r\n"</literal></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWrite</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><name>cmd</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkObject</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>rioWriteBulkLongLong</name><argument_list>(<argument><expr><name>aof</name></expr></argument>,<argument><expr><name>expiretime</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Read some diff from the parent process from time to time. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>aof</name><operator>-&gt;</operator><name>processed_bytes</name></name> <operator>&gt;</operator> <name>processed</name><operator>+</operator><name>AOF_READ_DIFF_INTERVAL_BYTES</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>processed</name> <operator>=</operator> <name><name>aof</name><operator>-&gt;</operator><name>processed_bytes</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>aofReadDiffFromParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>di</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>werr</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>di</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write a sequence of commands able to fully rebuild the dataset into
 * "filename". Used both by REWRITEAOF and BGREWRITEAOF.
 *
 * In order to minimize the number of commands needed in the rewritten
 * log Redis uses variadic commands when possible, such as RPUSH, SADD
 * and ZADD. However at max AOF_REWRITE_ITEMS_PER_CMD items per time
 * are inserted using a single command. */</comment>
<function><type><name>int</name></type> <name>rewriteAppendOnlyFile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>rio</name></type> <name>aof</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmpfile</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>byte</name></decl>;</decl_stmt>

    <comment type="block">/* Note that we have to use a different temp name here compared to the
     * one used by rewriteAppendOnlyFileBackground() function. */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,<argument><expr><literal type="string">"temp-rewriteaof-%d.aof"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><literal type="string">"wb"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_child_diff</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rioInitWithFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aof</name></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_rewrite_incremental_fsync</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>rioSetAutoSync</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aof</name></expr></argument>,<argument><expr><name>REDIS_AUTOSYNC_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_use_rdb_preamble</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rdbSaveRio</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aof</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>error</name></expr></argument>,<argument><expr><name>RDB_SAVE_AOF_PREAMBLE</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
            <goto>goto <name>werr</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>rewriteAppendOnlyFileRio</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aof</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Do an initial slow fsync here while the parent is still sending
     * data, in order to make the next final fsync faster. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Read again a few times to get more data from the parent.
     * We can't read forever (the server may receive data from clients
     * faster than it is able to send data to the child), so we try to read
     * some more data in a loop as soon as there is a good chance more data
     * will come. If it looks like we are wasting time, we abort (this
     * happens after 20 ms without new data). */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nodata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><call><name>mstime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name> <operator>&lt;</operator> <literal type="number">1000</literal> <operator>&amp;&amp;</operator> <name>nodata</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>aeWait</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_data_from_parent</name></name></expr></argument>, <argument><expr><name>AE_READABLE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nodata</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nodata</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Start counting from zero, we stop on N *contiguous*
                       timeouts. */</comment>
        <expr_stmt><expr><call><name>aofReadDiffFromParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Ask the master to stop sending diffs. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_parent</name></name></expr></argument>,<argument><expr><literal type="string">"!"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_parent</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ANET_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* We read the ACK from the server using a 10 seconds timeout. Normally
     * it should reply ASAP, but just in case we lose its reply, we are sure
     * the child will eventually get terminated. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>syncRead</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_parent</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>byte</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
        <name>byte</name> <operator>!=</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"Parent agreed to stop sending diffs. Finalizing AOF..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read the final diff if any. */</comment>
    <expr_stmt><expr><call><name>aofReadDiffFromParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write the received diff to the file. */</comment>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
        <argument><expr><literal type="string">"Concatenating %.2f MB of AOF diff received from parent."</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_child_diff</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <macro><name>WIN_PORT_FIX</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>rioWrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aof</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_child_diff</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_child_diff</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Make sure data will not remain on the OS's output buffers */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>werr</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Use RENAME to make sure the DB file is changed atomically only
     * if the generate DB file is ok. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error moving temp append only file on the final destination: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"SYNC append only file rewrite performed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>werr</name>:</label>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Write error writing append only file on disk: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * AOF rewrite pipes for IPC
 * -------------------------------------------------------------------------- */</comment>

<comment type="block">/* This event handler is called when the AOF rewriting child sends us a
 * single '!' char to signal we should stop sending buffer diffs. The
 * parent sends a '!' as well to acknowledge. */</comment>
<function><type><name>void</name></type> <name>aofChildPipeReadable</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>privdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>byte</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>privdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>byte</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>byte</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,<argument><expr><literal type="string">"AOF rewrite child asks to stop sending diffs."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_stop_sending_diff</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_child</name></name></expr></argument>,<argument><expr><literal type="string">"!"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If we can't send the ack, inform the user, but don't try again
             * since in the other side the children will use a timeout if the
             * kernel can't buffer our write, or, the children was
             * terminated. */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Can't send ACK to AOF child: %s"</literal></expr></argument>,
                <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <comment type="block">/* Remove the handler since this can be called only one time during a
     * rewrite. */</comment>
    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_child</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Create the pipes used for parent - child process IPC during rewrite.
 * We have a data pipe used to send AOF incremental diffs to the child,
 * and two other pipes used by the children to signal it finished with
 * the rewrite so no more data should be written, and another for the
 * parent to acknowledge it understood this new condition. */</comment>
<function><type><name>int</name></type> <name>aofCreatePipes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name><name>fds</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* parent -&gt; children data. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fds</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* children -&gt; parent ack. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fds</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* parent -&gt; children ack. */</comment>
    <comment type="block">/* Parent -&gt; children data is non blocking. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ANET_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>anetNonBlock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ANET_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>aeCreateFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>, <argument><expr><name><name>fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>AE_READABLE</name></expr></argument>, <argument><expr><name>aofChildPipeReadable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AE_ERR</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>FDAPI_PipeSetNonBlock</name><argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FDAPI_PipeSetNonBlock</name><argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FDAPI_PipeSetNonBlock</name><argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name> <operator>=</operator> <name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_data_from_parent</name></name> <operator>=</operator> <name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_parent</name></name> <operator>=</operator> <name><name>fds</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_child</name></name> <operator>=</operator> <name><name>fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_child</name></name> <operator>=</operator> <name><name>fds</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_parent</name></name> <operator>=</operator> <name><name>fds</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_stop_sending_diff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Error opening /setting AOF rewrite IPC pipes: %s"</literal></expr></argument>,
        <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>(<expr><name><name>fds</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fds</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>aofClosePipes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_child</name></name></expr></argument>,<argument><expr><name>AE_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aeDeleteFileEvent</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>el</name></name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>,<argument><expr><name>AE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_data_from_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * AOF background rewrite
 * ------------------------------------------------------------------------- */</comment>

<comment type="block">/* This is how rewriting of the append only file in background works:
 *
 * 1) The user calls BGREWRITEAOF
 * 2) Redis calls this function, that forks():
 *    2a) the child rewrite the append only file in a temp file.
 *    2b) the parent accumulates differences in server.aof_rewrite_buf.
 * 3) When the child finished '2a' exists.
 * 4) The parent will trap the exit code, if it's OK, will append the
 *    data accumulated into server.aof_rewrite_buf into the temp file, and
 *    finally will rename(2) the temp file in the actual file name.
 *    The the new file is reopened as the new append only file. Profit!
 */</comment>
<function><type><name>int</name></type> <name>rewriteAppendOnlyFileBackground</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>childpid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>start</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>aofCreatePipes</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>openChildInfoPipe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>childpid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>char</name></type> <name><name>tmpfile</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
        <comment type="block">/* Child */</comment>
        <expr_stmt><expr><call><name>closeListeningSockets</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>redisSetProcTitle</name><argument_list>(<argument><expr><literal type="string">"redis-aof-rewrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,<argument><expr><literal type="string">"temp-rewriteaof-bg-%d.aof"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <expr_stmt><expr><name>childpid</name> <operator>=</operator> <call><name>BeginForkOperation_Aof</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_ack_to_parent</name></name></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_parent</name></name></expr></argument>,
            <argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_data_from_parent</name></name></expr></argument>,
            <argument><expr><name>tmpfile</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>server</name></expr></argument>,
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <argument><expr><call><name>dictGetHashFunctionSeed</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><call><name>rewriteAppendOnlyFile</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>private_dirty</name> <init>= <expr><call><name>zmalloc_get_private_dirty</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>private_dirty</name></expr>)</condition> <block>{<block_content>
                <macro><name>serverLog</name><argument_list>(<argument>LL_NOTICE</argument>,
                    <argument><literal type="string">"AOF rewrite: %Iu MB of memory used by copy-on-write"</literal></argument>, <argument>WIN_PORT_FIX <comment type="block">/* %zu -&gt; %Iu */</comment>
                    private_dirty/(<literal type="number">1024</literal>*<literal type="number">1024</literal>)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>child_info_data</name><operator>.</operator><name>cow_size</name></name> <operator>=</operator> <name>private_dirty</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sendChildInfo</name><argument_list>(<argument><expr><name>CHILD_INFO_TYPE_AOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exitFromChild</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>exitFromChild</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Parent */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_fork_time</name></name> <operator>=</operator> <call><name>ustime</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr>;</expr_stmt>
<comment type="line">//[tporadowski/redis] issue #46: ustime() -&gt; gettimeofday_highres() uses GetSystemTimePreciseAsFileTime when available (Windows 8, Windows Server 2012) or</comment>
<comment type="line">//                    falls back to GetSystemTimeAsFileTime which does not have such high resolution, so "stat_fork_time" may be 0 here</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>stat_fork_time</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_fork_time</name></name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt> <comment type="line">//let's pretend it took 100ms (100000 microseconds)</comment>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_fork_rate</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">1000000</literal> <operator>/</operator> <name><name>server</name><operator>.</operator><name>stat_fork_time</name></name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* GB per second. */</comment>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type>
        <name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"fork"</literal></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>stat_fork_time</name></name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>childpid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>closeChildInfoPipe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Can't rewrite append only file in background: fork: %s"</literal></expr></argument>,
                <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>aofClosePipes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Background append only file rewriting started by pid %d"</literal></expr></argument>,<argument><expr><name>childpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_scheduled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_time_start</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>=</operator> <name>childpid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateDictResizePolicy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We set appendseldb to -1 in order to force the next call to the
         * feedAppendOnlyFile() to issue a SELECT command, so the differences
         * accumulated by the parent into server.aof_rewrite_buf will start
         * with a SELECT statement and it will be safe to merge. */</comment>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_selected_db</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>replicationScriptCacheFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>C_OK</name></expr>;</return> <comment type="block">/* unreached */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bgrewriteaofCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Background append only file rewriting already in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>rdb_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_scheduled</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyStatus</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Background append only file rewriting scheduled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>rewriteAppendOnlyFileBackground</name><argument_list>()</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyStatus</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Background append only file rewriting started"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>aofRemoveTempFile</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>childpid</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmpfile</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,<argument><expr><literal type="string">"temp-rewriteaof-bg-%d.aof"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>childpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>WIN32_ONLY</name><argument_list>(<argument>tmpfile[sizeof(tmpfile) - <literal type="number">1</literal>] = <literal type="number">0</literal>;</argument>)</argument_list></macro> <comment type="block">/*get rid of C6053 warning*/</comment>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Update the server.aof_current_size field explicitly using stat(2)
 * to check the size of the file. This is useful after a rewrite or after
 * a restart, normally the size is updated just adding the write length
 * to the current length, that is much faster. */</comment>
<function><type><name>void</name></type> <name>aofUpdateCurrentSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>redis_stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>latency</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Unable to check the AOF length: %s"</literal></expr></argument>, <argument><expr><literal type="string">"appendfd is -1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>redis_fstat</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"Unable to obtain the AOF file length. stat: %s"</literal></expr></argument>,
            <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_current_size</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-fstat"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* A background append only file rewriting (BGREWRITEAOF) terminated its work.
 * Handle this. */</comment>
<function><type><name>void</name></type> <name>backgroundRewriteDoneHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exitcode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bysignal</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bysignal</name> <operator>&amp;&amp;</operator> <name>exitcode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>newfd</name></decl>, <decl><type ref="prev"/><name>oldfd</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>tmpfile</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>now</name> <init>= <expr><call><name>ustime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mstime_t</name></type> <name>latency</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Background AOF rewrite terminated with success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Flush the differences accumulated by the parent to the
         * rewritten AOF. */</comment>
        <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,<argument><expr><literal type="string">"temp-rewriteaof-bg-%d.aof"</literal></expr></argument>,
            <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_APPEND</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>_O_BINARY</name></expr></argument>,<argument><expr><name>_S_IREAD</name><operator>|</operator><name>_S_IWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>,<argument><expr><literal type="string">"temp-rewriteaof-bg-%d.aof"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Unable to open the temporary AOF produced by the child: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>aofRewriteBufferWrite</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Error trying to flush the parent diff to the rewritten AOF: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-rewrite-diff-write"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><call><name>aofRewriteBufferSize</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type>

        <comment type="block">/* The only remaining thing to do is to rename the temporary file to
         * the configured file and switch the file descriptor used to do AOF
         * writes. We don't want close(2) or rename(2) calls to block the
         * server on old file deletion.
         *
         * There are two possible scenarios:
         *
         * 1) AOF is DISABLED and this was a one time rewrite. The temporary
         * file will be renamed to the configured file. When this file already
         * exists, it will be unlinked, which may block the server.
         *
         * 2) AOF is ENABLED and the rewritten AOF will immediately start
         * receiving writes. After the temporary file is renamed to the
         * configured file, the original AOF file descriptor will be closed.
         * Since this will be the last reference to that file, closing it
         * causes the underlying file to be unlinked, which may block the
         * server.
         *
         * To mitigate the blocking effect of the unlink operation (either
         * caused by rename(2) in scenario 1, or by close(2) in scenario 2), we
         * use a background thread to take care of this. First, we
         * make scenario 1 identical to scenario 2 by opening the target file
         * when it exists. The unlink operation after the rename(2) will then
         * be executed upon calling close(2) for its descriptor. Everything to
         * guarantee atomicity for this switch has already happened by then, so
         * we don't care what the outcome or duration of that close operation
         * is, as long as the file descriptor is released again. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
         <comment type="line">// On Windows, if AOF is disabled and an AOF file already exists,</comment>
         <comment type="line">// we don't need to open it since it will have to be closed anyway</comment>
         <comment type="line">// before renaming the temp AOF.</comment>
        <name>oldfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* We'll set this to the current AOF filedes later. */</comment>

        <decl_stmt><decl><type><name>char</name></type> <name><name>tmpfile_win_old</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile_win_old</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><literal type="string">"temp-rewriteaof-old-%d.aof"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// AOF enabled, close the existing AOF file</comment>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Now rename the existing AOF file to allow the new file to be renamed</comment>
            <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>, <argument><expr><name>tmpfile_win_old</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                    <argument><expr><literal type="string">"Error trying to rename the existing AOF to old tempfile: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Let's clean the Windows-specific temp file here</comment>
                <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile_win_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Close the temp AOF file before renaming it</comment>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Error trying to rename the temporary AOF file %s into %s: %s"</literal></expr></argument>,
                <argument><expr><name>tmpfile</name></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>,
                <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmpfile_win_old</name></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                        <argument><expr><literal type="string">"Error trying to rename the old tempfile %s into the existing AOF file %s: %s"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>,
                        <argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>,
                        <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                        <argument><expr><literal type="string">"Error trying to rename the existing AOF from old tempfile: %s"</literal></expr></argument>, <argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>wsa_strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// The Windows-specific temp file couldn't be renamed to</comment>
                    <comment type="line">// the configured AOF file, that should never happen but</comment>
                    <comment type="line">// if it happens we leave the file behind in case the user</comment>
                    <comment type="line">// needs it</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* now open the files again with new names */</comment>
        <expr_stmt><expr><name>newfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>_O_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Windows fix: More info */</comment>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Not able to reopen the temporary AOF file after rename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(
                <argument><expr><name>tmpfile_win_old</name></expr></argument>,
                <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>_O_BINARY</name> <operator>|</operator> <name>_O_TEMPORARY</name></expr></argument>,     <comment type="line">// _O_TEMPORARY forces delete on close flag in CreateFile call. File will be deleted in BIO_CLOSE_FILE job.</comment>
                <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* AOF disabled */</comment>

            <comment type="block">/* Don't care if this fails: oldfd will be -1 and we handle that.
             * One notable case of -1 return is if the old file does
             * not exist. */</comment>
            <expr_stmt><expr><name>oldfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>,<argument><expr><name>O_RDONLY</name><operator>|</operator><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* AOF enabled */</comment>
            <expr_stmt><expr><name>oldfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* We'll set this to the current AOF filedes later. */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Rename the temporary file. This will not unlink the target file if
         * it exists, because we reference it with "oldfd". */</comment>
        <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
                <argument><expr><literal type="string">"Error trying to rename the temporary AOF file %s into %s: %s"</literal></expr></argument>,
                <argument><expr><name>tmpfile</name></expr></argument>,
                <argument><expr><name><name>server</name><operator>.</operator><name>aof_filename</name></name></expr></argument>,
                <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>oldfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"aof-rename"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* AOF disabled, we don't need to set the AOF file descriptor
             * to this new file, so we can close it. */</comment>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* AOF enabled, replace the old fd with the new one. */</comment>
            <expr_stmt><expr><name>oldfd</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_fd</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fd</name></name> <operator>=</operator> <name>newfd</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>redis_fsync</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_fsync</name></name> <operator>==</operator> <name>AOF_FSYNC_EVERYSEC</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>aof_background_fsync</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_selected_db</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Make sure SELECT is re-issued */</comment>
            <expr_stmt><expr><call><name>aofUpdateCurrentSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_base_size</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_fsync_offset</name></name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>aof_current_size</name></name></expr>;</expr_stmt>

            <comment type="block">/* Clear regular AOF buffer since its contents was just written to
             * the new AOF from the background rewrite buffer. */</comment>
            <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name> <operator>=</operator> <call><name>sdsempty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_lastbgrewrite_status</name></name> <operator>=</operator> <name>C_OK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Background AOF rewrite finished successfully"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Change state from WAIT_REWRITE to ON if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>==</operator> <name>AOF_WAIT_REWRITE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>=</operator> <name>AOF_ON</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Asynchronously close the overwritten AOF. */</comment>
        <if_stmt><if>if <condition>(<expr><name>oldfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bioCreateBackgroundJob</name><argument_list>(<argument><expr><name>BIO_CLOSE_FILE</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>long</name><operator>)</operator><name>oldfd</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_VERBOSE</name></expr></argument>,
            <argument><expr><literal type="string">"Background AOF rewrite signal handler took %lldus"</literal></expr></argument>, <argument><expr><call><name>ustime</name><argument_list>()</argument_list></call><operator>-</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>bysignal</name> <operator>&amp;&amp;</operator> <name>exitcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_lastbgrewrite_status</name></name> <operator>=</operator> <name>C_ERR</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Background AOF rewrite terminated with error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* SIGUSR1 is whitelisted, so we have a way to kill a child without
         * tirggering an error condition. */</comment>
        <if_stmt><if>if <condition>(<expr><name>bysignal</name> <operator>!=</operator> <name>SIGUSR1</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_lastbgrewrite_status</name></name> <operator>=</operator> <name>C_ERR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,
            <argument><expr><literal type="string">"Background AOF rewrite terminated by signal %d"</literal></expr></argument>, <argument><expr><name>bysignal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>aofClosePipes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aofRewriteBufferReset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>aofRemoveTempFile</name><argument_list>(<argument><expr><call><name>IF_WIN32</name><argument_list>(<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_time_last</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>-</operator><name><name>server</name><operator>.</operator><name>aof_rewrite_time_start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_time_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>==</operator> <name>AOF_WAIT_REWRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>aof_rewrite_scheduled</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function><type><name>void</name></type> <name>aofProcessDiffRewriteEvents</name><parameter_list>(<parameter><decl><type><name>aeEventLoop</name><modifier>*</modifier></type> <name>eventLoop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// only do these checks in the parent process and if an aof rewrite is in progress</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_child_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_child</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">//1) check if more data can be written to the child and write it.</comment>
        <comment type="line">// in which case we dont need to send any more diffs to the parent</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_stop_sending_diff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>aofChildWriteDiffData</name><argument_list>(<argument><expr><name>eventLoop</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_write_data_to_child</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//2) check if child has signaled parent to stop sending diffs</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_stop_sending_diff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>aofChildPipeReadable</name><argument_list>(<argument><expr><name>eventLoop</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>aof_pipe_read_ack_from_child</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif></unit>
