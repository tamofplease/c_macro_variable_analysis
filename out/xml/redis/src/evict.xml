<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/evict.c"><comment type="block">/* Maxmemory directive handling (LRU eviction and other policies).
 *
 * ----------------------------------------------------------------------------
 *
 * Copyright (c) 2009-2016, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"atomicvar.h"</cpp:file></cpp:include>

<comment type="block">/* ----------------------------------------------------------------------------
 * Data structures
 * --------------------------------------------------------------------------*/</comment>

<comment type="block">/* To improve the quality of the LRU approximation we take a set of keys
 * that are good candidate for eviction across freeMemoryIfNeeded() calls.
 *
 * Entries inside the eviciton pool are taken ordered by idle time, putting
 * greater idle times to the right (ascending order).
 *
 * When an LFU policy is used instead, a reverse frequency indication is used
 * instead of the idle time, so that we still evict by larger value (larger
 * inverse frequency means to evict keys with the least frequent accesses).
 *
 * Empty entries have the key pointer set to NULL. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVPOOL_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVPOOL_CACHED_SDS_SIZE</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<struct>struct <name>evictionPoolEntry</name> <block>{
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>idle</name></decl>;</decl_stmt>    <comment type="block">/* Object idle time (inverse frequency for LFU) */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>key</name></decl>;</decl_stmt>                    <comment type="block">/* Key name. */</comment>
    <decl_stmt><decl><type><name>sds</name></type> <name>cached</name></decl>;</decl_stmt>                 <comment type="block">/* Cached SDS object for key name. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dbid</name></decl>;</decl_stmt>                   <comment type="block">/* Key DB number. */</comment>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>evictionPoolEntry</name></name> <modifier>*</modifier></type><name>EvictionPoolLRU</name></decl>;</decl_stmt>

<comment type="block">/* ----------------------------------------------------------------------------
 * Implementation of eviction, aging and LRU
 * --------------------------------------------------------------------------*/</comment>

<comment type="block">/* Return the LRU clock, based on the clock resolution. This is a time
 * in a reduced-bits format that can be used to set and check the
 * object-&gt;lru field of redisObject structures. */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>getLRUClock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call><operator>/</operator><name>LRU_CLOCK_RESOLUTION</name><operator>)</operator> <operator>&amp;</operator> <name>LRU_CLOCK_MAX</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is used to obtain the current LRU clock.
 * If the current resolution is lower than the frequency we refresh the
 * LRU clock (as it should be in production servers) we return the
 * precomputed value, otherwise we need to resort to a system call. */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>LRU_CLOCK</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lruclock</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">1000</literal><operator>/</operator><name><name>server</name><operator>.</operator><name>hz</name></name> <operator>&lt;=</operator> <name>LRU_CLOCK_RESOLUTION</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>atomicGet</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>lruclock</name></name></expr></argument>,<argument><expr><name>lruclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>lruclock</name> <operator>=</operator> <call><name>getLRUClock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>lruclock</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Given an object returns the min number of milliseconds the object was never
 * requested, using an approximated LRU algorithm. */</comment>
<function><type><name>PORT_ULONGLONG</name></type> <name>estimateObjectIdleTime</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>lruclock</name> <init>= <expr><call><name>LRU_CLOCK</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lruclock</name> <operator>&gt;=</operator> <name><name>o</name><operator>-&gt;</operator><name>lru</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>(</operator><name>lruclock</name> <operator>-</operator> <name><name>o</name><operator>-&gt;</operator><name>lru</name></name><operator>)</operator> <operator>*</operator> <name>LRU_CLOCK_RESOLUTION</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><operator>(</operator><name>lruclock</name> <operator>+</operator> <operator>(</operator><name>LRU_CLOCK_MAX</name> <operator>-</operator> <name><name>o</name><operator>-&gt;</operator><name>lru</name></name><operator>)</operator><operator>)</operator> <operator>*</operator>
                    <name>LRU_CLOCK_RESOLUTION</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* freeMemoryIfNeeded() gets called when 'maxmemory' is set on the config
 * file to limit the max memory used by the server, before processing a
 * command.
 *
 * The goal of the function is to free enough memory to keep Redis under the
 * configured memory limit.
 *
 * The function starts calculating how many bytes should be freed to keep
 * Redis under the limit, and enters a loop selecting the best keys to
 * evict accordingly to the configured policy.
 *
 * If all the bytes needed to return back under the limit were freed the
 * function returns C_OK, otherwise C_ERR is returned, and the caller
 * should block the execution of commands that will result in more memory
 * used by the server.
 *
 * ------------------------------------------------------------------------
 *
 * LRU approximation algorithm
 *
 * Redis uses an approximation of the LRU algorithm that runs in constant
 * memory. Every time there is a key to expire, we sample N keys (with
 * N very small, usually in around 5) to populate a pool of best keys to
 * evict of M keys (the pool size is defined by EVPOOL_SIZE).
 *
 * The N keys sampled are added in the pool of good keys to expire (the one
 * with an old access time) if they are better than one of the current keys
 * in the pool.
 *
 * After the pool is populated, the best key we have in the pool is expired.
 * However note that we don't remove keys from the pool when they are deleted
 * so the pool may contain keys that no longer exist.
 *
 * When we try to evict a key, and all the entries in the pool don't exist
 * we populate it again. This time we'll be sure that the pool has at least
 * one key that can be evicted, if there is at least one key that can be
 * evicted in the whole database. */</comment>

<comment type="block">/* Create a new eviction pool. */</comment>
<function><type><name>void</name></type> <name>evictionPoolAlloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>evictionPoolEntry</name></name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ep</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>EVPOOL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>EVPOOL_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>ep</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>idle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ep</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ep</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cached</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>EVPOOL_CACHED_SDS_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ep</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dbid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>EvictionPoolLRU</name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is an helper function for freeMemoryIfNeeded(), it is used in order
 * to populate the evictionPool with a few entries every time we want to
 * expire a key. Keys with idle time smaller than one of the current
 * keys are added. Keys are always added if there are free entries.
 *
 * We insert keys on place in ascending order, so keys with the smaller
 * idle time are on the left, and keys with the higher idle time on the
 * right. */</comment>

<function><type><name>void</name></type> <name>evictionPoolPopulate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>sampledict</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>keydict</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evictionPoolEntry</name></name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name><name>samples</name><index>[<expr><name><name>server</name><operator>.</operator><name>maxmemory_samples</name></name></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>samples</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>samples</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dictEntry</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>server</name><operator>.</operator><name>maxmemory_samples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>dictGetSomeKeys</name><argument_list>(<argument><expr><name>sampledict</name></expr></argument>,<argument><expr><name>samples</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>maxmemory_samples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>idle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>de</name> <operator>=</operator> <name><name>samples</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>!=</operator> <name>MAXMEMORY_VOLATILE_TTL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>sampledict</name> <operator>!=</operator> <name>keydict</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name>keydict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Calculate the idle time according to the policy. This is called
         * idle just because the code initially handled LRU, but is in fact
         * just a score where an higher score means better candidate. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LRU</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>idle</name> <operator>=</operator> <call><name>estimateObjectIdleTime</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_LFU</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* When we use an LRU policy, we sort the keys by idle time
             * so that we expire keys starting from greater idle time.
             * However when the policy is an LFU one, we have a frequency
             * estimation, and we want to evict keys with lower frequency
             * first. So inside the pool we put objects using the inverted
             * frequency subtracting the actual frequency to the maximum
             * frequency of 255. */</comment>
            <expr_stmt><expr><name>idle</name> <operator>=</operator> <literal type="number">255</literal><operator>-</operator><call><name>LFUDecrAndReturn</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>==</operator> <name>MAXMEMORY_VOLATILE_TTL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* In this case the sooner the expire the better. */</comment>
            <expr_stmt><expr><name>idle</name> <operator>=</operator> <name>ULLONG_MAX</name> <operator>-</operator> <operator>(</operator><name>PORT_LONG</name><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown eviction policy in evictionPoolPopulate()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Insert the element inside the pool.
         * First, find the first empty bucket or the first populated
         * bucket that has an idle time smaller than our idle time. */</comment>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>k</name> <operator>&lt;</operator> <name>EVPOOL_SIZE</name> <operator>&amp;&amp;</operator>
               <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>&amp;&amp;</operator>
               <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>idle</name> <operator>&lt;</operator> <name>idle</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pool</name><index>[<expr><name>EVPOOL_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Can't insert if the element is &lt; the worst element we have
             * and there are no empty buckets. */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>k</name> <operator>&lt;</operator> <name>EVPOOL_SIZE</name> <operator>&amp;&amp;</operator> <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Inserting into empty position. No setup needed before insert. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Inserting in the middle. Now k points to the first element
             * greater than the element to insert.  */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pool</name><index>[<expr><name>EVPOOL_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Free space on the right? Insert at k shifting
                 * all the elements from k to end to the right. */</comment>

                <comment type="block">/* Save SDS before overwriting. */</comment>
                <decl_stmt><decl><type><name>sds</name></type> <name>cached</name> <init>= <expr><name><name>pool</name><index>[<expr><name>EVPOOL_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>cached</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pool</name><operator>+</operator><name>k</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>pool</name><operator>+</operator><name>k</name></expr></argument>,
                    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pool</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>EVPOOL_SIZE</name><operator>-</operator><name>k</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>WIN_PORT_FIX</name> <comment type="block">/* cast (size_t) */</comment>
                <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>cached</name> <operator>=</operator> <name>cached</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* No free space on right? Insert at k-1 */</comment>
                <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>
                <comment type="block">/* Shift all elements on the left of k (included) to the
                 * left, so we discard the element with smaller idle time. */</comment>
                <decl_stmt><decl><type><name>sds</name></type> <name>cached</name> <init>= <expr><name><name>pool</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cached</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Save SDS before overwriting. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pool</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>key</name> <operator>!=</operator> <name><name>pool</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cached</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>pool</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,<argument><expr><name>pool</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pool</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>cached</name> <operator>=</operator> <name>cached</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Try to reuse the cached SDS string allocated in the pool entry,
         * because allocating and deallocating this object is costly
         * (according to the profiler, not my fantasy. Remember:
         * premature optimizbla bla bla bla. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>klen</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>klen</name> <operator>&gt;</operator> <name>EVPOOL_CACHED_SDS_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>cached</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>klen</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <decl_stmt><decl><type><name>WIN_PORT_FIX</name></type> <comment type="block">/* cast (size_t) */</comment>
            <name>sdssetlen</name><argument_list>(<argument><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>cached</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>=</operator> <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>cached</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>idle</name> <operator>=</operator> <name>idle</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dbid</name> <operator>=</operator> <name>dbid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>samples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * LFU (Least Frequently Used) implementation.

 * We have 24 total bits of space in each object in order to implement
 * an LFU (Least Frequently Used) eviction policy, since we re-use the
 * LRU field for this purpose.
 *
 * We split the 24 bits into two fields:
 *
 *          16 bits      8 bits
 *     +----------------+--------+
 *     + Last decr time | LOG_C  |
 *     +----------------+--------+
 *
 * LOG_C is a logarithmic counter that provides an indication of the access
 * frequency. However this field must also be decremented otherwise what used
 * to be a frequently accessed key in the past, will remain ranked like that
 * forever, while we want the algorithm to adapt to access pattern changes.
 *
 * So the remaining 16 bits are used in order to store the "decrement time",
 * a reduced-precision Unix time (we take 16 bits of the time converted
 * in minutes since we don't care about wrapping around) where the LOG_C
 * counter is halved if it has an high value, or just decremented if it
 * has a low value.
 *
 * New keys don't start at zero, in order to have the ability to collect
 * some accesses before being trashed away, so they start at COUNTER_INIT_VAL.
 * The logarithmic increment performed on LOG_C takes care of COUNTER_INIT_VAL
 * when incrementing the key, so that keys starting at COUNTER_INIT_VAL
 * (or having a smaller value) have a very high chance of being incremented
 * on access.
 *
 * During decrement, the value of the logarithmic counter is halved if
 * its current value is greater than two times the COUNTER_INIT_VAL, otherwise
 * it is just decremented by one.
 * --------------------------------------------------------------------------*/</comment>

<comment type="block">/* Return the current time in minutes, just taking the least significant
 * 16 bits. The returned time is suitable to be stored as LDT (last decrement
 * time) for the LFU implementation. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>LFUGetTimeInMinutes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>server</name><operator>.</operator><name>unixtime</name></name><operator>/</operator><literal type="number">60</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">65535</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Given an object last access time, compute the minimum number of minutes
 * that elapsed since the last access. Handle overflow (ldt greater than
 * the current 16 bits minutes time) considering the time as wrapping
 * exactly once. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>LFUTimeElapsed</name><parameter_list>(<parameter><decl><type><name>PORT_ULONG</name></type> <name>ldt</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>now</name> <init>= <expr><call><name>LFUGetTimeInMinutes</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>ldt</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>now</name><operator>-</operator><name>ldt</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">65535</literal><operator>-</operator><name>ldt</name><operator>+</operator><name>now</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Logarithmically increment a counter. The greater is the current counter value
 * the less likely is that it gets really implemented. Saturate it at 255. */</comment>
<function><type><name>uint8_t</name></type> <name>LFULogIncr</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>counter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>counter</name> <operator>==</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">255</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>/</operator><name>RAND_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>baseval</name> <init>= <expr><name>counter</name> <operator>-</operator> <name>LFU_INIT_VAL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>baseval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>baseval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>p</name> <init>= <expr><literal type="number">1.0</literal><operator>/</operator><operator>(</operator><name>baseval</name><operator>*</operator><name><name>server</name><operator>.</operator><name>lfu_log_factor</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>counter</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>counter</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If the object decrement time is reached decrement the LFU counter but
 * do not update LFU fields of the object, we update the access time
 * and counter in an explicit way when the object is really accessed.
 * And we will times halve the counter according to the times of
 * elapsed time than server.lfu_decay_time.
 * Return the object frequency counter.
 *
 * This function is used in order to scan the dataset for the best object
 * to fit: as we check for the candidate, we incrementally decrement the
 * counter of the scanned objects if needed. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>LFUDecrAndReturn</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content> 				<decl_stmt><decl><type><name>WIN_PORT_FIX</name>
    <name>PORT_ULONG</name></type> <name>ldt</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>lru</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>					<decl_stmt><decl><type><name>WIN_PORT_FIX</name>
    <name>PORT_ULONG</name></type> <name>counter</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>lru</name></name> <operator>&amp;</operator> <literal type="number">255</literal></expr></init></decl>;</decl_stmt>				<decl_stmt><decl><type><name>WIN_PORT_FIX</name>
    <name>PORT_ULONG</name></type> <name>num_periods</name> <init>= <expr><ternary><condition><expr><name><name>server</name><operator>.</operator><name>lfu_decay_time</name></name></expr> ?</condition><then> <expr><call><name>LFUTimeElapsed</name><argument_list>(<argument><expr><name>ldt</name></expr></argument>)</argument_list></call> <operator>/</operator> <name><name>server</name><operator>.</operator><name>lfu_decay_time</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>	<macro><name>WIN_PORT_FIX</name></macro>
    <if_stmt><if>if <condition>(<expr><name>num_periods</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>counter</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>num_periods</name> <operator>&gt;</operator> <name>counter</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>counter</name> <operator>-</operator> <name>num_periods</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>counter</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 * The external API for eviction: freeMemroyIfNeeded() is called by the
 * server when there is data to add in order to make space if needed.
 * --------------------------------------------------------------------------*/</comment>

<comment type="block">/* We don't want to count AOF buffers and slaves output buffers as
 * used memory: the eviction should use mostly data size. This function
 * returns the sum of AOF and slaves buffer. */</comment>
<function><type><name>size_t</name></type> <name>freeMemoryGetNotCountedMemory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>overhead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slaves</name> <init>= <expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>slaves</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>listIter</name></type> <name>li</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>listRewind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>listNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>slave</name> <init>= <expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>overhead</name> <operator>+=</operator> <call><name>getClientOutputBufferMemoryUsage</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>aof_state</name></name> <operator>!=</operator> <name>AOF_OFF</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>overhead</name> <operator>+=</operator> <call><name>sdsalloc</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>aof_buf</name></name></expr></argument>)</argument_list></call><operator>+</operator><call><name>aofRewriteBufferSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>overhead</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the memory status from the point of view of the maxmemory directive:
 * if the memory used is under the maxmemory setting then C_OK is returned.
 * Otherwise, if we are over the memory limit, the function returns
 * C_ERR.
 *
 * The function may return additional info via reference, only if the
 * pointers to the respective arguments is not NULL. Certain fields are
 * populated only when C_ERR is returned:
 *
 *  'total'     total amount of bytes used.
 *              (Populated both for C_ERR and C_OK)
 *
 *  'logical'   the amount of memory used minus the slaves/AOF buffers.
 *              (Populated when C_ERR is returned)
 *
 *  'tofree'    the amount of memory that should be released
 *              in order to return back into the memory limits.
 *              (Populated when C_ERR is returned)
 *
 *  'level'     this usually ranges from 0 to 1, and reports the amount of
 *              memory currently used. May be &gt; 1 if we are over the memory
 *              limit.
 *              (Populated both for C_ERR and C_OK)
 */</comment>
<function><type><name>int</name></type> <name>getMaxmemoryState</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>total</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>logical</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>tofree</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mem_reported</name></decl>, <decl><type ref="prev"/><name>mem_used</name></decl>, <decl><type ref="prev"/><name>mem_tofree</name></decl>;</decl_stmt>

    <comment type="block">/* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */</comment>
    <expr_stmt><expr><name>mem_reported</name> <operator>=</operator> <call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>total</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>total</name> <operator>=</operator> <name>mem_reported</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We may return ASAP if there is no need to compute the level. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>return_ok_asap</name> <init>= <expr><operator>!</operator><name><name>server</name><operator>.</operator><name>maxmemory</name></name> <operator>||</operator> <name>mem_reported</name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>maxmemory</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>return_ok_asap</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>level</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */</comment>
    <expr_stmt><expr><name>mem_used</name> <operator>=</operator> <name>mem_reported</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>overhead</name> <init>= <expr><call><name>freeMemoryGetNotCountedMemory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mem_used</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mem_used</name> <operator>&gt;</operator> <name>overhead</name><operator>)</operator></expr> ?</condition><then> <expr><name>mem_used</name><operator>-</operator><name>overhead</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* Compute the ratio of memory usage. */</comment>
    <if_stmt><if>if <condition>(<expr><name>level</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>server</name><operator>.</operator><name>maxmemory</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>level</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>mem_used</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>server</name><operator>.</operator><name>maxmemory</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>return_ok_asap</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Check if we are still over the memory limit. */</comment>
    <if_stmt><if>if <condition>(<expr><name>mem_used</name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>maxmemory</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Compute how much memory we need to free. */</comment>
    <expr_stmt><expr><name>mem_tofree</name> <operator>=</operator> <name>mem_used</name> <operator>-</operator> <name><name>server</name><operator>.</operator><name>maxmemory</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>logical</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>logical</name> <operator>=</operator> <name>mem_used</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>tofree</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>tofree</name> <operator>=</operator> <name>mem_tofree</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is periodically called to see if there is memory to free
 * according to the current "maxmemory" settings. In case we are over the
 * memory limit, the function will try to free some memory to return back
 * under the limit.
 *
 * The function returns C_OK if we are under the memory limit or if we
 * were over the limit, but the attempt to free memory was successful.
 * Otehrwise if we are over the memory limit, but not enough memory
 * was freed to return back under the limit, the function returns C_ERR. */</comment>
<function><type><name>int</name></type> <name>freeMemoryIfNeeded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* By default replicas should ignore maxmemory
     * and just be masters exact copies. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>masterhost</name></name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>repl_slave_ignore_maxmemory</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>mem_reported</name></decl>, <decl><type ref="prev"/><name>mem_tofree</name></decl>, <decl><type ref="prev"/><name>mem_freed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>latency</name></decl>, <decl><type ref="prev"/><name>eviction_latency</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>delta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slaves</name> <init>= <expr><call><name>listLength</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>slaves</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* When clients are paused the dataset should be static not just from the
     * POV of clients not being able to write, but also from the POV of
     * expires and evictions of keys not being performed. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>clientsArePaused</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getMaxmemoryState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem_reported</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>mem_tofree</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>mem_freed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>==</operator> <name>MAXMEMORY_NO_EVICTION</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>cant_free</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* We need to free memory, but policy forbids. */</comment>

    <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>mem_freed</name> <operator>&lt;</operator> <name>mem_tofree</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>keys_freed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>next_db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sds</name></type> <name>bestkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bestdbid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>redisDb</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <operator>(</operator><name>MAXMEMORY_FLAG_LRU</name><operator>|</operator><name>MAXMEMORY_FLAG_LFU</name><operator>)</operator> <operator>||</operator>
            <name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>==</operator> <name>MAXMEMORY_VOLATILE_TTL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>evictionPoolEntry</name></name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><name>EvictionPoolLRU</name></expr></init></decl>;</decl_stmt>

            <while>while<condition>(<expr><name>bestkey</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>PORT_ULONG</name></type> <name>total_keys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>keys</name></decl>;</decl_stmt>

                <comment type="block">/* We don't want to make local-db choices when expiring keys,
                 * so to start populate the eviction pool sampling keys from
                 * every DB. */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dict</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_ALLKEYS</name><operator>)</operator></expr> ?</condition><then>
                            <expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr> </then><else>: <expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></else></ternary></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>keys</name> <operator>=</operator> <call><name>dictSize</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>evictionPoolPopulate</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>total_keys</name> <operator>+=</operator> <name>keys</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>total_keys</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* No keys to evict. */</comment>

                <comment type="block">/* Go backward from best to worst element to evict. */</comment>
                <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>EVPOOL_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>bestdbid</name> <operator>=</operator> <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dbid</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>&amp;</operator> <name>MAXMEMORY_FLAG_ALLKEYS</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dbid</name></expr>]</index></name><operator>.</operator><name>dict</name></expr></argument>,
                            <argument><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>db</name><index>[<expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dbid</name></expr>]</index></name><operator>.</operator><name>expires</name></expr></argument>,
                            <argument><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="block">/* Remove the entry from the pool. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>!=</operator> <name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>cached</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pool</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>idle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                    <comment type="block">/* If the key exists, is our pick. Otherwise it is
                     * a ghost and we need to try the next element. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>de</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>bestkey</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="block">/* Ghost... Iterate again. */</comment>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></while>
        </block_content>}</block></if>

        <comment type="block">/* volatile-random and allkeys-random policy */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>==</operator> <name>MAXMEMORY_ALLKEYS_RANDOM</name> <operator>||</operator>
                 <name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>==</operator> <name>MAXMEMORY_VOLATILE_RANDOM</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* When evicting a random key, we try to evict a key for
             * each DB, so we use the static 'next_db' variable to
             * incrementally visit all DBs. */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>next_db</name><operator>)</operator> <operator>%</operator> <name><name>server</name><operator>.</operator><name>dbnum</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>j</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>dict</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>server</name><operator>.</operator><name>maxmemory_policy</name></name> <operator>==</operator> <name>MAXMEMORY_ALLKEYS_RANDOM</name><operator>)</operator></expr> ?</condition><then>
                        <expr><name><name>db</name><operator>-&gt;</operator><name>dict</name></name></expr> </then><else>: <expr><name><name>db</name><operator>-&gt;</operator><name>expires</name></name></expr></else></ternary></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictGetRandomKey</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bestkey</name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bestdbid</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Finally remove the selected key. */</comment>
        <if_stmt><if>if <condition>(<expr><name>bestkey</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>db</name></name><operator>+</operator><name>bestdbid</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>keyobj</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>bestkey</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>bestkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>propagateExpire</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>,<argument><expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_eviction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* We compute the amount of memory freed by db*Delete() alone.
             * It is possible that actually the memory needed to propagate
             * the DEL in AOF and replication link is greater than the one
             * we are freeing removing the key, but we can't account for
             * that otherwise we would never exit the loop.
             *
             * AOF and Output buffer memory will be freed eventually so
             * we only care about memory used by the key space. */</comment>
            <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>latencyStartMonitor</name><argument_list>(<argument><expr><name>eviction_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_eviction</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>dbAsyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>dbSyncDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>eviction_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"eviction-del"</literal></expr></argument>,<argument><expr><name>eviction_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>latencyRemoveNestedEvent</name><argument_list>(<argument><expr><name>latency</name></expr></argument>,<argument><expr><name>eviction_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>delta</name> <operator>-=</operator> <operator>(</operator><name>PORT_LONGLONG</name><operator>)</operator> <call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mem_freed</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>stat_evictedkeys</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_EVICTED</name></expr></argument>, <argument><expr><literal type="string">"evicted"</literal></expr></argument>,
                <argument><expr><name>keyobj</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>keyobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>keys_freed</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* When the memory to free starts to be big enough, we may
             * start spending so much time here that is impossible to
             * deliver data to the slaves fast enough, so we force the
             * transmission here inside the loop. */</comment>
            <if_stmt><if>if <condition>(<expr><name>slaves</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>flushSlavesOutputBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Normally our stop condition is the ability to release
             * a fixed, pre-computed amount of memory. However when we
             * are deleting objects in another thread, it's better to
             * check, from time to time, if we already reached our target
             * memory, since the "mem_freed" amount is computed only
             * across the dbAsyncDelete() call, while the thread can
             * release the memory all the time. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lazyfree_lazy_eviction</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>keys_freed</name> <operator>%</operator> <literal type="number">16</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>getMaxmemoryState</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
                    <comment type="block">/* Let's satisfy our stop condition. */</comment>
                    <expr_stmt><expr><name>mem_freed</name> <operator>=</operator> <name>mem_tofree</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>keys_freed</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"eviction-cycle"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cant_free</name>;</goto> <comment type="block">/* nothing to free... */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>latencyEndMonitor</name><argument_list>(<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>latencyAddSampleIfNeeded</name><argument_list>(<argument><expr><literal type="string">"eviction-cycle"</literal></expr></argument>,<argument><expr><name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>cant_free</name>:</label>
    <comment type="block">/* We are here if we are not able to reclaim memory. There is only one
     * last thing we can try: check if the lazyfree thread has jobs in queue
     * and wait... */</comment>
    <while>while<condition>(<expr><call><name>bioPendingJobsOfType</name><argument_list>(<argument><expr><name>BIO_LAZY_FREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>mem_reported</name> <operator>-</operator> <call><name>zmalloc_used_memory</name><argument_list>()</argument_list></call><operator>)</operator> <operator>+</operator> <name>mem_freed</name><operator>)</operator> <operator>&gt;=</operator> <name>mem_tofree</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is a wrapper for freeMemoryIfNeeded() that only really calls the
 * function if right now there are the conditions to do so safely:
 *
 * - There must be no script in timeout condition.
 * - Nor we are loading data right now.
 *
 */</comment>
<function><type><name>int</name></type> <name>freeMemoryIfNeededAndSafe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>lua_timedout</name></name> <operator>||</operator> <name><name>server</name><operator>.</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>freeMemoryIfNeeded</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
