<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/extent.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_EXTENT_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_dss.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_mmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/rtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex_pool.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<decl_stmt><decl><type><name>rtree_t</name></type>		<name>extents_rtree</name></decl>;</decl_stmt>
<comment type="block">/* Keyed by the address of the extent_t being protected. */</comment>
<decl_stmt><decl><type><name>mutex_pool_t</name></type>	<name>extent_mutex_pool</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>opt_lg_extent_max_active_fit</name> <init>= <expr><name>LG_EXTENT_MAX_ACTIVE_FIT_DEFAULT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bitmap_info_t</name></type> <name>extents_bitmap_info</name> <init>=
    <expr><call><name>BITMAP_INFO_INITIALIZER</name><argument_list>(<argument><expr><name>SC_NPSIZES</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>extent_alloc_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_dalloc_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>extent_destroy_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_commit_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_commit_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_decommit_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PAGES_CAN_PURGE_LAZY</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_purge_lazy_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_purge_lazy_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PAGES_CAN_PURGE_FORCED</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_purge_forced_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_purge_forced_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_split_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent_split_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind_a</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab_a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab_b</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_merge_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr_a</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr_b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>extent_merge_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>extent_hooks_t</name></type>	<name>extent_hooks_default</name> <init>= <expr><block>{
	<expr><name>extent_alloc_default</name></expr>,
	<expr><name>extent_dalloc_default</name></expr>,
	<expr><name>extent_destroy_default</name></expr>,
	<expr><name>extent_commit_default</name></expr>,
	<expr><name>extent_decommit_default</name></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PAGES_CAN_PURGE_LAZY</name></cpp:ifdef>
	,
	<expr><name>extent_purge_lazy_default</name></expr>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	,
	<expr><name>NULL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PAGES_CAN_PURGE_FORCED</name></cpp:ifdef>
	,
	<expr><name>extent_purge_forced_default</name></expr>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	,
	<expr><name>NULL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	,
	<expr><name>extent_split_default</name></expr>,
	<expr><name>extent_merge_default</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Used exclusively for gdump triggering. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_zu_t</name></type> <name>curpages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_zu_t</name></type> <name>highpages</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Function prototypes for static functions that are referenced prior to
 * definition.
 */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>extent_deregister</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent_recycle</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>,
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent_try_coalesce</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>coalesced</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>extent_record</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTR_NONE</name></cpp:macro></cpp:define> <comment type="block">/* does nothing */</comment>

<macro><name>ph_gen</name><argument_list>(<argument>ATTR_NONE</argument>, <argument>extent_avail_</argument>, <argument>extent_tree_t</argument>, <argument>extent_t</argument>, <argument>ph_link</argument>,
    <argument>extent_esnead_comp</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ATTR_NONE</name></cpp:undef>

<typedef>typedef <type><enum>enum <block>{
	<decl><name>lock_result_success</name></decl>,
	<decl><name>lock_result_failure</name></decl>,
	<decl><name>lock_result_no_extent</name></decl>
}</block></enum></type> <name>lock_result_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>lock_result_t</name></type>
<name>extent_rtree_leaf_elm_try_lock</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>elm</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inactive_only</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent1</name> <init>= <expr><call><name>rtree_leaf_elm_extent_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>,
	    <argument><expr><name>elm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Slab implies active extents and should be skipped. */</comment>
	<if_stmt><if>if <condition>(<expr><name>extent1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>inactive_only</name> <operator>&amp;&amp;</operator> <call><name>rtree_leaf_elm_slab_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>elm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>lock_result_no_extent</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's possible that the extent changed out from under us, and with it
	 * the leaf-&gt;extent mapping.  We have to recheck while holding the lock.
	 */</comment>
	<expr_stmt><expr><call><name>extent_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent2</name> <init>= <expr><call><name>rtree_leaf_elm_extent_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>elm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extent1</name> <operator>==</operator> <name>extent2</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>extent1</name></expr>;</expr_stmt>
		<return>return <expr><name>lock_result_success</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>lock_result_failure</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a pool-locked extent_t * if there's one associated with the given
 * address, and NULL otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_lock_from_addr</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>inactive_only</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>elm</name> <init>= <expr><call><name>rtree_leaf_elm_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>,
	    <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>elm</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>lock_result_t</name></type> <name>lock_result</name></decl>;</decl_stmt>
	<do>do <block>{<block_content>
		<expr_stmt><expr><name>lock_result</name> <operator>=</operator> <call><name>extent_rtree_leaf_elm_try_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>,
		    <argument><expr><name>inactive_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>lock_result</name> <operator>==</operator> <name>lock_result_failure</name></expr>)</condition>;</do>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_t</name> <modifier>*</modifier></type>
<name>extent_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_avail_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>base_alloc_extent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_avail_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail</name></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_fetch_sub_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_cnt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_dalloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_avail_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail</name></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_fetch_add_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_cnt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>extent_hooks_t</name> <modifier>*</modifier></type>
<name>extent_hooks_get</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>base_extent_hooks_get</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_hooks_t</name> <modifier>*</modifier></type>
<name>extent_hooks_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>arena_background_thread_info_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>base_extent_hooks_set</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>extent_hooks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_hooks_assure_initialized</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>==</operator> <name>EXTENT_HOOKS_INITIALIZER</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>r_extent_hooks</name> <operator>=</operator> <call><name>extent_hooks_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifndef>
<function><type><specifier>static</specifier>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>size_t</name></type>
<name>extent_size_quantize_floor</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pszind_t</name></type> <name>pind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pind</name> <operator>=</operator> <call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <name>sz_large_pad</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Avoid underflow.  This short-circuit would also do the right
		 * thing for all sizes in the range for which there are
		 * PAGE-spaced size classes, but it's simplest to just handle
		 * the one case that would cause erroneous results.
		 */</comment>
		<return>return <expr><name>size</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sz_pind2sz</name><argument_list>(<argument><expr><name>pind</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>sz_large_pad</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>&lt;=</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifndef>
<function><type><specifier>static</specifier>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>size_t</name></type>
<name>extent_size_quantize_ceil</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <name>sz_large_pad</name> <operator>&lt;=</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>extent_size_quantize_floor</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Skip a quantization that may have an adequately large extent,
		 * because under-sized extents may be mixed in.  This only
		 * happens when an unusual size is requested, i.e. for aligned
		 * allocation, and is just one of several places where linear
		 * search would potentially find sufficiently aligned available
		 * memory somewhere lower.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sz_pind2sz</name><argument_list>(<argument><expr><call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>ret</name> <operator>-</operator> <name>sz_large_pad</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
		    <name>sz_large_pad</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate pairing heap functions. */</comment>
<macro><name>ph_gen</name><argument_list>(<argument/>, <argument>extent_heap_</argument>, <argument>extent_heap_t</argument>, <argument>extent_t</argument>, <argument>ph_link</argument>, <argument>extent_snad_comp</argument>)</argument_list></macro>

<function><type><name>bool</name></type>
<name>extents_init</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_state_t</name></type> <name>state</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>delay_coalesce</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>, <argument><expr><literal type="string">"extents"</literal></expr></argument>, <argument><expr><name>WITNESS_RANK_EXTENTS</name></expr></argument>,
	    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NPSIZES</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_heap_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>bitmap_init</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>lru</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extents</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name> <operator>=</operator> <name>delay_coalesce</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_state_t</name></type>
<name>extents_state_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>extents</name><operator>-&gt;</operator><name>state</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>extents_npages_get</name><parameter_list>(<parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>extents_nextents_get</name><parameter_list>(<parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>pszind_t</name></type> <name>pind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>nextents</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>extents_nbytes_get</name><parameter_list>(<parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>pszind_t</name></type> <name>pind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>nbytes</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extents_stats_add</name><parameter_list>(<parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>pszind_t</name></type> <name>pind</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cur</name> <init>= <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nextents</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nextents</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nbytes</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nbytes</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>cur</name> <operator>+</operator> <name>sz</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extents_stats_sub</name><parameter_list>(<parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>pszind_t</name></type> <name>pind</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cur</name> <init>= <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nextents</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nextents</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>cur</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nbytes</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extent</name><operator>-&gt;</operator><name>nbytes</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>cur</name> <operator>-</operator> <name>sz</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extents_insert_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>extents</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>psz</name> <init>= <expr><call><name>extent_size_quantize_floor</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pszind_t</name></type> <name>pind</name> <init>= <expr><call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>psz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_heap_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>bitmap_unset</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>pind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_heap_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extents_stats_add</name><argument_list>(<argument><expr><name>extents</name></expr></argument>, <argument><expr><name>pind</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>lru</name></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npages</name> <init>= <expr><name>size</name> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * All modifications to npages hold the mutex (as asserted above), so we
	 * don't need an atomic fetch-add; we can get by with a load followed by
	 * a store.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cur_extents_npages</name> <init>=
	    <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>, <argument><expr><name>cur_extents_npages</name> <operator>+</operator> <name>npages</name></expr></argument>,
	    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extents_remove_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>extents</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>psz</name> <init>= <expr><call><name>extent_size_quantize_floor</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pszind_t</name></type> <name>pind</name> <init>= <expr><call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>psz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_heap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extents_stats_sub</name><argument_list>(<argument><expr><name>extents</name></expr></argument>, <argument><expr><name>pind</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_heap_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>bitmap_set</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>pind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>lru</name></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npages</name> <init>= <expr><name>size</name> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * As in extents_insert_locked, we hold extents-&gt;mtx and so don't need
	 * atomic operations for updating extents-&gt;npages.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cur_extents_npages</name> <init>=
	    <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur_extents_npages</name> <operator>&gt;=</operator> <name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>,
	    <argument><expr><name>cur_extents_npages</name> <operator>-</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <name>LG_PAGE</name><operator>)</operator></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find an extent with size [min_size, max_size) to satisfy the alignment
 * requirement.  For each size, try only the first extent in the heap.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extents_fit_alignment</name><parameter_list>(<parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>min_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>pszind_t</name></type> <name>pind</name> <init>= <expr><call><name>sz_psz2ind</name><argument_list>(<argument><expr><call><name>extent_size_quantize_ceil</name><argument_list>(<argument><expr><name>min_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pszind_t</name></type> <name>pind_max</name> <init>= <expr><call><name>sz_psz2ind</name><argument_list>(<argument><expr><call><name>extent_size_quantize_ceil</name><argument_list>(<argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>pszind_t</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>pszind_t</name><operator>)</operator><call><name>bitmap_ffu</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>pind</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pind_max</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator>
	    <operator>(</operator><name>pszind_t</name><operator>)</operator><call><name>bitmap_ffu</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>SC_NPSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>extent_heap_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_heap_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name>base</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>candidate_size</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>candidate_size</name> <operator>&gt;=</operator> <name>min_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>uintptr_t</name></type> <name>next_align</name> <init>= <expr><call><name>ALIGNMENT_CEILING</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>base</name></expr></argument>,
		    <argument><expr><call><name>PAGE_CEILING</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>base</name> <operator>&gt;</operator> <name>next_align</name> <operator>||</operator> <name>base</name> <operator>+</operator> <name>candidate_size</name> <operator>&lt;=</operator> <name>next_align</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Overflow or not crossing the next alignment. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>size_t</name></type> <name>leadsize</name> <init>= <expr><name>next_align</name> <operator>-</operator> <name>base</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>candidate_size</name> <operator>-</operator> <name>leadsize</name> <operator>&gt;=</operator> <name>min_size</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>extent</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do first-fit extent selection, i.e. select the oldest/lowest extent that is
 * large enough.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extents_first_fit_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pszind_t</name></type> <name>pind</name> <init>= <expr><call><name>sz_psz2ind</name><argument_list>(<argument><expr><call><name>extent_size_quantize_ceil</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_coalesce</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_retain</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * No split / merge allowed (Windows w/o retain). Try exact fit
		 * only.
		 */</comment>
		<return>return <expr><ternary><condition><expr><call><name>extent_heap_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
		    <expr><call><name>extent_heap_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>pind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>pszind_t</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>pszind_t</name><operator>)</operator><call><name>bitmap_ffu</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>pind</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
	    <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NPSIZES</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition>
	    <incr><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>pszind_t</name><operator>)</operator><call><name>bitmap_ffu</name><argument_list>(<argument><expr><name><name>extents</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_bitmap_info</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>extent_heap_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_heap_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * In order to reduce fragmentation, avoid reusing and splitting
		 * large extents for much smaller sizes.
		 *
		 * Only do check for dirty extents (delay_coalesce).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name> <operator>&amp;&amp;</operator>
		    <operator>(</operator><call><name>sz_pind2sz</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>opt_lg_extent_max_active_fit</name><operator>)</operator> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>extent_snad_comp</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>extent</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>SC_NPSIZES</name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>SC_NPSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do first-fit extent selection, where the selection policy choice is
 * based on extents-&gt;delay_coalesce.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extents_fit_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>esize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>max_size</name> <init>= <expr><name>esize</name> <operator>+</operator> <call><name>PAGE_CEILING</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>PAGE</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Beware size_t wrap-around. */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_size</name> <operator>&lt;</operator> <name>esize</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>=
	    <expr><call><name>extents_first_fit_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>alignment</name> <operator>&gt;</operator> <name>PAGE</name> <operator>&amp;&amp;</operator> <name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * max_size guarantees the alignment requirement but is rather
		 * pessimistic.  Next we try to satisfy the aligned allocation
		 * with sizes in [esize, max_size).
		 */</comment>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extents_fit_alignment</name><argument_list>(<argument><expr><name>extents</name></expr></argument>, <argument><expr><name>esize</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>,
		    <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_try_delayed_coalesce</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>extent_state_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>coalesced</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_try_coalesce</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coalesced</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_state_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>coalesced</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extents_insert_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_t</name> <modifier>*</modifier></type>
<name>extents_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>pad</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>alignment</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_recycle</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
	    <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>extent</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>extent_dumpable_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extents_dalloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_dumpable_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_addr_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_zeroed_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>extent_t</name> <modifier>*</modifier></type>
<name>extents_evict</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_min</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the LRU coalesced extent, if any.  If coalescing was delayed,
	 * the loop will iterate until the LRU extent is fully coalesced.
	 */</comment>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Get the LRU extent, if any. */</comment>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_list_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>lru</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Check the eviction limit. */</comment>
		<decl_stmt><decl><type><name>size_t</name></type> <name>extents_npages</name> <init>= <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>extents_npages</name> <operator>&lt;=</operator> <name>npages_min</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>extent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>extents_remove_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Try to coalesce. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>extent_try_delayed_coalesce</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * The LRU extent was just coalesced and the result placed in
		 * the LRU at its neighbor's position.  Start over.
		 */</comment>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Either mark the extent active or deregister it to protect against
	 * concurrent operations.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>extent_state_active</name></expr>:</case>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<case>case <expr><name>extent_state_dirty</name></expr>:</case>
	<case>case <expr><name>extent_state_muzzy</name></expr>:</case>
		<expr_stmt><expr><call><name>extent_state_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>extent_state_retained</name></expr>:</case>
		<expr_stmt><expr><call><name>extent_deregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This can only happen when we fail to allocate a new extent struct (which
 * indicates OOM), e.g. when trying to split an existing extent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extents_abandon_vm</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>abandoned_vm</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Leak extent after making sure its pages have already been purged, so
	 * that this is only a virtual memory leak.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_dirty</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>extent_purge_lazy_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><name>extent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_purge_forced_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><name>extent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extents_prefork</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extents_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extents_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_deactivate_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_state_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_insert_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_deactivate</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_deactivate_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_activate_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extents_remove_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_state_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_rtree_leaf_elms_lookup</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dependent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>init_missing</name></decl></parameter>,
    <parameter><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_elm_a</name></decl></parameter>, <parameter><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_elm_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>r_elm_a</name> <operator>=</operator> <call><name>rtree_leaf_elm_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dependent</name></expr></argument>, <argument><expr><name>init_missing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dependent</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>r_elm_a</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>r_elm_a</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>r_elm_b</name> <operator>=</operator> <call><name>rtree_leaf_elm_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_last_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dependent</name></expr></argument>, <argument><expr><name>init_missing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dependent</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>r_elm_b</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>r_elm_b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_rtree_write_acquired</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>elm_a</name></decl></parameter>,
    <parameter><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>elm_b</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>rtree_leaf_elm_write</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>elm_a</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elm_b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rtree_leaf_elm_write</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>elm_b</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>,
		    <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_interior_register</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register interior. */</comment>
	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>rtree_write</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>i</name> <operator>&lt;&lt;</operator>
		    <name>LG_PAGE</name><operator>)</operator></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_gdump_add</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* prof_gdump() requirement. */</comment>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_prof</name> <operator>&amp;&amp;</operator> <call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_active</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>nadd</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>cur</name> <init>= <expr><call><name>atomic_fetch_add_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curpages</name></expr></argument>, <argument><expr><name>nadd</name></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nadd</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>high</name> <init>= <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>highpages</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>cur</name> <operator>&gt;</operator> <name>high</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>atomic_compare_exchange_weak_zu</name><argument_list>(
		    <argument><expr><operator>&amp;</operator><name>highpages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>high</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Don't refresh cur, because it may have decreased
			 * since this thread lost the highpages update race.
			 * Note that high is updated in case of CAS failure.
			 */</comment>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>&gt;</operator> <name>high</name> <operator>&amp;&amp;</operator> <call><name>prof_gdump_get_unlocked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_gdump</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_gdump_sub</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_prof</name> <operator>&amp;&amp;</operator> <call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_active</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>nsub</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curpages</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atomic_fetch_sub_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curpages</name></expr></argument>, <argument><expr><name>nsub</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_register_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gdump_add</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>elm_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elm_b</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to hold the lock to protect against a concurrent coalesce
	 * operation that sees us in a partial state.
	 */</comment>
	<expr_stmt><expr><call><name>extent_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_rtree_leaf_elms_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>elm_a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm_b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>szind_t</name></type> <name>szind</name> <init>= <expr><call><name>extent_szind_get_maybe_invalid</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>slab</name> <init>= <expr><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_rtree_write_acquired</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>elm_a</name></expr></argument>, <argument><expr><name>elm_b</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_interior_register</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>gdump_add</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_gdump_add</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_register</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_register_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_register_no_gdump_add</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_register_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_reregister</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>extent_register</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Removes all pointers to the given extent from the global rtree indices for
 * its interior.  This is relevant for slab extents, for which we need to do
 * metadata lookups at places other than the head of the extent.  We deregister
 * on the interior, then, when an extent moves from being an active slab to an
 * inactive state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_interior_deregister</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>rtree_clear</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>i</name> <operator>&lt;&lt;</operator>
		    <name>LG_PAGE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Removes all pointers to the given extent from the global rtree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_deregister_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gdump</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>elm_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elm_b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_rtree_leaf_elms_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>elm_a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_rtree_write_acquired</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>elm_a</name></expr></argument>, <argument><expr><name>elm_b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_interior_deregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_slab_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>gdump</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_gdump_sub</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_deregister</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>extent_deregister_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_deregister_no_gdump_sub</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>extent_deregister_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tries to find and remove an extent from extents that can be used for the
 * given allocation request.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_recycle_extract</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>alignment</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_debug</name> <operator>&amp;&amp;</operator> <name>new_addr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Non-NULL new_addr has two use cases:
		 *
		 *   1) Recycle a known-extant extent, e.g. during purging.
		 *   2) Perform in-place expanding reallocation.
		 *
		 * Regardless of use case, new_addr must either refer to a
		 * non-existing extent, or to the base of an extant extent,
		 * since only active slabs support interior lookups (which of
		 * course cannot be recycled).
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PAGE_ADDR2BASE</name><argument_list>(<argument><expr><name>new_addr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>new_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pad</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>alignment</name> <operator>&lt;=</operator> <name>PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>esize</name> <init>= <expr><name>size</name> <operator>+</operator> <name>pad</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_addr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_lock_from_addr</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>,
		    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * We might null-out extent to report an error, but we
			 * still need to unlock the associated mutex after.
			 */</comment>
			<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>unlock_extent</name> <init>= <expr><name>extent</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>new_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>arena</name> <operator>||</operator>
			    <call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>esize</name> <operator>||</operator>
			    <call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator>
			    <call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>extent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>unlock_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extents_fit_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>esize</name></expr></argument>,
		    <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_activate_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given an allocation request and an extent guaranteed to be able to satisfy
 * it, this splits off lead and trail extents, leaving extent pointing to an
 * extent satisfying the allocation.
 * This function doesn't put lead or trail into any extents_t; it's the caller's
 * job to ensure that they can be reused.
 */</comment>
<typedef>typedef <type><enum>enum <block>{
	<comment type="block">/*
	 * Split successfully.  lead, extent, and trail, are modified to extents
	 * describing the ranges before, in, and after the given allocation.
	 */</comment>
	<decl><name>extent_split_interior_ok</name></decl>,
	<comment type="block">/*
	 * The extent can't satisfy the given allocation request.  None of the
	 * input extent_t *s are touched.
	 */</comment>
	<decl><name>extent_split_interior_cant_alloc</name></decl>,
	<comment type="block">/*
	 * In a potentially invalid state.  Must leak (if *to_leak is non-NULL),
	 * and salvage what's still salvageable (if *to_salvage is non-NULL).
	 * None of lead, extent, or trail are valid.
	 */</comment>
	<decl><name>extent_split_interior_error</name></decl>
}</block></enum></type> <name>extent_split_interior_result_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>extent_split_interior_result_t</name></type>
<name>extent_split_interior</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>,
    <comment type="block">/* The result of splitting, in case of success. */</comment>
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>lead</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>trail</name></decl></parameter>,
    <comment type="block">/* The mess to clean up, in case of error. */</comment>
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>to_leak</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>to_salvage</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>esize</name> <init>= <expr><name>size</name> <operator>+</operator> <name>pad</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>leadsize</name> <init>= <expr><call><name>ALIGNMENT_CEILING</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><call><name>PAGE_CEILING</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new_addr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>leadsize</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_size_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>leadsize</name> <operator>+</operator> <name>esize</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>extent_split_interior_cant_alloc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>trailsize</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>leadsize</name> <operator>-</operator> <name>esize</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>lead</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>trail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>to_leak</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>to_salvage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Split the lead. */</comment>
	<if_stmt><if>if <condition>(<expr><name>leadsize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lead</name> <operator>=</operator> <operator>*</operator><name>extent</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>extent</name> <operator>=</operator> <call><name>extent_split_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><operator>*</operator><name>lead</name></expr></argument>, <argument><expr><name>leadsize</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>esize</name> <operator>+</operator> <name>trailsize</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>,
		    <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to_leak</name> <operator>=</operator> <operator>*</operator><name>lead</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>lead</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>extent_split_interior_error</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Split the trail. */</comment>
	<if_stmt><if>if <condition>(<expr><name>trailsize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>trail</name> <operator>=</operator> <call><name>extent_split_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><operator>*</operator><name>extent</name></expr></argument>,
		    <argument><expr><name>esize</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>trailsize</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>trail</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to_leak</name> <operator>=</operator> <operator>*</operator><name>extent</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to_salvage</name> <operator>=</operator> <operator>*</operator><name>lead</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>lead</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>extent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>extent_split_interior_error</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>leadsize</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>trailsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Splitting causes szind to be set as a side effect, but no
		 * splitting occurred.
		 */</comment>
		<expr_stmt><expr><call><name>extent_szind_set</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>szind</name> <operator>!=</operator> <name>SC_NSIZES</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>rtree_szind_slab_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
			    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>&amp;&amp;</operator> <call><name>extent_size_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>PAGE</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>rtree_szind_slab_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>,
				    <argument><expr><name>rtree_ctx</name></expr></argument>,
				    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_past_get</name><argument_list>(<argument><expr><operator>*</operator><name>extent</name></expr></argument>)</argument_list></call> <operator>-</operator>
				    <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>PAGE</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extent_split_interior_ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This fulfills the indicated allocation request out of the given extent (which
 * the caller should have ensured was big enough).  If there's any unused space
 * before or after the resulting allocation, that space is given its own extent
 * and put back into extents.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_recycle_split</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>lead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>trail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>to_leak</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>to_salvage</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>extent_split_interior_result_t</name></type> <name>result</name> <init>= <expr><call><name>extent_split_interior</name><argument_list>(
	    <argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trail</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>to_leak</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_salvage</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>,
	    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_coalesce</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name>extent_split_interior_ok</name>
	    <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_retain</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Split isn't supported (implies Windows w/o retain).  Avoid
		 * leaking the extents.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>to_leak</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>lead</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>trail</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_deactivate</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>to_leak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>extent_split_interior_ok</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lead</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_deactivate</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>lead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>trail</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_deactivate</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>extent</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * We should have picked an extent that was large enough to
		 * fulfill our allocation request.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>extent_split_interior_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>to_salvage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_deregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>to_salvage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>to_leak</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>leak</name> <init>= <expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>to_leak</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>extent_deregister_no_gdump_sub</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>to_leak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>extents_abandon_vm</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
			    <argument><expr><name>to_leak</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_lock_from_addr</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>leak</name></expr></argument>,
			    <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_need_manual_zero</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Need to manually zero the extent on repopulating if either; 1) non
	 * default extent hooks installed (in which case the purge semantics may
	 * change); or 2) transparent huge pages enabled.
	 */</comment>
	<return>return <expr><operator>(</operator><operator>!</operator><call><name>arena_has_default_hooks</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name>opt_thp</name> <operator>==</operator> <name>thp_mode_always</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Tries to satisfy the given allocation request by reusing one of the extents
 * in the given extents_t.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_recycle</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new_addr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pad</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>*</operator><name>zero</name> <operator>||</operator> <operator>!</operator><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_recycle_extract</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>,
	    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_recycle_split</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
	    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>commit</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>extent_commit_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
		    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
			    <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_need_manual_zero</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_zeroed_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>commit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zero</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_addr_randomize</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_slab_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_interior_register</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>zero</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>extent_need_manual_zero</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call> <operator>||</operator>
			    <call><name>pages_purge_forced</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>config_debug</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Check the first page only. */</comment>
			<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PAGE</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the caller specifies (!*zero), it is still possible to receive zeroed
 * memory, in which case *zero is toggled to true.  arena_extent_alloc() takes
 * advantage of this to avoid demanding zeroed extents, but taking advantage of
 * them if they are returned.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>extent_alloc_core</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>dss_prec_t</name></type> <name>dss_prec</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>alignment</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* "primary" dss. */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_dss</name> <operator>&amp;&amp;</operator> <name>dss_prec</name> <operator>==</operator> <name>dss_prec_primary</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ret</name> <operator>=</operator>
	    <call><name>extent_alloc_dss</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
	    <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* mmap. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>extent_alloc_mmap</name><argument_list>(<argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator>
	    <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* "secondary" dss. */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_dss</name> <operator>&amp;&amp;</operator> <name>dss_prec</name> <operator>==</operator> <name>dss_prec_secondary</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ret</name> <operator>=</operator>
	    <call><name>extent_alloc_dss</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
	    <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* All strategies for allocation failed. */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>extent_alloc_default_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>extent_alloc_core</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
	    <argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>(</operator><name>dss_prec_t</name><operator>)</operator><call><name>atomic_load_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>dss_prec</name></name></expr></argument>,
	    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_madvise_huge</name> <operator>&amp;&amp;</operator> <name>ret</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>pages_set_thp_state</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>extent_alloc_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The arena we're allocating on behalf of must have been initialized
	 * already.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arena</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>extent_alloc_default_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
	    <argument><expr><call><name>ALIGNMENT_CEILING</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_hook_pre_reentrancy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><ternary><condition><expr><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * The only legitimate case of customized extent hooks for a0 is
		 * hooks with no allocation activities.  One such example is to
		 * place metadata on pre-allocated resources such as huge pages.
		 * In that case, rely on reentrancy_level checks to catch
		 * infinite recursions.
		 */</comment>
		<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_hook_post_reentrancy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><ternary><condition><expr><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If virtual memory is retained, create increasingly larger extents from which
 * to split requested extents in order to limit the total number of disjoint
 * virtual memory ranges retained by each arena.
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_grow_retained</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pad</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>*</operator><name>zero</name> <operator>||</operator> <operator>!</operator><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>esize</name> <init>= <expr><name>size</name> <operator>+</operator> <name>pad</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_size_min</name> <init>= <expr><name>esize</name> <operator>+</operator> <call><name>PAGE_CEILING</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>PAGE</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Beware size_t wrap-around. */</comment>
	<if_stmt><if>if <condition>(<expr><name>alloc_size_min</name> <operator>&lt;</operator> <name>esize</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_err</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Find the next extent size in the series that would be large enough to
	 * satisfy this request.
	 */</comment>
	<decl_stmt><decl><type><name>pszind_t</name></type> <name>egn_skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_size</name> <init>= <expr><call><name>sz_pind2sz</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>+</operator> <name>egn_skip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>alloc_size</name> <operator>&lt;</operator> <name>alloc_size_min</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>egn_skip</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>+</operator> <name>egn_skip</name> <operator>&gt;=</operator>
		    <call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Outside legal range. */</comment>
			<goto>goto <name>label_err</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>alloc_size</name> <operator>=</operator> <call><name>sz_pind2sz</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>+</operator> <name>egn_skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_err</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>zeroed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>committed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>==</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>extent_alloc_default_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>alloc_size</name></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zeroed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>committed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>alloc_size</name></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zeroed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>committed</name></expr></argument>,
		    <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>extent_init</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>,
	    <argument><expr><call><name>arena_extent_sn_next</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extent_state_active</name></expr></argument>, <argument><expr><name>zeroed</name></expr></argument>,
	    <argument><expr><name>committed</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>EXTENT_IS_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>label_err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_register_no_gdump_add</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>label_err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zero</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>commit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>lead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>trail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>to_leak</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>to_salvage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_split_interior_result_t</name></type> <name>result</name> <init>= <expr><call><name>extent_split_interior</name><argument_list>(
	    <argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trail</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>to_leak</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_salvage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>,
	    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>extent_split_interior_ok</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lead</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>lead</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>trail</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * We should have allocated a sufficiently large extent; the
		 * cant_alloc case should not occur.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>extent_split_interior_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>to_salvage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>extent_gdump_add</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>to_salvage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>to_salvage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>to_leak</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_deregister_no_gdump_sub</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>to_leak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>extents_abandon_vm</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>to_leak</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<goto>goto <name>label_err</name>;</goto>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>commit</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>extent_commit_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>label_err</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_need_manual_zero</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_zeroed_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Increment extent_grow_next if doing so wouldn't exceed the allowed
	 * range.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>+</operator> <name>egn_skip</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator>
	    <name><name>arena</name><operator>-&gt;</operator><name>retain_grow_limit</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>+=</operator> <name>egn_skip</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>=</operator> <name><name>arena</name><operator>-&gt;</operator><name>retain_grow_limit</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* All opportunities for failure are past. */</comment>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Adjust gdump stats now that extent is final size. */</comment>
		<expr_stmt><expr><call><name>extent_gdump_add</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_addr_randomize</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>extent_slab_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_interior_register</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>zero</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>extent_need_manual_zero</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call> <operator>||</operator>
		    <call><name>pages_purge_forced</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extent</name></expr>;</return>
<label><name>label_err</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_alloc_retained</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>alignment</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_recycle</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>,
	    <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>extent_gdump_add</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>opt_retain</name> <operator>&amp;&amp;</operator> <name>new_addr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_grow_retained</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
		    <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* extent_grow_retained() always releases extent_grow_mtx. */</comment>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_not_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_alloc_wrapper_hard</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>esize</name> <init>= <expr><name>size</name> <operator>+</operator> <name>pad</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>palignment</name> <init>= <expr><call><name>ALIGNMENT_CEILING</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>==</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Call directly to propagate tsdn. */</comment>
		<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>extent_alloc_default_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>esize</name></expr></argument>,
		    <argument><expr><name>palignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>new_addr</name></expr></argument>,
		    <argument><expr><name>esize</name></expr></argument>, <argument><expr><name>palignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_init</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>esize</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>,
	    <argument><expr><call><name>arena_extent_sn_next</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extent_state_active</name></expr></argument>, <argument><expr><operator>*</operator><name>zero</name></expr></argument>, <argument><expr><operator>*</operator><name>commit</name></expr></argument>,
	    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>EXTENT_NOT_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_addr_randomize</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_register</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_t</name> <modifier>*</modifier></type>
<name>extent_alloc_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_alloc_retained</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>opt_retain</name> <operator>&amp;&amp;</operator> <name>new_addr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * When retain is enabled and new_addr is set, we do not
			 * attempt extent_alloc_wrapper_hard which does mmap
			 * that is very unlikely to succeed (unless it happens
			 * to be at the end).
			 */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_alloc_wrapper_hard</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><name>new_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>extent</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>extent_dumpable_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_can_coalesce</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>inner</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>outer</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>arena</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>extents</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>extent_committed_get</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_coalesce</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>inner</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>outer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_can_coalesce</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>inner</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_activate_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>extent_merge_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>inner</name></expr> </then><else>: <expr><name>outer</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>outer</name></expr> </then><else>: <expr><name>inner</name></expr></else></ternary></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_deactivate_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_try_coalesce_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>coalesced</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>inactive_only</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * We avoid checking / locking inactive neighbors for large size
	 * classes, since they are eagerly coalesced on deallocation which can
	 * cause lock contention.
	 */</comment>
	<comment type="block">/*
	 * Continue attempting to coalesce until failure, to protect against
	 * races with other threads that are thwarted by this one.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>again</name></decl>;</decl_stmt>
	<do>do <block>{<block_content>
		<expr_stmt><expr><name>again</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Try to coalesce forward. */</comment>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>extent_lock_from_addr</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><call><name>extent_past_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inactive_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * extents-&gt;mtx only protects against races for
			 * like-state extents, so call extent_can_coalesce()
			 * before releasing next's pool lock.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>can_coalesce</name> <init>= <expr><call><name>extent_can_coalesce</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
			    <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>can_coalesce</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extent_coalesce</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
			    <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name></expr>)</condition> <block>{<block_content>
					<comment type="block">/* Do minimal coalescing. */</comment>
					<expr_stmt><expr><operator>*</operator><name>coalesced</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>extent</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>again</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Try to coalesce backward. */</comment>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><call><name>extent_lock_from_addr</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><call><name>extent_before_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inactive_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>can_coalesce</name> <init>= <expr><call><name>extent_can_coalesce</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
			    <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>extent_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>can_coalesce</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extent_coalesce</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
			    <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
			    <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>extent</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name></expr>)</condition> <block>{<block_content>
					<comment type="block">/* Do minimal coalescing. */</comment>
					<expr_stmt><expr><operator>*</operator><name>coalesced</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>extent</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>again</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>again</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>coalesced</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_try_coalesce</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>coalesced</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_try_coalesce_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>coalesced</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_try_coalesce_large</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>coalesced</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_try_coalesce_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>coalesced</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the metadata management portions of putting an unused extent into the
 * given extents_t (coalesces, deregisters slab interiors, the heap operations).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_record</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>extent_state_dirty</name> <operator>&amp;&amp;</operator>
	    <call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>extent_state_muzzy</name><operator>)</operator> <operator>||</operator>
	    <operator>!</operator><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_szind_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_interior_deregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_slab_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>rtree_extent_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extents</name><operator>-&gt;</operator><name>delay_coalesce</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_try_coalesce</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>extents</name> <operator>==</operator> <operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Always coalesce large extents eagerly. */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>coalesced</name></decl>;</decl_stmt>
		<do>do <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_try_coalesce_large</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
			    <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>coalesced</name></expr></argument>, <argument><expr><name>growing_retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>coalesced</name></expr>)</condition>;</do>
		<if_stmt><if>if <condition>(<expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>oversize_threshold</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Shortcut to purge the oversize extent eagerly. */</comment>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>arena_decay_extent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_deactivate_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extents</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_dalloc_gap</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name> <init>= <expr><name>EXTENT_HOOKS_INITIALIZER</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>extent_register</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_dalloc_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_may_dalloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* With retain enabled, the default dalloc always fails. */</comment>
	<return>return <expr><operator>!</operator><name>opt_retain</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_dalloc_default_impl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_dss</name> <operator>||</operator> <operator>!</operator><call><name>extent_in_dss</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>extent_dalloc_mmap</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_dalloc_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_dalloc_default_impl</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_dalloc_wrapper_try</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_addr_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Try to deallocate. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>==</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Call directly to propagate tsdn. */</comment>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>extent_dalloc_default_impl</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>dalloc</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		    <call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>dalloc</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_dalloc_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_dumpable_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid calling the default extent_dalloc unless have to. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name> <operator>||</operator> <call><name>extent_may_dalloc</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Deregister first to avoid a race with other allocating
		 * threads, and reregister if deallocation fails.
		 */</comment>
		<expr_stmt><expr><call><name>extent_deregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_dalloc_wrapper_try</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>extent_reregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Try to decommit; purge if that fails. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>zeroed</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>zeroed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>extent_decommit_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
	    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>zeroed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_forced</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_forced</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
	    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>zeroed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extent_state_muzzy</name> <operator>||</operator>
	    <operator>(</operator><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_lazy</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_lazy</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
	    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>zeroed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>zeroed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_zeroed_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>zeroed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_gdump_sub</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_record</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>,
	    <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_destroy_default_impl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_dss</name> <operator>||</operator> <operator>!</operator><call><name>extent_in_dss</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>pages_unmap</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extent_destroy_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>extent_destroy_default_impl</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_destroy_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deregister first to avoid a race with other allocating threads. */</comment>
	<expr_stmt><expr><call><name>extent_deregister</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_addr_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Try to destroy; silently fail otherwise. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>==</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Call directly to propagate tsdn. */</comment>
		<expr_stmt><expr><call><name>extent_destroy_default_impl</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>destroy</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>destroy</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_commit_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>pages_commit</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>addr</name> <operator>+</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>offset</name><operator>)</operator></expr></argument>,
	    <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_commit_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>commit</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
	    <call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>commit</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>, <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_committed_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>extent_commit_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_commit_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
	    <argument><expr><name>length</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_decommit_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>pages_decommit</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>addr</name> <operator>+</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>offset</name><operator>)</operator></expr></argument>,
	    <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>extent_decommit_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>decommit</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
	    <call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>decommit</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
	    <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_committed_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PAGES_CAN_PURGE_LAZY</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_purge_lazy_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>addr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>offset</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>length</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pages_purge_lazy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>addr</name> <operator>+</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>offset</name><operator>)</operator></expr></argument>,
	    <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_purge_lazy_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_lazy</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_lazy</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
	    <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>extent_purge_lazy_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_purge_lazy_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
	    <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PAGES_CAN_PURGE_FORCED</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_purge_forced_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>addr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>offset</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>length</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pages_purge_forced</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>addr</name> <operator>+</operator>
	    <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>offset</name><operator>)</operator></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_purge_forced_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_forced</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>purge_forced</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
	    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
	    <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>extent_purge_forced_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_purge_forced_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
	    <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_split_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_coalesce</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Without retain, only whole regions can be purged (required by
		 * MEM_RELEASE on Windows) -- therefore disallow splitting.  See
		 * comments in extent_head_no_merge().
		 */</comment>
		<return>return <expr><operator>!</operator><name>opt_retain</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Accepts the extent to split, and the characteristics of each side of the
 * split.  The 'a' parameters go with the 'lead' of the resulting pair of
 * extents (the lower addressed portion of the split), and the 'b' parameters go
 * with the trail (the higher addressed portion).  This makes 'extent' the lead,
 * and returns the trail (except in case of error).
 */</comment>
<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>extent_split_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind_a</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab_a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab_b</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>size_a</name> <operator>+</operator> <name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>split</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>trail</name> <init>= <expr><call><name>extent_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>trail</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error_a</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_init</name><argument_list>(<argument><expr><name>trail</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>+</operator>
	    <name>size_a</name><operator>)</operator></expr></argument>, <argument><expr><name>size_b</name></expr></argument>, <argument><expr><name>slab_b</name></expr></argument>, <argument><expr><name>szind_b</name></expr></argument>, <argument><expr><call><name>extent_sn_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_dumpable_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>EXTENT_NOT_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>lead_elm_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lead_elm_b</name></decl>;</decl_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>extent_t</name></type> <name>lead</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>extent_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lead</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_a</name></expr></argument>,
		    <argument><expr><name>slab_a</name></expr></argument>, <argument><expr><name>szind_a</name></expr></argument>, <argument><expr><call><name>extent_sn_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_state_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_dumpable_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>EXTENT_NOT_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>extent_rtree_leaf_elms_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lead</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lead_elm_a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lead_elm_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<decl_stmt><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>trail_elm_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>trail_elm_b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_rtree_leaf_elms_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>trail_elm_a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trail_elm_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lead_elm_a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>lead_elm_b</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>trail_elm_a</name> <operator>==</operator> <name>NULL</name>
	    <operator>||</operator> <name>trail_elm_b</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error_b</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_lock2</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>split</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>, <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>size_a</name> <operator>+</operator> <name>size_b</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>, <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>!=</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error_c</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_size_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_szind_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_rtree_write_acquired</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>lead_elm_a</name></expr></argument>, <argument><expr><name>lead_elm_b</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>,
	    <argument><expr><name>szind_a</name></expr></argument>, <argument><expr><name>slab_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_rtree_write_acquired</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>trail_elm_a</name></expr></argument>, <argument><expr><name>trail_elm_b</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
	    <argument><expr><name>szind_b</name></expr></argument>, <argument><expr><name>slab_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_unlock2</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>trail</name></expr>;</return>
<label><name>label_error_c</name>:</label>
	<expr_stmt><expr><call><name>extent_unlock2</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>label_error_b</name>:</label>
	<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>label_error_a</name>:</label>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_t</name> <modifier>*</modifier></type>
<name>extent_split_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind_a</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab_a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>szind_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slab_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_split_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>,
	    <argument><expr><name>szind_a</name></expr></argument>, <argument><expr><name>slab_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>, <argument><expr><name>szind_b</name></expr></argument>, <argument><expr><name>slab_b</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_merge_default_impl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr_a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_coalesce</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_retain</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_dss</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extent_dss_mergeable</name><argument_list>(<argument><expr><name>addr_a</name></expr></argument>, <argument><expr><name>addr_b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the given extents can't be merged because of their head bit
 * settings.  Assumes the second extent has the higher address.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_head_no_merge</name><parameter_list>(<parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>extent_base_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * When coalesce is not always allowed (Windows), only merge extents
	 * from the same VirtualAlloc region under opt.retain (in which case
	 * MEM_DECOMMIT is utilized for purging).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>maps_coalesce</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_retain</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* If b is a head extent, disallow the cross-region merge. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extent_is_head_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Additionally, sn should not overflow with retain; sanity
		 * check that different regions have unique sn.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_sn_comp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_sn_comp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_merge_default</name><parameter_list>(<parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr_a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_a</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr_b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_b</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>committed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_coalesce</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>addr_a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>addr_b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>extent_head_no_merge</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>extent_merge_default_impl</name><argument_list>(<argument><expr><name>addr_a</name></expr></argument>, <argument><expr><name>addr_b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extent_merge_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>growing_retained</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><ternary><condition><expr><name>growing_retained</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>extent_base_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_hooks_assure_initialized</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>merge</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>extent_head_no_merge</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>err</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>r_extent_hooks</name> <operator>==</operator> <operator>&amp;</operator><name>extent_hooks_default</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Call directly to propagate tsdn. */</comment>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>extent_merge_default_impl</name><argument_list>(<argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>extent_hook_pre_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name>r_extent_hooks</name><operator>)</operator><operator>-&gt;</operator><name>merge</name></name><argument_list>(<argument><expr><operator>*</operator><name>r_extent_hooks</name></expr></argument>,
		    <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>extent_committed_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_hook_post_reentrancy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The rtree writes must happen while all the relevant elements are
	 * owned, so the following code uses decomposed helper functions rather
	 * than extent_{,de}register() to do things in the right order.
	 */</comment>
	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_leaf_elm_t</name> <modifier>*</modifier></type><name>a_elm_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a_elm_b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b_elm_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b_elm_b</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_rtree_leaf_elms_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a_elm_a</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>a_elm_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_rtree_leaf_elms_lookup</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b_elm_a</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>b_elm_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_lock2</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>a_elm_b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rtree_leaf_elm_write</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>a_elm_b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>SC_NSIZES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b_elm_b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>rtree_leaf_elm_write</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>b_elm_a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>SC_NSIZES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>b_elm_b</name> <operator>=</operator> <name>b_elm_a</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>extent_size_set</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>extent_size_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_szind_set</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_sn_set</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>extent_sn_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>extent_sn_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
	    <expr><call><name>extent_sn_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>extent_sn_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_zeroed_set</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>extent_zeroed_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_rtree_write_acquired</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>a_elm_a</name></expr></argument>, <argument><expr><name>b_elm_b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>SC_NSIZES</name></expr></argument>,
	    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_unlock2</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>extent_merge_wrapper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>extent_merge_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>extent_boot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>rtree_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>mutex_pool_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extent_mutex_pool</name></expr></argument>, <argument><expr><literal type="string">"extent_mutex_pool"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_EXTENT_POOL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_dss</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_dss_boot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_util_stats_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nfree</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nregs</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nfree</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nregs</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>size</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nfree</name> <operator>=</operator> <operator>*</operator><name>nregs</name> <operator>=</operator> <operator>*</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nfree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nregs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nfree</name> <operator>=</operator> <call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nregs</name> <operator>=</operator> <name><name>bin_infos</name><index>[<expr><call><name>extent_szind_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>nregs</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>nfree</name> <operator>&lt;=</operator> <operator>*</operator><name>nregs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>nfree</name> <operator>*</operator> <call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>*</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_util_stats_verbose_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nfree</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nregs</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bin_nfree</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bin_nregs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>slabcur_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nfree</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nregs</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>size</name> <operator>!=</operator> <name>NULL</name>
	    <operator>&amp;&amp;</operator> <name>bin_nfree</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>bin_nregs</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>slabcur_addr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nfree</name> <operator>=</operator> <operator>*</operator><name>nregs</name> <operator>=</operator> <operator>*</operator><name>size</name> <operator>=</operator> <operator>*</operator><name>bin_nfree</name> <operator>=</operator> <operator>*</operator><name>bin_nregs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>slabcur_addr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nfree</name> <operator>=</operator> <operator>*</operator><name>bin_nfree</name> <operator>=</operator> <operator>*</operator><name>bin_nregs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nregs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>slabcur_addr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>nfree</name> <operator>=</operator> <call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>szind_t</name></type> <name>szind</name> <init>= <expr><call><name>extent_szind_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>nregs</name> <operator>=</operator> <name><name>bin_infos</name><index>[<expr><name>szind</name></expr>]</index></name><operator>.</operator><name>nregs</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>nfree</name> <operator>&lt;=</operator> <operator>*</operator><name>nregs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>nfree</name> <operator>*</operator> <call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>*</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arena</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>binshard</name> <init>= <expr><call><name>extent_binshard_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>szind</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>binshard</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bin_nregs</name> <operator>=</operator> <operator>*</operator><name>nregs</name> <operator>*</operator> <name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curslabs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>bin_nregs</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curregs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bin_nfree</name> <operator>=</operator> <operator>*</operator><name>bin_nregs</name> <operator>-</operator> <name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curregs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bin_nfree</name> <operator>=</operator> <operator>*</operator><name>bin_nregs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>slabcur_addr</name> <operator>=</operator> <call><name>extent_addr_get</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>slabcur_addr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
