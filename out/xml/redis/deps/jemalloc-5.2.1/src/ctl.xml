<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/ctl.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_CTL_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ctl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_dss.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_mmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/nstime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/sc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/util.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<comment type="block">/*
 * ctl_mtx protects the following:
 * - ctl_stats-&gt;*
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>ctl_mtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>ctl_initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ctl_stats_t</name>	<modifier>*</modifier></type><name>ctl_stats</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ctl_arenas_t</name>	<modifier>*</modifier></type><name>ctl_arenas</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Helpers for named and indexed nodes. */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>ctl_named_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctl_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>named</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>ctl_named_node_t</name> <operator>*</operator><operator>)</operator><name>node</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>ctl_named_children</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><call><name>ctl_named_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name>children</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name> <modifier>*</modifier></type>
<name>ctl_indexed_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctl_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>named</name></name></expr> ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>ctl_indexed_node_t</name> <operator>*</operator><operator>)</operator><name>node</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Function prototypes for non-inline static functions. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_PROTO</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>							\
<cpp:value>static int	n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,	\
    void *oldp, size_t *oldlenp, void *newp, size_t newlen);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_PROTO</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>							\
<cpp:value>static const ctl_named_node_t	*n##_index(tsdn_t *tsdn,		\
    const size_t *mib, size_t miblen, size_t i);</cpp:value></cpp:define>

<macro><name>CTL_PROTO</name><argument_list>(<argument>version</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>epoch</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>background_thread</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>max_background_threads</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_tcache_enabled</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_tcache_flush</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_prof_name</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_prof_active</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_arena</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_allocated</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_allocatedp</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_deallocated</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>thread_deallocatedp</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_cache_oblivious</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_debug</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_fill</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_lazy_lock</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_malloc_conf</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_opt_safety_checks</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_prof</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_prof_libgcc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_prof_libunwind</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_stats</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_utrace</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>config_xmalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_abort</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_abort_conf</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_confirm_conf</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_metadata_thp</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_retain</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_dss</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_narenas</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_percpu_arena</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_oversize_threshold</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_background_thread</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_max_background_threads</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_dirty_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_muzzy_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_stats_print</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_stats_print_opts</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_junk</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_zero</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_utrace</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_xmalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_tcache</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_thp</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_lg_extent_max_active_fit</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_lg_tcache_max</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_prefix</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_active</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_thread_active_init</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_lg_prof_sample</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_lg_prof_interval</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_gdump</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_final</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_leak</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>opt_prof_accum</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>tcache_create</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>tcache_flush</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>tcache_destroy</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_initialized</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_decay</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_purge</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_reset</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_destroy</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_dss</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_dirty_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_muzzy_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_extent_hooks</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arena_i_retain_grow_limit</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>arena_i</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_bin_i_size</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_bin_i_nregs</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_bin_i_slab_size</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_bin_i_nshards</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>arenas_bin_i</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_lextent_i_size</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>arenas_lextent_i</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_narenas</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_dirty_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_muzzy_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_quantum</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_page</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_tcache_max</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_nbins</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_nhbins</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_nlextents</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_create</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>arenas_lookup</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_thread_active_init</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_active</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_dump</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_gdump</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_reset</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_interval</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>lg_prof_sample</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_log_start</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>prof_log_stop</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_small_allocated</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_small_nmalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_small_ndalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_small_nrequests</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_small_nfills</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_small_nflushes</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_large_allocated</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_large_nmalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_large_ndalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_large_nrequests</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_large_nfills</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_large_nflushes</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nmalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_ndalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nrequests</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_curregs</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nfills</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nflushes</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nslabs</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nreslabs</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_curslabs</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j_nonfull_slabs</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>stats_arenas_i_bins_j</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_lextents_j_nmalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_lextents_j_ndalloc</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_lextents_j_nrequests</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_lextents_j_curlextents</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>stats_arenas_i_lextents_j</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j_ndirty</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j_nmuzzy</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j_nretained</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j_dirty_bytes</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j_muzzy_bytes</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j_retained_bytes</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>stats_arenas_i_extents_j</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_nthreads</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_uptime</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_dss</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_dirty_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_muzzy_decay_ms</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_pactive</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_pdirty</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_pmuzzy</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_mapped</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_retained</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_extent_avail</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_dirty_npurge</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_dirty_nmadvise</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_dirty_purged</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_muzzy_npurge</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_muzzy_nmadvise</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_muzzy_purged</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_base</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_internal</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_metadata_thp</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_tcache_bytes</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_resident</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_arenas_i_abandoned_vm</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>stats_arenas_i</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_allocated</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_active</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_background_thread_num_threads</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_background_thread_num_runs</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_background_thread_run_interval</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_metadata</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_metadata_thp</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_resident</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_mapped</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>stats_retained</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>experimental_hooks_install</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>experimental_hooks_remove</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>experimental_utilization_query</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>experimental_utilization_batch_query</argument>)</argument_list></macro>
<macro><name>CTL_PROTO</name><argument_list>(<argument>experimental_arenas_i_pactivep</argument>)</argument_list></macro>
<macro><name>INDEX_PROTO</name><argument_list>(<argument>experimental_arenas_i</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_STATS_CTL_PROTO_GEN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>					\
<cpp:value>CTL_PROTO(stats_##n##_num_ops)						\
CTL_PROTO(stats_##n##_num_wait)						\
CTL_PROTO(stats_##n##_num_spin_acq)					\
CTL_PROTO(stats_##n##_num_owner_switch)					\
CTL_PROTO(stats_##n##_total_wait_time)					\
CTL_PROTO(stats_##n##_max_wait_time)					\
CTL_PROTO(stats_##n##_max_num_thds)</cpp:value></cpp:define>

<comment type="block">/* Global mutexes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUTEX_STATS_CTL_PROTO_GEN(mutexes_##mtx)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>MUTEX_PROF_GLOBAL_MUTEXES</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

<comment type="block">/* Per arena mutexes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUTEX_STATS_CTL_PROTO_GEN(arenas_i_mutexes_##mtx)</cpp:value></cpp:define>
<name>MUTEX_PROF_ARENA_MUTEXES</name></type>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

<comment type="block">/* Arena bin mutexes. */</comment>
<name>MUTEX_STATS_CTL_PROTO_GEN</name><argument_list>(<argument><expr><name>arenas_i_bins_j_mutex</name></expr></argument>)</argument_list>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MUTEX_STATS_CTL_PROTO_GEN</name></cpp:undef>

<name>CTL_PROTO</name><argument_list>(<argument><expr><name>stats_mutexes_reset</name></expr></argument>)</argument_list>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* mallctl tree. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{true},	n</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHILD</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>							\
	<cpp:value>sizeof(c##_node) / sizeof(ctl_##t##_node_t),			\
	(ctl_node_t *)c##_node,						\
	NULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>0, NULL, c##_ctl</cpp:value></cpp:define>

<comment type="block">/*
 * Only handles internal indexed nodes, since there are currently no external
 * ones.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{false},	i##_index</cpp:value></cpp:define>

static const <name>ctl_named_node_t</name>	<name><name>thread_tcache_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"enabled"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>thread_tcache_enabled</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"flush"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>thread_tcache_flush</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type>	<name><name>thread_prof_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>thread_prof_name</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"active"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>thread_prof_active</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type>	<name><name>thread_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"arena"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>thread_arena</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"allocated"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>thread_allocated</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"allocatedp"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>thread_allocatedp</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"deallocated"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>thread_deallocated</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"deallocatedp"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>thread_deallocatedp</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"tcache"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>thread_tcache</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>thread_prof</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type>	<name><name>config_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"cache_oblivious"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>config_cache_oblivious</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>config_debug</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"fill"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>config_fill</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lazy_lock"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>config_lazy_lock</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"malloc_conf"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>config_malloc_conf</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"opt_safety_checks"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>config_opt_safety_checks</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>config_prof</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_libgcc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>config_prof_libgcc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_libunwind"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>config_prof_libunwind</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"stats"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>config_stats</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"utrace"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>config_utrace</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"xmalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>config_xmalloc</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>opt_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"abort"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>opt_abort</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"abort_conf"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_abort_conf</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"confirm_conf"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_confirm_conf</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"metadata_thp"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_metadata_thp</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"retain"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_retain</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dss"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>opt_dss</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"narenas"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_narenas</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"percpu_arena"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_percpu_arena</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"oversize_threshold"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_oversize_threshold</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"background_thread"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_background_thread</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"max_background_threads"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_max_background_threads</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>opt_dirty_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>opt_muzzy_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"stats_print"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_stats_print</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"stats_print_opts"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_stats_print_opts</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"junk"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>opt_junk</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"zero"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>opt_zero</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"utrace"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_utrace</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"xmalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_xmalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"tcache"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_tcache</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"thp"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>opt_thp</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lg_extent_max_active_fit"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>opt_lg_extent_max_active_fit</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lg_tcache_max"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_lg_tcache_max</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>opt_prof</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_prefix"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_prof_prefix</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_active"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_prof_active</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_thread_active_init"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>opt_prof_thread_active_init</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lg_prof_sample"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>opt_lg_prof_sample</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lg_prof_interval"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>opt_lg_prof_interval</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_gdump"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_prof_gdump</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_final"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_prof_final</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_leak"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_prof_leak</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof_accum"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>opt_prof_accum</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type>	<name><name>tcache_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"create"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>tcache_create</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"flush"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>tcache_flush</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"destroy"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>tcache_destroy</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>arena_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"initialized"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arena_i_initialized</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"decay"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arena_i_decay</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"purge"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arena_i_purge</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arena_i_reset</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"destroy"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arena_i_destroy</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dss"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arena_i_dss</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>arena_i_dirty_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>arena_i_muzzy_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"extent_hooks"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arena_i_extent_hooks</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"retain_grow_limit"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arena_i_retain_grow_limit</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_arena_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>arena_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>arena_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>arena_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>arenas_bin_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"size"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arenas_bin_i_size</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nregs"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arenas_bin_i_nregs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"slab_size"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_bin_i_slab_size</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nshards"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_bin_i_nshards</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_arenas_bin_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>arenas_bin_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>arenas_bin_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>arenas_bin_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>arenas_lextent_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"size"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arenas_lextent_i_size</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_arenas_lextent_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>arenas_lextent_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>arenas_lextent_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>arenas_lextent_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>arenas_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"narenas"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_narenas</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>arenas_dirty_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>arenas_muzzy_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"quantum"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_quantum</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"page"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arenas_page</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"tcache_max"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_tcache_max</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nbins"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>arenas_nbins</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nhbins"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_nhbins</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"bin"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>arenas_bin</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nlextents"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_nlextents</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lextent"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>arenas_lextent</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"create"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_create</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lookup"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>arenas_lookup</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type>	<name><name>prof_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"thread_active_init"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>prof_thread_active_init</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"active"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>prof_active</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dump"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>prof_dump</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"gdump"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>prof_gdump</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>prof_reset</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"interval"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>prof_interval</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lg_sample"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>lg_prof_sample</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"log_start"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>prof_log_start</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"log_stop"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>prof_log_stop</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_small_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"allocated"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_small_allocated</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nmalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_small_nmalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"ndalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_small_ndalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nrequests"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_small_nrequests</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nfills"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_small_nfills</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nflushes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_small_nflushes</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_large_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"allocated"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_large_allocated</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nmalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_large_nmalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"ndalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_large_ndalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nrequests"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_large_nrequests</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nfills"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_large_nfills</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nflushes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_large_nflushes</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_PROF_DATA_NODE</name><parameter_list>(<parameter><type><name>prefix</name></type></parameter>)</parameter_list></cpp:macro>					\
<cpp:value>static const ctl_named_node_t stats_##prefix##_node[] = {		\
	{NAME("num_ops"),						\
	 CTL(stats_##prefix##_num_ops)},				\
	{NAME("num_wait"),						\
	 CTL(stats_##prefix##_num_wait)},				\
	{NAME("num_spin_acq"),						\
	 CTL(stats_##prefix##_num_spin_acq)},				\
	{NAME("num_owner_switch"),					\
	 CTL(stats_##prefix##_num_owner_switch)},			\
	{NAME("total_wait_time"),					\
	 CTL(stats_##prefix##_total_wait_time)},			\
	{NAME("max_wait_time"),						\
	 CTL(stats_##prefix##_max_wait_time)},				\
	{NAME("max_num_thds"),						\
	 CTL(stats_##prefix##_max_num_thds)}				\
	<comment type="block">/* Note that # of current waiting thread not provided. */</comment>	\
};</cpp:value></cpp:define>

<macro><name>MUTEX_PROF_DATA_NODE</name><argument_list>(<argument>arenas_i_bins_j_mutex</argument>)</argument_list></macro>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_bins_j_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nmalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nmalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"ndalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_ndalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nrequests"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nrequests</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"curregs"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_curregs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nfills"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nfills</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nflushes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nflushes</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nslabs"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nslabs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nreslabs"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nreslabs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"curslabs"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_curslabs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nonfull_slabs"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_bins_j_nonfull_slabs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"mutex"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_bins_j_mutex</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_stats_arenas_i_bins_j_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_bins_j</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>stats_arenas_i_bins_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>stats_arenas_i_bins_j</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_lextents_j_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nmalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_lextents_j_nmalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"ndalloc"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_lextents_j_ndalloc</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nrequests"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_lextents_j_nrequests</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"curlextents"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_lextents_j_curlextents</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_stats_arenas_i_lextents_j_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_lextents_j</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>stats_arenas_i_lextents_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>stats_arenas_i_lextents_j</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_extents_j_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"ndirty"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extents_j_ndirty</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nmuzzy"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extents_j_nmuzzy</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nretained"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extents_j_nretained</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_bytes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extents_j_dirty_bytes</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_bytes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extents_j_muzzy_bytes</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"retained_bytes"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extents_j_retained_bytes</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_stats_arenas_i_extents_j_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_extents_j</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>stats_arenas_i_extents_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>stats_arenas_i_extents_j</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>MUTEX_PROF_DATA_NODE(arenas_i_mutexes_##mtx)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>MUTEX_PROF_ARENA_MUTEXES</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

<specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_mutexes_node</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{NAME(#mtx), CHILD(named, stats_arenas_i_mutexes_##mtx)},</cpp:value></cpp:define>
<expr><name>MUTEX_PROF_ARENA_MUTEXES</name></expr>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_arenas_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"nthreads"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_nthreads</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"uptime"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_uptime</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dss"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_dss</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_dirty_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_muzzy_decay_ms</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"pactive"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_pactive</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"pdirty"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_pdirty</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"pmuzzy"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_pmuzzy</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"mapped"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_mapped</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"retained"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_retained</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"extent_avail"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_extent_avail</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_npurge"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_dirty_npurge</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_nmadvise"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_dirty_nmadvise</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"dirty_purged"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_dirty_purged</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_npurge"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_muzzy_npurge</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_nmadvise"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_muzzy_nmadvise</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"muzzy_purged"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_muzzy_purged</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_base</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_internal</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"metadata_thp"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_metadata_thp</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"tcache_bytes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_tcache_bytes</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"resident"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_resident</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"abandoned_vm"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_arenas_i_abandoned_vm</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"small"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_small</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"large"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_large</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"bins"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>stats_arenas_i_bins</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"lextents"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>stats_arenas_i_lextents</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"extents"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>stats_arenas_i_extents</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"mutexes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i_mutexes</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_stats_arenas_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_arenas_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>stats_arenas_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>stats_arenas_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_background_thread_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"num_threads"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_background_thread_num_threads</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"num_runs"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_background_thread_num_runs</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"run_interval"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_background_thread_run_interval</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUTEX_PROF_DATA_NODE(mutexes_##mtx)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>MUTEX_PROF_GLOBAL_MUTEXES</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

<specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_mutexes_node</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{NAME(#mtx), CHILD(named, stats_mutexes_##mtx)},</cpp:value></cpp:define>
<expr><name>MUTEX_PROF_GLOBAL_MUTEXES</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
	<block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>stats_mutexes_reset</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MUTEX_PROF_DATA_NODE</name></cpp:undef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>stats_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"allocated"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_allocated</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"active"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_active</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"metadata"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_metadata</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"metadata_thp"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_metadata_thp</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"resident"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_resident</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"mapped"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_mapped</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"retained"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>stats_retained</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"background_thread"</literal></expr></argument>)</argument_list></call></expr>,
	 <macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_background_thread</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"mutexes"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats_mutexes</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"arenas"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>stats_arenas</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>experimental_hooks_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"install"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>experimental_hooks_install</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"remove"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>experimental_hooks_remove</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>experimental_utilization_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"query"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>experimental_utilization_query</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"batch_query"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>experimental_utilization_batch_query</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>experimental_arenas_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"pactivep"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>experimental_arenas_i_pactivep</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_experimental_arenas_i_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>experimental_arenas_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_indexed_node_t</name></type> <name><name>experimental_arenas_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<macro><name>INDEX</name><argument_list>(<argument>experimental_arenas_i</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>experimental_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"hooks"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>experimental_hooks</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"utilization"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>experimental_utilization</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"arenas"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>experimental_arenas</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type>	<name><name>root_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"version"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>version</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"epoch"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CTL</name><argument_list>(<argument>epoch</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"background_thread"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>background_thread</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"max_background_threads"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CTL</name><argument_list>(<argument>max_background_threads</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"thread"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>thread</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"config"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>config</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"opt"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>opt</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"tcache"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>tcache</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"arena"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>indexed</argument>, <argument>arena</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"arenas"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>arenas</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"prof"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>prof</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"stats"</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>stats</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">"experimental"</literal></expr></argument>)</argument_list></call></expr>,	<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>experimental</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name></type> <name><name>super_root_node</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><call><name>NAME</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,		<macro><name>CHILD</name><argument_list>(<argument>named</argument>, <argument>root</argument>)</argument_list></macro>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NAME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHILD</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CTL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INDEX</name></cpp:undef>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<comment type="block">/*
 * Sets *dst + *src non-atomically.  This is safe, since everything is
 * synchronized by the ctl mutex.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_accum_arena_stats_u64</name><parameter_list>(<parameter><decl><type><name>arena_stats_u64_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>arena_stats_u64_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_ATOMIC_U64</name></cpp:ifdef>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>cur_dst</name> <init>= <expr><call><name>atomic_load_u64</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>cur_src</name> <init>= <expr><call><name>atomic_load_u64</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>atomic_store_u64</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>cur_dst</name> <operator>+</operator> <name>cur_src</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>+=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Likewise: with ctl mutex synchronization, reading is simple. */</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>ctl_arena_stats_read_u64</name><parameter_list>(<parameter><decl><type><name>arena_stats_u64_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_ATOMIC_U64</name></cpp:ifdef>
	<return>return <expr><call><name>atomic_load_u64</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><operator>*</operator><name>p</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_atomic_zu</name><parameter_list>(<parameter><decl><type><name>atomic_zu_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>atomic_zu_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cur_dst</name> <init>= <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cur_src</name> <init>= <expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>cur_dst</name> <operator>+</operator> <name>cur_src</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>arenas_i2a_impl</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>compat</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>a</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>MALLCTL_ARENAS_ALL</name></expr>:</case>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>MALLCTL_ARENAS_DESTROYED</name></expr>:</case>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Provide deprecated backward compatibility for
			 * accessing the merged stats at index narenas rather
			 * than via MALLCTL_ARENAS_ALL.  This is scheduled for
			 * removal in 6.0.0.
			 */</comment>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>validate</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/*
			 * This function should never be called for an index
			 * more than one past the range of indices that have
			 * initialized ctl data.
			 */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>validate</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator>
			    <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>arenas_i2a</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arenas_i2a_impl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ctl_arena_t</name> <modifier>*</modifier></type>
<name>arenas_i_impl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>compat</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>compat</name> <operator>||</operator> <operator>!</operator><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>arenas</name><index>[<expr><call><name>arenas_i2a_impl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>compat</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>init</name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<struct>struct <name>container_s</name> <block>{
				<decl_stmt><decl><type><name>ctl_arena_t</name></type>		<name>ctl_arena</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ctl_arena_stats_t</name></type>	<name>astats</name></decl>;</decl_stmt>
			}</block>;</struct>
			<decl_stmt><decl><type><name><name>struct</name> <name>container_s</name></name> <modifier>*</modifier></type><name>cont</name> <init>=
			    <expr><operator>(</operator>struct <name>container_s</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>container_s</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>QUANTUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>cont</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>&amp;</operator><name><name>cont</name><operator>-&gt;</operator><name>ctl_arena</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>astats</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>cont</name><operator>-&gt;</operator><name>astats</name></name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ctl_arena_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>,
			    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl_arena_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>QUANTUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>arena_ind</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>arenas</name><index>[<expr><call><name>arenas_i2a_impl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>compat</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>arenas_i2a</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>arena_ind</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>arenas_i2a</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ctl_arena_t</name> <modifier>*</modifier></type>
<name>arenas_i</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>arenas_i_impl</name><argument_list>(<argument><expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_arena_clear</name><parameter_list>(<parameter><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>nthreads</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>dss</name></name> <operator>=</operator> <name><name>dss_prec_names</name><index>[<expr><name>dss_prec_limit</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>dirty_decay_ms</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>muzzy_decay_ms</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>pactive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>pdirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>pmuzzy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arena_stats_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>allocated_small</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nmalloc_small</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>ndalloc_small</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nrequests_small</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nfills_small</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nflushes_small</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SC_NBINS</name> <operator>*</operator>
		    <sizeof>sizeof<argument_list>(<argument><expr><name>bin_stats_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>lstats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>SC_NSIZES</name> <operator>-</operator> <name>SC_NBINS</name><operator>)</operator> <operator>*</operator>
		    <sizeof>sizeof<argument_list>(<argument><expr><name>arena_stats_large_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>estats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SC_NPSIZES</name> <operator>*</operator>
		    <sizeof>sizeof<argument_list>(<argument><expr><name>arena_stats_extents_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_arena_stats_amerge</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_arena</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_merge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>nthreads</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>dss</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>dirty_decay_ms</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>muzzy_decay_ms</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>pactive</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>pdirty</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>pmuzzy</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name></name></expr></argument>, <argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name></name></expr></argument>,
		    <argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>lstats</name></name></expr></argument>, <argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>estats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>allocated_small</name></name> <operator>+=</operator>
			    <name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curregs</name> <operator>*</operator>
			    <call><name>sz_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nmalloc_small</name></name> <operator>+=</operator>
			    <name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>ndalloc_small</name></name> <operator>+=</operator>
			    <name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nrequests_small</name></name> <operator>+=</operator>
			    <name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nfills_small</name></name> <operator>+=</operator>
			    <name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nfills</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>nflushes_small</name></name> <operator>+=</operator>
			    <name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nflushes</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>arena_basic_stats_merge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>nthreads</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>dss</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>dirty_decay_ms</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>muzzy_decay_ms</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>pactive</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>pdirty</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctl_arena</name><operator>-&gt;</operator><name>pmuzzy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_arena_stats_sdmerge</name><parameter_list>(<parameter><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_sdarena</name></decl></parameter>, <parameter><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_arena</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>destroyed</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ctl_sdarena</name><operator>-&gt;</operator><name>nthreads</name></name> <operator>+=</operator> <name><name>ctl_arena</name><operator>-&gt;</operator><name>nthreads</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_sdarena</name><operator>-&gt;</operator><name>pactive</name></name> <operator>+=</operator> <name><name>ctl_arena</name><operator>-&gt;</operator><name>pactive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_sdarena</name><operator>-&gt;</operator><name>pdirty</name></name> <operator>+=</operator> <name><name>ctl_arena</name><operator>-&gt;</operator><name>pdirty</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_sdarena</name><operator>-&gt;</operator><name>pmuzzy</name></name> <operator>+=</operator> <name><name>ctl_arena</name><operator>-&gt;</operator><name>pmuzzy</name></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>nthreads</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>pactive</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>pdirty</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>pmuzzy</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>ctl_arena_stats_t</name> <modifier>*</modifier></type><name>sdstats</name> <init>= <expr><name><name>ctl_sdarena</name><operator>-&gt;</operator><name>astats</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ctl_arena_stats_t</name> <modifier>*</modifier></type><name>astats</name> <init>= <expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>astats</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>mapped</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>mapped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>retained</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>retained</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>extent_avail</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>extent_avail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>npurge</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>npurge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>nmadvise</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>nmadvise</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>purged</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>purged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>npurge</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>npurge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>nmadvise</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>nmadvise</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>purged</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>purged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>malloc_mutex_prof_merge(				\
		    &amp;(sdstats-&gt;astats.mutex_prof_data[			\
		        arena_prof_mutex_##mtx]),			\
		    &amp;(astats-&gt;astats.mutex_prof_data[			\
		        arena_prof_mutex_##mtx]));</cpp:value></cpp:define>
<macro><name>MUTEX_PROF_ARENA_MUTEXES</name></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>base</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>internal</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>resident</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>resident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>metadata_thp</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>metadata_thp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>atomic_load_zu</name><argument_list>(
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>internal</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>allocated_small</name></name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>allocated_small</name></name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>astats</name><operator>-&gt;</operator><name>allocated_small</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>nmalloc_small</name></name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>nmalloc_small</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>ndalloc_small</name></name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>ndalloc_small</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>nrequests_small</name></name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>nrequests_small</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>nfills_small</name></name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>nfills_small</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>nflushes_small</name></name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>nflushes_small</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>allocated_large</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>allocated_large</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>allocated_large</name></name></expr></argument>,
			    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>nmalloc_large</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>nmalloc_large</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>ndalloc_large</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>ndalloc_large</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>nrequests_large</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>nrequests_large</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>abandoned_vm</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>abandoned_vm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>tcache_bytes</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>tcache_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>arena_ind</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>uptime</name></name> <operator>=</operator> <name><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>uptime</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Merge bin stats. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name> <operator>+=</operator>
			    <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curregs</name> <operator>+=</operator>
				    <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curregs</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curregs</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nfills</name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nfills</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nflushes</name> <operator>+=</operator>
			    <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nflushes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nslabs</name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nslabs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reslabs</name> <operator>+=</operator> <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reslabs</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curslabs</name> <operator>+=</operator>
				    <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curslabs</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nonfull_slabs</name> <operator>+=</operator>
				    <name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nonfull_slabs</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curslabs</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nonfull_slabs</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_prof_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mutex_data</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mutex_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Merge stats for large allocations. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NSIZES</name> <operator>-</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ctl_accum_arena_stats_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroyed</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>sdstats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curlextents</name> <operator>+=</operator>
				    <name><name>astats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curlextents</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>astats</name><operator>-&gt;</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curlextents</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Merge extents stats. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NPSIZES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndirty</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmuzzy</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmuzzy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nretained</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nretained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dirty_bytes</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dirty_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>muzzy_bytes</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>muzzy_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_atomic_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdstats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>retained_bytes</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>retained_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_arena_refresh</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_sdarena</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>destroyed</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_arena</name> <init>= <expr><call><name>arenas_i</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ctl_arena_clear</name><argument_list>(<argument><expr><name>ctl_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ctl_arena_stats_amerge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ctl_arena</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Merge into sum stats as well. */</comment>
	<expr_stmt><expr><call><name>ctl_arena_stats_sdmerge</name><argument_list>(<argument><expr><name>ctl_sdarena</name></expr></argument>, <argument><expr><name>ctl_arena</name></expr></argument>, <argument><expr><name>destroyed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>ctl_arena_init</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_arena</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ctl_arena</name> <operator>=</operator> <call><name>ql_last</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_arenas</name><operator>-&gt;</operator><name>destroyed</name></name></expr></argument>, <argument><expr><name>destroyed_link</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
	    <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ql_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_arenas</name><operator>-&gt;</operator><name>destroyed</name></name></expr></argument>, <argument><expr><name>ctl_arena</name></expr></argument>, <argument><expr><name>destroyed_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arena_ind</name> <operator>=</operator> <name><name>ctl_arena</name><operator>-&gt;</operator><name>arena_ind</name></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>arena_ind</name> <operator>=</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Trigger stats allocation. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>arenas_i_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>UINT_MAX</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize new arena. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>arena_init</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>extent_hooks</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>UINT_MAX</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>==</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>arena_ind</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_background_thread_stats_read</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>background_thread_stats_t</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><operator>&amp;</operator><name><name>ctl_stats</name><operator>-&gt;</operator><name>background_thread</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_background_thread</name> <operator>||</operator>
	    <call><name>background_thread_stats_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>background_thread_stats_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>run_interval</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ctl_refresh</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_sarena</name> <init>= <expr><call><name>arenas_i</name><argument_list>(<argument><expr><name>MALLCTL_ARENAS_ALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>VARIABLE_ARRAY</name><argument_list>(<argument><expr><name>arena_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>tarenas</name></expr></argument>, <argument><expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear sum stats, since they will be merged into by
	 * ctl_arena_refresh().
	 */</comment>
	<expr_stmt><expr><call><name>ctl_arena_clear</name><argument_list>(<argument><expr><name>ctl_sarena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>tarenas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_arena</name> <init>= <expr><call><name>arenas_i</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>initialized</name> <init>= <expr><operator>(</operator><name><name>tarenas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>initialized</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>initialized</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ctl_arena_refresh</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tarenas</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ctl_sarena</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
			    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>allocated_small</name></name> <operator>+</operator>
		    <call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>allocated_large</name></name></expr></argument>,
			<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <operator>(</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>pactive</name></name> <operator>&lt;&lt;</operator> <name>LG_PAGE</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>metadata</name></name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(
		    <argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>+</operator>
		    <call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>internal</name></name></expr></argument>,
			<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>metadata_thp</name></name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(
		    <argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>metadata_thp</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>resident</name></name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(
		    <argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>resident</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>mapped</name></name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(
		    <argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>mapped</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_stats</name><operator>-&gt;</operator><name>retained</name></name> <operator>=</operator> <call><name>atomic_load_zu</name><argument_list>(
		    <argument><expr><operator>&amp;</operator><name><name>ctl_sarena</name><operator>-&gt;</operator><name>astats</name><operator>-&gt;</operator><name>astats</name><operator>.</operator><name>retained</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ctl_background_thread_stats_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_GLOBAL_MUTEX_PROF_DATA</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro>				\
    <cpp:value>malloc_mutex_lock(tsdn, &amp;mtx);					\
    malloc_mutex_prof_read(tsdn, &amp;ctl_stats-&gt;mutex_prof_data[i], &amp;mtx);	\
    malloc_mutex_unlock(tsdn, &amp;mtx);</cpp:value></cpp:define>

		<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>READ_GLOBAL_MUTEX_PROF_DATA</name><argument_list>(<argument><expr><name>global_prof_mutex_prof</name></expr></argument>,
			    <argument><expr><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>READ_GLOBAL_MUTEX_PROF_DATA</name><argument_list>(
			    <argument><expr><name>global_prof_mutex_background_thread</name></expr></argument>,
			    <argument><expr><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_stats</name><operator>-&gt;</operator><name>mutex_prof_data</name><index>[
			    <expr><name>global_prof_mutex_background_thread</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mutex_prof_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* We own ctl mutex already. */</comment>
		<expr_stmt><expr><call><name>malloc_mutex_prof_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>ctl_stats</name><operator>-&gt;</operator><name>mutex_prof_data</name><index>[<expr><name>global_prof_mutex_ctl</name></expr>]</index></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>READ_GLOBAL_MUTEX_PROF_DATA</name></cpp:undef>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>epoch</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ctl_init</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl_initialized</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_sarena</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ctl_darena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate demand-zeroed space for pointers to the full
		 * range of supported arena indices.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ctl_arenas</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ctl_arenas</name> <operator>=</operator> <operator>(</operator><name>ctl_arenas_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
			    <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl_arenas_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>QUANTUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ctl_arenas</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>config_stats</name> <operator>&amp;&amp;</operator> <name>ctl_stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ctl_stats</name> <operator>=</operator> <operator>(</operator><name>ctl_stats_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>,
			    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl_stats_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>QUANTUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ctl_stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Allocate space for the current full range of arenas
		 * here rather than doing it lazily elsewhere, in order
		 * to limit when OOM-caused errors can occur.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ctl_sarena</name> <operator>=</operator> <call><name>arenas_i_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>MALLCTL_ARENAS_ALL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>ctl_sarena</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ctl_darena</name> <operator>=</operator> <call><name>arenas_i_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>MALLCTL_ARENAS_DESTROYED</name></expr></argument>,
		    <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ctl_arena_clear</name><argument_list>(<argument><expr><name>ctl_darena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Don't toggle ctl_darena to initialized until an arena is
		 * actually destroyed, so that arena.&lt;i&gt;.initialized can be used
		 * to query whether the stats are relevant.
		 */</comment>

		<expr_stmt><expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>arenas_i_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>ql_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_arenas</name><operator>-&gt;</operator><name>destroyed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ctl_refresh</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctl_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ctl_lookup</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ctl_node_t</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>nodesp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>mibp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>depthp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tdot</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>elen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>elm</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<comment type="block">/* Equivalent to strchrnul(). */</comment>
	<expr_stmt><expr><name>dot</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>tdot</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>elm</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>tdot</name></expr> </then><else>: <expr><call><name>strchr</name><argument_list>(<argument><expr><name>elm</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>elen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>dot</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>elm</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name>super_root_node</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>depthp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nchildren</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ctl_named_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>pnode</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Children are named. */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nchildren</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>child</name> <init>=
				    <expr><call><name>ctl_named_children</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>child</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>elen</name> <operator>&amp;&amp;</operator>
				    <call><name>strncmp</name><argument_list>(<argument><expr><name>elm</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>elen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nodesp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name><name>nodesp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						    <operator>(</operator><specifier>const</specifier> <name>ctl_node_t</name> <operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>mibp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>pnode</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name>uintmax_t</name></type> <name>index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_indexed_node_t</name> <modifier>*</modifier></type><name>inode</name></decl>;</decl_stmt>

			<comment type="block">/* Children are indexed. */</comment>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>malloc_strtoumax</name><argument_list>(<argument><expr><name>elm</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>UINTMAX_MAX</name> <operator>||</operator> <name>index</name> <operator>&gt;</operator> <name>SIZE_T_MAX</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>inode</name> <operator>=</operator> <call><name>ctl_indexed_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>inode</name><operator>-&gt;</operator><name>index</name></name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>mibp</name></expr></argument>, <argument><expr><operator>*</operator><name>depthp</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>nodesp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>nodesp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>ctl_node_t</name> <operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>mibp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>index</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ctl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Terminal node. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dot</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * The name contains more elements than are
				 * in this path through the tree.
				 */</comment>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Complete lookup successful. */</comment>
			<expr_stmt><expr><operator>*</operator><name>depthp</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update elm. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dot</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* No more elements. */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>elm</name> <operator>=</operator> <operator>&amp;</operator><name><name>dot</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dot</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>tdot</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>elm</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>tdot</name></expr> </then><else>:
		    <expr><call><name>strchr</name><argument_list>(<argument><expr><name>elm</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>elen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>dot</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>elm</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ctl_byname</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>depth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ctl_node_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name><name>nodes</name><index>[<expr><name>CTL_MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name><name>mib</name><index>[<expr><name>CTL_MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl_initialized</name> <operator>&amp;&amp;</operator> <call><name>ctl_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>depth</name> <operator>=</operator> <name>CTL_MAX_DEPTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ctl_lookup</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ctl_named_node</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>depth</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>ctl</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>node</name><operator>-&gt;</operator><name>ctl</name></name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* The name refers to a partial path through the ctl tree. */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<label><name>label_return</name>:</label>
	<return>return<expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ctl_nametomib</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>mibp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>miblenp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl_initialized</name> <operator>&amp;&amp;</operator> <call><name>ctl_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ctl_lookup</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mibp</name></expr></argument>, <argument><expr><name>miblenp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return<expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ctl_bymib</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl_initialized</name> <operator>&amp;&amp;</operator> <call><name>ctl_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Iterate down the tree. */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name>super_root_node</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>miblen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nchildren</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ctl_named_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Children are named. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nchildren</name></name> <operator>&lt;=</operator> <name><name>mib</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ctl_named_children</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>mib</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_indexed_node_t</name> <modifier>*</modifier></type><name>inode</name></decl>;</decl_stmt>

			<comment type="block">/* Indexed element. */</comment>
			<expr_stmt><expr><name>inode</name> <operator>=</operator> <call><name>ctl_indexed_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>inode</name><operator>-&gt;</operator><name>index</name></name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name><name>mib</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Call the ctl function. */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>ctl</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>node</name><operator>-&gt;</operator><name>ctl</name></name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* Partial MIB. */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<label><name>label_return</name>:</label>
	<return>return<expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ctl_boot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>, <argument><expr><literal type="string">"ctl"</literal></expr></argument>, <argument><expr><name>WITNESS_RANK_CTL</name></expr></argument>,
	    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ctl_initialized</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ctl_prefork</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ctl_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ctl_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* *_ctl() functions. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READONLY</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>do {						\
	if (newp != NULL || newlen != 0) {				\
		ret = EPERM;						\
		goto label_return;					\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEONLY</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>do {						\
	if (oldp != NULL || oldlenp != NULL) {				\
		ret = EPERM;						\
		goto label_return;					\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_XOR_WRITE</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>do {					\
	if ((oldp != NULL &amp;&amp; oldlenp != NULL) &amp;&amp; (newp != NULL ||	\
	    newlen != 0)) {						\
		ret = EPERM;						\
		goto label_return;					\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {						\
	if (oldp != NULL &amp;&amp; oldlenp != NULL) {				\
		if (*oldlenp != sizeof(t)) {				\
			size_t	copylen = (sizeof(t) &lt;= *oldlenp)	\
			    ? sizeof(t) : *oldlenp;			\
			memcpy(oldp, (void *)&amp;(v), copylen);		\
			ret = EINVAL;					\
			goto label_return;				\
		}							\
		*(t *)oldp = (v);					\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {						\
	if (newp != NULL) {						\
		if (newlen != sizeof(t)) {				\
			ret = EINVAL;					\
			goto label_return;				\
		}							\
		(v) = *(t *)newp;					\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIB_UNSIGNED</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {						\
	if (mib[i] &gt; UINT_MAX) {					\
		ret = EFAULT;						\
		goto label_return;					\
	}								\
	v = (unsigned)mib[i];						\
} while (0)</cpp:value></cpp:define>

<comment type="block">/*
 * There's a lot of code duplication in the following macros due to limitations
 * in how nested cpp macros are expanded.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_RO_CLGEN</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>					\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
    size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	if (!(c)) {							\
		return ENOENT;						\
	}								\
	if (l) {							\
		malloc_mutex_lock(tsd_tsdn(tsd), &amp;ctl_mtx);		\
	}								\
	READONLY();							\
	oldval = (v);							\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	if (l) {							\
		malloc_mutex_unlock(tsd_tsdn(tsd), &amp;ctl_mtx);		\
	}								\
	return ret;							\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_RO_CGEN</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>						\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, \
    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	if (!(c)) {							\
		return ENOENT;						\
	}								\
	malloc_mutex_lock(tsd_tsdn(tsd), &amp;ctl_mtx);			\
	READONLY();							\
	oldval = (v);							\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	malloc_mutex_unlock(tsd_tsdn(tsd), &amp;ctl_mtx);			\
	return ret;							\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_RO_GEN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>						\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
    size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	malloc_mutex_lock(tsd_tsdn(tsd), &amp;ctl_mtx);			\
	READONLY();							\
	oldval = (v);							\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	malloc_mutex_unlock(tsd_tsdn(tsd), &amp;ctl_mtx);			\
	return ret;							\
}</cpp:value></cpp:define>

<comment type="block">/*
 * ctl_mtx is not acquired, under the assumption that no pertinent data will
 * mutate during the call.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_RO_NL_CGEN</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>					\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, \
    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	if (!(c)) {							\
		return ENOENT;						\
	}								\
	READONLY();							\
	oldval = (v);							\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	return ret;							\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_RO_NL_GEN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>						\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, \
    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	READONLY();							\
	oldval = (v);							\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	return ret;							\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_TSD_RO_NL_CGEN</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>m</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>					\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
    size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	if (!(c)) {							\
		return ENOENT;						\
	}								\
	READONLY();							\
	oldval = (m(tsd));						\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	return ret;							\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_RO_CONFIG_GEN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>						\
<cpp:value>static int								\
n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, \
    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {			\
	int ret;							\
	t oldval;							\
									\
	READONLY();							\
	oldval = n;							\
	READ(oldval, t);						\
									\
	ret = 0;							\
label_return:								\
	return ret;							\
}</cpp:value></cpp:define>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>version</argument>, <argument>JEMALLOC_VERSION</argument>, <argument>const char *</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>epoch_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UNUSED</name> <name>uint64_t</name></type> <name>newval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ctl_refresh</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>background_thread_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>background_thread_ctl_init</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>newval</name> <init>= <expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>oldval</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>background_thread_enabled_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newval</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>background_threads_enable</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>background_threads_disable</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>max_background_threads_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>oldval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>background_thread_ctl_init</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <name>max_background_threads</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <name>max_background_threads</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>size_t</name></type> <name>newval</name> <init>= <expr><operator>*</operator><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>oldval</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>&gt;</operator> <name>opt_max_background_threads</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>background_thread_enabled_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>background_threads_disable</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>max_background_threads</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>background_thread_enabled_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>background_threads_enable</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>max_background_threads</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_cache_oblivious</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_debug</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_fill</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_lazy_lock</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_malloc_conf</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_opt_safety_checks</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_prof</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_prof_libgcc</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_prof_libunwind</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_stats</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_utrace</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_CONFIG_GEN</name><argument_list>(<argument>config_xmalloc</argument>, <argument>bool</argument>)</argument_list></macro>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_abort</argument>, <argument>opt_abort</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_abort_conf</argument>, <argument>opt_abort_conf</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_confirm_conf</argument>, <argument>opt_confirm_conf</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_metadata_thp</argument>, <argument>metadata_thp_mode_names[opt_metadata_thp]</argument>,
    <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_retain</argument>, <argument>opt_retain</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_dss</argument>, <argument>opt_dss</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_narenas</argument>, <argument>opt_narenas</argument>, <argument>unsigned</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_percpu_arena</argument>, <argument>percpu_arena_mode_names[opt_percpu_arena]</argument>,
    <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_oversize_threshold</argument>, <argument>opt_oversize_threshold</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_background_thread</argument>, <argument>opt_background_thread</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_max_background_threads</argument>, <argument>opt_max_background_threads</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_dirty_decay_ms</argument>, <argument>opt_dirty_decay_ms</argument>, <argument>ssize_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_muzzy_decay_ms</argument>, <argument>opt_muzzy_decay_ms</argument>, <argument>ssize_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_stats_print</argument>, <argument>opt_stats_print</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_stats_print_opts</argument>, <argument>opt_stats_print_opts</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_fill</argument>, <argument>opt_junk</argument>, <argument>opt_junk</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_fill</argument>, <argument>opt_zero</argument>, <argument>opt_zero</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_utrace</argument>, <argument>opt_utrace</argument>, <argument>opt_utrace</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_xmalloc</argument>, <argument>opt_xmalloc</argument>, <argument>opt_xmalloc</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_tcache</argument>, <argument>opt_tcache</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_thp</argument>, <argument>thp_mode_names[opt_thp]</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_lg_extent_max_active_fit</argument>, <argument>opt_lg_extent_max_active_fit</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>opt_lg_tcache_max</argument>, <argument>opt_lg_tcache_max</argument>, <argument>ssize_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof</argument>, <argument>opt_prof</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_prefix</argument>, <argument>opt_prof_prefix</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_active</argument>, <argument>opt_prof_active</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_thread_active_init</argument>,
    <argument>opt_prof_thread_active_init</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_lg_prof_sample</argument>, <argument>opt_lg_prof_sample</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_accum</argument>, <argument>opt_prof_accum</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_lg_prof_interval</argument>, <argument>opt_lg_prof_interval</argument>, <argument>ssize_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_gdump</argument>, <argument>opt_prof_gdump</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_final</argument>, <argument>opt_prof_final</argument>, <argument>bool</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>opt_prof_leak</argument>, <argument>opt_prof_leak</argument>, <argument>bool</argument>)</argument_list></macro>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>thread_arena_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>oldarena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>newind</name></decl>, <decl><type ref="prev"/><name>oldind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldarena</name> <operator>=</operator> <call><name>arena_choose</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldarena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>EAGAIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>newind</name> <operator>=</operator> <name>oldind</name> <operator>=</operator> <call><name>arena_ind_get</name><argument_list>(<argument><expr><name>oldarena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>newind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newind</name> <operator>!=</operator> <name>oldind</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>newarena</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newind</name> <operator>&gt;=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/* New arena index is out of range. */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_percpu_arena</name> <operator>&amp;&amp;</operator>
		    <call><name>PERCPU_ARENA_ENABLED</name><argument_list>(<argument><expr><name>opt_percpu_arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>newind</name> <operator>&lt;</operator> <call><name>percpu_arena_ind_limit</name><argument_list>(<argument><expr><name>opt_percpu_arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * If perCPU arena is enabled, thread_arena
				 * control is not allowed for the auto arena
				 * range.
				 */</comment>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EPERM</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Initialize arena if necessary. */</comment>
		<expr_stmt><expr><name>newarena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newarena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Set new arena/tcache associations. */</comment>
		<expr_stmt><expr><call><name>arena_migrate</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>oldind</name></expr></argument>, <argument><expr><name>newind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>tcache_available</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tcache_arena_reassociate</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newarena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>CTL_TSD_RO_NL_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>thread_allocated</argument>, <argument>tsd_thread_allocated_get</argument>,
    <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_TSD_RO_NL_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>thread_allocatedp</argument>, <argument>tsd_thread_allocatedp_get</argument>,
    <argument>uint64_t *</argument>)</argument_list></macro>
<macro><name>CTL_TSD_RO_NL_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>thread_deallocated</argument>, <argument>tsd_thread_deallocated_get</argument>,
    <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_TSD_RO_NL_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>thread_deallocatedp</argument>,
    <argument>tsd_thread_deallocatedp_get</argument>, <argument>uint64_t *</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>thread_tcache_enabled_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>tcache_enabled_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>tcache_enabled_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>thread_tcache_flush_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tcache_available</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tcache_flush</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>thread_prof_name_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>READ_XOR_WRITE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>prof_thread_name_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
		    <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldname</name> <init>= <expr><call><name>prof_thread_name_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>thread_prof_active_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_thread_active_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>prof_thread_active_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tcache_create_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>tcache_ind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tcaches_create</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcache_ind</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>tcache_ind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tcache_flush_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>tcache_ind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tcache_ind</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>tcache_ind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tcache_ind</name> <operator>==</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>tcaches_flush</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tcache_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tcache_destroy_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>tcache_ind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tcache_ind</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>tcache_ind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tcache_ind</name> <operator>==</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>tcaches_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tcache_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_initialized_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>initialized</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initialized</name> <operator>=</operator> <call><name>arenas_i</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>initialized</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>initialized</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_i_decay</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas</name> <init>= <expr><name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Access via index narenas is deprecated, and scheduled for
		 * removal in 6.0.0.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>==</operator> <name>MALLCTL_ARENAS_ALL</name> <operator>||</operator> <name>arena_ind</name> <operator>==</operator> <name>narenas</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>VARIABLE_ARRAY</name><argument_list>(<argument><expr><name>arena_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>tarenas</name></expr></argument>, <argument><expr><name>narenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name><name>tarenas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * No further need to hold ctl_mtx, since narenas and
			 * tarenas contain everything needed below.
			 */</comment>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tarenas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>arena_decay</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tarenas</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					    <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>tarena</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arena_ind</name> <operator>&lt;</operator> <name>narenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tarena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* No further need to hold ctl_mtx. */</comment>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>tarena</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>arena_decay</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tarena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_decay_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_i_decay</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_purge_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_i_decay</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_reset_destroy_helper</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>arena_ind</name></decl></parameter>,
    <parameter><decl><type><name>arena_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><operator>*</operator><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arena</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>arena_is_auto</name><argument_list>(<argument><expr><operator>*</operator><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_reset_prepare_background_thread</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Temporarily disable the background thread during arena reset. */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>=
			    <expr><call><name>background_thread_info_get</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_paused</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_reset_finish_background_thread</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>=
			    <expr><call><name>background_thread_info_get</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_paused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_started</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_reset_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_i_reset_destroy_helper</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>,
	    <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arena_ind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>arena_reset_prepare_background_thread</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_reset</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_reset_finish_background_thread</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_destroy_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ctl_arena_t</name> <modifier>*</modifier></type><name>ctl_darena</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ctl_arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_i_reset_destroy_helper</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>,
	    <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arena_ind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>arena_nthreads_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>arena_nthreads_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>,
	    <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>arena_reset_prepare_background_thread</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Merge stats after resetting and purging arena. */</comment>
	<expr_stmt><expr><call><name>arena_reset</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_decay</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctl_darena</name> <operator>=</operator> <call><name>arenas_i</name><argument_list>(<argument><expr><name>MALLCTL_ARENAS_DESTROYED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_darena</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ctl_arena_refresh</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>ctl_darena</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Destroy arena. */</comment>
	<expr_stmt><expr><call><name>arena_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctl_arena</name> <operator>=</operator> <call><name>arenas_i</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_arena</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Record arena index for later recycling via arenas.create. */</comment>
	<expr_stmt><expr><call><name>ql_elm_new</name><argument_list>(<argument><expr><name>ctl_arena</name></expr></argument>, <argument><expr><name>destroyed_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_tail_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl_arenas</name><operator>-&gt;</operator><name>destroyed</name></name></expr></argument>, <argument><expr><name>ctl_arena</name></expr></argument>, <argument><expr><name>destroyed_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_reset_finish_background_thread</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_dss_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dss_prec_t</name></type> <name>dss_prec_old</name> <init>= <expr><name>dss_prec_limit</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dss_prec_t</name></type> <name>dss_prec</name> <init>= <expr><name>dss_prec_limit</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>dss</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dss</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dss_prec_limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dss_prec_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dss</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>dss_prec</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Access via index narenas is deprecated, and scheduled for removal in
	 * 6.0.0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>==</operator> <name>MALLCTL_ARENAS_ALL</name> <operator>||</operator> <name>arena_ind</name> <operator>==</operator>
	    <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dss_prec</name> <operator>!=</operator> <name>dss_prec_limit</name> <operator>&amp;&amp;</operator>
		    <call><name>extent_dss_prec_set</name><argument_list>(<argument><expr><name>dss_prec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>dss_prec_old</name> <operator>=</operator> <call><name>extent_dss_prec_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>dss_prec</name> <operator>!=</operator> <name>dss_prec_limit</name> <operator>&amp;&amp;</operator>
		    <call><name>arena_dss_prec_set</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>dss_prec</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>dss_prec_old</name> <operator>=</operator> <call><name>arena_dss_prec_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>dss</name> <operator>=</operator> <name><name>dss_prec_names</name><index>[<expr><name>dss_prec_old</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>dss</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_decay_ms_ctl_impl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dirty</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>oldlenp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>oldval</name> <init>= <expr><ternary><condition><expr><name>dirty</name></expr> ?</condition><then> <expr><call><name>arena_dirty_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr> </then><else>:
		    <expr><call><name>arena_muzzy_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ssize_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>arena_is_huge</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ssize_t</name> <operator>*</operator><operator>)</operator><name>newp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * By default the huge arena purges eagerly.  If it is
			 * set to non-zero decay time afterwards, background
			 * thread might be needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>background_thread_create</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>dirty</name></expr> ?</condition><then> <expr><call><name>arena_dirty_decay_ms_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
		    <argument><expr><operator>*</operator><operator>(</operator><name>ssize_t</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>arena_muzzy_decay_ms_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>ssize_t</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_dirty_decay_ms_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_i_decay_ms_ctl_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>,
	    <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_muzzy_decay_ms_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_i_decay_ms_ctl_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>,
	    <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_extent_hooks_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>&lt;</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>old_extent_hooks</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>&gt;=</operator> <name>narenas_auto</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
				<goto>goto <name>label_return</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>old_extent_hooks</name> <operator>=</operator>
			    <operator>(</operator><name>extent_hooks_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>extent_hooks_default</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>old_extent_hooks</name></expr></argument>, <argument><expr><name>extent_hooks_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* Initialize a new arena as a side effect. */</comment>
				<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><name>new_extent_hooks</name></type>
				    <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>new_extent_hooks</name></expr></argument>, <argument><expr><name>extent_hooks_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_init</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>,
				    <argument><expr><name>new_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
					<goto>goto <name>label_return</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><name>new_extent_hooks</name></type>
				    <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>new_extent_hooks</name></expr></argument>, <argument><expr><name>extent_hooks_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>old_extent_hooks</name> <operator>=</operator> <call><name>extent_hooks_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
				    <argument><expr><name>new_extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>old_extent_hooks</name></expr></argument>, <argument><expr><name>extent_hooks_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>old_extent_hooks</name> <operator>=</operator> <call><name>extent_hooks_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>old_extent_hooks</name></expr></argument>, <argument><expr><name>extent_hooks_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arena_i_retain_grow_limit_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_retain</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Only relevant when retain is enabled. */</comment>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>&lt;</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>arena</name> <operator>=</operator>
	    <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>old_limit</name></decl>, <decl><type ref="prev"/><name>new_limit</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>new_limit</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>arena_retain_grow_limit_get_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>old_limit</name></expr></argument>, <argument><expr><ternary><condition><expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>new_limit</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>old_limit</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>arena_i_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>MALLCTL_ARENAS_ALL</name></expr>:</case>
	<case>case <expr><name>MALLCTL_ARENAS_DESTROYED</name></expr>:</case>
		<break>break;</break>
	<default>default:</default>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>super_arena_i_node</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arenas_narenas_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>oldlenp</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>narenas</name> <operator>=</operator> <name><name>ctl_arenas</name><operator>-&gt;</operator><name>narenas</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>narenas</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arenas_decay_ms_ctl_impl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dirty</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>oldlenp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>oldval</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>dirty</name></expr> ?</condition><then> <expr><call><name>arena_dirty_decay_ms_default_get</name><argument_list>()</argument_list></call></expr> </then><else>:
		    <expr><call><name>arena_muzzy_decay_ms_default_get</name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ssize_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>dirty</name></expr> ?</condition><then> <expr><call><name>arena_dirty_decay_ms_default_set</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ssize_t</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr>
		    </then><else>: <expr><call><name>arena_muzzy_decay_ms_default_set</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ssize_t</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arenas_dirty_decay_ms_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arenas_decay_ms_ctl_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>,
	    <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arenas_muzzy_decay_ms_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arenas_decay_ms_ctl_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>,
	    <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_quantum</argument>, <argument>QUANTUM</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_page</argument>, <argument>PAGE</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_tcache_max</argument>, <argument>tcache_maxclass</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_nbins</argument>, <argument>SC_NBINS</argument>, <argument>unsigned</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_nhbins</argument>, <argument>nhbins</argument>, <argument>unsigned</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_bin_i_size</argument>, <argument>bin_infos[mib[<literal type="number">2</literal>]].reg_size</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_bin_i_nregs</argument>, <argument>bin_infos[mib[<literal type="number">2</literal>]].nregs</argument>, <argument>uint32_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_bin_i_slab_size</argument>, <argument>bin_infos[mib[<literal type="number">2</literal>]].slab_size</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_bin_i_nshards</argument>, <argument>bin_infos[mib[<literal type="number">2</literal>]].n_shards</argument>, <argument>uint32_t</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>arenas_bin_i_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>SC_NBINS</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>super_arenas_bin_i_node</name></expr>;</return>
</block_content>}</block></function>

<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_nlextents</argument>, <argument>SC_NSIZES - SC_NBINS</argument>, <argument>unsigned</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_GEN</name><argument_list>(<argument>arenas_lextent_i_size</argument>, <argument>sz_index2size(SC_NBINS+(szind_t)mib[<literal type="number">2</literal>])</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>arenas_lextent_i_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>SC_NSIZES</name> <operator>-</operator> <name>SC_NBINS</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>super_arenas_lextent_i_node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arenas_create_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extent_hooks</name> <operator>=</operator> <operator>(</operator><name>extent_hooks_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>extent_hooks_default</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>extent_hooks</name></expr></argument>, <argument><expr><name>extent_hooks_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arena_ind</name> <operator>=</operator> <call><name>ctl_arena_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>extent_hooks</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>arenas_lookup_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>iealloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>label_return</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>label_return</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arena_ind</name> <operator>=</operator> <call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_thread_active_init_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_thread_active_init_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_thread_active_init_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_active_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_active_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_active_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_dump_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_mdump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_gdump_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_gdump_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>newp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>prof_gdump_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_reset_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>lg_sample</name> <init>= <expr><name>lg_prof_sample</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>lg_sample</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lg_sample</name> <operator>&gt;=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>lg_sample</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>prof_reset</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>lg_sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>prof_interval</argument>, <argument>prof_interval</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_NL_CGEN</name><argument_list>(<argument>config_prof</argument>, <argument>lg_prof_sample</argument>, <argument>lg_prof_sample</argument>, <argument>size_t</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_log_start_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_log_start</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_log_stop_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_log_stop</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>EFAULT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_allocated</argument>, <argument>ctl_stats-&gt;allocated</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_active</argument>, <argument>ctl_stats-&gt;active</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_metadata</argument>, <argument>ctl_stats-&gt;metadata</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_metadata_thp</argument>, <argument>ctl_stats-&gt;metadata_thp</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_resident</argument>, <argument>ctl_stats-&gt;resident</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_mapped</argument>, <argument>ctl_stats-&gt;mapped</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_retained</argument>, <argument>ctl_stats-&gt;retained</argument>, <argument>size_t</argument>)</argument_list></macro>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_background_thread_num_threads</argument>,
    <argument>ctl_stats-&gt;background_thread.num_threads</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_background_thread_num_runs</argument>,
    <argument>ctl_stats-&gt;background_thread.num_runs</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_background_thread_run_interval</argument>,
    <argument>nstime_ns(&amp;ctl_stats-&gt;background_thread.run_interval)</argument>, <argument>uint64_t</argument>)</argument_list></macro>

<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_dss</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;dss</argument>, <argument>const char *</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_dirty_decay_ms</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;dirty_decay_ms</argument>,
    <argument>ssize_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_muzzy_decay_ms</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;muzzy_decay_ms</argument>,
    <argument>ssize_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_nthreads</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;nthreads</argument>, <argument>unsigned</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_uptime</argument>,
    <argument>nstime_ns(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.uptime)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_pactive</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;pactive</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_pdirty</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;pdirty</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_GEN</name><argument_list>(<argument>stats_arenas_i_pmuzzy</argument>, <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;pmuzzy</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_mapped</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.mapped, ATOMIC_RELAXED)</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_retained</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.retained, ATOMIC_RELAXED)</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_extent_avail</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.extent_avail,
        ATOMIC_RELAXED)</argument>,
    <argument>size_t</argument>)</argument_list></macro>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_dirty_npurge</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.decay_dirty.npurge)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_dirty_nmadvise</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.decay_dirty.nmadvise)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_dirty_purged</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.decay_dirty.purged)</argument>, <argument>uint64_t</argument>)</argument_list></macro>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_muzzy_npurge</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.decay_muzzy.npurge)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_muzzy_nmadvise</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.decay_muzzy.nmadvise)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_muzzy_purged</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.decay_muzzy.purged)</argument>, <argument>uint64_t</argument>)</argument_list></macro>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_base</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.base, ATOMIC_RELAXED)</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_internal</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.internal, ATOMIC_RELAXED)</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_metadata_thp</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.metadata_thp,
    ATOMIC_RELAXED)</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_tcache_bytes</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.tcache_bytes,
    ATOMIC_RELAXED)</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_resident</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.resident, ATOMIC_RELAXED)</argument>,
    <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_abandoned_vm</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.abandoned_vm,
    ATOMIC_RELAXED)</argument>, <argument>size_t</argument>)</argument_list></macro>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_small_allocated</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;allocated_small</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_small_nmalloc</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;nmalloc_small</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_small_ndalloc</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;ndalloc_small</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_small_nrequests</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;nrequests_small</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_small_nfills</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;nfills_small</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_small_nflushes</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;nflushes_small</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_large_allocated</argument>,
    <argument>atomic_load_zu(&amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.allocated_large,
    ATOMIC_RELAXED)</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_large_nmalloc</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.nmalloc_large)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_large_ndalloc</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.ndalloc_large)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_large_nrequests</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.nrequests_large)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<comment type="block">/*
 * Note: "nmalloc_large" here instead of "nfills" in the read.  This is
 * intentional (large has no batch fill).
 */</comment>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_large_nfills</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.nmalloc_large)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_large_nflushes</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;astats.nflushes_large)</argument>, <argument>uint64_t</argument>)</argument_list></macro>

<comment type="block">/* Lock profiling related APIs below. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RO_MUTEX_CTL_GEN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>						\
<cpp:value>CTL_RO_CGEN(config_stats, stats_##n##_num_ops,				\
    l.n_lock_ops, uint64_t)						\
CTL_RO_CGEN(config_stats, stats_##n##_num_wait,				\
    l.n_wait_times, uint64_t)						\
CTL_RO_CGEN(config_stats, stats_##n##_num_spin_acq,			\
    l.n_spin_acquired, uint64_t)					\
CTL_RO_CGEN(config_stats, stats_##n##_num_owner_switch,			\
    l.n_owner_switches, uint64_t) 					\
CTL_RO_CGEN(config_stats, stats_##n##_total_wait_time,			\
    nstime_ns(&amp;l.tot_wait_time), uint64_t)				\
CTL_RO_CGEN(config_stats, stats_##n##_max_wait_time,			\
    nstime_ns(&amp;l.max_wait_time), uint64_t)				\
CTL_RO_CGEN(config_stats, stats_##n##_max_num_thds,			\
    l.max_n_thds, uint32_t)</cpp:value></cpp:define>

<comment type="block">/* Global mutexes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro>								\
    <cpp:value>RO_MUTEX_CTL_GEN(mutexes_##mtx,					\
        ctl_stats-&gt;mutex_prof_data[global_prof_mutex_##mtx])</cpp:value></cpp:define>
<decl_stmt><decl><type><name>MUTEX_PROF_GLOBAL_MUTEXES</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

<comment type="block">/* Per arena mutexes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RO_MUTEX_CTL_GEN(arenas_i_mutexes_##mtx,		\
    arenas_i(mib[2])-&gt;astats-&gt;astats.mutex_prof_data[arena_prof_mutex_##mtx])</cpp:value></cpp:define>
<name>MUTEX_PROF_ARENA_MUTEXES</name></type>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

<comment type="block">/* tcache bin mutex */</comment>
<name>RO_MUTEX_CTL_GEN</name><argument_list>(<argument><expr><name>arenas_i_bins_j_mutex</name></expr></argument>,
    <argument><expr><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>bstats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>mutex_data</name></expr></argument>)</argument_list>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RO_MUTEX_CTL_GEN</name></cpp:undef>

<comment type="block">/* Resets all mutex stats, including global, arena and bin mutexes. */</comment>
static <name>int</name>
<name>stats_mutexes_reset_ctl</name><argument_list>(<argument><expr><name>tsd_t</name> <operator>*</operator><name>tsd</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>size_t</name> <operator>*</operator><name>mib</name></expr></argument>,
    <argument><expr><name>size_t</name> <name>miblen</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>oldp</name></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator><name>oldlenp</name></expr></argument>,
    <argument><expr><name>void</name> <operator>*</operator><name>newp</name></expr></argument>, <argument><expr><name>size_t</name> <name>newlen</name></expr></argument>)</argument_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_PROF_RESET</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro>						\
    <cpp:value>malloc_mutex_lock(tsdn, &amp;mtx);					\
    malloc_mutex_prof_data_reset(tsdn, &amp;mtx);				\
    malloc_mutex_unlock(tsdn, &amp;mtx);</cpp:value></cpp:define>

	<comment type="block">/* Global mutexes: ctl and prof. */</comment>
	<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* Per arena mutexes. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arena</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>szind_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>MUTEX_PROF_RESET</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MUTEX_PROF_RESET</name></cpp:undef>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nmalloc</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].nmalloc</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_ndalloc</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].ndalloc</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nrequests</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].nrequests</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_curregs</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].curregs</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nfills</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].nfills</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nflushes</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].nflushes</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nslabs</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].nslabs</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nreslabs</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].reslabs</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_curslabs</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].curslabs</argument>, <argument>size_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_bins_j_nonfull_slabs</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;bstats[mib[<literal type="number">4</literal>]].nonfull_slabs</argument>, <argument>size_t</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>stats_arenas_i_bins_j_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>SC_NBINS</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>super_stats_arenas_i_bins_j_node</name></expr>;</return>
</block_content>}</block></function>

<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_lextents_j_nmalloc</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;lstats[mib[<literal type="number">4</literal>]].nmalloc)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_lextents_j_ndalloc</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;lstats[mib[<literal type="number">4</literal>]].ndalloc)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_lextents_j_nrequests</argument>,
    <argument>ctl_arena_stats_read_u64(
    &amp;arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;lstats[mib[<literal type="number">4</literal>]].nrequests)</argument>, <argument>uint64_t</argument>)</argument_list></macro>
<macro><name>CTL_RO_CGEN</name><argument_list>(<argument>config_stats</argument>, <argument>stats_arenas_i_lextents_j_curlextents</argument>,
    <argument>arenas_i(mib[<literal type="number">2</literal>])-&gt;astats-&gt;lstats[mib[<literal type="number">4</literal>]].curlextents</argument>, <argument>size_t</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>stats_arenas_i_lextents_j_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>SC_NSIZES</name> <operator>-</operator> <name>SC_NBINS</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>super_stats_arenas_i_lextents_j_node</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>CTL_RO_CGEN</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>, <argument><expr><name>stats_arenas_i_extents_j_ndirty</name></expr></argument>,
    <argument><expr><call><name>atomic_load_zu</name><argument_list>(
        <argument><expr><operator>&amp;</operator><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>ndirty</name></expr></argument>,
	<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CTL_RO_CGEN</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>, <argument><expr><name>stats_arenas_i_extents_j_nmuzzy</name></expr></argument>,
    <argument><expr><call><name>atomic_load_zu</name><argument_list>(
        <argument><expr><operator>&amp;</operator><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>nmuzzy</name></expr></argument>,
	<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CTL_RO_CGEN</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>, <argument><expr><name>stats_arenas_i_extents_j_nretained</name></expr></argument>,
    <argument><expr><call><name>atomic_load_zu</name><argument_list>(
        <argument><expr><operator>&amp;</operator><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>nretained</name></expr></argument>,
	<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CTL_RO_CGEN</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>, <argument><expr><name>stats_arenas_i_extents_j_dirty_bytes</name></expr></argument>,
    <argument><expr><call><name>atomic_load_zu</name><argument_list>(
        <argument><expr><operator>&amp;</operator><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>dirty_bytes</name></expr></argument>,
	<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CTL_RO_CGEN</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>, <argument><expr><name>stats_arenas_i_extents_j_muzzy_bytes</name></expr></argument>,
    <argument><expr><call><name>atomic_load_zu</name><argument_list>(
        <argument><expr><operator>&amp;</operator><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>muzzy_bytes</name></expr></argument>,
	<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CTL_RO_CGEN</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>, <argument><expr><name>stats_arenas_i_extents_j_retained_bytes</name></expr></argument>,
    <argument><expr><call><name>atomic_load_zu</name><argument_list>(
        <argument><expr><operator>&amp;</operator><call><name>arenas_i</name><argument_list>(<argument><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>astats</name><operator>-&gt;</operator><name>estats</name><index>[<expr><name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>retained_bytes</name></expr></argument>,
	<argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>stats_arenas_i_extents_j_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>SC_NPSIZES</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>super_stats_arenas_i_extents_j_node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ctl_arenas_i_verify</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>a</name> <init>= <expr><call><name>arenas_i2a_impl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>UINT_MAX</name> <operator>||</operator> <operator>!</operator><name><name>ctl_arenas</name><operator>-&gt;</operator><name>arenas</name><index>[<expr><name>a</name></expr>]</index></name><operator>-&gt;</operator><name>initialized</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>stats_arenas_i_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctl_arenas_i_verify</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>super_stats_arenas_i_node</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>experimental_hooks_install_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>oldlenp</name> <operator>==</operator> <name>NULL</name><operator>||</operator> <name>newp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Note: this is a *private* struct.  This is an experimental interface;
	 * forcing the user to know the jemalloc internals well enough to
	 * extract the ABI hopefully ensures nobody gets too comfortable with
	 * this API, which can change at a moment's notice.
	 */</comment>
	<decl_stmt><decl><type><name>hooks_t</name></type> <name>hooks</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>hooks_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><call><name>hook_install</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>hooks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>experimental_hooks_remove_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITEONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>hook_remove</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Output six memory utilization entries for an input pointer, the first one of
 * type (void *) and the remaining five of type size_t, describing the following
 * (in the same order):
 *
 * (a) memory address of the extent a potential reallocation would go into,
 * == the five fields below describe about the extent the pointer resides in ==
 * (b) number of free regions in the extent,
 * (c) number of regions in the extent,
 * (d) size of the extent in terms of bytes,
 * (e) total number of free regions in the bin the extent belongs to, and
 * (f) total number of regions in the bin the extent belongs to.
 *
 * Note that "(e)" and "(f)" are only available when stats are enabled;
 * otherwise their values are undefined.
 *
 * This API is mainly intended for small class allocations, where extents are
 * used as slab.
 *
 * In case of large class allocations, "(a)" will be NULL, and "(e)" and "(f)"
 * will be zero (if stats are enabled; otherwise undefined).  The other three
 * fields will be properly set though the values are trivial: "(b)" will be 0,
 * "(c)" will be 1, and "(d)" will be the usable size.
 *
 * The input pointer and size are respectively passed in by newp and newlen,
 * and the output fields and size are respectively oldp and *oldlenp.
 *
 * It can be beneficial to define the following macros to make it easier to
 * access the output:
 *
 * #define SLABCUR_READ(out) (*(void **)out)
 * #define COUNTS(out) ((size_t *)((void **)out + 1))
 * #define NFREE_READ(out) COUNTS(out)[0]
 * #define NREGS_READ(out) COUNTS(out)[1]
 * #define SIZE_READ(out) COUNTS(out)[2]
 * #define BIN_NFREE_READ(out) COUNTS(out)[3]
 * #define BIN_NREGS_READ(out) COUNTS(out)[4]
 *
 * and then write e.g. NFREE_READ(oldp) to fetch the output.  See the unit test
 * test_query in test/unit/extent_util.c for an example.
 *
 * For a typical defragmentation workflow making use of this API for
 * understanding the fragmentation level, please refer to the comment for
 * experimental_utilization_batch_query_ctl.
 *
 * It's up to the application how to determine the significance of
 * fragmentation relying on the outputs returned.  Possible choices are:
 *
 * (a) if extent utilization ratio is below certain threshold,
 * (b) if extent memory consumption is above certain threshold,
 * (c) if extent utilization ratio is significantly below bin utilization ratio,
 * (d) if input pointer deviates a lot from potential reallocation address, or
 * (e) some selection/combination of the above.
 *
 * The caller needs to make sure that the input/output arguments are valid,
 * in particular, that the size of the output is correct, i.e.:
 *
 *     *oldlenp = sizeof(void *) + sizeof(size_t) * 5
 *
 * Otherwise, the function immediately returns EINVAL without touching anything.
 *
 * In the rare case where there's no associated extent found for the input
 * pointer, the function zeros out all output fields and return.  Please refer
 * to the comment for experimental_utilization_batch_query_ctl to understand the
 * motivation from C++.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>experimental_utilization_query_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extent_util_stats_verbose_t</name></expr></argument>)</argument_list></sizeof>
	    <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>oldlenp</name> <operator>==</operator> <name>NULL</name>
	    <operator>||</operator> <operator>*</operator><name>oldlenp</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>extent_util_stats_verbose_t</name></expr></argument>)</argument_list></sizeof>
	    <operator>||</operator> <name>newp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>extent_util_stats_verbose_t</name> <modifier>*</modifier></type><name>util_stats</name>
	    <init>= <expr><operator>(</operator><name>extent_util_stats_verbose_t</name> <operator>*</operator><operator>)</operator><name>oldp</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_util_stats_verbose_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>util_stats</name><operator>-&gt;</operator><name>nfree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>util_stats</name><operator>-&gt;</operator><name>nregs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>util_stats</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>util_stats</name><operator>-&gt;</operator><name>bin_nfree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>util_stats</name><operator>-&gt;</operator><name>bin_nregs</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>util_stats</name><operator>-&gt;</operator><name>slabcur_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given an input array of pointers, output three memory utilization entries of
 * type size_t for each input pointer about the extent it resides in:
 *
 * (a) number of free regions in the extent,
 * (b) number of regions in the extent, and
 * (c) size of the extent in terms of bytes.
 *
 * This API is mainly intended for small class allocations, where extents are
 * used as slab.  In case of large class allocations, the outputs are trivial:
 * "(a)" will be 0, "(b)" will be 1, and "(c)" will be the usable size.
 *
 * Note that multiple input pointers may reside on a same extent so the output
 * fields may contain duplicates.
 *
 * The format of the input/output looks like:
 *
 * input[0]:  1st_pointer_to_query	|  output[0]: 1st_extent_n_free_regions
 *					|  output[1]: 1st_extent_n_regions
 *					|  output[2]: 1st_extent_size
 * input[1]:  2nd_pointer_to_query	|  output[3]: 2nd_extent_n_free_regions
 *					|  output[4]: 2nd_extent_n_regions
 *					|  output[5]: 2nd_extent_size
 * ...					|  ...
 *
 * The input array and size are respectively passed in by newp and newlen, and
 * the output array and size are respectively oldp and *oldlenp.
 *
 * It can be beneficial to define the following macros to make it easier to
 * access the output:
 *
 * #define NFREE_READ(out, i) out[(i) * 3]
 * #define NREGS_READ(out, i) out[(i) * 3 + 1]
 * #define SIZE_READ(out, i) out[(i) * 3 + 2]
 *
 * and then write e.g. NFREE_READ(oldp, i) to fetch the output.  See the unit
 * test test_batch in test/unit/extent_util.c for a concrete example.
 *
 * A typical workflow would be composed of the following steps:
 *
 * (1) flush tcache: mallctl("thread.tcache.flush", ...)
 * (2) initialize input array of pointers to query fragmentation
 * (3) allocate output array to hold utilization statistics
 * (4) query utilization: mallctl("experimental.utilization.batch_query", ...)
 * (5) (optional) decide if it's worthwhile to defragment; otherwise stop here
 * (6) disable tcache: mallctl("thread.tcache.enabled", ...)
 * (7) defragment allocations with significant fragmentation, e.g.:
 *         for each allocation {
 *             if it's fragmented {
 *                 malloc(...);
 *                 memcpy(...);
 *                 free(...);
 *             }
 *         }
 * (8) enable tcache: mallctl("thread.tcache.enabled", ...)
 *
 * The application can determine the significance of fragmentation themselves
 * relying on the statistics returned, both at the overall level i.e. step "(5)"
 * and at individual allocation level i.e. within step "(7)".  Possible choices
 * are:
 *
 * (a) whether memory utilization ratio is below certain threshold,
 * (b) whether memory consumption is above certain threshold, or
 * (c) some combination of the two.
 *
 * The caller needs to make sure that the input/output arrays are valid and
 * their sizes are proper as well as matched, meaning:
 *
 * (a) newlen = n_pointers * sizeof(const void *)
 * (b) *oldlenp = n_pointers * sizeof(size_t) * 3
 * (c) n_pointers &gt; 0
 *
 * Otherwise, the function immediately returns EINVAL without touching anything.
 *
 * In the rare case where there's no associated extent found for some pointers,
 * rather than immediately terminating the computation and raising an error,
 * the function simply zeros out the corresponding output fields and continues
 * the computation until all input pointers are handled.  The motivations of
 * such a design are as follows:
 *
 * (a) The function always either processes nothing or processes everything, and
 * never leaves the output half touched and half untouched.
 *
 * (b) It facilitates usage needs especially common in C++.  A vast variety of
 * C++ objects are instantiated with multiple dynamic memory allocations.  For
 * example, std::string and std::vector typically use at least two allocations,
 * one for the metadata and one for the actual content.  Other types may use
 * even more allocations.  When inquiring about utilization statistics, the
 * caller often wants to examine into all such allocations, especially internal
 * one(s), rather than just the topmost one.  The issue comes when some
 * implementations do certain optimizations to reduce/aggregate some internal
 * allocations, e.g. putting short strings directly into the metadata, and such
 * decisions are not known to the caller.  Therefore, we permit pointers to
 * memory usages that may not be returned by previous malloc calls, and we
 * provide the caller a convenient way to identify such cases.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>experimental_utilization_batch_query_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extent_util_stats_t</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><name>newlen</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>oldlenp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newlen</name> <operator>==</operator> <literal type="number">0</literal>
	    <operator>||</operator> <name>newlen</name> <operator>!=</operator> <name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof>
	    <operator>||</operator> <operator>*</operator><name>oldlenp</name> <operator>!=</operator> <name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>extent_util_stats_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptrs</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>newp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_util_stats_t</name> <modifier>*</modifier></type><name>util_stats</name> <init>= <expr><operator>(</operator><name>extent_util_stats_t</name> <operator>*</operator><operator>)</operator><name>oldp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_util_stats_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ptrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>util_stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nfree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>util_stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nregs</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>util_stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type>
<name>experimental_arenas_i_index</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ctl_named_node_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctl_arenas_i_verify</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>super_experimental_arenas_i_node</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>experimental_arenas_i_pactivep_ctl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>oldlenp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>oldlenp</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>EINVAL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>pactivep</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MIB_UNSIGNED</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>&lt;</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>arena</name> <operator>=</operator>
	    <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_GCC_ATOMIC_ATOMICS</name></expr></argument>)</argument_list></call> <operator>||</operator>				\
    <call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_GCC_SYNC_ATOMICS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<comment type="block">/* Expose the underlying counter for fast read. */</comment>
		<expr_stmt><expr><name>pactivep</name> <operator>=</operator> <operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name><operator>.</operator><name>repr</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ</name><argument_list>(<argument><expr><name>pactivep</name></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
</unit>
