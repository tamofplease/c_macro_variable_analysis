<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/background_thread.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_BACKGROUND_THREAD_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>JEMALLOC_DIAGNOSTIC_DISABLE_SPURIOUS</name>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<comment type="block">/* This option should be opt-in only. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKGROUND_THREAD_DEFAULT</name></cpp:macro> <cpp:value>false</cpp:value></cpp:define>
<comment type="block">/* Read-only after initialization. */</comment>
<name>bool</name></type> <name>opt_background_thread</name> <init>= <expr><name>BACKGROUND_THREAD_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>opt_max_background_threads</name> <init>= <expr><name>MAX_BACKGROUND_THREAD_LIMIT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Used for thread creation, termination and stats. */</comment>
<decl_stmt><decl><type><name>malloc_mutex_t</name></type> <name>background_thread_lock</name></decl>;</decl_stmt>
<comment type="block">/* Indicates global state.  Atomic because decay reads this w/o locking. */</comment>
<decl_stmt><decl><type><name>atomic_b_t</name></type> <name>background_thread_enabled_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n_background_threads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max_background_threads</name></decl>;</decl_stmt>
<comment type="block">/* Thread info per-index. */</comment>
<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>background_thread_info</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PTHREAD_CREATE_WRAPPER</name></cpp:ifdef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> (<modifier>*</modifier><name>pthread_create_fptr</name>)<parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier></type><name>__restrict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pthread_attr_t</name> <modifier>*</modifier></type></decl></parameter>,
    <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>__restrict</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pthread_create_wrapper_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_LAZY_LOCK</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isthreaded</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>isthreaded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pthread_create_wrapper</name><parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier><name>__restrict</name></type> <name>thread</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pthread_attr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
    <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>start_routine</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>__restrict</name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>pthread_create_wrapper_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pthread_create_fptr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>start_routine</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JEMALLOC_PTHREAD_CREATE_WRAPPER */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_BACKGROUND_THREAD</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOT_REACHED</name></cpp:macro> <cpp:value>{ not_reached(); }</cpp:value></cpp:define>
<decl_stmt><decl><type><name>bool</name></type> <name>background_thread_create</name><argument_list>(<argument><expr><name>tsd_t</name> <operator>*</operator><name>tsd</name></expr></argument>, <argument><expr><name>unsigned</name> <name>arena_ind</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>bool</name> <name>background_threads_enable</name><argument_list>(<argument><expr><name>tsd_t</name> <operator>*</operator><name>tsd</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>bool</name> <name>background_threads_disable</name><argument_list>(<argument><expr><name>tsd_t</name> <operator>*</operator><name>tsd</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>void</name> <name>background_thread_interval_check</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>, <argument><expr><name>arena_t</name> <operator>*</operator><name>arena</name></expr></argument>,
    <argument><expr><name>arena_decay_t</name> <operator>*</operator><name>decay</name></expr></argument>, <argument><expr><name>size_t</name> <name>npages_new</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>void</name> <name>background_thread_prefork0</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>void</name> <name>background_thread_prefork1</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>void</name> <name>background_thread_postfork_parent</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>void</name> <name>background_thread_postfork_child</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>bool</name> <name>background_thread_stats_read</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>,
    <argument><expr><name>background_thread_stats_t</name> <operator>*</operator><name>stats</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<name>void</name> <name>background_thread_ctl_init</name><argument_list>(<argument><expr><name>tsdn_t</name> <operator>*</operator><name>tsdn</name></expr></argument>)</argument_list> <name>NOT_REACHED</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NOT_REACHED</name></cpp:undef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

static <name>bool</name> <name>background_thread_enabled_at_fork</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>background_thread_info_init</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>background_thread_wakeup_time_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>npages_to_purge_new</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tot_n_runs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>tot_sleep_time</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>set_current_thread_affinity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cpu</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_HAVE_SCHED_SETAFFINITY</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>cpu_set_t</name></type> <name>cpuset</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CPU_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CPU_SET</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>sched_setaffinity</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cpu_set_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>ret</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Threshold for determining when to wake up the background thread. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></cpp:macro> <cpp:value>UINT64_C(1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BILLION</name></cpp:macro> <cpp:value>UINT64_C(1000000000)</cpp:value></cpp:define>
<comment type="block">/* Minimal sleep interval 100 ms. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></cpp:macro> <cpp:value>(BILLION / 10)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>
<name>decay_npurge_after_interval</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>interval</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>interval</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>h_steps</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name><name>h_steps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>h_steps</name><index>[<expr><name>i</name> <operator>-</operator> <name>interval</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>sum</name> <operator>&gt;&gt;</operator> <name>SMOOTHSTEP_BFP</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>arena_decay_compute_purge_interval_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_trylock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Use minimal interval if decay is contended. */</comment>
		<return>return <expr><name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>decay_time</name> <init>= <expr><call><name>atomic_load_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>time_ms</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>decay_time</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Purging is eagerly done or disabled currently. */</comment>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr>;</expr_stmt>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>decay_interval_ns</name> <init>= <expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>decay_interval_ns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npages</name> <init>= <expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* No dirty pages recorded.  Sleep indefinitely. */</comment>
			<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr>;</expr_stmt>
			<goto>goto <name>label_done</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>&lt;=</operator> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Use max interval. */</comment>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>decay_interval_ns</name> <operator>*</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>;</expr_stmt>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>lb</name> <init>= <expr><name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name> <operator>/</operator> <name>decay_interval_ns</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ub</name> <init>= <expr><name>SMOOTHSTEP_NSTEPS</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Minimal 2 intervals to ensure reaching next epoch deadline. */</comment>
	<expr_stmt><expr><name>lb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lb</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><name>lb</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>decay_interval_ns</name> <operator>*</operator> <name>ub</name> <operator>&lt;=</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name>lb</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>ub</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr>;</expr_stmt>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lb</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npurge_lb</name></decl>, <decl><type ref="prev"/><name>npurge_ub</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>npurge_lb</name> <operator>=</operator> <call><name>decay_npurge_after_interval</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>npurge_lb</name> <operator>&gt;</operator> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>decay_interval_ns</name> <operator>*</operator> <name>lb</name></expr>;</expr_stmt>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>npurge_ub</name> <operator>=</operator> <call><name>decay_npurge_after_interval</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>npurge_ub</name> <operator>&lt;</operator> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>decay_interval_ns</name> <operator>*</operator> <name>ub</name></expr>;</expr_stmt>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_search</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>target</name></decl>, <decl><type ref="prev"/><name>npurge</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>npurge_lb</name> <operator>+</operator> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name> <operator>&lt;</operator> <name>npurge_ub</name><operator>)</operator>
	    <operator>&amp;&amp;</operator> <operator>(</operator><name>lb</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>ub</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>lb</name> <operator>+</operator> <name>ub</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>npurge</name> <operator>=</operator> <call><name>decay_npurge_after_interval</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>npurge</name> <operator>&gt;</operator> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ub</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>npurge_ub</name> <operator>=</operator> <name>npurge</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>lb</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>npurge_lb</name> <operator>=</operator> <name>npurge</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n_search</name><operator>++</operator> <operator>&lt;</operator> <call><name>lg_floor</name><argument_list>(<argument><expr><name>SMOOTHSTEP_NSTEPS</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>interval</name> <operator>=</operator> <name>decay_interval_ns</name> <operator>*</operator> <operator>(</operator><name>ub</name> <operator>+</operator> <name>lb</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<label><name>label_done</name>:</label>
	<expr_stmt><expr><name>interval</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>interval</name> <operator>&lt;</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name><operator>)</operator></expr> ?</condition><then>
	    <expr><name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr> </then><else>: <expr><name>interval</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>interval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute purge interval for background threads. */</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>arena_decay_compute_purge_interval</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>i1</name> <operator>=</operator> <call><name>arena_decay_compute_purge_interval_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>==</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>i1</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>i2</name> <operator>=</operator> <call><name>arena_decay_compute_purge_interval_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name>i1</name> <operator>&lt;</operator> <name>i2</name></expr> ?</condition><then> <expr><name>i1</name></expr> </then><else>: <expr><name>i2</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>background_thread_sleep</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
    <parameter><decl><type><name>uint64_t</name></type> <name>interval</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tot_n_runs</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>npages_to_purge_new</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
	<comment type="block">/* Specific clock required by timedwait. */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>nstime_t</name></type> <name>before_sleep</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>before_sleep</name></expr></argument>, <argument><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>==</operator> <name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>background_thread_indefinite_sleep</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>interval</name> <operator>&gt;=</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name> <operator>&amp;&amp;</operator>
		    <name>interval</name> <operator>&lt;=</operator> <name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We need malloc clock (can be different from tv). */</comment>
		<decl_stmt><decl><type><name>nstime_t</name></type> <name>next_wakeup</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_wakeup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_iadd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_wakeup</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_wakeup</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
		    <name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>background_thread_wakeup_time_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
		    <argument><expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_wakeup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>nstime_t</name></type> <name>ts_wakeup</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>nstime_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts_wakeup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>before_sleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_iadd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts_wakeup</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>nstime_sec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>nstime_nsec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>background_thread_indefinite_sleep</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>ETIMEDOUT</name> <operator>||</operator> <name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>background_thread_wakeup_time_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
		    <argument><expr><name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>nstime_t</name></type> <name>after_sleep</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>nstime_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>after_sleep</name></expr></argument>, <argument><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>nstime_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>after_sleep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>before_sleep</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>nstime_subtract</name><argument_list>(<argument><expr><operator>&amp;</operator><name>after_sleep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>before_sleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nstime_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>tot_sleep_time</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>after_sleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>background_thread_pause_check</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_paused</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Wait on global lock to update status. */</comment>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>background_work_sleep_once</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>min_interval</name> <init>= <expr><name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas</name> <init>= <expr><call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><name>ind</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>max_background_threads</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arena</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>arena_decay</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>min_interval</name> <operator>==</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Min interval will be used. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>interval</name> <init>= <expr><call><name>arena_decay_compute_purge_interval</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
		    <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>interval</name> <operator>&gt;=</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>min_interval</name> <operator>&gt;</operator> <name>interval</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>min_interval</name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>background_thread_sleep</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>min_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>background_threads_disable_single</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_assert_not_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_thread</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>background_thread_paused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_started</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>has_thread</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_stopped</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>has_thread</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_background_threads</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>background_thread_entry</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ind_arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>background_thread_create_signals_masked</name><parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>pthread_attr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>start_routine</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Mask signals during thread creation so that the thread inherits
	 * an empty signal set.
	 */</comment>
	<decl_stmt><decl><type><name>sigset_t</name></type> <name>set</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>sigfillset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>sigset_t</name></type> <name>oldset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mask_err</name> <init>= <expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>mask_err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>mask_err</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>create_err</name> <init>= <expr><call><name>pthread_create_wrapper</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>start_routine</name></expr></argument>,
	    <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * Restore the signal mask.  Failure to restore the signal mask here
	 * changes program behavior.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>restore_err</name> <init>= <expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>restore_err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: background thread creation "</literal>
		    <literal type="string">"failed (%d), and signal mask restoration failed "</literal>
		    <literal type="string">"(%d)\n"</literal></expr></argument>, <argument><expr><name>create_err</name></expr></argument>, <argument><expr><name>restore_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>create_err</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_background_thread_creation</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n_created</name></decl></parameter>,
    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>created_threads</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>*</operator><name>n_created</name> <operator>==</operator> <name>n_background_threads</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>created_threads</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * In case of the background_thread_paused state because of
		 * arena reset, delay the creation.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>create</name> <init>= <expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_started</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>background_thread_create_signals_masked</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>,
		    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>background_thread_entry</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>n_created</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>created_threads</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: background thread "</literal>
			    <literal type="string">"creation failed (%d)\n"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Return to restart the loop since we unlocked. */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>background_thread0_work</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Thread0 is also responsible for launching / terminating threads. */</comment>
	<expr_stmt><expr><call><name>VARIABLE_ARRAY</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>created_threads</name></expr></argument>, <argument><expr><name>max_background_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>created_threads</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Start working, and create more threads when asked. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_created</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>state</name> <operator>!=</operator> <name>background_thread_stopped</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>background_thread_pause_check</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>check_background_thread_creation</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_created</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>created_threads</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>background_work_sleep_once</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Shut down other threads at exit.  Note that the ctl thread is holding
	 * the global background_thread mutex (and is waiting) for us.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>background_thread_paused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>created_threads</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>background_threads_disable_single</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>background_thread_stopped</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* The thread was not created. */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator>
				    <name>background_thread_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>n_background_threads</name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_stopped</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>background_thread_stopped</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n_background_threads</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>background_work</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>background_thread_wakeup_time_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>info</name></expr></argument>,
	    <argument><expr><name>BACKGROUND_THREAD_INDEFINITE_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread0_work</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<while>while <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>background_thread_stopped</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>background_thread_pause_check</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>background_work_sleep_once</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_stopped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>background_thread_wakeup_time_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>background_thread_entry</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ind_arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>thread_ind</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ind_arg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>thread_ind</name> <operator>&lt;</operator> <name>max_background_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_HAVE_PTHREAD_SETNAME_NP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_setname_np</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"jemalloc_bg_thd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>pthread_set_name_np</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"jemalloc_bg_thd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>opt_percpu_arena</name> <operator>!=</operator> <name>percpu_arena_disabled</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>set_current_thread_affinity</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>thread_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Start periodic background work.  We use internal tsd which avoids
	 * side effects, for example triggering new arena creation (which in
	 * turn triggers another background thread creation).
	 */</comment>
	<expr_stmt><expr><call><name>background_work</name><argument_list>(<argument><expr><call><name>tsd_internal_fetch</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>thread_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pthread_equal</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>,
	    <argument><expr><name><name>background_thread_info</name><index>[<expr><name>thread_ind</name></expr>]</index></name><operator>.</operator><name>thread</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>background_thread_init</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_started</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>background_thread_info_init</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_background_threads</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>background_thread_create_locked</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>have_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We create at most NCPUs threads. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>thread_ind</name> <init>= <expr><name>arena_ind</name> <operator>%</operator> <name>max_background_threads</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>thread_ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>need_new_thread</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>need_new_thread</name> <operator>=</operator> <call><name>background_thread_enabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
	    <operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_stopped</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_new_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_new_thread</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena_ind</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Threads are created asynchronously by Thread 0. */</comment>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>t0</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t0</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t0</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t0</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t0</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * To avoid complications (besides reentrancy), create internal
	 * background threads with the underlying pthread_create.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>background_thread_create_signals_masked</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
	    <argument><expr><name>background_thread_entry</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>thread_ind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: arena 0 background thread creation "</literal>
		    <literal type="string">"failed (%d)\n"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_stopped</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_background_threads</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new background thread if needed. */</comment>
<function><type><name>bool</name></type>
<name>background_thread_create</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>have_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>background_thread_create_locked</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>background_threads_enable</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n_background_threads</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VARIABLE_ARRAY</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>marked</name></expr></argument>, <argument><expr><name>max_background_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nmarked</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>marked</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>nmarked</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Thread 0 is required and created at the end. */</comment>
	<expr_stmt><expr><name><name>marked</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* Mark the threads we need to create for thread 0. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>marked</name><index>[<expr><name>i</name> <operator>%</operator> <name>max_background_threads</name></expr>]</index></name> <operator>||</operator>
		    <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[
		    <expr><name>i</name> <operator>%</operator> <name>max_background_threads</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>background_thread_stopped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>background_thread_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>marked</name><index>[<expr><name>i</name> <operator>%</operator> <name>max_background_threads</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nmarked</name> <operator>==</operator> <name>max_background_threads</name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><call><name>background_thread_create_locked</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>background_threads_disable</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Thread 0 will be responsible for terminating other threads. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>background_threads_disable_single</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n_background_threads</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check if we need to signal the background thread early. */</comment>
<function><type><name>void</name></type>
<name>background_thread_interval_check</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_new</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>arena_background_thread_info_get</name><argument_list>(
	    <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_trylock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Background thread may hold the mutex for a long period of
		 * time.  We'd like to avoid the variance on application
		 * threads.  So keep this non-blocking, and leave the work to a
		 * future epoch.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>background_thread_started</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_trylock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ssize_t</name></type> <name>decay_time</name> <init>= <expr><call><name>atomic_load_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>time_ms</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>decay_time</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Purging is eagerly done or disabled currently. */</comment>
		<goto>goto <name>label_done_unlock2</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>decay_interval_ns</name> <init>= <expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>decay_interval_ns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>nstime_t</name></type> <name>diff</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>, <argument><expr><call><name>background_thread_wakeup_time_get</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nstime_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_done_unlock2</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>nstime_subtract</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_done_unlock2</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>npages_new</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>n_epoch</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>decay_interval_ns</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Compute how many new pages we would need to purge by the next
		 * wakeup, which is used to determine if we should signal the
		 * background thread.
		 */</comment>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>npurge_new</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_epoch</name> <operator>&gt;=</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>npurge_new</name> <operator>=</operator> <name>npages_new</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name>uint64_t</name></type> <name>h_steps_max</name> <init>= <expr><name><name>h_steps</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>h_steps_max</name> <operator>&gt;=</operator>
			    <name><name>h_steps</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n_epoch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>npurge_new</name> <operator>=</operator> <name>npages_new</name> <operator>*</operator> <operator>(</operator><name>h_steps_max</name> <operator>-</operator>
			    <name><name>h_steps</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n_epoch</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>npurge_new</name> <operator>&gt;&gt;=</operator> <name>SMOOTHSTEP_BFP</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>npages_to_purge_new</name></name> <operator>+=</operator> <name>npurge_new</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>should_signal</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>npages_to_purge_new</name></name> <operator>&gt;</operator> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>should_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>background_thread_indefinite_sleep</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <operator>(</operator><call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
	    <call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
	    <name><name>info</name><operator>-&gt;</operator><name>npages_to_purge_new</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>should_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>should_signal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_signal</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>npages_to_purge_new</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<label><name>label_done_unlock2</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>label_done</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>background_thread_prefork0</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>background_thread_enabled_at_fork</name> <operator>=</operator> <call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>background_thread_prefork1</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>background_thread_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>background_thread_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>background_thread_enabled_at_fork</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clear background_thread state (reset to disabled for child). */</comment>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_background_threads</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>background_thread_enabled_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_stopped</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>background_thread_info_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>background_thread_stats_read</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>background_thread_stats_t</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>background_thread_enabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_threads</name></name> <operator>=</operator> <name>n_background_threads</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>num_runs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>run_interval</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_trylock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Each background thread run may take a long time;
			 * avoid waiting on the stats if the thread is active.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>background_thread_stopped</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>num_runs</name> <operator>+=</operator> <name><name>info</name><operator>-&gt;</operator><name>tot_n_runs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nstime_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>run_interval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>tot_sleep_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_runs</name></name> <operator>=</operator> <name>num_runs</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_runs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>nstime_idivide</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>run_interval</name></name></expr></argument>, <argument><expr><name>num_runs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BACKGROUND_THREAD_NPAGES_THRESHOLD</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BILLION</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BACKGROUND_THREAD_MIN_INTERVAL_NS</name></cpp:undef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_HAVE_DLSYM</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pthread_create_fptr_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pthread_create_fptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Try the next symbol first, because 1) when use lazy_lock we have a
	 * wrapper for pthread_create; and 2) application may define its own
	 * wrapper as well (and can call malloc within the wrapper).
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_HAVE_DLSYM</name></cpp:ifdef>
	<expr_stmt><expr><name>pthread_create_fptr</name> <operator>=</operator> <call><name>dlsym</name><argument_list>(<argument><expr><name>RTLD_NEXT</name></expr></argument>, <argument><expr><literal type="string">"pthread_create"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>pthread_create_fptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>pthread_create_fptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_lazy_lock</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in dlsym(RTLD_NEXT, "</literal>
			    <literal type="string">"\"pthread_create\")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* Fall back to the default symbol. */</comment>
			<expr_stmt><expr><name>pthread_create_fptr</name> <operator>=</operator> <name>pthread_create</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When lazy lock is enabled, we need to make sure setting isthreaded before
 * taking any background_thread locks.  This is called early in ctl (instead of
 * wait for the pthread_create calls to trigger) because the mutex is required
 * before creating background threads.
 */</comment>
<function><type><name>void</name></type>
<name>background_thread_ctl_init</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_not_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PTHREAD_CREATE_WRAPPER</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_create_fptr_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_create_wrapper_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(JEMALLOC_BACKGROUND_THREAD) */</comment>

<function><type><name>bool</name></type>
<name>background_thread_boot0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_background_thread</name> <operator>&amp;&amp;</operator> <name>opt_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: option background_thread currently "</literal>
		    <literal type="string">"supports pthread only\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PTHREAD_CREATE_WRAPPER</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>config_lazy_lock</name> <operator>||</operator> <name>opt_background_thread</name><operator>)</operator> <operator>&amp;&amp;</operator>
	    <call><name>pthread_create_fptr_init</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>background_thread_boot1</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_BACKGROUND_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>have_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>narenas_total_get</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_max_background_threads</name> <operator>&gt;</operator> <name>MAX_BACKGROUND_THREAD_LIMIT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>opt_max_background_threads</name> <operator>=</operator> <name>DEFAULT_NUM_BACKGROUND_THREAD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>max_background_threads</name> <operator>=</operator> <name>opt_max_background_threads</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>background_thread_enabled_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>opt_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>background_thread_lock</name></expr></argument>,
	    <argument><expr><literal type="string">"background_thread_global"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_BACKGROUND_THREAD_GLOBAL</name></expr></argument>,
	    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>background_thread_info</name> <operator>=</operator> <operator>(</operator><name>background_thread_info_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
	    <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>opt_max_background_threads</name> <operator>*</operator>
	    <sizeof>sizeof<argument_list>(<argument><expr><name>background_thread_info_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>CACHELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>background_thread_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_background_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>background_thread_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>background_thread_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Thread mutex is rank_inclusive because of thread0. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>, <argument><expr><literal type="string">"background_thread"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_BACKGROUND_THREAD</name></expr></argument>,
		    <argument><expr><name>malloc_mutex_address_ordered</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>background_thread_stopped</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>background_thread_info_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
