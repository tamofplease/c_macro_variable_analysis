<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/jemalloc.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/atomic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ctl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_dss.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_mmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/malloc_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/rtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/safety_check.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/sc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/sz.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ticker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/util.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<comment type="block">/* Runtime configuration options. */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier><name>je_malloc_conf</name></type>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
    <name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>weak</name></type></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</function_decl>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_abort</name> <init>=
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_DEBUG</name></cpp:ifdef>
    <expr><name>true</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <name>false</name></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_abort_conf</name> <init>=
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_DEBUG</name></cpp:ifdef>
    <expr><name>true</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <name>false</name></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</decl_stmt>
<comment type="block">/* Intentionally default off, even with debug builds. */</comment>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_confirm_conf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>opt_junk</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_FILL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
    <expr><literal type="string">"true"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <literal type="string">"false"</literal></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_junk_alloc</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_FILL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
    <expr><name>true</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <name>false</name></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_junk_free</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_FILL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
    <expr><name>true</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <name>false</name></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>	<name>opt_utrace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_xmalloc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>opt_zero</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type>	<name>opt_narenas</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type>	<name>ncpus</name></decl>;</decl_stmt>

<comment type="block">/* Protects arenas initialization. */</comment>
<decl_stmt><decl><type><name>malloc_mutex_t</name></type> <name>arenas_lock</name></decl>;</decl_stmt>
<comment type="block">/*
 * Arenas that are used to service external requests.  Not all elements of the
 * arenas array are necessarily used; arenas are created lazily as needed.
 *
 * arenas[0..narenas_auto) are used for automatic multiplexing of threads and
 * arenas.  arenas[narenas_auto..narenas_total) are only used if the application
 * takes some action to create them and allocate from them.
 *
 * Points to an arena_t.
 */</comment>
<macro><name>JEMALLOC_ALIGNED</name><argument_list>(<argument>CACHELINE</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>atomic_p_t</name></type>		<name><name>arenas</name><index>[<expr><name>MALLOCX_ARENA_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_u_t</name></type>	<name>narenas_total</name></decl>;</decl_stmt> <comment type="block">/* Use narenas_total_*(). */</comment>
<comment type="block">/* Below three are read-only after initialization. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>arena_t</name>		<modifier>*</modifier></type><name>a0</name></decl>;</decl_stmt> <comment type="block">/* arenas[0]. */</comment>
<decl_stmt><decl><type><name>unsigned</name></type>		<name>narenas_auto</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type>		<name>manual_arena_base</name></decl>;</decl_stmt>

<typedef>typedef <type><enum>enum <block>{
	<decl><name>malloc_init_uninitialized</name>	<init>= <expr><literal type="number">3</literal></expr></init></decl>,
	<decl><name>malloc_init_a0_initialized</name>	<init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>malloc_init_recursible</name>		<init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>malloc_init_initialized</name>		<init>= <expr><literal type="number">0</literal></expr></init></decl> <comment type="block">/* Common case --&gt; jnz. */</comment>
}</block></enum></type> <name>malloc_init_t</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_init_t</name></type>	<name>malloc_init_state</name> <init>= <expr><name>malloc_init_uninitialized</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* False should be the common case.  Set to true to trigger initialization. */</comment>
<decl_stmt><decl><type><name>bool</name></type>			<name>malloc_slow</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* When malloc_slow is true, set the corresponding bits for sanity check. */</comment>
<enum>enum <block>{
	<decl><name>flag_opt_junk_alloc</name>	<init>= <expr><operator>(</operator><literal type="number">1U</literal><operator>)</operator></expr></init></decl>,
	<decl><name>flag_opt_junk_free</name>	<init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>,
	<decl><name>flag_opt_zero</name>		<init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>,
	<decl><name>flag_opt_utrace</name>		<init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>,
	<decl><name>flag_opt_xmalloc</name>	<init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>
}</block>;</enum>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type>	<name>malloc_slow_flags</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_THREADED_INIT</name></cpp:ifdef>
<comment type="block">/* Used to let the initializing thread recursively allocate. */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NO_INITIALIZER</name></cpp:macro>	<cpp:value>((unsigned long)0)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>INITIALIZER</name></cpp:macro>		<cpp:value>pthread_self()</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INITIALIZER</name></cpp:macro>	<cpp:value>(malloc_initializer == pthread_self())</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_t</name></type>		<name>malloc_initializer</name> <init>= <expr><name>NO_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NO_INITIALIZER</name></cpp:macro>	<cpp:value>false</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>INITIALIZER</name></cpp:macro>		<cpp:value>true</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INITIALIZER</name></cpp:macro>	<cpp:value>malloc_initializer</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>			<name>malloc_initializer</name> <init>= <expr><name>NO_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Used to avoid initialization races. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_WIN32_WINNT</name> <operator>&gt;=</operator> <literal type="number">0x0600</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>init_lock</name> <init>= <expr><name>SRWLOCK_INIT</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>init_lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>init_lock_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<macro><name>JEMALLOC_ATTR</name><argument_list>(<argument>constructor</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type>
<name>_init_init_lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * If another constructor in the same binary is using mallctl to e.g.
	 * set up extent hooks, it may end up running before this one, and
	 * malloc_init_hard will crash trying to lock the uninitialized lock. So
	 * we force an initialization of the lock in malloc_init_hard as well.
	 * We don't try to care about atomicity of the accessed to the
	 * init_lock_initialized boolean, since it really only matters early in
	 * the process creation, before any separate thread normally starts
	 * doing anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>init_lock_initialized</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>, <argument><expr><literal type="string">"init"</literal></expr></argument>, <argument><expr><name>WITNESS_RANK_INIT</name></expr></argument>,
		    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>init_lock_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>section</name><name>(</name><cpp:literal>".CRT$XCU"</cpp:literal><name>,</name> <name>read</name><name>)</name></cpp:pragma>
<macro><name>JEMALLOC_SECTION</name><argument_list>(<argument><literal type="string">".CRT$XCU"</literal></argument>)</argument_list></macro> <macro><name>JEMALLOC_ATTR</name><argument_list>(<argument>used</argument>)</argument_list></macro>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name></type> (<name>WINAPI</name> <modifier>*</modifier><name>init_init_lock</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>_init_init_lock</name></expr></init>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>init_lock</name> <init>= <expr><name>MALLOC_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>void</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>	<comment type="block">/* Input pointer (as in realloc(p, s)). */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>s</name></decl>;</decl_stmt>	<comment type="block">/* Request size. */</comment>
	<decl_stmt><decl><type><name>void</name>	<modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>	<comment type="block">/* Result pointer. */</comment>
}</block></struct></type> <name>malloc_utrace_t</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_UTRACE</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UTRACE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {						\
	if (unlikely(opt_utrace)) {					\
		int utrace_serrno = errno;				\
		malloc_utrace_t ut;					\
		ut.p = (a);						\
		ut.s = (b);						\
		ut.r = (c);						\
		utrace(&amp;ut, sizeof(ut));				\
		errno = utrace_serrno;					\
	}								\
} while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UTRACE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Whether encountered any invalid config options. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>had_conf_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Function prototypes for static functions that are referenced prior to
 * definition.
 */</comment>

<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>malloc_init_hard_a0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>malloc_init_hard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Begin miscellaneous support functions.
 */</comment>

<function><type><name>bool</name></type>
<name>malloc_initialized</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>malloc_init_state</name> <operator>==</operator> <name>malloc_init_initialized</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>bool</name></type>
<name>malloc_init_a0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>malloc_init_state</name> <operator>==</operator> <name>malloc_init_uninitialized</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>malloc_init_hard_a0</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>bool</name></type>
<name>malloc_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>malloc_init_hard</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The a0*() functions are used instead of i{d,}alloc() in situations that
 * cannot tolerate TLS variable access.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>a0ialloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>malloc_init_a0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>iallocztm</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
	    <argument><expr><name>is_internal</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>a0idalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>a0malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>a0ialloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>a0dalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>a0idalloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FreeBSD's libc uses the bootstrap_*() functions in bootstrap-senstive
 * situations that cannot tolerate TLS variable access (TLS allocation and very
 * early internal data structure initialization).
 */</comment>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>bootstrap_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>a0ialloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>bootstrap_calloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>num_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_size</name> <operator>=</operator> <name>num</name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>num_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>a0ialloc</name><argument_list>(<argument><expr><name>num_size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>bootstrap_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>a0idalloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_set</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_store_p</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arenas</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>narenas_total_set</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>narenas</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name>narenas_total</name></expr></argument>, <argument><expr><name>narenas</name></expr></argument>, <argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>narenas_total_inc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_fetch_add_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name>narenas_total</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name></type>
<name>narenas_total_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name>narenas_total</name></expr></argument>, <argument><expr><name>ATOMIC_ACQUIRE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new arena and insert it into the arenas array at index ind. */</comment>
<function><type><specifier>static</specifier> <name>arena_t</name> <modifier>*</modifier></type>
<name>arena_init_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ind</name> <operator>&lt;=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>&gt;=</operator> <name>MALLOCX_ARENA_LIMIT</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>==</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>narenas_total_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Another thread may have already initialized arenas[ind] if it's an
	 * auto arena.
	 */</comment>
	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>arena_is_auto</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>arena</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Actually initialize the arena. */</comment>
	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_new</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>arena</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_new_create_background_thread</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Avoid creating a new background thread just for the huge arena, which
	 * purges eagerly by default.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>arena_is_huge</name><argument_list>(<argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>background_thread_create</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: error in background thread "</literal>
				      <literal type="string">"creation for arena %u. Abort.\n"</literal></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>arena_t</name> <modifier>*</modifier></type>
<name>arena_init</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_init_locked</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_new_create_background_thread</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>arena</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bind</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>arena_nthreads_inc</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>internal</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_iarena_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_arena_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>shard</name> <init>= <expr><call><name>atomic_fetch_add_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>binshard_next</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tsd_binshards_t</name> <modifier>*</modifier></type><name>bins</name> <init>= <expr><call><name>tsd_binshardsp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			    <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name> <operator>&lt;=</operator> <name>BIN_SHARDS_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bins</name><operator>-&gt;</operator><name>binshard</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>shard</name> <operator>%</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_migrate</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>oldind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>newind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>oldarena</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newarena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldarena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newarena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_nthreads_dec</name><argument_list>(<argument><expr><name>oldarena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_nthreads_inc</name><argument_list>(<argument><expr><name>newarena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tsd_arena_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>newarena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_unbind</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_nthreads_dec</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>internal</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_iarena_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_arena_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>arena_tdata_t</name> <modifier>*</modifier></type>
<name>arena_tdata_get_hard</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arenas_tdata_old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_tdata_t</name> <modifier>*</modifier></type><name>arenas_tdata</name> <init>= <expr><call><name>tsd_arenas_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas_tdata_old</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas_tdata</name> <init>= <expr><call><name>tsd_narenas_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas_actual</name> <init>= <expr><call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Dissociate old tdata array (and set up for deallocation upon return)
	 * if it's too small.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arenas_tdata</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>narenas_tdata</name> <operator>&lt;</operator> <name>narenas_actual</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>arenas_tdata_old</name> <operator>=</operator> <name>arenas_tdata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>narenas_tdata_old</name> <operator>=</operator> <name>narenas_tdata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>arenas_tdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>narenas_tdata</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_arenas_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arenas_tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_narenas_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>narenas_tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>arenas_tdata_old</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>narenas_tdata_old</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Allocate tdata array if it's missing. */</comment>
	<if_stmt><if>if <condition>(<expr><name>arenas_tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>arenas_tdata_bypassp</name> <init>= <expr><call><name>tsd_arenas_tdata_bypassp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>narenas_tdata</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ind</name> <operator>&lt;</operator> <name>narenas_actual</name><operator>)</operator></expr> ?</condition><then> <expr><name>narenas_actual</name></expr> </then><else>: <expr><name>ind</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>tsd_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>arenas_tdata_bypassp</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>arenas_tdata_bypassp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arenas_tdata</name> <operator>=</operator> <operator>(</operator><name>arena_tdata_t</name> <operator>*</operator><operator>)</operator><call><name>a0malloc</name><argument_list>(
			    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arena_tdata_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>narenas_tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>arenas_tdata_bypassp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>arenas_tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>tdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>arenas_tdata_bypassp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_arenas_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arenas_tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_narenas_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>narenas_tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy to tdata array.  It's possible that the actual number of arenas
	 * has increased since narenas_total_get() was called above, but that
	 * causes no correctness issues unless two threads concurrently execute
	 * the arenas.create mallctl, which we trust mallctl synchronization to
	 * prevent.
	 */</comment>

	<comment type="block">/* Copy/initialize tickers. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas_actual</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>narenas_tdata_old</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ticker_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arenas_tdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>decay_ticker</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arenas_tdata_old</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>decay_ticker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>ticker_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arenas_tdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>decay_ticker</name></expr></argument>,
			    <argument><expr><name>DECAY_NTICKS_PER_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>narenas_tdata</name> <operator>&gt;</operator> <name>narenas_actual</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arenas_tdata</name><index>[<expr><name>narenas_actual</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arena_tdata_t</name></expr></argument>)</argument_list></sizeof>
		    <operator>*</operator> <operator>(</operator><name>narenas_tdata</name> <operator>-</operator> <name>narenas_actual</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Read the refreshed tdata array. */</comment>
	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>&amp;</operator><name><name>arenas_tdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>arenas_tdata_old</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>a0dalloc</name><argument_list>(<argument><expr><name>arenas_tdata_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>tdata</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Slow path, called only by arena_choose(). */</comment>
<function><type><name>arena_t</name> <modifier>*</modifier></type>
<name>arena_choose_hard</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier><name>ret</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_percpu_arena</name> <operator>&amp;&amp;</operator> <call><name>PERCPU_ARENA_ENABLED</name><argument_list>(<argument><expr><name>opt_percpu_arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>choose</name> <init>= <expr><call><name>percpu_arena_choose</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>choose</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_bind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_bind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>narenas_auto</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name><name>choose</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>first_null</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>is_new_arena</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Determine binding for both non-internal and internal
		 * allocation.
		 *
		 *   choose[0]: For application allocation.
		 *   choose[1]: For internal metadata allocation.
		 */</comment>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>is_new_arena</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>first_null</name> <operator>=</operator> <name>narenas_auto</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas_auto</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * Choose the first arena that has the lowest
				 * number of threads assigned to it.
				 */</comment>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>arena_nthreads_get</name><argument_list>(<argument><expr><call><name>arena_get</name><argument_list>(
					    <argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!</operator><operator>!</operator><name>j</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
					    <call><name>arena_nthreads_get</name><argument_list>(<argument><expr><call><name>arena_get</name><argument_list>(
					    <argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><operator>!</operator><operator>!</operator><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>first_null</name> <operator>==</operator> <name>narenas_auto</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * Record the index of the first uninitialized
				 * arena, in case all extant arenas are in use.
				 *
				 * NB: It is possible for there to be
				 * discontinuities in terms of initialized
				 * versus uninitialized arenas, due to the
				 * "thread.arena" mallctl.
				 */</comment>
				<expr_stmt><expr><name>first_null</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>arena_nthreads_get</name><argument_list>(<argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!</operator><operator>!</operator><name>j</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>first_null</name> <operator>==</operator>
			    <name>narenas_auto</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * Use an unloaded arena, or the least loaded
				 * arena if all arenas are already initialized.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>j</name> <operator>==</operator> <name>internal</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

				<comment type="block">/* Initialize a new arena. */</comment>
				<expr_stmt><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>first_null</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_init_locked</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
				    <argument><expr><operator>(</operator><name>extent_hooks_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>extent_hooks_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>is_new_arena</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>j</name> <operator>==</operator> <name>internal</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>arena</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>arena_bind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>!</operator><operator>!</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>is_new_arena</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>arena_new_create_background_thread</name><argument_list>(
				    <argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>choose</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_bind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_bind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>iarena_cleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>iarena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>iarena</name> <operator>=</operator> <call><name>tsd_iarena_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>iarena</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_unbind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>iarena</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_cleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>tsd_arena_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_unbind</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>arena_ind_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arenas_tdata_cleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_tdata_t</name> <modifier>*</modifier></type><name>arenas_tdata</name></decl>;</decl_stmt>

	<comment type="block">/* Prevent tsd-&gt;arenas_tdata from being (re)created. */</comment>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_arenas_tdata_bypassp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>arenas_tdata</name> <operator>=</operator> <call><name>tsd_arenas_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arenas_tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_arenas_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>a0dalloc</name><argument_list>(<argument><expr><name>arenas_tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_print_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Merge stats from extant threads.  This is racy, since
		 * individual threads do not lock when recording tcache stats
		 * events.  As a consequence, the final stats may be slightly
		 * out of date by the time they are reported, if other threads
		 * continue to allocate.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>narenas</name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>arena_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>ql_foreach</name><argument_list>(<argument>tcache</argument>, <argument>&amp;arena-&gt;tcache_ql</argument>, <argument>link</argument>)</argument_list></macro> <block>{<block_content>
					<expr_stmt><expr><call><name>tcache_stats_merge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
				    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>je_malloc_stats_print</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>opt_stats_print_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure that we don't hold any locks upon entry to or exit from allocator
 * code (in a "broad" sense that doesn't count a reentrant allocation as an
 * entrance or exit).
 */</comment>
<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name></type>
<name>check_entry_exit_locking</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_debug</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * It's possible we hold locks at entry/exit if we're in a nested
	 * allocation.
	 */</comment>
	<decl_stmt><decl><type><name>int8_t</name></type> <name>reentrancy_level</name> <init>= <expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>reentrancy_level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>witness_assert_lockless</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * End miscellaneous support functions.
 */</comment>
<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Begin initialization functions.
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>jemalloc_secure_getenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_HAVE_SECURE_GETENV</name></cpp:ifdef>
	<return>return <expr><call><name>secure_getenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_HAVE_ISSETUGID</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>issetugid</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>getenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>malloc_ncpus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>SYSTEM_INFO</name></type> <name>si</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GetSystemInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>si</name><operator>.</operator><name>dwNumberOfProcessors</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_GLIBC_MALLOC_HOOK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CPU_COUNT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<comment type="block">/*
	 * glibc &gt;= 2.6 has the CPU_COUNT macro.
	 *
	 * glibc's sysconf() uses isspace().  glibc allocates for the first time
	 * *before* setting up the isspace tables.  Therefore we need a
	 * different method to get the number of CPUs.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>cpu_set_t</name></type> <name>set</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pthread_getaffinity_np</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CPU_COUNT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_NPROCESSORS_ONLN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>result</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_opt_stats_print_opts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>vlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>opts_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>opt_stats_print_opts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opts_len</name> <operator>&lt;=</operator> <name>stats_print_tot_num_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>vlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<switch>switch <condition>(<expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case o: break;</cpp:value></cpp:define>
			<macro><name>STATS_PRINT_OPTIONS</name></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPTION</name></cpp:undef>
		<default>default:</default> <continue>continue;</continue>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>opt_stats_print_opts</name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Ignore repeated. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>opt_stats_print_opts</name><index>[<expr><name>opts_len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opt_stats_print_opts</name><index>[<expr><name>opts_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opts_len</name> <operator>&lt;=</operator> <name>stats_print_tot_num_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opts_len</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opt_stats_print_opts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reads the next size pair in a multi-sized option. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_conf_multi_sizes_next</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>slab_size_segment_cur</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>vlen_left</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slab_start</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slab_end</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>new_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>*</operator><name>slab_size_segment_cur</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uintmax_t</name></type> <name>um</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First number, then '-' */</comment>
	<expr_stmt><expr><name>um</name> <operator>=</operator> <call><name>malloc_strtoumax</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_errno</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>slab_start</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>um</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Second number, then ':' */</comment>
	<expr_stmt><expr><name>um</name> <operator>=</operator> <call><name>malloc_strtoumax</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_errno</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>slab_end</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>um</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Last number */</comment>
	<expr_stmt><expr><name>um</name> <operator>=</operator> <call><name>malloc_strtoumax</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_errno</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>new_size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>um</name></expr>;</expr_stmt>

	<comment type="block">/* Consume the separator if there is one. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>vlen_left</name> <operator>-=</operator> <name>end</name> <operator>-</operator> <operator>*</operator><name>slab_size_segment_cur</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>slab_size_segment_cur</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_conf_next</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>opts_p</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>k_p</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>klen_p</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>v_p</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>vlen_p</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>accept</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opts</name> <init>= <expr><operator>*</operator><name>opts_p</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>k_p</name> <operator>=</operator> <name>opts</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>accept</name> <operator>=</operator> <name>false</name></expr>;</init> <condition><expr><operator>!</operator><name>accept</name></expr>;</condition><incr/>)</control> <block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>opts</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="char">'A'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case> <case>case <expr><literal type="char">'C'</literal></expr>:</case> <case>case <expr><literal type="char">'D'</literal></expr>:</case> <case>case <expr><literal type="char">'E'</literal></expr>:</case> <case>case <expr><literal type="char">'F'</literal></expr>:</case>
		<case>case <expr><literal type="char">'G'</literal></expr>:</case> <case>case <expr><literal type="char">'H'</literal></expr>:</case> <case>case <expr><literal type="char">'I'</literal></expr>:</case> <case>case <expr><literal type="char">'J'</literal></expr>:</case> <case>case <expr><literal type="char">'K'</literal></expr>:</case> <case>case <expr><literal type="char">'L'</literal></expr>:</case>
		<case>case <expr><literal type="char">'M'</literal></expr>:</case> <case>case <expr><literal type="char">'N'</literal></expr>:</case> <case>case <expr><literal type="char">'O'</literal></expr>:</case> <case>case <expr><literal type="char">'P'</literal></expr>:</case> <case>case <expr><literal type="char">'Q'</literal></expr>:</case> <case>case <expr><literal type="char">'R'</literal></expr>:</case>
		<case>case <expr><literal type="char">'S'</literal></expr>:</case> <case>case <expr><literal type="char">'T'</literal></expr>:</case> <case>case <expr><literal type="char">'U'</literal></expr>:</case> <case>case <expr><literal type="char">'V'</literal></expr>:</case> <case>case <expr><literal type="char">'W'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case>
		<case>case <expr><literal type="char">'Y'</literal></expr>:</case> <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
		<case>case <expr><literal type="char">'a'</literal></expr>:</case> <case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'e'</literal></expr>:</case> <case>case <expr><literal type="char">'f'</literal></expr>:</case>
		<case>case <expr><literal type="char">'g'</literal></expr>:</case> <case>case <expr><literal type="char">'h'</literal></expr>:</case> <case>case <expr><literal type="char">'i'</literal></expr>:</case> <case>case <expr><literal type="char">'j'</literal></expr>:</case> <case>case <expr><literal type="char">'k'</literal></expr>:</case> <case>case <expr><literal type="char">'l'</literal></expr>:</case>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case> <case>case <expr><literal type="char">'n'</literal></expr>:</case> <case>case <expr><literal type="char">'o'</literal></expr>:</case> <case>case <expr><literal type="char">'p'</literal></expr>:</case> <case>case <expr><literal type="char">'q'</literal></expr>:</case> <case>case <expr><literal type="char">'r'</literal></expr>:</case>
		<case>case <expr><literal type="char">'s'</literal></expr>:</case> <case>case <expr><literal type="char">'t'</literal></expr>:</case> <case>case <expr><literal type="char">'u'</literal></expr>:</case> <case>case <expr><literal type="char">'v'</literal></expr>:</case> <case>case <expr><literal type="char">'w'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case>
		<case>case <expr><literal type="char">'y'</literal></expr>:</case> <case>case <expr><literal type="char">'z'</literal></expr>:</case>
		<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case>
		<case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>
		<case>case <expr><literal type="char">'_'</literal></expr>:</case>
			<expr_stmt><expr><name>opts</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">':'</literal></expr>:</case>
			<expr_stmt><expr><name>opts</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>klen_p</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>opts</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>*</operator><name>k_p</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>v_p</name> <operator>=</operator> <name>opts</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>accept</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>!=</operator> <operator>*</operator><name>opts_p</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Conf string ends "</literal>
				    <literal type="string">"with key\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Malformed conf string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>accept</name> <operator>=</operator> <name>false</name></expr>;</init> <condition><expr><operator>!</operator><name>accept</name></expr>;</condition><incr/>)</control> <block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>opts</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="char">','</literal></expr>:</case>
			<expr_stmt><expr><name>opts</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/*
			 * Look ahead one character here, because the next time
			 * this function is called, it will assume that end of
			 * input has been cleanly reached if no input remains,
			 * but we have optimistically already consumed the
			 * comma if one exists.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>opts</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Conf string ends "</literal>
				    <literal type="string">"with comma\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>vlen_p</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>opts</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>*</operator><name>v_p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>accept</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>vlen_p</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>opts</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>*</operator><name>v_p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>accept</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>opts</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>opts_p</name> <operator>=</operator> <name>opts</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_abort_invalid_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opt_abort_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Abort (abort_conf:true) on invalid conf "</literal>
	    <literal type="string">"value (see above).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_conf_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>vlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: %s: %.*s:%.*s\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>klen</name></expr></argument>, <argument><expr><name>k</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>vlen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If abort_conf is set, error out after processing all options. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>experimental</name> <init>= <expr><literal type="string">"experimental_"</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>experimental</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>experimental</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* However, tolerate experimental features. */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>had_conf_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_slow_flag_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Combine the runtime options into malloc_slow for fast path.  Called
	 * after processing all the options.
	 */</comment>
	<expr_stmt><expr><name>malloc_slow_flags</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>opt_junk_alloc</name></expr> ?</condition><then> <expr><name>flag_opt_junk_alloc</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
	    <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>opt_junk_free</name></expr> ?</condition><then> <expr><name>flag_opt_junk_free</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
	    <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>opt_zero</name></expr> ?</condition><then> <expr><name>flag_opt_zero</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
	    <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>opt_utrace</name></expr> ?</condition><then> <expr><name>flag_opt_utrace</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
	    <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>opt_xmalloc</name></expr> ?</condition><then> <expr><name>flag_opt_xmalloc</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>malloc_slow</name> <operator>=</operator> <operator>(</operator><name>malloc_slow_flags</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Number of sources for initializing malloc_conf */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_CONF_NSOURCES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>obtain_malloc_conf</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>which_source</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_debug</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>read_source</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Each source should only be read once, to minimize # of
		 * syscalls on init.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>read_source</name><operator>++</operator> <operator>==</operator> <name>which_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>which_source</name> <operator>&lt;</operator> <name>MALLOC_CONF_NSOURCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>which_source</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><literal type="number">0</literal></expr>:</case>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>config_malloc_conf</name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="number">1</literal></expr>:</case>
		<if_stmt><if>if <condition>(<expr><name>je_malloc_conf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Use options that were compiled into the program. */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>je_malloc_conf</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* No configuration specified. */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>linklen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linkname</name> <init>=
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PREFIX</name></cpp:ifdef>
		    <expr><literal type="string">"/etc/"</literal><name>JEMALLOC_PREFIX</name><literal type="string">"malloc.conf"</literal>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
		    <literal type="string">"/etc/malloc.conf"</literal></expr></init></decl>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
		    ;</decl_stmt>

		<comment type="block">/*
		 * Try to use the contents of the "/etc/malloc.conf" symbolic
		 * link's name.
		 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_READLINKAT</name></cpp:ifndef>
		<expr_stmt><expr><name>linklen</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>linklen</name> <operator>=</operator> <call><name>readlinkat</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name>linklen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* No configuration specified. */</comment>
			<expr_stmt><expr><name>linklen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* Restore errno. */</comment>
			<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>linklen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block> <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envname</name> <init>=
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PREFIX</name></cpp:ifdef>
		    <expr><name>JEMALLOC_CPREFIX</name><literal type="string">"MALLOC_CONF"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		    <literal type="string">"MALLOC_CONF"</literal></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    ;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>jemalloc_secure_getenv</name><argument_list>(<argument><expr><name>envname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Do nothing; opts is already initialized to the value
			 * of the MALLOC_CONF environment variable.
			 */</comment>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* No configuration specified. */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	</block_content>}</block> <default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_conf_init_helper</name><parameter_list>(<parameter><decl><type><name>sc_data_t</name> <modifier>*</modifier></type><name>sc_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name><name>bin_shard_sizes</name><index>[<expr><name>SC_NBINS</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>initial_call</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>opts_cache</name><index>[<expr><name>MALLOC_CONF_NSOURCES</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>opts_explain</name><index>[<expr><name>MALLOC_CONF_NSOURCES</name></expr>]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"string specified via --with-malloc-conf"</literal></expr>,
		<expr><literal type="string">"string pointed to by the global variable malloc_conf"</literal></expr>,
		<expr><literal type="string">"\"name\" of the file referenced by the symbolic link named "</literal>
		    <literal type="string">"/etc/malloc.conf"</literal></expr>,
		<expr><literal type="string">"value of the environment variable MALLOC_CONF"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>k</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>klen</name></decl>, <decl><type ref="prev"/><name>vlen</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MALLOC_CONF_NSOURCES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="block">/* Get runtime configuration. */</comment>
		<if_stmt><if>if <condition>(<expr><name>initial_call</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>opts_cache</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>obtain_malloc_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>opts</name> <operator>=</operator> <name><name>opts_cache</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>initial_call</name> <operator>&amp;&amp;</operator> <name>opt_confirm_conf</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(
			    <argument><expr><literal type="string">"&lt;jemalloc&gt;: malloc_conf #%u (%s): \"%s\"\n"</literal></expr></argument>,
			    <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>opts_explain</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>opts</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>opts</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<while>while <condition>(<expr><operator>*</operator><name>opts</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>malloc_conf_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_ERROR</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>klen</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>vlen</name></type></parameter>)</parameter_list></cpp:macro>				\
			<cpp:value>if (!initial_call) {				\
				malloc_conf_error(			\
				    msg, k, klen, v, vlen);		\
				cur_opt_valid = false;			\
			}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_CONTINUE</name></cpp:macro>	<cpp:value>{						\
				if (!initial_call &amp;&amp; opt_confirm_conf	\
				    &amp;&amp; cur_opt_valid) {			\
					malloc_printf("&lt;jemalloc&gt;: -- "	\
					    "Set conf value: %.*s:%.*s"	\
					    "\n", (int)klen, k,		\
					    (int)vlen, v);		\
				}					\
				continue;				\
			}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_MATCH</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>							\
	<cpp:value>(sizeof(n)-1 == klen &amp;&amp; strncmp(n, k, klen) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_MATCH_VALUE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>						\
	<cpp:value>(sizeof(n)-1 == vlen &amp;&amp; strncmp(n, v, vlen) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_HANDLE_BOOL</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>						\
			<cpp:value>if (CONF_MATCH(n)) {				\
				if (CONF_MATCH_VALUE("true")) {		\
					o = true;			\
				} else if (CONF_MATCH_VALUE("false")) {	\
					o = false;			\
				} else {				\
					CONF_ERROR("Invalid conf value",\
					    k, klen, v, vlen);		\
				}					\
				CONF_CONTINUE;				\
			}</cpp:value></cpp:define>
      <comment type="block">/*
       * One of the CONF_MIN macros below expands, in one of the use points,
       * to "unsigned integer &lt; 0", which is always false, triggering the
       * GCC -Wtype-limits warning, which we disable here and re-enable below.
       */</comment>
      <decl_stmt><decl><type><name>JEMALLOC_DIAGNOSTIC_PUSH</name>
      <name>JEMALLOC_DIAGNOSTIC_IGNORE_TYPE_LIMITS</name>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_DONT_CHECK_MIN</name><parameter_list>(<parameter><type><name>um</name></type></parameter>, <parameter><type><name>min</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>false</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_CHECK_MIN</name><parameter_list>(<parameter><type><name>um</name></type></parameter>, <parameter><type><name>min</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((um) &lt; (min))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_DONT_CHECK_MAX</name><parameter_list>(<parameter><type><name>um</name></type></parameter>, <parameter><type><name>max</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>false</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_CHECK_MAX</name><parameter_list>(<parameter><type><name>um</name></type></parameter>, <parameter><type><name>max</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((um) &gt; (max))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_HANDLE_T_U</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>min</name></type></parameter>, <parameter><type><name>max</name></type></parameter>, <parameter><type><name>check_min</name></type></parameter>, <parameter><type><name>check_max</name></type></parameter>, <parameter><type><name>clip</name></type></parameter>)</parameter_list></cpp:macro>	\
			<cpp:value>if (CONF_MATCH(n)) {				\
				uintmax_t um;				\
				char *end;				\
									\
				set_errno(0);				\
				um = malloc_strtoumax(v, &amp;end, 0);	\
				if (get_errno() != 0 || (uintptr_t)end -\
				    (uintptr_t)v != vlen) {		\
					CONF_ERROR("Invalid conf value",\
					    k, klen, v, vlen);		\
				} else if (clip) {			\
					if (check_min(um, (t)(min))) {	\
						o = (t)(min);		\
					} else if (			\
					    check_max(um, (t)(max))) {	\
						o = (t)(max);		\
					} else {			\
						o = (t)um;		\
					}				\
				} else {				\
					if (check_min(um, (t)(min)) ||	\
					    check_max(um, (t)(max))) {	\
						CONF_ERROR(		\
						    "Out-of-range "	\
						    "conf value",	\
						    k, klen, v, vlen);	\
					} else {			\
						o = (t)um;		\
					}				\
				}					\
				CONF_CONTINUE;				\
			}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_HANDLE_UNSIGNED</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>min</name></type></parameter>, <parameter><type><name>max</name></type></parameter>, <parameter><type><name>check_min</name></type></parameter>, <parameter><type><name>check_max</name></type></parameter>,	\
    <parameter><type><name>clip</name></type></parameter>)</parameter_list></cpp:macro>								\
			<cpp:value>CONF_HANDLE_T_U(unsigned, o, n, min, max,	\
			    check_min, check_max, clip)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_HANDLE_SIZE_T</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>min</name></type></parameter>, <parameter><type><name>max</name></type></parameter>, <parameter><type><name>check_min</name></type></parameter>, <parameter><type><name>check_max</name></type></parameter>, <parameter><type><name>clip</name></type></parameter>)</parameter_list></cpp:macro>	\
			<cpp:value>CONF_HANDLE_T_U(size_t, o, n, min, max,		\
			    check_min, check_max, clip)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_HANDLE_SSIZE_T</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>min</name></type></parameter>, <parameter><type><name>max</name></type></parameter>)</parameter_list></cpp:macro>				\
			<cpp:value>if (CONF_MATCH(n)) {				\
				long l;					\
				char *end;				\
									\
				set_errno(0);				\
				l = strtol(v, &amp;end, 0);			\
				if (get_errno() != 0 || (uintptr_t)end -\
				    (uintptr_t)v != vlen) {		\
					CONF_ERROR("Invalid conf value",\
					    k, klen, v, vlen);		\
				} else if (l &lt; (ssize_t)(min) || l &gt;	\
				    (ssize_t)(max)) {			\
					CONF_ERROR(			\
					    "Out-of-range conf value",	\
					    k, klen, v, vlen);		\
				} else {				\
					o = l;				\
				}					\
				CONF_CONTINUE;				\
			}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_HANDLE_CHAR_P</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>					\
			<cpp:value>if (CONF_MATCH(n)) {				\
				size_t cpylen = (vlen &lt;=		\
				    sizeof(o)-1) ? vlen :		\
				    sizeof(o)-1;			\
				strncpy(o, v, cpylen);			\
				o[cpylen] = '\0';			\
				CONF_CONTINUE;				\
			}</cpp:value></cpp:define>

			<name>bool</name></type> <name>cur_opt_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_confirm_conf</argument>, <argument><literal type="string">"confirm_conf"</literal></argument>)</argument_list></macro>
			<if_stmt><if>if <condition>(<expr><name>initial_call</name></expr>)</condition> <block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_abort</argument>, <argument><literal type="string">"abort"</literal></argument>)</argument_list></macro>
			<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_abort_conf</argument>, <argument><literal type="string">"abort_conf"</literal></argument>)</argument_list></macro>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"metadata_thp"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>metadata_thp_mode_limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>metadata_thp_mode_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					    <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>opt_metadata_thp</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(<argument><expr><literal type="string">"Invalid conf value"</literal></expr></argument>,
					    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_retain</argument>, <argument><literal type="string">"retain"</literal></argument>)</argument_list></macro>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"dss"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dss_prec_limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>dss_prec_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call>
					    <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>extent_dss_prec_set</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
							<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(
							    <argument><expr><literal type="string">"Error setting dss"</literal></expr></argument>,
							    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if> <else>else <block>{<block_content>
							<expr_stmt><expr><name>opt_dss</name> <operator>=</operator>
							    <name><name>dss_prec_names</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(<argument><expr><literal type="string">"Invalid conf value"</literal></expr></argument>,
					    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<macro><name>CONF_HANDLE_UNSIGNED</name><argument_list>(<argument>opt_narenas</argument>, <argument><literal type="string">"narenas"</literal></argument>, <argument><literal type="number">1</literal></argument>,
			    <argument>UINT_MAX</argument>, <argument>CONF_CHECK_MIN</argument>, <argument>CONF_DONT_CHECK_MAX</argument>,
			    <argument>false</argument>)</argument_list></macro>
			<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH</name><argument_list>(<argument><expr><literal type="string">"bin_shards"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bin_shards_segment_cur</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type> <name>vlen_left</name> <init>= <expr><name>vlen</name></expr></init></decl>;</decl_stmt>
				<do>do <block>{<block_content>
					<decl_stmt><decl><type><name>size_t</name></type> <name>size_start</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>size_t</name></type> <name>size_end</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>size_t</name></type> <name>nshards</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>malloc_conf_multi_sizes_next</name><argument_list>(
					    <argument><expr><operator>&amp;</operator><name>bin_shards_segment_cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen_left</name></expr></argument>,
					    <argument><expr><operator>&amp;</operator><name>size_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nshards</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>err</name> <operator>||</operator> <call><name>bin_update_shard_size</name><argument_list>(
					    <argument><expr><name>bin_shard_sizes</name></expr></argument>, <argument><expr><name>size_start</name></expr></argument>,
					    <argument><expr><name>size_end</name></expr></argument>, <argument><expr><name>nshards</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(
						    <argument><expr><literal type="string">"Invalid settings for "</literal>
						    <literal type="string">"bin_shards"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>,
						    <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block> while <condition>(<expr><name>vlen_left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>CONF_HANDLE_SSIZE_T</name><argument_list>(<argument><expr><name>opt_dirty_decay_ms</name></expr></argument>,
			    <argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>NSTIME_SEC_MAX</name> <operator>*</operator> <call><name>KQU</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			    <call><name>QU</name><argument_list>(<argument><expr><name>SSIZE_MAX</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NSTIME_SEC_MAX</name> <operator>*</operator> <call><name>KQU</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr> </then><else>:
			    <expr><name>SSIZE_MAX</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CONF_HANDLE_SSIZE_T</name><argument_list>(<argument><expr><name>opt_muzzy_decay_ms</name></expr></argument>,
			    <argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>NSTIME_SEC_MAX</name> <operator>*</operator> <call><name>KQU</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			    <call><name>QU</name><argument_list>(<argument><expr><name>SSIZE_MAX</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NSTIME_SEC_MAX</name> <operator>*</operator> <call><name>KQU</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr> </then><else>:
			    <expr><name>SSIZE_MAX</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_stats_print</argument>, <argument><literal type="string">"stats_print"</literal></argument>)</argument_list></macro>
			<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH</name><argument_list>(<argument><expr><literal type="string">"stats_print_opts"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>init_opt_stats_print_opts</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_fill</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH</name><argument_list>(<argument><expr><literal type="string">"junk"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH_VALUE</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>opt_junk</name> <operator>=</operator> <literal type="string">"true"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>opt_junk_alloc</name> <operator>=</operator> <name>opt_junk_free</name> <operator>=</operator>
						    <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>CONF_MATCH_VALUE</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>opt_junk</name> <operator>=</operator> <literal type="string">"false"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>opt_junk_alloc</name> <operator>=</operator> <name>opt_junk_free</name> <operator>=</operator>
						    <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>CONF_MATCH_VALUE</name><argument_list>(<argument><expr><literal type="string">"alloc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>opt_junk</name> <operator>=</operator> <literal type="string">"alloc"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>opt_junk_alloc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>opt_junk_free</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>CONF_MATCH_VALUE</name><argument_list>(<argument><expr><literal type="string">"free"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>opt_junk</name> <operator>=</operator> <literal type="string">"free"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>opt_junk_alloc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>opt_junk_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if> <else>else <block>{<block_content>
						<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(
						    <argument><expr><literal type="string">"Invalid conf value"</literal></expr></argument>,
						    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_zero</argument>, <argument><literal type="string">"zero"</literal></argument>)</argument_list></macro>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_utrace</name></expr>)</condition> <block>{<block_content>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_utrace</argument>, <argument><literal type="string">"utrace"</literal></argument>)</argument_list></macro>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_xmalloc</name></expr>)</condition> <block>{<block_content>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_xmalloc</argument>, <argument><literal type="string">"xmalloc"</literal></argument>)</argument_list></macro>
			</block_content>}</block></if></if_stmt>
			<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_tcache</argument>, <argument><literal type="string">"tcache"</literal></argument>)</argument_list></macro>
			<macro><name>CONF_HANDLE_SSIZE_T</name><argument_list>(<argument>opt_lg_tcache_max</argument>, <argument><literal type="string">"lg_tcache_max"</literal></argument>,
			    <argument>-<literal type="number">1</literal></argument>, <argument>(sizeof(size_t) &lt;&lt; <literal type="number">3</literal>) - <literal type="number">1</literal></argument>)</argument_list></macro>

			<comment type="block">/*
			 * The runtime option of oversize_threshold remains
			 * undocumented.  It may be tweaked in the next major
			 * release (6.0).  The default value 8M is rather
			 * conservative / safe.  Tuning it further down may
			 * improve fragmentation a bit more, but may also cause
			 * contention on the huge arena.
			 */</comment>
			<macro><name>CONF_HANDLE_SIZE_T</name><argument_list>(<argument>opt_oversize_threshold</argument>,
			    <argument><literal type="string">"oversize_threshold"</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>SC_LARGE_MAXCLASS</argument>,
			    <argument>CONF_DONT_CHECK_MIN</argument>, <argument>CONF_CHECK_MAX</argument>, <argument>false</argument>)</argument_list></macro>
			<macro><name>CONF_HANDLE_SIZE_T</name><argument_list>(<argument>opt_lg_extent_max_active_fit</argument>,
			    <argument><literal type="string">"lg_extent_max_active_fit"</literal></argument>, <argument><literal type="number">0</literal></argument>,
			    <argument>(sizeof(size_t) &lt;&lt; <literal type="number">3</literal>)</argument>, <argument>CONF_DONT_CHECK_MIN</argument>,
			    <argument>CONF_CHECK_MAX</argument>, <argument>false</argument>)</argument_list></macro>

			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"percpu_arena"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>percpu_arena_mode_names_base</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator>
				    <name>percpu_arena_mode_names_limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>percpu_arena_mode_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					    <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_percpu_arena</name></expr>)</condition> <block>{<block_content>
							<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(
							    <argument><expr><literal type="string">"No getcpu support"</literal></expr></argument>,
							    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>opt_percpu_arena</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(<argument><expr><literal type="string">"Invalid conf value"</literal></expr></argument>,
					    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>CONF_HANDLE_BOOL</name><argument_list>(<argument><expr><name>opt_background_thread</name></expr></argument>,
			    <argument><expr><literal type="string">"background_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CONF_HANDLE_SIZE_T</name><argument_list>(<argument><expr><name>opt_max_background_threads</name></expr></argument>,
					   <argument><expr><literal type="string">"max_background_threads"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					   <argument><expr><name>opt_max_background_threads</name></expr></argument>,
					   <argument><expr><name>CONF_CHECK_MIN</name></expr></argument>, <argument><expr><name>CONF_CHECK_MAX</name></expr></argument>,
					   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH</name><argument_list>(<argument><expr><literal type="string">"slab_sizes"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>err</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slab_size_segment_cur</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type> <name>vlen_left</name> <init>= <expr><name>vlen</name></expr></init></decl>;</decl_stmt>
				<do>do <block>{<block_content>
					<decl_stmt><decl><type><name>size_t</name></type> <name>slab_start</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>size_t</name></type> <name>slab_end</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>size_t</name></type> <name>pgs</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>malloc_conf_multi_sizes_next</name><argument_list>(
					    <argument><expr><operator>&amp;</operator><name>slab_size_segment_cur</name></expr></argument>,
					    <argument><expr><operator>&amp;</operator><name>vlen_left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slab_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slab_end</name></expr></argument>,
					    <argument><expr><operator>&amp;</operator><name>pgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><call><name>sc_data_update_slab_size</name><argument_list>(
						    <argument><expr><name>sc_data</name></expr></argument>, <argument><expr><name>slab_start</name></expr></argument>,
						    <argument><expr><name>slab_end</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if> <else>else <block>{<block_content>
						<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(<argument><expr><literal type="string">"Invalid settings "</literal>
						    <literal type="string">"for slab_sizes"</literal></expr></argument>,
						    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block> while <condition>(<expr><operator>!</operator><name>err</name> <operator>&amp;&amp;</operator> <name>vlen_left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof</argument>, <argument><literal type="string">"prof"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_CHAR_P</name><argument_list>(<argument>opt_prof_prefix</argument>,
				    <argument><literal type="string">"prof_prefix"</literal></argument>, <argument><literal type="string">"jeprof"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_active</argument>, <argument><literal type="string">"prof_active"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_thread_active_init</argument>,
				    <argument><literal type="string">"prof_thread_active_init"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_SIZE_T</name><argument_list>(<argument>opt_lg_prof_sample</argument>,
				    <argument><literal type="string">"lg_prof_sample"</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>(sizeof(uint64_t) &lt;&lt; <literal type="number">3</literal>)
				    - <literal type="number">1</literal></argument>, <argument>CONF_DONT_CHECK_MIN</argument>, <argument>CONF_CHECK_MAX</argument>,
				    <argument>true</argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_accum</argument>, <argument><literal type="string">"prof_accum"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_SSIZE_T</name><argument_list>(<argument>opt_lg_prof_interval</argument>,
				    <argument><literal type="string">"lg_prof_interval"</literal></argument>, <argument>-<literal type="number">1</literal></argument>,
				    <argument>(sizeof(uint64_t) &lt;&lt; <literal type="number">3</literal>) - <literal type="number">1</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_gdump</argument>, <argument><literal type="string">"prof_gdump"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_final</argument>, <argument><literal type="string">"prof_final"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_leak</argument>, <argument><literal type="string">"prof_leak"</literal></argument>)</argument_list></macro>
				<macro><name>CONF_HANDLE_BOOL</name><argument_list>(<argument>opt_prof_log</argument>, <argument><literal type="string">"prof_log"</literal></argument>)</argument_list></macro>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_log</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH</name><argument_list>(<argument><expr><literal type="string">"log"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<decl_stmt><decl><type><name>size_t</name></type> <name>cpylen</name> <init>= <expr><operator>(</operator>
					    <ternary><condition><expr><name>vlen</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_var_names</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then>
					    <expr><name>vlen</name></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_var_names</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>log_var_names</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>cpylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>log_var_names</name><index>[<expr><name>cpylen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>CONF_MATCH</name><argument_list>(<argument><expr><literal type="string">"thp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thp_mode_names_limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>thp_mode_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call>
					    <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_madvise_huge</name></expr>)</condition> <block>{<block_content>
							<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(
							    <argument><expr><literal type="string">"No THP support"</literal></expr></argument>,
							    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>opt_thp</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(<argument><expr><literal type="string">"Invalid conf value"</literal></expr></argument>,
					    <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>CONF_CONTINUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>CONF_ERROR</name><argument_list>(<argument><expr><literal type="string">"Invalid conf pair"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_ERROR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_CONTINUE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_MATCH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_MATCH_VALUE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_HANDLE_BOOL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_DONT_CHECK_MIN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_CHECK_MIN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_DONT_CHECK_MAX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_CHECK_MAX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_HANDLE_T_U</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_HANDLE_UNSIGNED</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_HANDLE_SIZE_T</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_HANDLE_SSIZE_T</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONF_HANDLE_CHAR_P</name></cpp:undef>
    <comment type="block">/* Re-enable diagnostic "-Wtype-limits" */</comment>
    <expr_stmt><expr><name>JEMALLOC_DIAGNOSTIC_POP</name></expr></expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>opt_abort_conf</name> <operator>&amp;&amp;</operator> <name>had_conf_error</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_abort_invalid_conf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>atomic_store_b</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_init_done</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_conf_init</name><parameter_list>(<parameter><decl><type><name>sc_data_t</name> <modifier>*</modifier></type><name>sc_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name><name>bin_shard_sizes</name><index>[<expr><name>SC_NBINS</name></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>opts_cache</name><index>[<expr><name>MALLOC_CONF_NSOURCES</name></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* The first call only set the confirm_conf option and opts_cache */</comment>
	<expr_stmt><expr><call><name>malloc_conf_init_helper</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>opts_cache</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_conf_init_helper</name><argument_list>(<argument><expr><name>sc_data</name></expr></argument>, <argument><expr><name>bin_shard_sizes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>opts_cache</name></expr></argument>,
	    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MALLOC_CONF_NSOURCES</name></cpp:undef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_hard_needed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><name>IS_INITIALIZER</name> <operator>&amp;&amp;</operator> <name>malloc_init_state</name> <operator>==</operator>
	    <name>malloc_init_recursible</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Another thread initialized the allocator before this one
		 * acquired init_lock, or this thread is the initializing
		 * thread, and it is recursively allocating.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_THREADED_INIT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>malloc_initializer</name> <operator>!=</operator> <name>NO_INITIALIZER</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IS_INITIALIZER</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Busy-wait until the initializing thread completes. */</comment>
		<decl_stmt><decl><type><name>spin_t</name></type> <name>spinner</name> <init>= <expr><name>SPIN_INITIALIZER</name></expr></init></decl>;</decl_stmt>
		<do>do <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>spin_adaptive</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spinner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr>)</condition>;</do>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_hard_a0_locked</name><parameter_list>()</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>malloc_initializer</name> <operator>=</operator> <name>INITIALIZER</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>JEMALLOC_DIAGNOSTIC_PUSH</name>
	<name>JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS</name>
	<name>sc_data_t</name></type> <name>sc_data</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JEMALLOC_DIAGNOSTIC_POP</name></type>

	<comment type="block">/*
	 * Ordering here is somewhat tricky; we need sc_boot() first, since that
	 * determines what the size classes will be, and then
	 * malloc_conf_init(), since any slab size tweaking will need to be done
	 * before sz_boot and bin_boot, which assume that the values they read
	 * out of sc_data_global are final.
	 */</comment>
	<name>sc_boot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_data</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name><name>bin_shard_sizes</name><index>[<expr><name>SC_NBINS</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>bin_shard_sizes_boot</name><argument_list>(<argument><expr><name>bin_shard_sizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * prof_boot0 only initializes opt_prof_prefix.  We need to do it before
	 * we parse malloc_conf options, in case malloc_conf parsing overwrites
	 * it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_boot0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_conf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_data</name></expr></argument>, <argument><expr><name>bin_shard_sizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sz_boot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bin_boot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_data</name></expr></argument>, <argument><expr><name>bin_shard_sizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_stats_print</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Print statistics at exit. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><name>stats_print_atexit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in atexit()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pages_boot</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>base_boot</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>extent_boot</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctl_boot</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_boot1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>arena_boot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tcache_boot</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>, <argument><expr><literal type="string">"arenas"</literal></expr></argument>, <argument><expr><name>WITNESS_RANK_ARENAS</name></expr></argument>,
	    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>hook_boot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Create enough scaffolding to allow recursive allocation in
	 * malloc_ncpus().
	 */</comment>
	<expr_stmt><expr><name>narenas_auto</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>manual_arena_base</name> <operator>=</operator> <name>narenas_auto</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>arenas</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arena_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>narenas_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Initialize one arena here.  The rest are lazily created in
	 * arena_choose_hard().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>arena_init</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>extent_hooks_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>extent_hooks_default</name></expr></argument>)</argument_list></call>
	    <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>a0</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>malloc_init_state</name> <operator>=</operator> <name>malloc_init_a0_initialized</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_hard_a0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>malloc_init_hard_a0_locked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize data structures which may trigger recursive allocation. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_hard_recursible</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>malloc_init_state</name> <operator>=</operator> <name>malloc_init_recursible</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ncpus</name> <operator>=</operator> <call><name>malloc_ncpus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_HAVE_PTHREAD_ATFORK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MUTEX_INIT_CB</name></expr></argument>)</argument_list></call> \
    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_ZONE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__native_client__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
	<comment type="block">/* LinuxThreads' pthread_atfork() allocates. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pthread_atfork</name><argument_list>(<argument><expr><name>jemalloc_prefork</name></expr></argument>, <argument><expr><name>jemalloc_postfork_parent</name></expr></argument>,
	    <argument><expr><name>jemalloc_postfork_child</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in pthread_atfork()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>background_thread_boot0</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>malloc_narenas_default</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ncpus</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * For SMP systems, create more than one arena per CPU by
	 * default.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncpus</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ncpus</name> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>percpu_arena_mode_t</name></type>
<name>percpu_arena_as_initialized</name><parameter_list>(<parameter><decl><type><name>percpu_arena_mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mode</name> <operator>&lt;=</operator> <name>percpu_arena_disabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>percpu_arena_disabled</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>mode</name> <operator>+=</operator> <name>percpu_arena_mode_enabled_base</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>mode</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_narenas</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ncpus</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_percpu_arena</name> <operator>!=</operator> <name>percpu_arena_disabled</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_percpu_arena</name> <operator>||</operator> <call><name>malloc_getcpu</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>opt_percpu_arena</name> <operator>=</operator> <name>percpu_arena_disabled</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: perCPU arena getcpu() not "</literal>
			    <literal type="string">"available. Setting narenas to %u.\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>opt_narenas</name></expr> ?</condition><then>
			    <expr><name>opt_narenas</name></expr> </then><else>: <expr><call><name>malloc_narenas_default</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ncpus</name> <operator>&gt;=</operator> <name>MALLOCX_ARENA_LIMIT</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: narenas w/ percpu"</literal>
				    <literal type="string">"arena beyond limit (%d)\n"</literal></expr></argument>, <argument><expr><name>ncpus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* NB: opt_percpu_arena isn't fully initialized yet. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>percpu_arena_as_initialized</name><argument_list>(<argument><expr><name>opt_percpu_arena</name></expr></argument>)</argument_list></call> <operator>==</operator>
			    <name>per_phycpu_arena</name> <operator>&amp;&amp;</operator> <name>ncpus</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: invalid "</literal>
				    <literal type="string">"configuration -- per physical CPU arena "</literal>
				    <literal type="string">"with odd number (%u) of CPUs (no hyper "</literal>
				    <literal type="string">"threading?).\n"</literal></expr></argument>, <argument><expr><name>ncpus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><call><name>percpu_arena_ind_limit</name><argument_list>(
			    <argument><expr><call><name>percpu_arena_as_initialized</name><argument_list>(<argument><expr><name>opt_percpu_arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_narenas</name> <operator>&lt;</operator> <name>n</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * If narenas is specified with percpu_arena
				 * enabled, actual narenas is set as the greater
				 * of the two. percpu_arena_choose will be free
				 * to use any of the arenas based on CPU
				 * id. This is conservative (at a small cost)
				 * but ensures correctness.
				 *
				 * If for some reason the ncpus determined at
				 * boot is not the actual number (e.g. because
				 * of affinity setting from numactl), reserving
				 * narenas this way provides a workaround for
				 * percpu_arena.
				 */</comment>
				<expr_stmt><expr><name>opt_narenas</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>opt_narenas</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>opt_narenas</name> <operator>=</operator> <call><name>malloc_narenas_default</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opt_narenas</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>narenas_auto</name> <operator>=</operator> <name>opt_narenas</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * Limit the number of arenas to the indexing range of MALLOCX_ARENA().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>narenas_auto</name> <operator>&gt;=</operator> <name>MALLOCX_ARENA_LIMIT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>narenas_auto</name> <operator>=</operator> <name>MALLOCX_ARENA_LIMIT</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Reducing narenas to limit (%d)\n"</literal></expr></argument>,
		    <argument><expr><name>narenas_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>narenas_total_set</name><argument_list>(<argument><expr><name>narenas_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>arena_init_huge</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>narenas_total_inc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>manual_arena_base</name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_init_percpu</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>opt_percpu_arena</name> <operator>=</operator> <call><name>percpu_arena_as_initialized</name><argument_list>(<argument><expr><name>opt_percpu_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_hard_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_boot</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>malloc_init_state</name> <operator>=</operator> <name>malloc_init_initialized</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_slow_flag_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>malloc_init_hard_cleanup</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reentrancy_set</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reentrancy_set</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>malloc_init_hard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_WIN32_WINNT</name> <operator>&lt;</operator> <literal type="number">0x0600</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>_init_init_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNLOCK_RETURN</name><parameter_list>(<parameter><type><name>tsdn</name></type></parameter>, <parameter><type><name>ret</name></type></parameter>, <parameter><type><name>reentrancy</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>malloc_init_hard_cleanup(tsdn, reentrancy);	\
	return ret;</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>malloc_init_hard_needed</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<macro><name>UNLOCK_RETURN</name><argument_list>(<argument>TSDN_NULL</argument>, <argument>false</argument>, <argument>false</argument>)</argument_list></macro>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>malloc_init_state</name> <operator>!=</operator> <name>malloc_init_a0_initialized</name> <operator>&amp;&amp;</operator>
	    <call><name>malloc_init_hard_a0_locked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<macro><name>UNLOCK_RETURN</name><argument_list>(<argument>TSDN_NULL</argument>, <argument>true</argument>, <argument>false</argument>)</argument_list></macro>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Recursive allocation relies on functional tsd. */</comment>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>malloc_tsd_boot0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tsd</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_init_hard_recursible</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Set reentrancy level to 1 during init. */</comment>
	<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize narenas before prof_boot2 (for allocation). */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_init_narenas</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>background_thread_boot1</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<macro><name>UNLOCK_RETURN</name><argument_list>(<argument>tsd_tsdn(tsd)</argument>, <argument>true</argument>, <argument>true</argument>)</argument_list></macro>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <call><name>prof_boot2</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<macro><name>UNLOCK_RETURN</name><argument_list>(<argument>tsd_tsdn(tsd)</argument>, <argument>true</argument>, <argument>true</argument>)</argument_list></macro>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_init_percpu</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>malloc_init_hard_finish</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<macro><name>UNLOCK_RETURN</name><argument_list>(<argument>tsd_tsdn(tsd)</argument>, <argument>true</argument>, <argument>true</argument>)</argument_list></macro>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>witness_assert_lockless</name><argument_list>(<argument><expr><call><name>witness_tsd_tsdn</name><argument_list>(
	    <argument><expr><call><name>tsd_witness_tsdp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_tsd_boot1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Update TSD after tsd_boot1. */</comment>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>opt_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>have_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Need to finish init &amp; unlock first before creating background
		 * threads (pthread_create depends on malloc).  ctl_init (which
		 * sets isthreaded) needs to be called without holding any lock.
		 */</comment>
		<expr_stmt><expr><call><name>background_thread_ctl_init</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>background_thread_create</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UNLOCK_RETURN</name></cpp:undef>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * End initialization functions.
 */</comment>
<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Begin allocation-path internal functions and data structures.
 */</comment>

<comment type="block">/*
 * Settings determined by the documented behavior of the allocation functions.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>static_opts_s</name></name></type> <name>static_opts_t</name>;</typedef>
<struct>struct <name>static_opts_s</name> <block>{
	<comment type="block">/* Whether or not allocation size may overflow. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>may_overflow</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Whether or not allocations (with alignment) of size 0 should be
	 * treated as size 1.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>bump_empty_aligned_alloc</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Whether to assert that allocations are not of size 0 (after any
	 * bumping).
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>assert_nonempty_alloc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Whether or not to modify the 'result' argument to malloc in case of
	 * error.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>null_out_result_on_error</name></decl>;</decl_stmt>
	<comment type="block">/* Whether to set errno when we encounter an error condition. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>set_errno_on_error</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The minimum valid alignment for functions requesting aligned storage.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>min_alignment</name></decl>;</decl_stmt>

	<comment type="block">/* The error string to use if we oom. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oom_string</name></decl>;</decl_stmt>
	<comment type="block">/* The error string to use if the passed-in alignment is invalid. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>invalid_alignment_string</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * False if we're configured to skip some time-consuming operations.
	 *
	 * This isn't really a malloc "behavior", but it acts as a useful
	 * summary of several other static (or at least, static after program
	 * initialization) options.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>slow</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Return size.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>usize</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name></type>
<name>static_opts_init</name><parameter_list>(<parameter><decl><type><name>static_opts_t</name> <modifier>*</modifier></type><name>static_opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>may_overflow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>bump_empty_aligned_alloc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>assert_nonempty_alloc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>set_errno_on_error</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>min_alignment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>oom_string</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>invalid_alignment_string</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>slow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>static_opts</name><operator>-&gt;</operator><name>usize</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * These correspond to the macros in jemalloc/jemalloc_macros.h.  Broadly, we
 * should have one constant here per magic value there.  Note however that the
 * representations need not be related.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCACHE_IND_NONE</name></cpp:macro> <cpp:value>((unsigned)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCACHE_IND_AUTOMATIC</name></cpp:macro> <cpp:value>((unsigned)-2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_IND_AUTOMATIC</name></cpp:macro> <cpp:value>((unsigned)-1)</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>dynamic_opts_s</name></name></type> <name>dynamic_opts_t</name>;</typedef>
<struct>struct <name>dynamic_opts_s</name> <block>{
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>num_items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>item_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alignment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>zero</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>tcache_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name></type>
<name>dynamic_opts_init</name><parameter_list>(<parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dynamic_opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>usize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>item_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>zero</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>tcache_ind</name></name> <operator>=</operator> <name>TCACHE_IND_AUTOMATIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dynamic_opts</name><operator>-&gt;</operator><name>arena_ind</name></name> <operator>=</operator> <name>ARENA_IND_AUTOMATIC</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ind is ignored if dopts-&gt;alignment &gt; 0. */</comment>
<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name> <modifier>*</modifier></type>
<name>imalloc_no_sample</name><parameter_list>(<parameter><decl><type><name>static_opts_t</name> <modifier>*</modifier></type><name>sopts</name></decl></parameter>, <parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dopts</name></decl></parameter>, <parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

	<comment type="block">/* Fill in the tcache. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopts</name><operator>-&gt;</operator><name>tcache_ind</name></name> <operator>==</operator> <name>TCACHE_IND_AUTOMATIC</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Getting tcache ptr unconditionally. */</comment>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tcache</name> <operator>==</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dopts</name><operator>-&gt;</operator><name>tcache_ind</name></name> <operator>==</operator> <name>TCACHE_IND_NONE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcaches_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>tcache_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Fill in the arena. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopts</name><operator>-&gt;</operator><name>arena_ind</name></name> <operator>==</operator> <name>ARENA_IND_AUTOMATIC</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * In case of automatic arena management, we defer arena
		 * computation until as late as we can, hoping to fill the
		 * allocation out of the tcache.
		 */</comment>
		<expr_stmt><expr><name>arena</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>arena_ind</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>ipalloct</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name></expr></argument>,
		    <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>zero</name></name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>zero</name></name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
	    <argument><expr><name>arena</name></expr></argument>, <argument><expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name> <modifier>*</modifier></type>
<name>imalloc_sample</name><parameter_list>(<parameter><decl><type><name>static_opts_t</name> <modifier>*</modifier></type><name>sopts</name></decl></parameter>, <parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dopts</name></decl></parameter>, <parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For small allocations, sampling bumps the usize.  If so, we allocate
	 * from the ind_large bucket.
	 */</comment>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>ind_large</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bumped_usize</name> <init>= <expr><name>usize</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		    <expr><call><name>sz_s2u</name><argument_list>(<argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr> </then><else>:
		    <expr><call><name>sz_sa2u</name><argument_list>(<argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator>
			<operator>==</operator> <name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ind_large</name> <operator>=</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bumped_usize</name> <operator>=</operator> <call><name>sz_s2u</name><argument_list>(<argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>imalloc_no_sample</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>bumped_usize</name></expr></argument>,
		    <argument><expr><name>bumped_usize</name></expr></argument>, <argument><expr><name>ind_large</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>arena_prof_promote</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>imalloc_no_sample</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the allocation will overflow, and false otherwise.  Sets
 * *size to the product either way.
 */</comment>
<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>bool</name></type>
<name>compute_size_with_overflow</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>may_overflow</name></decl></parameter>, <parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dopts</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * This function is just num_items * item_size, except that we may have
	 * to check for overflow.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>may_overflow</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>num_items</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>dopts</name><operator>-&gt;</operator><name>item_size</name></name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* A size_t with its high-half bits all set to 1. */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>high_bits</name> <init>= <expr><name>SIZE_T_MAX</name> <operator>&lt;&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>dopts</name><operator>-&gt;</operator><name>item_size</name></name> <operator>*</operator> <name><name>dopts</name><operator>-&gt;</operator><name>num_items</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>*</operator><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><operator>(</operator><name><name>dopts</name><operator>-&gt;</operator><name>num_items</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dopts</name><operator>-&gt;</operator><name>item_size</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We got a non-zero size, but we don't know if we overflowed to get
	 * there.  To avoid having to do a divide, we'll be clever and note that
	 * if both A and B can be represented in N/2 bits, then their product
	 * can be represented in N bits (without the possibility of overflow).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>(</operator><name>high_bits</name> <operator>&amp;</operator> <operator>(</operator><name><name>dopts</name><operator>-&gt;</operator><name>num_items</name></name> <operator>|</operator> <name><name>dopts</name><operator>-&gt;</operator><name>item_size</name></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>*</operator><name>size</name> <operator>/</operator> <name><name>dopts</name><operator>-&gt;</operator><name>item_size</name></name> <operator>==</operator> <name><name>dopts</name><operator>-&gt;</operator><name>num_items</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>int</name></type>
<name>imalloc_body</name><parameter_list>(<parameter><decl><type><name>static_opts_t</name> <modifier>*</modifier></type><name>sopts</name></decl></parameter>, <parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dopts</name></decl></parameter>, <parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Where the actual allocated memory will live. */</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>allocation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Filled in by compute_size_with_overflow below. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * For unaligned allocations, we need only ind.  For aligned
	 * allocations, or in case of stats or profiling we need usize.
	 *
	 * These are actually dead stores, in that their values are reset before
	 * any branch on their value is taken.  Sometimes though, it's
	 * convenient to pass them as arguments before this point.  To avoid
	 * undefined behavior then, we initialize them with dummy stores.
	 */</comment>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>ind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Reentrancy is only checked on slow path. */</comment>
	<decl_stmt><decl><type><name>int8_t</name></type> <name>reentrancy_level</name></decl>;</decl_stmt>

	<comment type="block">/* Compute the amount of memory the user wants. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>compute_size_with_overflow</name><argument_list>(<argument><expr><name><name>sopts</name><operator>-&gt;</operator><name>may_overflow</name></name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_oom</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>&lt;</operator> <name><name>sopts</name><operator>-&gt;</operator><name>min_alignment</name></name>
	    <operator>||</operator> <operator>(</operator><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_invalid_alignment</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* This is the beginning of the "core" algorithm. */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ind</name> <operator>&gt;=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name> <operator>||</operator> <operator>(</operator><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name><operator>)</operator> <operator>||</operator> <name><name>sopts</name><operator>-&gt;</operator><name>usize</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dopts</name><operator>-&gt;</operator><name>usize</name></name> <operator>=</operator> <name>usize</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>usize</name>
			    <operator>&lt;=</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>bump_empty_aligned_alloc</name></name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_sa2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dopts</name><operator>-&gt;</operator><name>usize</name></name> <operator>=</operator> <name>usize</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <literal type="number">0</literal>
		    <operator>||</operator> <name>usize</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Validate the user input. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>assert_nonempty_alloc</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we need to handle reentrancy, we can do it out of a
	 * known-initialized arena (i.e. arena 0).
	 */</comment>
	<expr_stmt><expr><name>reentrancy_level</name> <operator>=</operator> <call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>reentrancy_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * We should never specify particular arenas or tcaches from
		 * within our internal allocations.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>tcache_ind</name></name> <operator>==</operator> <name>TCACHE_IND_AUTOMATIC</name> <operator>||</operator>
		    <name><name>dopts</name><operator>-&gt;</operator><name>tcache_ind</name></name> <operator>==</operator> <name>TCACHE_IND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>arena_ind</name></name> <operator>==</operator> <name>ARENA_IND_AUTOMATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dopts</name><operator>-&gt;</operator><name>tcache_ind</name></name> <operator>=</operator> <name>TCACHE_IND_NONE</name></expr>;</expr_stmt>
		<comment type="block">/* We know that arena 0 has already been initialized. */</comment>
		<expr_stmt><expr><name><name>dopts</name><operator>-&gt;</operator><name>arena_ind</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If profiling is on, get our profiling context. */</comment>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Note that if we're going down this path, usize must have been
		 * initialized in the previous if statement.
		 */</comment>
		<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><call><name>prof_alloc_prep</name><argument_list>(
		    <argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>==</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name> <operator>=</operator> <operator>(</operator><name>usize</name>
			    <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation</name> <operator>=</operator> <call><name>imalloc_no_sample</name><argument_list>(
			    <argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Note that ind might still be 0 here.  This is fine;
			 * imalloc_sample ignores ind if dopts-&gt;alignment &gt; 0.
			 */</comment>
			<expr_stmt><expr><name>allocation</name> <operator>=</operator> <call><name>imalloc_sample</name><argument_list>(
			    <argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>allocation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>allocation</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_alloc_rollback</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>prof_malloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>allocation</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * If dopts-&gt;alignment &gt; 0, then ind is still 0, but usize was
		 * computed in the previous if statement.  Down the positive
		 * alignment path, imalloc_no_sample ignores ind and size
		 * (relying only on usize).
		 */</comment>
		<expr_stmt><expr><name>allocation</name> <operator>=</operator> <call><name>imalloc_no_sample</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>,
		    <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>allocation</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allocation has been done at this point.  We still have some
	 * post-allocation work to do though.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>==</operator> <literal type="number">0</literal>
	    <operator>||</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>allocation</name> <operator>&amp;</operator> <operator>(</operator><name><name>dopts</name><operator>-&gt;</operator><name>alignment</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <call><name>ZU</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>allocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_allocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>allocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Success! */</comment>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>dopts</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>allocation</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>label_oom</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>config_xmalloc</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_xmalloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><name><name>sopts</name><operator>-&gt;</operator><name>oom_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>set_errno_on_error</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>null_out_result_on_error</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>dopts</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ENOMEM</name></expr>;</return>

	<comment type="block">/*
	 * This label is only jumped to by one goto; we move it out of line
	 * anyways to avoid obscuring the non-error paths, and for symmetry with
	 * the oom case.
	 */</comment>
<label><name>label_invalid_alignment</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>config_xmalloc</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_xmalloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><name><name>sopts</name><operator>-&gt;</operator><name>invalid_alignment_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>set_errno_on_error</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>-&gt;</operator><name>null_out_result_on_error</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>dopts</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>EINVAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>bool</name></type>
<name>imalloc_init_check</name><parameter_list>(<parameter><decl><type><name>static_opts_t</name> <modifier>*</modifier></type><name>sopts</name></decl></parameter>, <parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dopts</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><call><name>malloc_init</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_xmalloc</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_xmalloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><name><name>sopts</name><operator>-&gt;</operator><name>oom_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dopts</name><operator>-&gt;</operator><name>num_items</name></name> <operator>*</operator> <name><name>dopts</name><operator>-&gt;</operator><name>item_size</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>dopts</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the errno-style error code of the allocation. */</comment>
<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>int</name></type>
<name>imalloc</name><parameter_list>(<parameter><decl><type><name>static_opts_t</name> <modifier>*</modifier></type><name>sopts</name></decl></parameter>, <parameter><decl><type><name>dynamic_opts_t</name> <modifier>*</modifier></type><name>dopts</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_get_allocates</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>imalloc_init_check</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>ENOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We always need the tsd.  Let's grab it right away. */</comment>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Fast and common path. */</comment>
		<expr_stmt><expr><call><name>tsd_assert_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><call><name>imalloc_body</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsd_get_allocates</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>imalloc_init_check</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>ENOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>sopts</name><operator>-&gt;</operator><name>slow</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>imalloc_body</name><argument_list>(<argument><expr><name>sopts</name></expr></argument>, <argument><expr><name>dopts</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>JEMALLOC_NOINLINE</name>
<name>void</name> <modifier>*</modifier></type>
<name>malloc_default</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc.entry"</literal></expr></argument>, <argument><expr><literal type="string">"size: %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>set_errno_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator> <literal type="string">"&lt;jemalloc&gt;: Error in malloc(): out of memory\n"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Note that this branch gets optimized away -- it immediately follows
	 * the check on tsd_fast that sets sopts.slow.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_malloc</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Begin malloc(3)-compatible functions.
 */</comment>

<comment type="block">/*
 * malloc() fastpath.
 *
 * Fastpath assumes size &lt;= SC_LOOKUP_MAXCLASS, and that we hit
 * tcache.  If either of these is false, we tail-call to the slowpath,
 * malloc_default().  Tail-calling is used to avoid any caller-saved
 * registers.
 *
 * fastpath supports ticker and profiling, both of which will also
 * tail-call to the slowpath if they fire.
 */</comment>
<function><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>malloc</name></type></decl></parameter>)</parameter_list> JEMALLOC_ALLOC_SIZE<parameter_list>(</parameter_list>1</function>)
<macro><name>je_malloc</name><argument_list>(<argument>size_t size</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc.entry"</literal></expr></argument>, <argument><expr><literal type="string">"size: %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>tsd_get_allocates</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>malloc_default</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_get</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>tsd</name> <operator>||</operator> <operator>!</operator><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>size</name> <operator>&gt;</operator> <name>SC_LOOKUP_MAXCLASS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>malloc_default</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name> <init>= <expr><call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>ticker_trytick</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tcache</name><operator>-&gt;</operator><name>gc_ticker</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>malloc_default</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>szind_t</name></type> <name>ind</name> <init>= <expr><call><name>sz_size2index_lookup</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name> <operator>||</operator> <name>config_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fast path relies on size being a bin. I.e. SC_LOOKUP_MAXCLASS &lt; SC_SMALL_MAXCLASS */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ind</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int64_t</name></type> <name>bytes_until_sample</name> <init>= <expr><call><name>tsd_bytes_until_sample_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>bytes_until_sample</name> <operator>-=</operator> <name>usize</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_bytes_until_sample_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>bytes_until_sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>bytes_until_sample</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Avoid a prof_active check on the fastpath.
			 * If prof_active is false, set bytes_until_sample to
			 * a large value.  If prof_active is set to true,
			 * bytes_until_sample will be reset.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_active</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>tsd_bytes_until_sample_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>SSIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><call><name>malloc_default</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>cache_bin_t</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><call><name>tcache_small_bin_get</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>tcache_success</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ret</name> <init>= <expr><call><name>cache_bin_alloc_easy</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcache_success</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tcache_success</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_allocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>tstats</name><operator>.</operator><name>nrequests</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>tcache</name><operator>-&gt;</operator><name>prof_accumbytes</name></name> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fastpath success */</comment>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>malloc_default</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<decl_stmt><decl><type><name>JEMALLOC_EXPORT</name> <name>int</name> <name>JEMALLOC_NOTHROW</name></type>
<name>JEMALLOC_ATTR</name><argument_list>(<argument><expr><call><name>nonnull</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<name>je_posix_memalign</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><operator>*</operator><name>memptr</name></expr></argument>, <argument><expr><name>size_t</name> <name>alignment</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.posix_memalign.entry"</literal></expr></argument>, <argument><expr><literal type="string">"mem ptr: %p, alignment: %zu, "</literal>
	    <literal type="string">"size: %zu"</literal></expr></argument>, <argument><expr><name>memptr</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>bump_empty_aligned_alloc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>min_alignment</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>invalid_alignment_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>memptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>alignment</name></name> <operator>=</operator> <name>alignment</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>memptr</name></expr>, <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>alignment</name></expr>,
			<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_posix_memalign</name></expr></argument>, <argument><expr><operator>*</operator><name>memptr</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.posix_memalign.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d, alloc ptr: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>,
	    <argument><expr><operator>*</operator><name>memptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>malloc</name></type></decl></parameter>)</parameter_list> JEMALLOC_ALLOC_SIZE<parameter_list>(</parameter_list>2</function>)
<macro><name>je_aligned_alloc</name><argument_list>(<argument>size_t alignment</argument>, <argument>size_t size</argument>)</argument_list></macro> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.aligned_alloc.entry"</literal></expr></argument>, <argument><expr><literal type="string">"alignment: %zu, size: %zu\n"</literal></expr></argument>,
	    <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>bump_empty_aligned_alloc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>set_errno_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>min_alignment</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>invalid_alignment_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>alignment</name></name> <operator>=</operator> <name>alignment</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>alignment</name></expr>, <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_aligned_alloc</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.aligned_alloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>

<function><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>malloc</name></type></decl></parameter>)</parameter_list> JEMALLOC_ALLOC_SIZE2<parameter_list>(</parameter_list>1<operator>,</operator> 2</function>)
<macro><name>je_calloc</name><argument_list>(<argument>size_t num</argument>, <argument>size_t size</argument>)</argument_list></macro> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.calloc.entry"</literal></expr></argument>, <argument><expr><literal type="string">"num: %zu, size: %zu\n"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>may_overflow</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>set_errno_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator> <literal type="string">"&lt;jemalloc&gt;: Error in calloc(): out of memory\n"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>zero</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>num</name></expr>, <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_calloc</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.calloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>irealloc_prof_sample</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old_ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
    <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>hook_ralloc_args_t</name> <modifier>*</modifier></type><name>hook_args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
		    <argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>arena_prof_promote</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name> <modifier>*</modifier></type>
<name>irealloc_prof</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old_ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
   <parameter><decl><type><name>alloc_ctx_t</name> <modifier>*</modifier></type><name>alloc_ctx</name></decl></parameter>, <parameter><decl><type><name>hook_ralloc_args_t</name> <modifier>*</modifier></type><name>hook_args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_active</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>old_tctx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_tctx</name> <operator>=</operator> <call><name>prof_tctx_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>alloc_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tctx</name> <operator>=</operator> <call><name>prof_alloc_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>prof_active</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>!=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>irealloc_prof_sample</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>,
		    <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_alloc_rollback</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>prof_realloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>prof_active</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
	    <argument><expr><name>old_tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name></type>
<name>ifree</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slow_path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow_path</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_assert_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>slow_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>!=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_free</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_deallocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><name>slow_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name></type>
<name>isfree</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slow_path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow_path</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_assert_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>slow_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_cache_oblivious</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * When cache_oblivious is disabled and ptr is not page aligned,
		 * the allocation was not sampled -- usize can be used to
		 * determine szind directly.
		 */</comment>
		<expr_stmt><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>=</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>&amp;</operator><name>alloc_ctx</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_debug</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>dbg_ctx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>,
			    <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dbg_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>dbg_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dbg_ctx</name><operator>.</operator><name>szind</name></name> <operator>==</operator> <name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dbg_ctx</name><operator>.</operator><name>slab</name></name> <operator>==</operator> <name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>==</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>&amp;</operator><name>alloc_ctx</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_free</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_deallocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><name>slow_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>isdalloct</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>isdalloct</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list>
<name>je_realloc</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>size_t</name> <name>arg_size</name></expr></argument>)</argument_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<function_decl><type><name>tsdn_t</name> <modifier>*</modifier><name>tsdn</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><parameter_list>(<parameter><decl><type><name>NULL</name></type></decl></parameter>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>size_t</name> <name>usize</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>old_usize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>arg_size</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.realloc.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, size: %zu\n"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* realloc(ptr, 0) is equivalent to free(ptr). */</comment>
			<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>, <expr><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>hook_invoke_dalloc</name><argument_list>(<argument><expr><name>hook_dalloc_realloc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ifree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.realloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<decl_stmt><decl><type><name>hook_ralloc_args_t</name></type> <name>hook_args</name> <init>= <expr><block>{<expr><name>true</name></expr>, <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>,
			<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>arg_size</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>!=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old_usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <literal type="number">0</literal>
			    <operator>||</operator> <name>usize</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>irealloc_prof</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>,
				    <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>iralloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* realloc(NULL, size) is equivalent to malloc(size). */</comment>
		<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>set_errno_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator>
		    <literal type="string">"&lt;jemalloc&gt;: Error in realloc(): out of memory\n"</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>, <expr><name>arg_size</name></expr>}</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_realloc</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>,
			    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_xmalloc</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_xmalloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in realloc(): "</literal>
			    <literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name> <operator>&amp;&amp;</operator> <call><name>likely</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_allocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_deallocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>old_usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.realloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>JEMALLOC_NOINLINE</name>
<name>void</name></type>
<name>free_default</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * We avoid setting up tsd fully (e.g. tcache, arena binding)
		 * based on only free() calls -- other activities trigger the
		 * minimal to full transition.  This is because free() may
		 * happen during thread shutdown after tls deallocation: if a
		 * thread never had any malloc activities until then, a
		 * fully-setup tsd won't be destructed properly.
		 */</comment>
		<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch_min</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tsd_assert_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unconditionally get tcache ptr on fast path. */</comment>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ifree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args_raw</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>}</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>hook_invoke_dalloc</name><argument_list>(<argument><expr><name>hook_dalloc_free</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>args_raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ifree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name>
<name>bool</name></type> <name>free_fastpath</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>size_hint</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_get</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>tsd</name> <operator>||</operator> <operator>!</operator><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name> <init>= <expr><call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * If !config_cache_oblivious, we can check PAGE alignment to
	 * detect sampled objects.  Otherwise addresses are
	 * randomized, and we have to look it up in the rtree anyway.
	 * See also isfree().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_hint</name> <operator>||</operator> <name>config_cache_oblivious</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>rtree_szind_slab_read_fast</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>,
						      <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>,
						      <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Note: profiled objects will have alloc_ctx.slab set */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <operator>!</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>!=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * Check for both sizes that are too large, and for sampled objects.
		 * Sampled objects are always page-aligned.  The sampled object check
		 * will also check for null ptr.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>SC_LOOKUP_MAXCLASS</name> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>=</operator> <call><name>sz_size2index_lookup</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>ticker_trytick</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tcache</name><operator>-&gt;</operator><name>gc_ticker</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>cache_bin_t</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><call><name>tcache_small_bin_get</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>, <argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cache_bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name> <init>= <expr><operator>&amp;</operator><name><name>tcache_bin_info</name><index>[<expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cache_bin_dalloc_easy</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>bin_info</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_deallocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>void</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.free.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>free_fastpath</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>free_default</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.free.exit"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * End malloc(3)-compatible functions.
 */</comment>
<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Begin non-standard override functions.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE_MEMALIGN</name></cpp:ifdef>
<function><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>malloc</name></type></decl></parameter>)</parameter_list>
je_memalign<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.memalign.entry"</literal></expr></argument>, <argument><expr><literal type="string">"alignment: %zu, size: %zu\n"</literal></expr></argument>, <argument><expr><name>alignment</name></expr></argument>,
	    <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>min_alignment</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>invalid_alignment_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>alignment</name></name> <operator>=</operator> <name>alignment</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>alignment</name></expr>, <expr><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_memalign</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>,
		    <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.memalign.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE_VALLOC</name></cpp:ifdef>
<function><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>malloc</name></type></decl></parameter>)</parameter_list>
je_valloc<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.valloc.entry"</literal></expr></argument>, <argument><expr><literal type="string">"size: %zu\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>min_alignment</name></name> <operator>=</operator> <name>PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>invalid_alignment_string</name></name> <operator>=</operator>
	    <literal type="string">"&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>alignment</name></name> <operator>=</operator> <name>PAGE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_valloc</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.valloc.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p\n"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_IS_MALLOC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_GLIBC_MALLOC_HOOK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible
 * to inconsistently reference libc's malloc(3)-compatible functions
 * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).
 *
 * These definitions interpose hooks in glibc.  The functions are actually
 * passed an extra argument for the caller return address, which will be
 * ignored.
 */</comment>
<function_decl><type><name>JEMALLOC_EXPORT</name> <name>void</name></type> (<modifier>*</modifier><name>__free_hook</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <init>= <expr><name>je_free</name></expr></init>;</function_decl>
<function_decl><type><name>JEMALLOC_EXPORT</name> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>__malloc_hook</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <init>= <expr><name>je_malloc</name></expr></init>;</function_decl>
<function_decl><type><name>JEMALLOC_EXPORT</name> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>__realloc_hook</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <init>= <expr><name>je_realloc</name></expr></init>;</function_decl>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_GLIBC_MEMALIGN_HOOK</name></cpp:ifdef>
<function_decl><type><name>JEMALLOC_EXPORT</name> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>__memalign_hook</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <init>=
    <expr><name>je_memalign</name></expr></init>;</function_decl>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>CPU_COUNT</name></cpp:ifdef>
<comment type="block">/*
 * To enable static linking with glibc, the libc specific malloc interface must
 * be implemented also, so none of glibc's malloc.o functions are added to the
 * link.
 */</comment>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>ALIAS</name><parameter_list>(<parameter><type><name>je_fn</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>__attribute__((alias (#je_fn), used))</cpp:value></cpp:define>
<comment type="block">/* To force macro expansion of je_ prefix before stringification. */</comment>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PREALIAS</name><parameter_list>(<parameter><type><name>je_fn</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>ALIAS(je_fn)</cpp:value></cpp:define>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___LIBC_CALLOC</name></cpp:ifdef>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>__libc_calloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_calloc</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___LIBC_FREE</name></cpp:ifdef>
<function_decl><type><name>void</name></type> <name>__libc_free</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_free</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___LIBC_MALLOC</name></cpp:ifdef>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>__libc_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_malloc</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___LIBC_MEMALIGN</name></cpp:ifdef>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>__libc_memalign</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>align</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_memalign</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___LIBC_REALLOC</name></cpp:ifdef>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>__libc_realloc</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_realloc</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___LIBC_VALLOC</name></cpp:ifdef>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>__libc_valloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_valloc</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_OVERRIDE___POSIX_MEMALIGN</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>__posix_memalign</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list> PREALIAS<parameter_list>(<parameter><decl><type><name>je_posix_memalign</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#    <cpp:directive>undef</cpp:directive> <name>PREALIAS</name></cpp:undef>
<cpp:undef>#    <cpp:directive>undef</cpp:directive> <name>ALIAS</name></cpp:undef>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * End non-standard override functions.
 */</comment>
<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Begin non-standard functions.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_EXPERIMENTAL_SMALLOCX_API</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_SMALLOCX_CONCAT_HELPER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x ## y</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_SMALLOCX_CONCAT_HELPER2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>  \
  <cpp:value>JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>smallocx_return_t</name>;</typedef>

<decl_stmt><decl><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>smallocx_return_t</name> <name>JEMALLOC_NOTHROW</name></type>
<comment type="block">/*
 * The attribute JEMALLOC_ATTR(malloc) cannot be used due to:
 *  - https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86488
 */</comment>
<name>JEMALLOC_SMALLOCX_CONCAT_HELPER2</name><argument_list>(<argument><expr><name>je_smallocx_</name></expr></argument>, <argument><expr><name>JEMALLOC_VERSION_GID_IDENT</name></expr></argument>)</argument_list>
  <argument_list>(<argument><expr><name>size_t</name> <name>size</name></expr></argument>, <argument><expr><name>int</name> <name>flags</name></expr></argument>)</argument_list> <block>{<block_content>
	<comment type="block">/*
	 * Note: the attribute JEMALLOC_ALLOC_SIZE(1) cannot be
	 * used here because it makes writing beyond the `size`
	 * of the `ptr` undefined behavior, but the objective
	 * of this function is to allow writing beyond `size`
	 * up to `smallocx_return_t::size`.
	 */</comment>
	<decl_stmt><decl><type><name>smallocx_return_t</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.smallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"size: %zu, flags: %d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>assert_nonempty_alloc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator> <literal type="string">"&lt;jemalloc&gt;: Error in mallocx(): out of memory\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>usize</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ret</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_LG_ALIGN_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>alignment</name></name> <operator>=</operator> <call><name>MALLOCX_ALIGN_GET_SPECIFIED</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>zero</name></name> <operator>=</operator> <call><name>MALLOCX_ZERO_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator>
			    <operator>==</operator> <name>MALLOCX_TCACHE_NONE</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>tcache_ind</name></name> <operator>=</operator> <name>TCACHE_IND_NONE</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>tcache_ind</name></name> <operator>=</operator> <call><name>MALLOCX_TCACHE_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>tcache_ind</name></name> <operator>=</operator> <name>TCACHE_IND_AUTOMATIC</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_ARENA_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>arena_ind</name></name> <operator>=</operator> <call><name>MALLOCX_ARENA_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dopts</name><operator>.</operator><name>usize</name></name> <operator>==</operator> <call><name>je_nallocx</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>dopts</name><operator>.</operator><name>usize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.smallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p, size: %zu"</literal></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JEMALLOC_SMALLOCX_CONCAT_HELPER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JEMALLOC_SMALLOCX_CONCAT_HELPER2</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>malloc</name></type></decl></parameter>)</parameter_list> JEMALLOC_ALLOC_SIZE<parameter_list>(</parameter_list>1</function>)
<macro><name>je_mallocx</name><argument_list>(<argument>size_t size</argument>, <argument>int flags</argument>)</argument_list></macro> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static_opts_t</name></type> <name>sopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dynamic_opts_t</name></type> <name>dopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"size: %zu, flags: %d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>static_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dynamic_opts_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>assert_nonempty_alloc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>null_out_result_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sopts</name><operator>.</operator><name>oom_string</name></name> <operator>=</operator> <literal type="string">"&lt;jemalloc&gt;: Error in mallocx(): out of memory\n"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>result</name></name> <operator>=</operator> <operator>&amp;</operator><name>ret</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>item_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_LG_ALIGN_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>alignment</name></name> <operator>=</operator> <call><name>MALLOCX_ALIGN_GET_SPECIFIED</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>zero</name></name> <operator>=</operator> <call><name>MALLOCX_ZERO_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator>
			    <operator>==</operator> <name>MALLOCX_TCACHE_NONE</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>tcache_ind</name></name> <operator>=</operator> <name>TCACHE_IND_NONE</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>tcache_ind</name></name> <operator>=</operator> <call><name>MALLOCX_TCACHE_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>tcache_ind</name></name> <operator>=</operator> <name>TCACHE_IND_AUTOMATIC</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_ARENA_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dopts</name><operator>.</operator><name>arena_ind</name></name> <operator>=</operator> <call><name>MALLOCX_ARENA_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>imalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sopts</name><operator>.</operator><name>slow</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>size</name></expr>, <expr><name>flags</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><name>hook_alloc_mallocx</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>,
		    <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>irallocx_prof_sample</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old_ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>hook_ralloc_args_t</name> <modifier>*</modifier></type><name>hook_args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloct</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
		    <argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>,
		    <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>arena_prof_promote</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloct</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
		    <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>void</name> <modifier>*</modifier></type>
<name>irallocx_prof</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old_ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>usize</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>,
    <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>alloc_ctx_t</name> <modifier>*</modifier></type><name>alloc_ctx</name></decl></parameter>, <parameter><decl><type><name>hook_ralloc_args_t</name> <modifier>*</modifier></type><name>hook_args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_active</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>old_tctx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_tctx</name> <operator>=</operator> <call><name>prof_tctx_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>alloc_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tctx</name> <operator>=</operator> <call><name>prof_alloc_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>*</operator><name>usize</name></expr></argument>, <argument><expr><name>prof_active</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>!=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>irallocx_prof_sample</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
		    <argument><expr><operator>*</operator><name>usize</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloct</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>,
		    <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_alloc_rollback</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>old_ptr</name> <operator>&amp;&amp;</operator> <name>alignment</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * The allocation did not move, so it is possible that the size
		 * class is smaller than would guarantee the requested
		 * alignment, and that the alignment constraint was
		 * serendipitously satisfied.  Additionally, old_usize may not
		 * be the same as the current usize because of in-place large
		 * reallocation.  Therefore, query the actual value of usize.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>usize</name> <operator>=</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>prof_realloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>usize</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>prof_active</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>,
	    <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>old_tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>JEMALLOC_EXPORT</name> <name>JEMALLOC_ALLOCATOR</name> <name>JEMALLOC_RESTRICT_RETURN</name>
<name>void</name> <name>JEMALLOC_NOTHROW</name> <modifier>*</modifier></type>
<name>JEMALLOC_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list>
<name>je_rallocx</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>, <argument><expr><name>int</name> <name>flags</name></expr></argument>)</argument_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>old_usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alignment</name> <init>= <expr><call><name>MALLOCX_ALIGN_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>zero</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_ZERO</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.rallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, size: %zu, flags: %d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
	    <argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_ARENA_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>arena_ind</name> <init>= <expr><call><name>MALLOCX_ARENA_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>arena</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>==</operator> <name>MALLOCX_TCACHE_NONE</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcaches_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>MALLOCX_TCACHE_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>!=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old_usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>hook_ralloc_args_t</name></type> <name>hook_args</name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>, <expr><name>size</name></expr>, <expr><name>flags</name></expr>,
		<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>alignment</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		    <expr><call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>sz_sa2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <literal type="number">0</literal>
		    <operator>||</operator> <name>usize</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>irallocx_prof</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usize</name></expr></argument>,
		    <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>iralloct</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>,
		    <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_oom</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>alignment</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name> <operator>&amp;</operator> <operator>(</operator><name>alignment</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <call><name>ZU</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_allocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_deallocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>old_usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.rallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
<label><name>label_oom</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>config_xmalloc</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_xmalloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in rallocx(): out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.rallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %p"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>size_t</name></type>
<name>ixallocx_helper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>extra</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ixalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>newsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>old_usize</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>newsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ixallocx_prof_sample</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>extra</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>old_usize</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>ixallocx_helper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>,
	    <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>usize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>size_t</name></type>
<name>ixallocx_prof</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>extra</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>alloc_ctx_t</name> <modifier>*</modifier></type><name>alloc_ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize_max</name></decl>, <decl><type ref="prev"/><name>usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_active</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>old_tctx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_tctx</name> <operator>=</operator> <call><name>prof_tctx_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>alloc_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * usize isn't knowable before ixalloc() returns when extra is non-zero.
	 * Therefore, compute its maximum possible value and use that in
	 * prof_alloc_prep() to decide whether to capture a backtrace.
	 * prof_realloc() will use the actual usize to decide whether to sample.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>alignment</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize_max</name> <operator>=</operator> <call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize_max</name> <operator>&gt;</operator> <literal type="number">0</literal>
		    <operator>&amp;&amp;</operator> <name>usize_max</name> <operator>&lt;=</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>usize_max</name> <operator>=</operator> <call><name>sz_sa2u</name><argument_list>(<argument><expr><name>size</name><operator>+</operator><name>extra</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize_max</name> <operator>==</operator> <literal type="number">0</literal>
		    <operator>||</operator> <name>usize_max</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * usize_max is out of range, and chances are that
			 * allocation will fail, but use the maximum possible
			 * value and carry on with prof_alloc_prep(), just in
			 * case allocation succeeds.
			 */</comment>
			<expr_stmt><expr><name>usize_max</name> <operator>=</operator> <name>SC_LARGE_MAXCLASS</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>tctx</name> <operator>=</operator> <call><name>prof_alloc_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>usize_max</name></expr></argument>, <argument><expr><name>prof_active</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>!=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>ixallocx_prof_sample</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
		    <argument><expr><name>size</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>ixallocx_helper</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
		    <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>==</operator> <name>old_usize</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_alloc_rollback</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>usize</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>prof_realloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>prof_active</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
	    <argument><expr><name>old_tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>usize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>size_t</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_xallocx</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>extra</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>, <decl><type ref="prev"/><name>old_usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alignment</name> <init>= <expr><call><name>MALLOCX_ALIGN_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>zero</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_ZERO</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.xallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, size: %zu, extra: %zu, "</literal>
	    <literal type="string">"flags: %d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SIZE_T_MAX</name> <operator>-</operator> <name>size</name> <operator>&gt;=</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>!=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old_usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The API explicitly absolves itself of protecting against (size +
	 * extra) numerical overflow, but we may need to clamp extra to avoid
	 * exceeding SC_LARGE_MAXCLASS.
	 *
	 * Ordinarily, size limit checking is handled deeper down, but here we
	 * have to check as part of (size + extra) clamping, since we need the
	 * clamped value in the above helper functions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <name>old_usize</name></expr>;</expr_stmt>
		<goto>goto <name>label_not_resized</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>SC_LARGE_MAXCLASS</name> <operator>-</operator> <name>size</name> <operator>&lt;</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>extra</name> <operator>=</operator> <name>SC_LARGE_MAXCLASS</name> <operator>-</operator> <name>size</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>ixallocx_prof</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>,
		    <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>ixallocx_helper</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
		    <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <name>old_usize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_not_resized</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_allocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>tsd_thread_deallocatedp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>old_usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<label><name>label_not_resized</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>, <expr><name>size</name></expr>, <expr><name>extra</name></expr>, <expr><name>flags</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_expand</name><argument_list>(<argument><expr><name>hook_expand_xallocx</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_usize</name></expr></argument>,
		    <argument><expr><name>usize</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>usize</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.xallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %zu"</literal></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>usize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>size_t</name> <name>JEMALLOC_NOTHROW</name></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>pure</name></type></decl></parameter>)</parameter_list>
je_sallocx<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.sallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, flags: %d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_debug</name> <operator>||</operator> <name>force_ivsalloc</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>ivsalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>force_ivsalloc</name> <operator>||</operator> <name>usize</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>isalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.sallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %zu"</literal></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>usize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>void</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_dallocx</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.dallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, flags: %d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fast</name> <init>= <expr><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Not allowed to be reentrant and specify a custom tcache. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>==</operator> <name>MALLOCX_TCACHE_NONE</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcaches_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>MALLOCX_TCACHE_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tcache</name> <operator>==</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>  <else>else <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_assert_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ifree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args_raw</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>, <expr><name>flags</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_dalloc</name><argument_list>(<argument><expr><name>hook_dalloc_dallocx</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>args_raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ifree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.dallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>size_t</name></type>
<name>inallocx</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_LG_ALIGN_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_sa2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MALLOCX_ALIGN_GET_SPECIFIED</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>usize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_NOINLINE</name> <name>void</name></type>
<name>sdallocx_default</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fast</name> <init>= <expr><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><call><name>inallocx</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Not allowed to be reentrant and specify a custom tcache. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MALLOCX_TCACHE_MASK</name><operator>)</operator> <operator>==</operator> <name>MALLOCX_TCACHE_NONE</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcaches_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>MALLOCX_TCACHE_GET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tsd_tcachep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tcache</name> <operator>==</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <call><name>tcache_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>tcache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>UTRACE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_assert_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>isfree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>args_raw</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr>, <expr><name>size</name></expr>, <expr><name>flags</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hook_invoke_dalloc</name><argument_list>(<argument><expr><name>hook_dalloc_sdallocx</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>args_raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>isfree</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>void</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_sdallocx</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.sdallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, size: %zu, flags: %d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
		<argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>free_fastpath</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sdallocx_default</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.sdallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_sdallocx_noflags</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.sdallocx.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p, size: %zu, flags: 0"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
		<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>free_fastpath</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sdallocx_default</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.sdallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>size_t</name> <name>JEMALLOC_NOTHROW</name></type>
<name>JEMALLOC_ATTR</name><parameter_list>(<parameter><decl><type><name>pure</name></type></decl></parameter>)</parameter_list>
je_nallocx<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>malloc_init</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.nallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %zu"</literal></expr></argument>, <argument><expr><call><name>ZU</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>inallocx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.nallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %zu"</literal></expr></argument>, <argument><expr><call><name>ZU</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.nallocx.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %zu"</literal></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>usize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>int</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_mallctl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctl.entry"</literal></expr></argument>, <argument><expr><literal type="string">"name: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>malloc_init</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctl.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d"</literal></expr></argument>, <argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EAGAIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ctl_byname</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctl.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>int</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_mallctlnametomib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>mibp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>miblenp</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctlnametomib.entry"</literal></expr></argument>, <argument><expr><literal type="string">"name: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>malloc_init</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctlnametomib.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d"</literal></expr></argument>, <argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EAGAIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ctl_nametomib</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mibp</name></expr></argument>, <argument><expr><name>miblenp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctlnametomib.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>int</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_mallctlbymib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>mib</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>miblen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>oldlenp</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctlbymib.entry"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>malloc_init</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctlbymib.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d"</literal></expr></argument>, <argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EAGAIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ctl_bymib</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldlenp</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.mallctlbymib.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>void</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_malloc_stats_print</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>write_cb</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbopaque</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc_stats_print.entry"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>stats_print</name><argument_list>(<argument><expr><name>write_cb</name></expr></argument>, <argument><expr><name>cbopaque</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc_stats_print.exit"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JEMALLOC_EXPORT</name> <name>size_t</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_malloc_usable_size</name><parameter_list>(<parameter><decl><type><name>JEMALLOC_USABLE_SIZE_CONST</name> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc_usable_size.entry"</literal></expr></argument>, <argument><expr><literal type="string">"ptr: %p"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IS_INITIALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_debug</name> <operator>||</operator> <name>force_ivsalloc</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ivsalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>force_ivsalloc</name> <operator>||</operator> <name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>isalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>check_entry_exit_locking</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr><literal type="string">"core.malloc_usable_size.exit"</literal></expr></argument>, <argument><expr><literal type="string">"result: %zu"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * End non-standard functions.
 */</comment>
<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * The following functions are used by threading libraries for protection of
 * malloc during fork().
 */</comment>

<comment type="block">/*
 * If an application creates a thread before doing any allocation in the main
 * thread, then calls fork(2) in the main thread followed by memory allocation
 * in the child process, a race can occur that results in deadlock within the
 * child: the main thread may have forked while the created thread had
 * partially initialized the allocator.  Ordinarily jemalloc prevents
 * fork/malloc races via the following functions it registers during
 * initialization using pthread_atfork(), but of course that does no good if
 * the allocator isn't fully initialized at fork time.  The following library
 * constructor is a partial solution to this problem.  It may still be possible
 * to trigger the deadlock described above, but doing so would involve forking
 * via a library constructor that runs before jemalloc's runs.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifndef>
<macro><name>JEMALLOC_ATTR</name><argument_list>(<argument>constructor</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jemalloc_constructor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_MUTEX_INIT_CB</name></cpp:ifndef>
<decl_stmt><decl><type><name>void</name></type>
<name>jemalloc_prefork</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>JEMALLOC_EXPORT</name> <name>void</name>
<name>_malloc_prefork</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>narenas</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_MUTEX_INIT_CB</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>narenas</name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>witness_prefork</name><argument_list>(<argument><expr><call><name>tsd_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Acquire all mutexes in a safe order. */</comment>
	<expr_stmt><expr><call><name>ctl_prefork</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tcache_prefork</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread_prefork0</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>prof_prefork0</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread_prefork1</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Break arena prefork into stages to preserve lock order. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
			    <name>NULL</name></expr>)</condition> <block>{<block_content>
				<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork0</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">1</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork1</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">2</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork2</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">3</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork3</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">4</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork4</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">5</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork5</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">6</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork6</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">7</literal></expr>:</case>
					<expr_stmt><expr><call><name>arena_prefork7</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default> <expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>prof_prefork1</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tsd_prefork</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_MUTEX_INIT_CB</name></cpp:ifndef>
<decl_stmt><decl><type><name>void</name></type>
<name>jemalloc_postfork_parent</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>JEMALLOC_EXPORT</name> <name>void</name>
<name>_malloc_postfork</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>narenas</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_MUTEX_INIT_CB</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tsd_postfork_parent</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>witness_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release all mutexes, now that fork() has completed. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>narenas</name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>prof_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tcache_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ctl_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type>
<name>jemalloc_postfork_child</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>narenas</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tsd_postfork_child</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>witness_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release all mutexes, now that fork() has completed. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>narenas</name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>prof_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>arenas_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tcache_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ctl_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>


<comment type="block">/* Helps the application decide if a pointer is worth re-allocating in order to reduce fragmentation.
 * returns 0 if the allocation is in the currently active run,
 * or when it is not causing any frag issue (large or huge bin)
 * returns the bin utilization and run utilization both in fixed point 16:16.
 * If the application decides to re-allocate it should use MALLOCX_TCACHE_NONE when doing so. */</comment>
<function><type><name>JEMALLOC_EXPORT</name> <name>int</name> <name>JEMALLOC_NOTHROW</name></type>
<name>je_get_defrag_hint</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bin_util</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>run_util</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>iget_defrag_hint</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>bin_util</name></expr></argument>, <argument><expr><name>run_util</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
