<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/arena.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_ARENA_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/div.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_dss.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/extent_mmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/rtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/safety_check.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/util.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>JEMALLOC_DIAGNOSTIC_DISABLE_SPURIOUS</name>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<comment type="block">/*
 * Define names for both unininitialized and initialized phases, so that
 * options and mallctl processing are straightforward.
 */</comment>
<specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>percpu_arena_mode_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"percpu"</literal></expr>,
	<expr><literal type="string">"phycpu"</literal></expr>,
	<expr><literal type="string">"disabled"</literal></expr>,
	<expr><literal type="string">"percpu"</literal></expr>,
	<expr><literal type="string">"phycpu"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>percpu_arena_mode_t</name></type> <name>opt_percpu_arena</name> <init>= <expr><name>PERCPU_ARENA_DEFAULT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>opt_dirty_decay_ms</name> <init>= <expr><name>DIRTY_DECAY_MS_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>opt_muzzy_decay_ms</name> <init>= <expr><name>MUZZY_DECAY_MS_DEFAULT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_zd_t</name></type> <name>dirty_decay_ms_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_zd_t</name></type> <name>muzzy_decay_ms_default</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name><name>h_steps</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name></expr>]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP</name><parameter_list>(<parameter><type><name>step</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>			\
		<cpp:value>h,</cpp:value></cpp:define>
		<expr><name>SMOOTHSTEP</name></expr>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STEP</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>div_info_t</name></type> <name><name>arena_binind_div_info</name><index>[<expr><name>SC_NBINS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>opt_oversize_threshold</name> <init>= <expr><name>OVERSIZE_THRESHOLD_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>oversize_threshold</name> <init>= <expr><name>OVERSIZE_THRESHOLD_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>huge_arena_ind</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Function prototypes for static functions that are referenced prior to
 * definition.
 */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arena_decay_to_limit</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_limit</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>npages_decay_max</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>arena_decay_dirty</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arena_dalloc_bin_slab</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>,
    <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arena_bin_lower_slab</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>,
    <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><name>void</name></type>
<name>arena_basic_stats_merge</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>nthreads</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dss</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>dirty_decay_ms</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>muzzy_decay_ms</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nactive</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ndirty</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nmuzzy</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>nthreads</name> <operator>+=</operator> <call><name>arena_nthreads_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>dss</name> <operator>=</operator> <name><name>dss_prec_names</name><index>[<expr><call><name>arena_dss_prec_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>dirty_decay_ms</name> <operator>=</operator> <call><name>arena_dirty_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>muzzy_decay_ms</name> <operator>=</operator> <call><name>arena_muzzy_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nactive</name> <operator>+=</operator> <call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ndirty</name> <operator>+=</operator> <call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nmuzzy</name> <operator>+=</operator> <call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_stats_merge</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>nthreads</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dss</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>dirty_decay_ms</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>muzzy_decay_ms</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nactive</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ndirty</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nmuzzy</name></decl></parameter>, <parameter><decl><type><name>arena_stats_t</name> <modifier>*</modifier></type><name>astats</name></decl></parameter>,
    <parameter><decl><type><name>bin_stats_t</name> <modifier>*</modifier></type><name>bstats</name></decl></parameter>, <parameter><decl><type><name>arena_stats_large_t</name> <modifier>*</modifier></type><name>lstats</name></decl></parameter>,
    <parameter><decl><type><name>arena_stats_extents_t</name> <modifier>*</modifier></type><name>estats</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_basic_stats_merge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>, <argument><expr><name>dss</name></expr></argument>, <argument><expr><name>dirty_decay_ms</name></expr></argument>,
	    <argument><expr><name>muzzy_decay_ms</name></expr></argument>, <argument><expr><name>nactive</name></expr></argument>, <argument><expr><name>ndirty</name></expr></argument>, <argument><expr><name>nmuzzy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>base_allocated</name></decl>, <decl><type ref="prev"/><name>base_resident</name></decl>, <decl><type ref="prev"/><name>base_mapped</name></decl>, <decl><type ref="prev"/><name>metadata_thp</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>base_stats_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_allocated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_resident</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>base_mapped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metadata_thp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>mapped</name></name></expr></argument>, <argument><expr><name>base_mapped</name>
	    <operator>+</operator> <call><name>arena_stats_read_zu</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>mapped</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>retained</name></name></expr></argument>,
	    <argument><expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>extent_avail</name></name></expr></argument>,
	    <argument><expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_cnt</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>npurge</name></name></expr></argument>,
	    <argument><expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>npurge</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>nmadvise</name></name></expr></argument>,
	    <argument><expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>nmadvise</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>purged</name></name></expr></argument>,
	    <argument><expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_dirty</name><operator>.</operator><name>purged</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>npurge</name></name></expr></argument>,
	    <argument><expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>npurge</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>nmadvise</name></name></expr></argument>,
	    <argument><expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>nmadvise</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>purged</name></name></expr></argument>,
	    <argument><expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_muzzy</name><operator>.</operator><name>purged</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>base_allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><call><name>arena_internal_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>metadata_thp</name></name></expr></argument>, <argument><expr><name>metadata_thp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>resident</name></name></expr></argument>, <argument><expr><name>base_resident</name> <operator>+</operator>
	    <operator>(</operator><operator>(</operator><operator>(</operator><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>+</operator>
	    <call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
	    <call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <name>LG_PAGE</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>abandoned_vm</name></name></expr></argument>, <argument><expr><call><name>atomic_load_zu</name><argument_list>(
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>abandoned_vm</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>szind_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NSIZES</name> <operator>-</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nmalloc</name> <init>= <expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr></argument>, <argument><expr><name>nmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>nmalloc_large</name></name></expr></argument>, <argument><expr><name>nmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>uint64_t</name></type> <name>ndalloc</name> <init>= <expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr></argument>, <argument><expr><name>ndalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>ndalloc_large</name></name></expr></argument>, <argument><expr><name>ndalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nrequests</name> <init>= <expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrequests</name></expr></argument>,
		    <argument><expr><name>nmalloc</name> <operator>+</operator> <name>nrequests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>nrequests_large</name></name></expr></argument>,
		    <argument><expr><name>nmalloc</name> <operator>+</operator> <name>nrequests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* nfill == nmalloc for large currently. */</comment>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nfills</name></expr></argument>, <argument><expr><name>nmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>nfills_large</name></name></expr></argument>, <argument><expr><name>nmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nflush</name> <init>= <expr><call><name>arena_stats_read_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nflushes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nflushes</name></expr></argument>, <argument><expr><name>nflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>nflushes_large</name></name></expr></argument>, <argument><expr><name>nflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nmalloc</name> <operator>&gt;=</operator> <name>ndalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nmalloc</name> <operator>-</operator> <name>ndalloc</name> <operator>&lt;=</operator> <name>SIZE_T_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>curlextents</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nmalloc</name> <operator>-</operator> <name>ndalloc</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>lstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>curlextents</name> <operator>+=</operator> <name>curlextents</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>allocated_large</name></name></expr></argument>,
		    <argument><expr><name>curlextents</name> <operator>*</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name>SC_NBINS</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><decl><type><name>pszind_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NPSIZES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>dirty</name></decl>, <decl><type ref="prev"/><name>muzzy</name></decl>, <decl><type ref="prev"/><name>retained</name></decl>, <decl><type ref="prev"/><name>dirty_bytes</name></decl>, <decl><type ref="prev"/><name>muzzy_bytes</name></decl>,
		    <decl><type ref="prev"/><name>retained_bytes</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <call><name>extents_nextents_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>muzzy</name> <operator>=</operator> <call><name>extents_nextents_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retained</name> <operator>=</operator> <call><name>extents_nextents_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty_bytes</name> <operator>=</operator> <call><name>extents_nbytes_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>muzzy_bytes</name> <operator>=</operator> <call><name>extents_nbytes_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retained_bytes</name> <operator>=</operator>
		    <call><name>extents_nbytes_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ndirty</name></expr></argument>, <argument><expr><name>dirty</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nmuzzy</name></expr></argument>, <argument><expr><name>muzzy</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nretained</name></expr></argument>, <argument><expr><name>retained</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dirty_bytes</name></expr></argument>, <argument><expr><name>dirty_bytes</name></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>muzzy_bytes</name></expr></argument>, <argument><expr><name>muzzy_bytes</name></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>retained_bytes</name></expr></argument>, <argument><expr><name>retained_bytes</name></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>arena_stats_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tcache_bytes counts currently cached bytes. */</comment>
	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>tcache_bytes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>cache_bin_array_descriptor_t</name> <modifier>*</modifier></type><name>descriptor</name></decl>;</decl_stmt>
	<macro><name>ql_foreach</name><argument_list>(<argument>descriptor</argument>, <argument>&amp;arena-&gt;cache_bin_array_descriptor_ql</argument>, <argument>link</argument>)</argument_list></macro> <block>{<block_content>
		<decl_stmt><decl><type><name>szind_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>cache_bin_t</name> <modifier>*</modifier></type><name>tbin</name> <init>= <expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>bins_small</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>tcache_bytes</name></name></expr></argument>,
			    <argument><expr><name><name>tbin</name><operator>-&gt;</operator><name>ncached</name></name> <operator>*</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nhbins</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>cache_bin_t</name> <modifier>*</modifier></type><name>tbin</name> <init>= <expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>bins_large</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>arena_stats_accum_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>tcache_bytes</name></name></expr></argument>,
			    <argument><expr><name><name>tbin</name><operator>-&gt;</operator><name>ncached</name></name> <operator>*</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>malloc_mutex_prof_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>mutex_prof_data</name><index>[<expr><name>arena_prof_mutex_tcache_list</name></expr>]</index></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ARENA_MUTEX_PROF_DATA</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>, <parameter><type><name>ind</name></type></parameter>)</parameter_list></cpp:macro>				\
    <cpp:value>malloc_mutex_lock(tsdn, &amp;arena-&gt;mtx);				\
    malloc_mutex_prof_read(tsdn, &amp;astats-&gt;mutex_prof_data[ind],		\
        &amp;arena-&gt;mtx);							\
    malloc_mutex_unlock(tsdn, &amp;arena-&gt;mtx);</cpp:value></cpp:define>

	<comment type="block">/* Gather per arena mutex profiling data. */</comment>
	<expr_stmt><expr><call><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument><expr><name>large_mtx</name></expr></argument>, <argument><expr><name>arena_prof_mutex_large</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>extent_avail_mtx</argument>,
	    <argument>arena_prof_mutex_extent_avail</argument>)</argument_list></macro>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>extents_dirty.mtx</argument>,
	    <argument>arena_prof_mutex_extents_dirty</argument>)</argument_list></macro>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>extents_muzzy.mtx</argument>,
	    <argument>arena_prof_mutex_extents_muzzy</argument>)</argument_list></macro>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>extents_retained.mtx</argument>,
	    <argument>arena_prof_mutex_extents_retained</argument>)</argument_list></macro>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>decay_dirty.mtx</argument>,
	    <argument>arena_prof_mutex_decay_dirty</argument>)</argument_list></macro>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>decay_muzzy.mtx</argument>,
	    <argument>arena_prof_mutex_decay_muzzy</argument>)</argument_list></macro>
	<macro><name>READ_ARENA_MUTEX_PROF_DATA</name><argument_list>(<argument>base-&gt;mtx</argument>,
	    <argument>arena_prof_mutex_base</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>READ_ARENA_MUTEX_PROF_DATA</name></cpp:undef>

	<expr_stmt><expr><call><name>nstime_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>uptime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>create_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>uptime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_subtract</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astats</name><operator>-&gt;</operator><name>uptime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>create_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>szind_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>bin_stats_merge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_extents_dirty_dalloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extents_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>,
	    <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>arena_dirty_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_decay_dirty</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>arena_background_thread_inactivity_check</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>arena_slab_reg_alloc</name><parameter_list>(<parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_slab_data_t</name> <modifier>*</modifier></type><name>slab_data</name> <init>= <expr><call><name>extent_slab_data_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>regind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bitmap_full</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>regind</name> <operator>=</operator> <call><name>bitmap_sfu</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>+</operator>
	    <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name><name>bin_info</name><operator>-&gt;</operator><name>reg_size</name></name> <operator>*</operator> <name>regind</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_nfree_dec</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_slab_reg_alloc_batch</name><parameter_list>(<parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl></parameter>,
			   <parameter><decl><type><name>unsigned</name></type> <name>cnt</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>ptrs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_slab_data_t</name> <modifier>*</modifier></type><name>slab_data</name> <init>= <expr><call><name>extent_slab_data_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bitmap_full</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator> <name>defined</name> <name>JEMALLOC_INTERNAL_POPCOUNTL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>defined</name> <name>BITMAP_USE_TREE</name><operator>)</operator></expr></cpp:if>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>regind</name> <init>= <expr><call><name>bitmap_sfu</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptrs</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>+</operator>
		    <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name><name>bin_info</name><operator>-&gt;</operator><name>reg_size</name></name> <operator>*</operator> <name>regind</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>group</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bitmap_t</name></type> <name>g</name> <init>= <expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name><index>[<expr><name>group</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>)</condition> <block>{<block_content>
		<while>while <condition>(<expr><name>g</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>g</name> <operator>=</operator> <name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name><index>[<expr><operator>++</operator><name>group</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<decl_stmt><decl><type><name>size_t</name></type> <name>shift</name> <init>= <expr><name>group</name> <operator>&lt;&lt;</operator> <name>LG_BITMAP_GROUP_NBITS</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>pop</name> <init>= <expr><call><name>popcount_lu</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>pop</name> <operator>&gt;</operator> <operator>(</operator><name>cnt</name> <operator>-</operator> <name>i</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>pop</name> <operator>=</operator> <name>cnt</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Load from memory locations only once, outside the
		 * hot loop below.
		 */</comment>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name>base</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uintptr_t</name></type> <name>regsize</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>bin_info</name><operator>-&gt;</operator><name>reg_size</name></name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>pop</name><operator>--</operator></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type> <name>bit</name> <init>= <expr><call><name>cfs_lu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>regind</name> <init>= <expr><name>shift</name> <operator>+</operator> <name>bit</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptrs</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>base</name> <operator>+</operator> <name>regsize</name> <operator>*</operator> <name>regind</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name><index>[<expr><name>group</name></expr>]</index></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>
	</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>extent_nfree_sub</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifndef>
<function><type><specifier>static</specifier>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>size_t</name></type>
<name>arena_slab_regind</name><parameter_list>(<parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>diff</name></decl>, <decl><type ref="prev"/><name>regind</name></decl>;</decl_stmt>

	<comment type="block">/* Freeing a pointer outside the slab can cause assertion failure. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name> <operator>&gt;=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name> <operator>&lt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_past_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Freeing an interior pointer can cause assertion failure. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator>
	    <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name><operator>.</operator><name>reg_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>diff</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>extent_addr_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Avoid doing division with a variable divisor. */</comment>
	<expr_stmt><expr><name>regind</name> <operator>=</operator> <call><name>div_compute</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena_binind_div_info</name><index>[<expr><name>binind</name></expr>]</index></name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>regind</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name><operator>.</operator><name>nregs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>regind</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_slab_reg_dalloc</name><parameter_list>(<parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>, <parameter><decl><type><name>arena_slab_data_t</name> <modifier>*</modifier></type><name>slab_data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>binind</name> <init>= <expr><call><name>extent_szind_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name> <init>= <expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>regind</name> <init>= <expr><call><name>arena_slab_regind</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>bin_info</name><operator>-&gt;</operator><name>nregs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Freeing an unallocated pointer can cause assertion failure. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>bitmap_get</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>, <argument><expr><name>regind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>bitmap_unset</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>, <argument><expr><name>regind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_nfree_inc</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_nactive_add</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>add_pages</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_fetch_add_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><name>add_pages</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_nactive_sub</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sub_pages</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>atomic_load_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>sub_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_fetch_sub_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><name>sub_pages</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_large_malloc_stats_update</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>hindex</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&lt;</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <name>SC_LARGE_MINCLASS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hindex</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>index</name> <operator>&gt;=</operator> <name>SC_NBINS</name><operator>)</operator></expr> ?</condition><then> <expr><name>index</name> <operator>-</operator> <name>SC_NBINS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_add_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lstats</name><index>[<expr><name>hindex</name></expr>]</index></name><operator>.</operator><name>nmalloc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_large_dalloc_stats_update</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>hindex</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&lt;</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>usize</name> <operator>=</operator> <name>SC_LARGE_MINCLASS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hindex</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>index</name> <operator>&gt;=</operator> <name>SC_NBINS</name><operator>)</operator></expr> ?</condition><then> <expr><name>index</name> <operator>-</operator> <name>SC_NBINS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_stats_add_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lstats</name><index>[<expr><name>hindex</name></expr>]</index></name><operator>.</operator><name>ndalloc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_large_ralloc_stats_update</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>oldusize</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>arena_large_dalloc_stats_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>oldusize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_large_malloc_stats_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_may_have_muzzy</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>pages_can_purge_lazy</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>arena_muzzy_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>extent_t</name> <modifier>*</modifier></type>
<name>arena_extent_alloc_large</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>zero</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name> <init>= <expr><name>EXTENT_HOOKS_INITIALIZER</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>szind_t</name></type> <name>szind</name> <init>= <expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>mapped_add</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>commit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extents_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>sz_large_pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
	    <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>arena_may_have_muzzy</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extents_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>sz_large_pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>,
		    <argument><expr><name>false</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>usize</name> <operator>+</operator> <name>sz_large_pad</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>extent</name> <operator>=</operator> <call><name>extent_alloc_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>sz_large_pad</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * extent may be NULL on OOM, but in that case
			 * mapped_add isn't used below, so there's no need to
			 * conditionlly set it to 0 here.
			 */</comment>
			<expr_stmt><expr><name>mapped_add</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>mapped_add</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>extent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_stats_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>arena_large_malloc_stats_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>mapped_add</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>arena_stats_add_zu</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
				    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>mapped</name></name></expr></argument>, <argument><expr><name>mapped_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>arena_stats_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>arena_nactive_add</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_extent_dalloc_large_prep</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_large_dalloc_stats_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
		    <argument><expr><call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>arena_nactive_sub</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_extent_ralloc_large_shrink</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>oldusize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>udiff</name> <init>= <expr><name>oldusize</name> <operator>-</operator> <name>usize</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_large_ralloc_stats_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>oldusize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>arena_nactive_sub</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>udiff</name> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_extent_ralloc_large_expand</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>oldusize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>udiff</name> <init>= <expr><name>usize</name> <operator>-</operator> <name>oldusize</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_large_ralloc_stats_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>oldusize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>arena_nactive_add</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>udiff</name> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>arena_decay_ms_read</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>time_ms</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_ms_write</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_store_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>time_ms</name></name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_deadline_init</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Generate a new deadline that is uniformly random within the next
	 * epoch after the current one.
	 */</comment>
	<expr_stmt><expr><call><name>nstime_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>deadline</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>deadline</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>arena_decay_ms_read</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>nstime_t</name></type> <name>jitter</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jitter</name></expr></argument>, <argument><expr><call><name>prng_range_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>jitter_state</name></name></expr></argument>,
		    <argument><expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>deadline</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_deadline_reached</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>nstime_t</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>nstime_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>deadline</name></name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>arena_decay_backlog_npages_limit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>sum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npages_limit_backlog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For each element of decay_backlog, multiply by the corresponding
	 * fixed-point smoothstep decay factor.  Sum the products, then divide
	 * to round down to the nearest whole number of pages.
	 */</comment>
	<expr_stmt><expr><name>sum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>h_steps</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>npages_limit_backlog</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>sum</name> <operator>&gt;&gt;</operator> <name>SMOOTHSTEP_BFP</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>npages_limit_backlog</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_backlog_update_last</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>current_npages</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npages_delta</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>current_npages</name> <operator>&gt;</operator> <name><name>decay</name><operator>-&gt;</operator><name>nunpurged</name></name><operator>)</operator></expr> ?</condition><then>
	    <expr><name>current_npages</name> <operator>-</operator> <name><name>decay</name><operator>-&gt;</operator><name>nunpurged</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>npages_delta</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_debug</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>current_npages</name> <operator>&gt;</operator> <name><name>decay</name><operator>-&gt;</operator><name>ceil_npages</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>ceil_npages</name></name> <operator>=</operator> <name>current_npages</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>npages_limit</name> <init>= <expr><call><name>arena_decay_backlog_npages_limit</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>decay</name><operator>-&gt;</operator><name>ceil_npages</name></name> <operator>&gt;=</operator> <name>npages_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>decay</name><operator>-&gt;</operator><name>ceil_npages</name></name> <operator>&gt;</operator> <name>npages_limit</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>ceil_npages</name></name> <operator>=</operator> <name>npages_limit</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_backlog_update</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>nadvance_u64</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>current_npages</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nadvance_u64</name> <operator>&gt;=</operator> <name>SMOOTHSTEP_NSTEPS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>decay</name><operator>-&gt;</operator><name>backlog</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>SMOOTHSTEP_NSTEPS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator>
		    <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>nadvance_z</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nadvance_u64</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>nadvance_z</name> <operator>==</operator> <name>nadvance_u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>decay</name><operator>-&gt;</operator><name>backlog</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>nadvance_z</name></expr>]</index></name></expr></argument>,
		    <argument><expr><operator>(</operator><name>SMOOTHSTEP_NSTEPS</name> <operator>-</operator> <name>nadvance_z</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nadvance_z</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name> <operator>-</operator>
			    <name>nadvance_z</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>nadvance_z</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>arena_decay_backlog_update_last</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>current_npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_try_purge</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>current_npages</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_limit</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>current_npages</name> <operator>&gt;</operator> <name>npages_limit</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_decay_to_limit</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		    <argument><expr><name>npages_limit</name></expr></argument>, <argument><expr><name>current_npages</name> <operator>-</operator> <name>npages_limit</name></expr></argument>,
		    <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_epoch_advance_helper</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>nstime_t</name> <modifier>*</modifier></type><name>time</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>current_npages</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>arena_decay_deadline_reached</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>nstime_t</name></type> <name>delta</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delta</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_subtract</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>nadvance_u64</name> <init>= <expr><call><name>nstime_divide</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nadvance_u64</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add nadvance_u64 decay intervals to epoch. */</comment>
	<expr_stmt><expr><call><name>nstime_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_imultiply</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delta</name></expr></argument>, <argument><expr><name>nadvance_u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set a new deadline. */</comment>
	<expr_stmt><expr><call><name>arena_decay_deadline_init</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the backlog. */</comment>
	<expr_stmt><expr><call><name>arena_decay_backlog_update</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>nadvance_u64</name></expr></argument>, <argument><expr><name>current_npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_epoch_advance</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>nstime_t</name> <modifier>*</modifier></type><name>time</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>current_npages</name> <init>= <expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>arena_decay_epoch_advance_helper</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>time</name></expr></argument>, <argument><expr><name>current_npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>npages_limit</name> <init>= <expr><call><name>arena_decay_backlog_npages_limit</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* We may unlock decay-&gt;mtx when try_purge(). Finish logging first. */</comment>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>nunpurged</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>npages_limit</name> <operator>&gt;</operator> <name>current_npages</name><operator>)</operator></expr> ?</condition><then> <expr><name>npages_limit</name></expr> </then><else>:
	    <expr><name>current_npages</name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>background_thread_enabled</name><argument_list>()</argument_list></call> <operator>||</operator> <name>is_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_decay_try_purge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
		    <argument><expr><name>current_npages</name></expr></argument>, <argument><expr><name>npages_limit</name></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_reinit</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>arena_decay_ms_write</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>decay_ms</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>decay_ms</name> <operator>*</operator>
		    <call><name>KQU</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>nstime_idivide</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>, <argument><expr><name>SMOOTHSTEP_NSTEPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>jitter_state</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>decay</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_decay_deadline_init</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>nunpurged</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>decay</name><operator>-&gt;</operator><name>backlog</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SMOOTHSTEP_NSTEPS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_init</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>,
    <parameter><decl><type><name>arena_stats_decay_t</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_debug</name></expr>)</condition> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>arena_decay_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>decay</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>ceil_npages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>, <argument><expr><literal type="string">"decay"</literal></expr></argument>, <argument><expr><name>WITNESS_RANK_DECAY</name></expr></argument>,
	    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>purging</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_decay_reinit</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Memory is zeroed, so there is no need to clear stats. */</comment>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>stats</name></name> <operator>=</operator> <name>stats</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_ms_valid</name><parameter_list>(<parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>decay_ms</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>decay_ms</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>decay_ms</name> <operator>&lt;=</operator> <name>NSTIME_SEC_MAX</name> <operator>*</operator>
	    <call><name>KQU</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_maybe_decay</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Purge all or nothing if the option is disabled. */</comment>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>decay_ms</name> <init>= <expr><call><name>arena_decay_ms_read</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>decay_ms</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>decay_ms</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_decay_to_limit</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
			    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>nstime_t</name></type> <name>time</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>nstime_monotonic</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>nstime_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call>
	    <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Time went backwards.  Move the epoch back in time and
		 * generate a new deadline, with the expectation that time
		 * typically flows forward for long enough periods of time that
		 * epochs complete.  Unfortunately, this strategy is susceptible
		 * to clock jitter triggering premature epoch advances, but
		 * clock jitter estimation and compensation isn't feasible here
		 * because calls into this code are event-driven.
		 */</comment>
		<expr_stmt><expr><call><name>nstime_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_decay_deadline_init</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* Verify that time does not go backwards. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>nstime_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>epoch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the deadline has been reached, advance to the current epoch and
	 * purge to the new limit if necessary.  Note that dirty pages created
	 * during the current epoch are not subject to purge until a future
	 * epoch, so as a result purging only happens during epoch advances, or
	 * being triggered by background threads (scheduled event).
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>advance_epoch</name> <init>= <expr><call><name>arena_decay_deadline_reached</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>advance_epoch</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_decay_epoch_advance</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>,
		    <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_decay_try_purge</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
		    <argument><expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>arena_decay_backlog_npages_limit</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>advance_epoch</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>arena_decay_ms_get</name><parameter_list>(<parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_ms_read</name><argument_list>(<argument><expr><name>decay</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>arena_dirty_decay_ms_get</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_ms_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>arena_muzzy_decay_ms_get</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_ms_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_ms_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>arena_decay_ms_valid</name><argument_list>(<argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Restart decay backlog from scratch, which may cause many dirty pages
	 * to be immediately purged.  It would conceptually be possible to map
	 * the old backlog onto the new backlog, but there is no justification
	 * for such complexity since decay_ms changes are intended to be
	 * infrequent, either between the {-1, 0, &gt;0} states, or a one-time
	 * arbitrary change during initial arena configuration.
	 */</comment>
	<expr_stmt><expr><call><name>arena_decay_reinit</name><argument_list>(<argument><expr><name>decay</name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_maybe_decay</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_dirty_decay_ms_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_ms_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_muzzy_decay_ms_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_ms_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>arena_stash_decayed</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_limit</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name></type> <name>npages_decay_max</name></decl></parameter>, <parameter><decl><type><name>extent_list_t</name> <modifier>*</modifier></type><name>decay_extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Stash extents according to npages_limit. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nstashed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>nstashed</name> <operator>&lt;</operator> <name>npages_decay_max</name> <operator>&amp;&amp;</operator>
	    <operator>(</operator><name>extent</name> <operator>=</operator> <call><name>extents_evict</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
	    <argument><expr><name>npages_limit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_list_append</name><argument_list>(<argument><expr><name>decay_extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nstashed</name> <operator>+=</operator> <call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>nstashed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>arena_decay_stashed</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>, <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>, <parameter><decl><type><name>extent_list_t</name> <modifier>*</modifier></type><name>decay_extents</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nmadvise</name></decl>, <decl><type ref="prev"/><name>nunmapped</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npurged</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>nmadvise</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nunmapped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>npurged</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ssize_t</name></type> <name>muzzy_decay_ms</name> <init>= <expr><call><name>arena_muzzy_decay_ms_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_list_first</name><argument_list>(<argument><expr><name>decay_extents</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>extent</name> <operator>!=</operator>
	    <name>NULL</name></expr>;</condition> <incr><expr><name>extent</name> <operator>=</operator> <call><name>extent_list_first</name><argument_list>(<argument><expr><name>decay_extents</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>nmadvise</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>npages</name> <init>= <expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>npurged</name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extent_list_remove</name><argument_list>(<argument><expr><name>decay_extents</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><call><name>extents_state_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>extent_state_active</name></expr>:</case>
			<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>extent_state_dirty</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name> <operator>&amp;&amp;</operator> <name>muzzy_decay_ms</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			    <operator>!</operator><call><name>extent_purge_lazy_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
			    <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>extents_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
				    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>arena_background_thread_inactivity_check</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
				    <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Fall through. */</comment>
		<case>case <expr><name>extent_state_muzzy</name></expr>:</case>
			<expr_stmt><expr><call><name>extent_dalloc_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>,
			    <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>nunmapped</name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>extent_state_retained</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_add_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>npurge</name></name></expr></argument>,
		    <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_add_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>nmadvise</name></name></expr></argument>, <argument><expr><name>nmadvise</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_add_u64</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>purged</name></name></expr></argument>,
		    <argument><expr><name>npurged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_sub_zu</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>mapped</name></name></expr></argument>,
		    <argument><expr><name>nunmapped</name> <operator>&lt;&lt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_stats_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>npurged</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * npages_limit: Decay at most npages_decay_max pages without violating the
 * invariant: (extents_npages_get(extents) &gt;= npages_limit).  We need an upper
 * bound on number of pages in order to prevent unbounded growth (namely in
 * stashed), otherwise unbounded new pages could be added to extents during the
 * current decay run, so that the purging thread never finishes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_decay_to_limit</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_limit</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>npages_decay_max</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>decay</name><operator>-&gt;</operator><name>purging</name></name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>purging</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name> <init>= <expr><call><name>extent_hooks_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>extent_list_t</name></type> <name>decay_extents</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decay_extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>npurge</name> <init>= <expr><call><name>arena_stash_decayed</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
	    <argument><expr><name>npages_limit</name></expr></argument>, <argument><expr><name>npages_decay_max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decay_extents</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>npurge</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>npurged</name> <init>= <expr><call><name>arena_decay_stashed</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>all</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decay_extents</name></expr></argument>,
		    <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>npurged</name> <operator>==</operator> <name>npurge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decay</name><operator>-&gt;</operator><name>purging</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>arena_decay_t</name> <modifier>*</modifier></type><name>decay</name></decl></parameter>,
    <parameter><decl><type><name>extents_t</name> <modifier>*</modifier></type><name>extents</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>all</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_decay_to_limit</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>, <argument><expr><name>all</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		    <argument><expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_trylock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* No need to wait if another thread is in progress. */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>epoch_advanced</name> <init>= <expr><call><name>arena_maybe_decay</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>,
	    <argument><expr><name>is_background_thread</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>npages_new</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>epoch_advanced</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Backlog is updated on epoch advance. */</comment>
		<expr_stmt><expr><name>npages_new</name> <operator>=</operator> <name><name>decay</name><operator>-&gt;</operator><name>backlog</name><index>[<expr><name>SMOOTHSTEP_NSTEPS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decay</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name> <operator>&amp;&amp;</operator> <call><name>background_thread_enabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
	    <name>epoch_advanced</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>background_thread_interval_check</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>decay</name></expr></argument>,
		    <argument><expr><name>npages_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_dirty</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arena_decay_muzzy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>arena_decay_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name></name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_decay</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_background_thread</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>arena_decay_dirty</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>arena_decay_muzzy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>is_background_thread</name></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_slab_dalloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>arena_nactive_sub</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name> <init>= <expr><name>EXTENT_HOOKS_INITIALIZER</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>arena_extents_dirty_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bin_slabs_nonfull_insert</name><parameter_list>(<parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extent_heap_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_nonfull</name></name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nonfull_slabs</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bin_slabs_nonfull_remove</name><parameter_list>(<parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>extent_heap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_nonfull</name></name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nonfull_slabs</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>arena_bin_slabs_nonfull_tryget</name><parameter_list>(<parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>extent_heap_remove_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_nonfull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>reslabs</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nonfull_slabs</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>slab</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bin_slabs_full_insert</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 *  Tracking extents is required by arena_reset, which is not allowed
	 *  for auto arenas.  Bypass this step to avoid touching the extent
	 *  linkage (often results in cache misses) for auto arenas.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>arena_is_auto</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_full</name></name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bin_slabs_full_remove</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>arena_is_auto</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extent_list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_full</name></name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bin_reset</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>slab</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_slab_dalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>slab</name> <operator>=</operator> <call><name>extent_heap_remove_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_nonfull</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_slab_dalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<for>for <control>(<init><expr><name>slab</name> <operator>=</operator> <call><name>extent_list_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_full</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>slab</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
	     <incr><expr><name>slab</name> <operator>=</operator> <call><name>extent_list_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>slabs_full</name></name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_bin_slabs_full_remove</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_slab_dalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curregs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curslabs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_reset</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Locking in this function is unintuitive.  The caller guarantees that
	 * no concurrent operations are happening in this arena, but there are
	 * still reasons that some locking is necessary:
	 *
	 * - Some of the functions in the transitive closure of calls assume
	 *   appropriate locks are held, and in some cases these locks are
	 *   temporarily dropped to avoid lock order reversal or deadlock due to
	 *   reentry.
	 * - mallctl("epoch", ...) may concurrently refresh stats.  While
	 *   strictly speaking this is a "concurrent operation", disallowing
	 *   stats refreshes would impose an inconvenient burden.
	 */</comment>

	<comment type="block">/* Large allocations. */</comment>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>extent_list_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>extent</name> <operator>!=</operator>
	    <name>NULL</name></expr>;</condition> <incr><expr><name>extent</name> <operator>=</operator> <call><name>extent_list_first</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large</name></name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>extent_base_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>alloc_ctx_t</name></type> <name>alloc_ctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsd_rtree_ctx</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>rtree_szind_slab_read</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_ctx</name><operator>.</operator><name>slab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name> <operator>!=</operator> <name>SC_NSIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>config_stats</name> <operator>||</operator> <operator>(</operator><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name><name>alloc_ctx</name><operator>.</operator><name>szind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <call><name>isalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Remove large allocation from prof sample set. */</comment>
		<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_free</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>large_dalloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bins. */</comment>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_bin_reset</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_destroy_retained</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Iterate over the retained extents and destroy them.  This gives the
	 * extent allocator underlying the extent hooks an opportunity to unmap
	 * all retained memory without having to keep its own metadata
	 * structures.  In practice, virtual memory for dss-allocated extents is
	 * leaked here, so best practice is to avoid dss for arenas to be
	 * destroyed, or provide custom extent hooks that track retained
	 * dss-based extents for later reuse.
	 */</comment>
	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name> <init>= <expr><call><name>extent_hooks_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>extent</name> <operator>=</operator> <call><name>extents_evict</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>extent_destroy_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>base_ind_get</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>narenas_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>arena_nthreads_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>arena_nthreads_get</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No allocations have occurred since arena_reset() was called.
	 * Furthermore, the caller (arena_i_destroy_ctl()) purged all cached
	 * extents, so only retained extents may remain.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extents_npages_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deallocate retained memory. */</comment>
	<expr_stmt><expr><call><name>arena_destroy_retained</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the arena pointer from the arenas array.  We rely on the fact
	 * that there is no way for the application to get a dirty read from the
	 * arenas array unless there is an inherent race in the application
	 * involving access of an arena being concurrently destroyed.  The
	 * application must synchronize knowledge of the arena's validity, so as
	 * long as we use an atomic write to update the arenas array, the
	 * application will get a clean read any time after it synchronizes
	 * knowledge that the arena is no longer valid.
	 */</comment>
	<expr_stmt><expr><call><name>arena_set</name><argument_list>(<argument><expr><call><name>base_ind_get</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Destroy the base allocator, which manages all metadata ever mapped by
	 * this arena.
	 */</comment>
	<expr_stmt><expr><call><name>base_delete</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>arena_slab_alloc_hard</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>,
    <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_extent_hooks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>szind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>zero</name></decl>, <decl><type ref="prev"/><name>commit</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>commit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>extent_alloc_wrapper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>r_extent_hooks</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
	    <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>slab_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name> <operator>&amp;&amp;</operator> <name>slab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_stats_mapped_add</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
		    <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>slab_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>slab</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>arena_slab_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>binshard</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>witness_assert_depth_to_rank</name><argument_list>(<argument><expr><call><name>tsdn_witness_tsdp_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name> <init>= <expr><name>EXTENT_HOOKS_INITIALIZER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>szind</name> <init>= <expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>reg_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>zero</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>commit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>extents_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>slab_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	    <argument><expr><name>binind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>arena_may_have_muzzy</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>extents_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>slab_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PAGE</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>arena_slab_alloc_hard</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_hooks</name></expr></argument>,
		    <argument><expr><name>bin_info</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_slab_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize slab internals. */</comment>
	<decl_stmt><decl><type><name>arena_slab_data_t</name> <modifier>*</modifier></type><name>slab_data</name> <init>= <expr><call><name>extent_slab_data_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_nfree_binshard_set</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>nregs</name></name></expr></argument>, <argument><expr><name>binshard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bitmap_init</name><argument_list>(<argument><expr><name><name>slab_data</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_info</name><operator>-&gt;</operator><name>bitmap_info</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>arena_nactive_add</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><call><name>extent_size_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>LG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slab</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>extent_t</name> <modifier>*</modifier></type>
<name>arena_bin_nonfull_slab_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>binshard</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl>;</decl_stmt>

	<comment type="block">/* Look for a usable slab. */</comment>
	<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>arena_bin_slabs_nonfull_tryget</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>slab</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* No existing slabs have any space available. */</comment>

	<expr_stmt><expr><name>bin_info</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Allocate a new slab. */</comment>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block" format="doxygen">/******************************/</comment>
	<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>arena_slab_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>binshard</name></expr></argument>, <argument><expr><name>bin_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block" format="doxygen">/********************************/</comment>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nslabs</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curslabs</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>slab</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * arena_slab_alloc() failed, but another thread may have made
	 * sufficient memory available while this one dropped bin-&gt;lock above,
	 * so search one more time.
	 */</comment>
	<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>arena_bin_slabs_nonfull_tryget</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>slab</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Re-fill bin-&gt;slabcur, then call arena_slab_reg_alloc(). */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>arena_bin_malloc_hard</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>binshard</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bin_info</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>arena_is_auto</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_bin_slabs_full_insert</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>slab</name> <operator>=</operator> <call><name>arena_bin_nonfull_slab_get</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>binshard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Another thread updated slabcur while this one ran without the
		 * bin lock in arena_bin_nonfull_slab_get().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>arena_slab_reg_alloc</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>,
			    <argument><expr><name>bin_info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * arena_slab_alloc() may have allocated slab,
				 * or it may have been pulled from
				 * slabs_nonfull.  Therefore it is unsafe to
				 * make any assumptions about how slab has
				 * previously been used, and
				 * arena_bin_lower_slab() must be called, as if
				 * a region were just deallocated from the slab.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>bin_info</name><operator>-&gt;</operator><name>nregs</name></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>arena_dalloc_bin_slab</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>,
					    <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if> <else>else <block>{<block_content>
					<expr_stmt><expr><call><name>arena_bin_lower_slab</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>,
					    <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>arena_bin_slabs_full_insert</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>=</operator> <name>slab</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>arena_slab_reg_alloc</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>bin_info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Choose a bin shard and return the locked bin. */</comment>
<function><type><name>bin_t</name> <modifier>*</modifier></type>
<name>arena_bin_choose_lock</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>binshard</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tsd_arena_get</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>binshard</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>binshard</name> <operator>=</operator> <call><name>tsd_binshardsp_get</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>binshard</name><index>[<expr><name>binind</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>binshard</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bin</name> <operator>=</operator> <operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>binind</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><operator>*</operator><name>binshard</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bin</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_tcache_fill_small</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>,
    <parameter><decl><type><name>cache_bin_t</name> <modifier>*</modifier></type><name>tbin</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>prof_accumbytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nfill</name></decl>, <decl><type ref="prev"/><name>cnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tbin</name><operator>-&gt;</operator><name>ncached</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <call><name>arena_prof_accum</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>prof_accumbytes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_idump</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>binshard</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><call><name>arena_bin_choose_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>binshard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>nfill</name> <operator>=</operator> <operator>(</operator><name><name>tcache_bin_info</name><index>[<expr><name>binind</name></expr>]</index></name><operator>.</operator><name>ncached_max</name> <operator>&gt;&gt;</operator>
	    <name><name>tcache</name><operator>-&gt;</operator><name>lg_fill_div</name><index>[<expr><name>binind</name></expr>]</index></name><operator>)</operator></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfill</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>cnt</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>slab</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
		    <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name></type> <name>tofill</name> <init>= <expr><name>nfill</name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>=</operator> <ternary><condition><expr><name>tofill</name> <operator>&lt;</operator> <call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
				<expr><name>tofill</name></expr> </then><else>: <expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>arena_slab_reg_alloc_batch</name><argument_list>(
			   <argument><expr><name>slab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>,
			   <argument><expr><name><name>tbin</name><operator>-&gt;</operator><name>avail</name></name> <operator>-</operator> <name>nfill</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>arena_bin_malloc_hard</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>,
			    <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>binshard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * OOM.  tbin-&gt;avail isn't yet filled down to its first
			 * element, so the successful allocations (if any) must
			 * be moved just before tbin-&gt;avail before bailing out.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>tbin</name><operator>-&gt;</operator><name>avail</name></name> <operator>-</operator> <name>i</name></expr></argument>,
						<argument><expr><name><name>tbin</name><operator>-&gt;</operator><name>avail</name></name> <operator>-</operator> <name>nfill</name></expr></argument>,
						<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Insert such that low regions get used first. */</comment>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>tbin</name><operator>-&gt;</operator><name>avail</name></name> <operator>-</operator> <name>nfill</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_fill</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_junk_alloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><operator>*</operator><operator>(</operator><name><name>tbin</name><operator>-&gt;</operator><name>avail</name></name> <operator>-</operator> <name>nfill</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>j</name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>arena_alloc_junk_small</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nmalloc</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nrequests</name></name> <operator>+=</operator> <name><name>tbin</name><operator>-&gt;</operator><name>tstats</name><operator>.</operator><name>nrequests</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curregs</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nfills</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbin</name><operator>-&gt;</operator><name>tstats</name><operator>.</operator><name>nrequests</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbin</name><operator>-&gt;</operator><name>ncached</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_decay_tick</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_alloc_junk_small</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>JEMALLOC_ALLOC_JUNK</name></expr></argument>, <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>reg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_dalloc_junk_small_impl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>JEMALLOC_FREE_JUNK</name></expr></argument>, <argument><expr><name><name>bin_info</name><operator>-&gt;</operator><name>reg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>arena_dalloc_junk_small_t</name> <modifier>*</modifier><name>JET_MUTABLE</name></type> <name>arena_dalloc_junk_small</name> <init>=
    <expr><name>arena_dalloc_junk_small_impl</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>arena_malloc_small</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>binind</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_index2size</name><argument_list>(<argument><expr><name>binind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>binshard</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>arena_bin_choose_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>binshard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>slab</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_slab_reg_alloc</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_bin_malloc_hard</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>binshard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nmalloc</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>nrequests</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curregs</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <call><name>arena_prof_accum</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_idump</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_fill</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>opt_junk_alloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>arena_alloc_junk_small</name><argument_list>(<argument><expr><name>ret</name></expr></argument>,
				    <argument><expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>opt_zero</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>config_fill</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_junk_alloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_alloc_junk_small</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></argument>,
			    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>arena_decay_tick</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>arena_malloc_hard</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>szind_t</name></type> <name>ind</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>arena</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>arena</name> <operator>=</operator> <call><name>arena_choose_maybe_huge</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>size</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>arena_malloc_small</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>large_malloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><call><name>sz_index2size</name><argument_list>(<argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>arena_palloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name>
	    <operator>&amp;&amp;</operator> <operator>(</operator><name>alignment</name> <operator>&lt;</operator> <name>PAGE</name>
	    <operator>||</operator> <operator>(</operator><name>alignment</name> <operator>==</operator> <name>PAGE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>usize</name> <operator>&amp;</operator> <name>PAGE_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Small; alignment doesn't require special slab placement. */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arena_malloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>alignment</name> <operator>&lt;=</operator> <name>CACHELINE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>large_malloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>large_palloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prof_promote</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_opt_safety_checks</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>safety_check_set_redzone</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>rtree_extent_read</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>szind_t</name></type> <name>szind</name> <init>= <expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extent_szind_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>szind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rtree_szind_slab_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>,
	    <argument><expr><name>szind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>prof_accum_cancel</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>prof_accum</name></name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>arena_prof_demote</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_szind_set</name><argument_list>(<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>SC_NBINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name></type> <name>rtree_ctx_fallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rtree_ctx_t</name> <modifier>*</modifier></type><name>rtree_ctx</name> <init>= <expr><call><name>tsdn_rtree_ctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtree_ctx_fallback</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>rtree_szind_slab_update</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extents_rtree</name></expr></argument>, <argument><expr><name>rtree_ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>,
	    <argument><expr><name>SC_NBINS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SC_LARGE_MINCLASS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_dalloc_promoted</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>slow_path</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opt_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bumped_usize</name> <init>= <expr><call><name>arena_prof_demote</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_opt_safety_checks</name> <operator>&amp;&amp;</operator> <name>usize</name> <operator>&lt;</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Currently, we only do redzoning for small sampled
		 * allocations.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bumped_usize</name> <operator>==</operator> <name>SC_LARGE_MINCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>safety_check_verify_redzone</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>bumped_usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>bumped_usize</name> <operator>&lt;=</operator> <name>tcache_maxclass</name> <operator>&amp;&amp;</operator> <name>tcache</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tcache_dalloc_large</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
		    <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>bumped_usize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slow_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>large_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_dissociate_bin_slab</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Dissociate slab from bin. */</comment>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>szind_t</name></type> <name>binind</name> <init>= <expr><call><name>extent_szind_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name> <init>= <expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The following block's conditional is necessary because if the
		 * slab only contains one region, then it never gets inserted
		 * into the non-full slabs heap.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bin_info</name><operator>-&gt;</operator><name>nregs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_bin_slabs_full_remove</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>arena_bin_slabs_nonfull_remove</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_dalloc_bin_slab</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>,
    <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>slab</name> <operator>!=</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block" format="doxygen">/******************************/</comment>
	<expr_stmt><expr><call><name>arena_slab_dalloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block" format="doxygen">/****************************/</comment>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curslabs</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_bin_lower_slab</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>,
    <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that if bin-&gt;slabcur is non-NULL, it refers to the
	 * oldest/lowest non-full slab.  It is okay to NULL slabcur out rather
	 * than proactively keeping it pointing at the oldest/lowest non-full
	 * slab.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>extent_snad_comp</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Switch slabcur. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_bin_slabs_nonfull_insert</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>arena_bin_slabs_full_insert</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name> <operator>=</operator> <name>slab</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>reslabs</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>arena_bin_slabs_nonfull_insert</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_dalloc_bin_locked_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>slab</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>junked</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_slab_data_t</name> <modifier>*</modifier></type><name>slab_data</name> <init>= <expr><call><name>extent_slab_data_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bin_info_t</name> <modifier>*</modifier></type><name>bin_info</name> <init>= <expr><operator>&amp;</operator><name><name>bin_infos</name><index>[<expr><name>binind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>junked</name> <operator>&amp;&amp;</operator> <name>config_fill</name> <operator>&amp;&amp;</operator> <call><name>unlikely</name><argument_list>(<argument><expr><name>opt_junk_free</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_dalloc_junk_small</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>bin_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>arena_slab_reg_dalloc</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>slab_data</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>nfree</name> <init>= <expr><call><name>extent_nfree_get</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfree</name> <operator>==</operator> <name><name>bin_info</name><operator>-&gt;</operator><name>nregs</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_dissociate_bin_slab</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_dalloc_bin_slab</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nfree</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>slab</name> <operator>!=</operator> <name><name>bin</name><operator>-&gt;</operator><name>slabcur</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_bin_slabs_full_remove</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>arena_bin_lower_slab</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>ndalloc</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>curregs</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_dalloc_bin_junked_locked</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>,
    <parameter><decl><type><name>szind_t</name></type> <name>binind</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>arena_dalloc_bin_locked_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
	    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arena_dalloc_bin</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>szind_t</name></type> <name>binind</name> <init>= <expr><call><name>extent_szind_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>binshard</name> <init>= <expr><call><name>extent_binshard_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bin_t</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>binind</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>binshard</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_dalloc_bin_locked_impl</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>binind</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
	    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_dalloc_small</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name> <init>= <expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>arena_dalloc_bin</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_decay_tick</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_ralloc_no_move</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>oldsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>extra</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>newsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<comment type="block">/* Calls with non-zero extra had to clamp extra. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>extra</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>size</name> <operator>+</operator> <name>extra</name> <operator>&lt;=</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>extent_t</name> <modifier>*</modifier></type><name>extent</name> <init>= <expr><call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>usize_min</name> <init>= <expr><call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize_max</name> <init>= <expr><call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <name>extra</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>oldsize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name> <operator>&amp;&amp;</operator> <name>usize_min</name>
	    <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Avoid moving the allocation if the size class can be left the
		 * same.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bin_infos</name><index>[<expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>reg_size</name> <operator>==</operator>
		    <name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>usize_max</name> <operator>&gt;</operator> <name>SC_SMALL_MAXCLASS</name>
		    <operator>||</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize_max</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>sz_size2index</name><argument_list>(<argument><expr><name>oldsize</name></expr></argument>)</argument_list></call><operator>)</operator>
		    <operator>&amp;&amp;</operator> <operator>(</operator><name>size</name> <operator>&gt;</operator> <name>oldsize</name> <operator>||</operator> <name>usize_max</name> <operator>&lt;</operator> <name>oldsize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>arena_decay_tick</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><call><name>extent_arena_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oldsize</name> <operator>&gt;=</operator> <name>SC_LARGE_MINCLASS</name>
	    <operator>&amp;&amp;</operator> <name>usize_max</name> <operator>&gt;=</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>large_ralloc_no_move</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>, <argument><expr><name>usize_min</name></expr></argument>, <argument><expr><name>usize_max</name></expr></argument>,
		    <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>extent</name> <operator>==</operator> <call><name>iealloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>newsize</name> <operator>=</operator> <call><name>extent_usize_get</name><argument_list>(<argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>arena_ralloc_move_helper</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>alignment</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>arena_malloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>sz_sa2u</name><argument_list>(<argument><expr><name>usize</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>usize</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>ipalloct</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>arena_ralloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>oldsize</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>, <parameter><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>,
    <parameter><decl><type><name>hook_ralloc_args_t</name> <modifier>*</modifier></type><name>hook_args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name> <init>= <expr><call><name>sz_s2u</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>usize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>size</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>usize</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Try to avoid moving the allocation. */</comment>
		<decl_stmt><decl><type><name>UNUSED</name> <name>size_t</name></type> <name>newsize</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>arena_ralloc_no_move</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zero</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>newsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>hook_invoke_expand</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>hook_args</name><operator>-&gt;</operator><name>is_realloc</name></name></expr>
			    ?</condition><then> <expr><name>hook_expand_realloc</name></expr> </then><else>: <expr><name>hook_expand_rallocx</name></expr></else></ternary></expr></argument>,
			    <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ptr</name></expr></argument>,
			    <argument><expr><name><name>hook_args</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ptr</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>&gt;=</operator> <name>SC_LARGE_MINCLASS</name>
	    <operator>&amp;&amp;</operator> <name>usize</name> <operator>&gt;=</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>large_ralloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>,
		    <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>hook_args</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * size and oldsize are different enough that we need to move the
	 * object.  In that case, fall back to allocating new space and copying.
	 */</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>arena_ralloc_move_helper</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>,
	    <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hook_invoke_alloc</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>hook_args</name><operator>-&gt;</operator><name>is_realloc</name></name></expr>
	    ?</condition><then> <expr><name>hook_alloc_realloc</name></expr> </then><else>: <expr><name>hook_alloc_rallocx</name></expr></else></ternary></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>ret</name></expr></argument>,
	    <argument><expr><name><name>hook_args</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hook_invoke_dalloc</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>hook_args</name><operator>-&gt;</operator><name>is_realloc</name></name></expr>
	    ?</condition><then> <expr><name>hook_dalloc_realloc</name></expr> </then><else>: <expr><name>hook_dalloc_rallocx</name></expr></else></ternary></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>hook_args</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Junk/zero-filling were already done by
	 * ipalloc()/arena_malloc().
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>copysize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>usize</name> <operator>&lt;</operator> <name>oldsize</name><operator>)</operator></expr> ?</condition><then> <expr><name>usize</name></expr> </then><else>: <expr><name>oldsize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>copysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>isdalloct</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>dss_prec_t</name></type>
<name>arena_dss_prec_get</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>(</operator><name>dss_prec_t</name><operator>)</operator><call><name>atomic_load_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>dss_prec</name></name></expr></argument>, <argument><expr><name>ATOMIC_ACQUIRE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_dss_prec_set</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>dss_prec_t</name></type> <name>dss_prec</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_dss</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><operator>(</operator><name>dss_prec</name> <operator>!=</operator> <name>dss_prec_disabled</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>dss_prec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>dss_prec</name></expr></argument>, <argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>arena_dirty_decay_ms_default_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirty_decay_ms_default</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_dirty_decay_ms_default_set</name><parameter_list>(<parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>arena_decay_ms_valid</name><argument_list>(<argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>atomic_store_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirty_decay_ms_default</name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>arena_muzzy_decay_ms_default_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>muzzy_decay_ms_default</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_muzzy_decay_ms_default_set</name><parameter_list>(<parameter><decl><type><name>ssize_t</name></type> <name>decay_ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>arena_decay_ms_valid</name><argument_list>(<argument><expr><name>decay_ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>atomic_store_zd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>muzzy_decay_ms_default</name></expr></argument>, <argument><expr><name>decay_ms</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_retain_grow_limit_get_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>old_limit</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>new_limit</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opt_retain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>pszind_t</name> <name>new_ind</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_limit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>limit</name> <init>= <expr><operator>*</operator><name>new_limit</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Grow no more than the new limit. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new_ind</name> <operator>=</operator> <call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>limit</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>SC_NPSIZES</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>old_limit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>old_limit</name> <operator>=</operator> <call><name>sz_pind2sz</name><argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>retain_grow_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_limit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>retain_grow_limit</name></name> <operator>=</operator> <name>new_ind</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name></type>
<name>arena_nthreads_get</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><name>internal</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_nthreads_inc</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_fetch_add_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><name>internal</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_nthreads_dec</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_fetch_sub_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><name>internal</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>arena_extent_sn_next</name><parameter_list>(<parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_fetch_add_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_sn_next</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>arena_t</name> <modifier>*</modifier></type>
<name>arena_new</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>extent_hooks_t</name> <modifier>*</modifier></type><name>extent_hooks</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>base_t</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>b0get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>base_new</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>extent_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>nbins_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>nbins_total</name> <operator>+=</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<decl_stmt><decl><type><name>size_t</name></type> <name>arena_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>arena_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bin_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nbins_total</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>arena</name> <operator>=</operator> <operator>(</operator><name>arena_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>arena_size</name></expr></argument>, <argument><expr><name>CACHELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>last_thd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>arena_stats_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_error</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ql_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ql_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>cache_bin_array_descriptor_ql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>, <argument><expr><literal type="string">"tcache_ql"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_TCACHE_QL</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>prof_accum_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>prof_accum</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_cache_oblivious</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * A nondeterministic seed based on the address of arena reduces
		 * the likelihood of lockstep non-uniform cache index
		 * utilization among identical concurrent processes, but at the
		 * cost of test repeatability.  For debug builds, instead use a
		 * deterministic seed.
		 */</comment>
		<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>offset_state</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>config_debug</name></expr> ?</condition><then> <expr><name>ind</name></expr> </then><else>:
		    <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>arena</name></expr></else></ternary></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_sn_next</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>dss_prec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>extent_dss_prec_get</name><argument_list>()</argument_list></call></expr></argument>,
	    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>atomic_store_zu</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nactive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>extent_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>, <argument><expr><literal type="string">"arena_large"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_ARENA_LARGE</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Delay coalescing for dirty extents despite the disruptive effect on
	 * memory layout for best-fit extent allocation, since cached extents
	 * are likely to be reused soon after deallocation, and the cost of
	 * merging/splitting extents is non-trivial.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extents_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>, <argument><expr><name>extent_state_dirty</name></expr></argument>,
	    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Coalesce muzzy extents immediately, because operations on them are in
	 * the critical path much less often than for dirty extents.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extents_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>, <argument><expr><name>extent_state_muzzy</name></expr></argument>,
	    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Coalesce retained extents immediately, in part because they will
	 * never be evicted (and therefore there's no opportunity for delayed
	 * coalescing), but also because operations on retained extents are not
	 * in the critical path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extents_init</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>, <argument><expr><name>extent_state_retained</name></expr></argument>,
	    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>arena_decay_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name></name></expr></argument>,
	    <argument><expr><call><name>arena_dirty_decay_ms_default_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_dirty</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>arena_decay_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name></name></expr></argument>,
	    <argument><expr><call><name>arena_muzzy_decay_ms_default_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>decay_muzzy</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_next</name></name> <operator>=</operator> <call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>HUGEPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>retain_grow_limit</name></name> <operator>=</operator> <call><name>sz_psz2ind</name><argument_list>(<argument><expr><name>SC_LARGE_MAXCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>, <argument><expr><literal type="string">"extent_grow"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_EXTENT_GROW</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>extent_avail_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>, <argument><expr><literal type="string">"extent_avail"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_EXTENT_AVAIL</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize bins. */</comment>
	<decl_stmt><decl><type><name>uintptr_t</name></type> <name>bin_addr</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>arena</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>arena_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>binshard_next</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>nshards</name> <init>= <expr><name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bin_shards</name> <operator>=</operator> <operator>(</operator><name>bin_t</name> <operator>*</operator><operator>)</operator><name>bin_addr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bin_addr</name> <operator>+=</operator> <name>nshards</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bin_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nshards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>bin_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
				<goto>goto <name>label_error</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bin_addr</name> <operator>==</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>arena</name> <operator>+</operator> <name>arena_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<comment type="block">/* Set arena before creating background threads. */</comment>
	<expr_stmt><expr><call><name>arena_set</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>nstime_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>create_time</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>create_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't support reentrancy for arena 0 bootstrapping. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * If we're here, then arena 0 already exists, so bootstrapping
		 * is done enough that we should have tsd.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>test_hooks_arena_new_hook</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>test_hooks_arena_new_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>arena</name></expr>;</return>
<label><name>label_error</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>ind</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>base_delete</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>arena_t</name> <modifier>*</modifier></type>
<name>arena_choose_huge</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* huge_arena_ind can be 0 during init (will use a0). */</comment>
	<if_stmt><if>if <condition>(<expr><name>huge_arena_ind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>malloc_initialized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>huge_arena</name> <init>= <expr><call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>huge_arena_ind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>huge_arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Create the huge arena on demand. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>huge_arena_ind</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>huge_arena</name> <operator>=</operator> <call><name>arena_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>huge_arena_ind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>huge_arena</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * Purge eagerly for huge allocations, because: 1) number of
		 * huge allocations is usually small, which means ticker based
		 * decay is not reliable; and 2) less immediate reuse is
		 * expected for huge allocations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>arena_dirty_decay_ms_default_get</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_dirty_decay_ms_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>huge_arena</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>arena_muzzy_decay_ms_default_get</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>arena_muzzy_decay_ms_set</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>huge_arena</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>huge_arena</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_init_huge</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>huge_enabled</name></decl>;</decl_stmt>

	<comment type="block">/* The threshold should be large size class. */</comment>
	<if_stmt><if>if <condition>(<expr><name>opt_oversize_threshold</name> <operator>&gt;</operator> <name>SC_LARGE_MAXCLASS</name> <operator>||</operator>
	    <name>opt_oversize_threshold</name> <operator>&lt;</operator> <name>SC_LARGE_MINCLASS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>opt_oversize_threshold</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>oversize_threshold</name> <operator>=</operator> <name>SC_LARGE_MAXCLASS</name> <operator>+</operator> <name>PAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>huge_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* Reserve the index for the huge arena. */</comment>
		<expr_stmt><expr><name>huge_arena_ind</name> <operator>=</operator> <call><name>narenas_total_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oversize_threshold</name> <operator>=</operator> <name>opt_oversize_threshold</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>huge_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>huge_enabled</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>arena_is_huge</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>huge_arena_ind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>arena_ind</name> <operator>==</operator> <name>huge_arena_ind</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_boot</name><parameter_list>(<parameter><decl><type><name>sc_data_t</name> <modifier>*</modifier></type><name>sc_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>arena_dirty_decay_ms_default_set</name><argument_list>(<argument><expr><name>opt_dirty_decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_muzzy_decay_ms_default_set</name><argument_list>(<argument><expr><name>opt_muzzy_decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>sc_t</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><operator>&amp;</operator><name><name>sc_data</name><operator>-&gt;</operator><name>sc</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>div_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena_binind_div_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
		    <argument><expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>sc</name><operator>-&gt;</operator><name>lg_base</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>sc</name><operator>-&gt;</operator><name>ndelta</name></name> <operator>&lt;&lt;</operator> <name><name>sc</name><operator>-&gt;</operator><name>lg_delta</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork0</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork1</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork2</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork3</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>extents_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork4</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork5</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>base_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork6</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_prefork7</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>bin_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>bin_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>base_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>arena_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>arena_t</name> <modifier>*</modifier></type><name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atomic_store_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>nthreads</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_arena_get</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>arena</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_nthreads_inc</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_iarena_get</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>arena</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>arena_nthreads_inc</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ql_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ql_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>cache_bin_array_descriptor_ql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>tcache_t</name> <modifier>*</modifier></type><name>tcache</name> <init>= <expr><call><name>tcache_get</name><argument_list>(<argument><expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tcache</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tcache</name><operator>-&gt;</operator><name>arena</name></name> <operator>==</operator> <name>arena</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ql_elm_new</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ql_tail_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql</name></name></expr></argument>, <argument><expr><name>tcache</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>cache_bin_array_descriptor_init</name><argument_list>(
			    <argument><expr><operator>&amp;</operator><name><name>tcache</name><operator>-&gt;</operator><name>cache_bin_array_descriptor</name></name></expr></argument>,
			    <argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>bins_small</name></name></expr></argument>, <argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>bins_large</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ql_tail_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>cache_bin_array_descriptor_ql</name></name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>tcache</name><operator>-&gt;</operator><name>cache_bin_array_descriptor</name></name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SC_NBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin_infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>bin_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>bins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bin_shards</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>large_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>base_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>arena</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_avail_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_dirty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_muzzy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>extents_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extents_retained</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>extent_grow_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_dirty</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>decay_muzzy</name><operator>.</operator><name>mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arena</name><operator>-&gt;</operator><name>tcache_ql_mtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
