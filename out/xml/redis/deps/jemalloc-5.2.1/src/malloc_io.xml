<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/malloc_io.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_MALLOC_IO_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/malloc_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/util.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>assert</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>assert</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>not_reached</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>not_reached</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>not_implemented</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>not_implemented</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>assert_not_implemented</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>assert_not_implemented</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Define simple versions of assertion macros that won't recurse in case
 * of assertion failures in malloc_*printf().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {							\
	if (config_debug &amp;&amp; !(e)) {					\
		malloc_write("&lt;jemalloc&gt;: Failed assertion\n");		\
		abort();						\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>not_reached</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {						\
	if (config_debug) {						\
		malloc_write("&lt;jemalloc&gt;: Unreachable code reached\n");	\
		abort();						\
	}								\
	unreachable();							\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>not_implemented</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {						\
	if (config_debug) {						\
		malloc_write("&lt;jemalloc&gt;: Not implemented\n");		\
		abort();						\
	}								\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert_not_implemented</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {					\
	if (unlikely(config_debug &amp;&amp; !(e))) {				\
		not_implemented();					\
	}								\
} while (0)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Function prototypes for non-inline static functions. */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wrtmessage</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbopaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U2S_BUFSIZE</name></cpp:macro> <cpp:value>((1U &lt;&lt; (LG_SIZEOF_INTMAX_T + 3)) + 1)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>u2s</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>uppercase</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D2S_BUFSIZE</name></cpp:macro> <cpp:value>(1 + U2S_BUFSIZE)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>d2s</name><parameter_list>(<parameter><decl><type><name>intmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sign</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O2S_BUFSIZE</name></cpp:macro> <cpp:value>(1 + U2S_BUFSIZE)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>o2s</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alt_form</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X2S_BUFSIZE</name></cpp:macro> <cpp:value>(2 + U2S_BUFSIZE)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>x2s</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alt_form</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>uppercase</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<comment type="block">/* malloc_message() setup. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wrtmessage</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbopaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_write_fd</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>JEMALLOC_EXPORT</name> <name>void</name></type>	(<modifier>*</modifier><name>je_malloc_message</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Wrapper around malloc_message() that avoids the need for
 * je_malloc_message(...) throughout the code.
 */</comment>
<function><type><name>void</name></type>
<name>malloc_write</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>je_malloc_message</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>je_malloc_message</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>wrtmessage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * glibc provides a non-standard strerror_r() when _GNU_SOURCE is defined, so
 * provide a wrapper.
 */</comment>
<function><type><name>int</name></type>
<name>buferror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FormatMessageA</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_FROM_SYSTEM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
	    <argument><expr><operator>(</operator><name>LPSTR</name><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>buflen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_STRERROR_R_RETURNS_CHAR_WITH_GNU_SOURCE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_GNU_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>uintmax_t</name></type>
<name>malloc_strtoumax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>nptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>endptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uintmax_t</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>digit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>neg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>nptr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>base</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>base</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>base</name></expr></argument> &gt;</argument_list></name> <literal type="number">36</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ns</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>UINTMAX_MAX</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>

	<comment type="block">/* Swallow leading whitespace and get sign, if any. */</comment>
	<expr_stmt><expr><name>neg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\v'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <case>case <expr><literal type="char">' '</literal></expr>:</case>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'-'</literal></expr>:</case>
			<expr_stmt><expr><name>neg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* Fall through. */</comment>
		<case>case <expr><literal type="char">'+'</literal></expr>:</case>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Fall through. */</comment>
		<default>default:</default>
			<goto>goto <name>label_prefix</name>;</goto>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/* Get prefix, if any. */</comment>
	<label><name>label_prefix</name>:</label>
	<comment type="block">/*
	 * Note where the first non-whitespace/sign character is so that it is
	 * possible to tell whether any digits are consumed (e.g., "  0" vs.
	 * "  -x").
	 */</comment>
	<expr_stmt><expr><name>ns</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case>
		<case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'X'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<switch>switch <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case> <case>case <expr><literal type="char">'C'</literal></expr>:</case> <case>case <expr><literal type="char">'D'</literal></expr>:</case> <case>case <expr><literal type="char">'E'</literal></expr>:</case>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case> <case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert. */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>digit</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>&lt;</operator> <name>b</name><operator>)</operator>
	    <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>digit</name> <operator>=</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>&lt;</operator> <name>b</name><operator>)</operator>
	    <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'z'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>digit</name> <operator>=</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>&lt;</operator> <name>b</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uintmax_t</name></type> <name>pret</name> <init>= <expr><name>ret</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ret</name> <operator>*=</operator> <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>+=</operator> <name>digit</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <name>pret</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Overflow. */</comment>
			<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>UINTMAX_MAX</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>uintmax_t</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><operator>(</operator><name>intmax_t</name><operator>)</operator><name>ret</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>ns</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* No conversion performed. */</comment>
		<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>UINTMAX_MAX</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

<label><name>label_return</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>ns</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* No characters were converted. */</comment>
			<expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>nptr</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>u2s</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>uppercase</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>U2S_BUFSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>base</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><literal type="number">10</literal></expr>:</case>
		<do>do <block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"0123456789"</literal><index>[<expr><name>x</name> <operator>%</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">10</literal></expr>]</index></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> <operator>/=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">10</literal></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
		<break>break;</break>
	<case>case <expr><literal type="number">16</literal></expr>:</case> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>uppercase</name><operator>)</operator></expr>
		    ?</condition><then> <expr><literal type="string">"0123456789ABCDEF"</literal></expr>
		    </then><else>: <expr><literal type="string">"0123456789abcdef"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<do>do <block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>digits</name><index>[<expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
		<break>break;</break>
	</block_content>}</block> <default>default:</default> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>uppercase</name><operator>)</operator></expr>
		    ?</condition><then> <expr><literal type="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal></expr>
		    </then><else>: <expr><literal type="string">"0123456789abcdefghijklmnopqrstuvwxyz"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>base</name> <operator>&lt;=</operator> <literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<do>do <block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>digits</name><index>[<expr><name>x</name> <operator>%</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>base</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> <operator>/=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>base</name></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
	</block_content>}</block></block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>slen_p</name> <operator>=</operator> <name>U2S_BUFSIZE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>d2s</name><parameter_list>(<parameter><decl><type><name>intmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sign</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>neg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>neg</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><name>x</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>u2s</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<switch>switch <condition>(<expr><name>sign</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><literal type="char">'-'</literal></expr>:</case>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>neg</name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Fall through. */</comment>
	<case>case <expr><literal type="char">' '</literal></expr>:</case>
	<case>case <expr><literal type="char">'+'</literal></expr>:</case>
		<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>slen_p</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>sign</name></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default> <expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>o2s</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alt_form</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>u2s</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>alt_form</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>slen_p</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>x2s</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alt_form</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>uppercase</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>slen_p</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>u2s</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>uppercase</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>alt_form</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>slen_p</name><operator>)</operator> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name>uppercase</name></expr> ?</condition><then> <expr><literal type="string">"0X"</literal></expr> </then><else>: <expr><literal type="string">"0x"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>malloc_vsnprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_C</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {						\
	if (i &lt; size) {							\
		str[i] = (c);						\
	}								\
	i++;								\
} while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_S</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>slen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {						\
	if (i &lt; size) {							\
		size_t cpylen = (slen &lt;= size - i) ? slen : size - i;	\
		memcpy(&amp;str[i], s, cpylen);				\
	}								\
	i += slen;							\
} while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_PADDED_S</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>slen</name></type></parameter>, <parameter><type><name>width</name></type></parameter>, <parameter><type><name>left_justify</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {		\
	<comment type="block">/* Left padding. */</comment>						\
	size_t pad_len = (width == -1) ? 0 : ((slen &lt; (size_t)width) ?	\
	    (size_t)width - slen : 0);					\
	if (!left_justify &amp;&amp; pad_len != 0) {				\
		size_t j;						\
		for (j = 0; j &lt; pad_len; j++) {				\
			APPEND_C(' ');					\
		}							\
	}								\
	<comment type="block">/* Value. */</comment>							\
	APPEND_S(s, slen);						\
	<comment type="block">/* Right padding. */</comment>						\
	if (left_justify &amp;&amp; pad_len != 0) {				\
		size_t j;						\
		for (j = 0; j &lt; pad_len; j++) {				\
			APPEND_C(' ');					\
		}							\
	}								\
} while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ARG_NUMERIC</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {					\
	switch ((unsigned char)len) {					\
	case '?':							\
		val = va_arg(ap, int);					\
		break;							\
	case '?' | 0x80:						\
		val = va_arg(ap, unsigned int);				\
		break;							\
	case 'l':							\
		val = va_arg(ap, long);					\
		break;							\
	case 'l' | 0x80:						\
		val = va_arg(ap, unsigned long);			\
		break;							\
	case 'q':							\
		val = va_arg(ap, long long);				\
		break;							\
	case 'q' | 0x80:						\
		val = va_arg(ap, unsigned long long);			\
		break;							\
	case 'j':							\
		val = va_arg(ap, intmax_t);				\
		break;							\
	case 'j' | 0x80:						\
		val = va_arg(ap, uintmax_t);				\
		break;							\
	case 't':							\
		val = va_arg(ap, ptrdiff_t);				\
		break;							\
	case 'z':							\
		val = va_arg(ap, ssize_t);				\
		break;							\
	case 'z' | 0x80:						\
		val = va_arg(ap, size_t);				\
		break;							\
	case 'p': <comment type="block">/* Synthetic; used for %p. */</comment>				\
		val = va_arg(ap, uintptr_t);				\
		break;							\
	default:							\
		not_reached();						\
		val = 0;						\
	}								\
} while (0)</cpp:value></cpp:define>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <name>format</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="char">'\0'</literal></expr>:</case> <goto>goto <name>label_out</name>;</goto>
		<case>case <expr><literal type="char">'%'</literal></expr>:</case> <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>alt_form</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>left_justify</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>plus_space</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>plus_plus</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>prec</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>len</name> <init>= <expr><literal type="char">'?'</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>slen</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Flags. */</comment>
			<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
				<switch>switch <condition>(<expr><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
				<case>case <expr><literal type="char">'#'</literal></expr>:</case>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>alt_form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>alt_form</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'-'</literal></expr>:</case>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>left_justify</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">' '</literal></expr>:</case>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>plus_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>plus_space</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'+'</literal></expr>:</case>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>plus_plus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>plus_plus</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default> <goto>goto <name>label_width</name>;</goto>
				</block_content>}</block></switch>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<comment type="block">/* Width. */</comment>
			<label><name>label_width</name>:</label>
			<switch>switch <condition>(<expr><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'*'</literal></expr>:</case>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>width</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>left_justify</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>width</name> <operator>=</operator> <operator>-</operator><name>width</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>uintmax_t</name></type> <name>uwidth</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>uwidth</name> <operator>=</operator> <call><name>malloc_strtoumax</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>uwidth</name> <operator>!=</operator> <name>UINTMAX_MAX</name> <operator>||</operator> <call><name>get_errno</name><argument_list>()</argument_list></call> <operator>!=</operator>
				    <name>ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>uwidth</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <default>default:</default>
				<break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* Width/precision separator. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>f</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<goto>goto <name>label_length</name>;</goto>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Precision. */</comment>
			<switch>switch <condition>(<expr><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'*'</literal></expr>:</case>
				<expr_stmt><expr><name>prec</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>uintmax_t</name></type> <name>uprec</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>set_errno</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>uprec</name> <operator>=</operator> <call><name>malloc_strtoumax</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>uprec</name> <operator>!=</operator> <name>UINTMAX_MAX</name> <operator>||</operator> <call><name>get_errno</name><argument_list>()</argument_list></call> <operator>!=</operator>
				    <name>ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>prec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>uprec</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default> <break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* Length. */</comment>
			<label><name>label_length</name>:</label>
			<switch>switch <condition>(<expr><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>f</name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="char">'q'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if> <else>else <block>{<block_content>
					<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'q'</literal></expr>:</case> <case>case <expr><literal type="char">'j'</literal></expr>:</case> <case>case <expr><literal type="char">'t'</literal></expr>:</case> <case>case <expr><literal type="char">'z'</literal></expr>:</case>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>f</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default> <break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* Conversion specifier. */</comment>
			<switch>switch <condition>(<expr><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'%'</literal></expr>:</case>
				<comment type="block">/* %% */</comment>
				<expr_stmt><expr><call><name>APPEND_C</name><argument_list>(<argument><expr><operator>*</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'i'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>intmax_t</name> <name>val</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>D2S_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GET_ARG_NUMERIC</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>d2s</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>plus_plus</name></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>plus_space</name></expr> ?</condition><then>
				    <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <case>case <expr><literal type="char">'o'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>uintmax_t</name> <name>val</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>O2S_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GET_ARG_NUMERIC</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name> <operator>|</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>o2s</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>alt_form</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <case>case <expr><literal type="char">'u'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>uintmax_t</name> <name>val</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>U2S_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GET_ARG_NUMERIC</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name> <operator>|</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>u2s</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>uintmax_t</name> <name>val</name></type> <name>JEMALLOC_CC_SILENCE_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>X2S_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GET_ARG_NUMERIC</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name> <operator>|</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>x2s</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>alt_form</name></expr></argument>, <argument><expr><operator>*</operator><name>f</name> <operator>==</operator> <literal type="char">'X'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_not_implemented</name><argument_list>(<argument><expr><name>len</name> <operator>!=</operator> <literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_not_implemented</name><argument_list>(<argument><expr><name>len</name> <operator>!=</operator> <literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>prec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>prec</name></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case> <block>{<block_content>
				<decl_stmt><decl><type><name>uintmax_t</name></type> <name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>X2S_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GET_ARG_NUMERIC</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>x2s</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_PADDED_S</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>left_justify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block> <default>default:</default> <expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>
		</block_content>}</block> <default>default:</default> <block>{<block_content>
			<expr_stmt><expr><call><name>APPEND_C</name><argument_list>(<argument><expr><operator>*</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></block_content>}</block></switch>
	</block_content>}</block></while>
	<label><name>label_out</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPEND_C</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPEND_S</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPEND_PADDED_S</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_ARG_NUMERIC</name></cpp:undef>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">3</literal></argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro>
<function><type><name>size_t</name></type>
<name>malloc_snprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>malloc_vsnprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>malloc_vcprintf</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>write_cb</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbopaque</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MALLOC_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>write_cb</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * The caller did not provide an alternate write_cb callback
		 * function, so use the default one.  malloc_write() is an
		 * inline function, so use malloc_message() directly here.
		 */</comment>
		<expr_stmt><expr><name>write_cb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>je_malloc_message</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>je_malloc_message</name></expr> </then><else>:
		    <expr><name>wrtmessage</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>write_cb</name><argument_list>(<argument><expr><name>cbopaque</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print to a callback function in such a way as to (hopefully) avoid memory
 * allocation.
 */</comment>
<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">3</literal></argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro>
<function><type><name>void</name></type>
<name>malloc_cprintf</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>write_cb</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbopaque</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_vcprintf</name><argument_list>(<argument><expr><name>write_cb</name></expr></argument>, <argument><expr><name>cbopaque</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Print to stderr in such a way as to avoid memory allocation. */</comment>
<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>
<function><type><name>void</name></type>
<name>malloc_printf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_vcprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore normal assertion macros, in order to make it possible to compile all
 * C files as a single concatenation.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>assert</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>not_reached</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>not_implemented</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>assert_not_implemented</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
</unit>
