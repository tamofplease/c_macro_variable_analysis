<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/prof.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_PROF_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ckh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/malloc_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/emitter.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF_LIBUNWIND</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNW_LOCAL_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libunwind.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF_LIBGCC</name></cpp:ifdef>
<comment type="block">/*
 * We have a circular dependency -- jemalloc_internal.h tells us if we should
 * use libgcc's unwinding functionality, but after we've included that, we've
 * already hooked _Unwind_Backtrace.  We'll temporarily disable hooking.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_Unwind_Backtrace</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unwind.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Unwind_Backtrace</name></cpp:macro> <cpp:value>JEMALLOC_HOOK(_Unwind_Backtrace, test_hooks_libc_hook)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_active</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_thread_active_init</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type>		<name>opt_lg_prof_sample</name> <init>= <expr><name>LG_PROF_SAMPLE_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type>		<name>opt_lg_prof_interval</name> <init>= <expr><name>LG_PROF_INTERVAL_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_gdump</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_final</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_leak</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_accum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>opt_prof_log</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type>		<name><name>opt_prof_prefix</name><index>[
    <comment type="block">/* Minimize memory bloat for non-prof builds. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF</name></cpp:ifdef>
    <expr><name>PATH_MAX</name> <operator>+</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * Initialized as opt_prof_active, and accessed via
 * prof_active_[gs]et{_unlocked,}().
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>			<name>prof_active</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>prof_active_mtx</name></decl>;</decl_stmt>

<comment type="block">/*
 * Initialized as opt_prof_thread_active_init, and accessed via
 * prof_thread_active_init_[gs]et().
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>prof_thread_active_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>prof_thread_active_init_mtx</name></decl>;</decl_stmt>

<comment type="block">/*
 * Initialized as opt_prof_gdump, and accessed via
 * prof_gdump_[gs]et{_unlocked,}().
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>			<name>prof_gdump_val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>prof_gdump_mtx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type>	<name>prof_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type>		<name>lg_prof_sample</name></decl>;</decl_stmt>

<typedef>typedef <type><name><name>enum</name> <name>prof_logging_state_e</name></name></type> <name>prof_logging_state_t</name>;</typedef>
<enum>enum <name>prof_logging_state_e</name> <block>{
	<decl><name>prof_logging_state_stopped</name></decl>,
	<decl><name>prof_logging_state_started</name></decl>,
	<decl><name>prof_logging_state_dumping</name></decl>
}</block>;</enum>

<comment type="block">/*
 * - stopped: log_start never called, or previous log_stop has completed.
 * - started: log_start called, log_stop not called yet. Allocations are logged.
 * - dumping: log_stop called but not finished; samples are not logged anymore.
 */</comment>
<decl_stmt><decl><type><name>prof_logging_state_t</name></type> <name>prof_logging_state</name> <init>= <expr><name>prof_logging_state_stopped</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_log_dummy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Incremented for every log file that is output. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>log_seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>log_filename</name><index>[
    <comment type="block">/* Minimize memory bloat for non-prof builds. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF</name></cpp:ifdef>
    <expr><name>PATH_MAX</name> <operator>+</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Timestamp for most recent call to log_start(). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>nstime_t</name></type> <name>log_start_timestamp</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Increment these when adding to the log_bt and log_thr linked lists. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>log_bt_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>log_thr_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Linked list node definitions. These are only used in prof.c. */</comment>
<typedef>typedef <type><name><name>struct</name> <name>prof_bt_node_s</name></name></type> <name>prof_bt_node_t</name>;</typedef>

<struct>struct <name>prof_bt_node_s</name> <block>{
	<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_bt_t</name></type> <name>bt</name></decl>;</decl_stmt>
	<comment type="block">/* Variable size backtrace vector pointed to by bt. */</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>prof_thr_node_s</name></name></type> <name>prof_thr_node_t</name>;</typedef>

<struct>struct <name>prof_thr_node_s</name> <block>{
	<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl>;</decl_stmt>
	<comment type="block">/* Variable size based on thr_name_sz. */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>prof_alloc_node_s</name></name></type> <name>prof_alloc_node_t</name>;</typedef>

<comment type="block">/* This is output when logging sampled allocations. */</comment>
<struct>struct <name>prof_alloc_node_s</name> <block>{
	<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<comment type="block">/* Indices into an array of thread data. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_thr_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>free_thr_ind</name></decl>;</decl_stmt>

	<comment type="block">/* Indices into an array of backtraces. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_bt_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>free_bt_ind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>alloc_time_ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>free_time_ns</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Created on the first call to prof_log_start and deleted on prof_log_stop.
 * These are the backtraces and threads that have already been logged by an
 * allocation.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>log_tables_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ckh_t</name></type> <name>log_bt_node_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ckh_t</name></type> <name>log_thr_node_set</name></decl>;</decl_stmt>

<comment type="block">/* Store linked lists for logged data. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>log_bt_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>log_bt_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>log_thr_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>log_thr_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>log_alloc_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>log_alloc_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Protects the prof_logging_state and any log_{...} variable. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>log_mtx</name></decl>;</decl_stmt>

<comment type="block">/*
 * Table of mutexes that are shared among gctx's.  These are leaf locks, so
 * there is no problem with using them for more than one gctx at the same time.
 * The primary motivation for this sharing though is that gctx's are ephemeral,
 * and destroying mutexes causes complications for systems that allocate when
 * creating/destroying mutexes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name>	<modifier>*</modifier></type><name>gctx_locks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_u_t</name></type>	<name>cum_gctxs</name></decl>;</decl_stmt> <comment type="block">/* Atomic counter. */</comment>

<comment type="block">/*
 * Table of mutexes that are shared among tdata's.  No operations require
 * holding multiple tdata locks, so there is no problem with using them for more
 * than one tdata at the same time, even though a gctx lock may be acquired
 * while holding a tdata lock.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name>	<modifier>*</modifier></type><name>tdata_locks</name></decl>;</decl_stmt>

<comment type="block">/*
 * Global hash of (prof_bt_t *)--&gt;(prof_gctx_t *).  This is the master data
 * structure that knows about all backtraces currently captured.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ckh_t</name></type>		<name>bt2gctx</name></decl>;</decl_stmt>
<comment type="block">/* Non static to enable profiling. */</comment>
<decl_stmt><decl><type><name>malloc_mutex_t</name></type>		<name>bt2gctx_mtx</name></decl>;</decl_stmt>

<comment type="block">/*
 * Tree of all extant prof_tdata_t structures, regardless of state,
 * {attached,detached,expired}.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_tdata_tree_t</name></type>	<name>tdatas</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>tdatas_mtx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type>		<name>next_thr_uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>next_thr_uid_mtx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>prof_dump_seq_mtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type>		<name>prof_dump_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type>		<name>prof_dump_iseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type>		<name>prof_dump_mseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type>		<name>prof_dump_useq</name></decl>;</decl_stmt>

<comment type="block">/*
 * This buffer is rather large for stack allocation, so use a single buffer for
 * all profile dumps.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type>	<name>prof_dump_mtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>		<name><name>prof_dump_buf</name><index>[
    <comment type="block">/* Minimize memory bloat for non-prof builds. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF</name></cpp:ifdef>
    <expr><name>PROF_DUMP_BUFSIZE</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <literal type="number">1</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type>		<name>prof_dump_buf_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>prof_dump_fd</name></decl>;</decl_stmt>

<comment type="block">/* Do not dump any profiles until bootstrapping is complete. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>prof_booted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/*
 * Function prototypes for static functions that are referenced prior to
 * definition.
 */</comment>

<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>prof_tctx_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>prof_tctx_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>prof_tdata_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>prof_tdata_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name>	<modifier>*</modifier></type><name>prof_thread_name_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Hashtable functions for log_bt_node_set and log_thr_node_set. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prof_thr_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_thr_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prof_bt_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_bt_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Red-black trees. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_tctx_comp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_thr_uid</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_thr_uid</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>(</operator><name>a_thr_uid</name> <operator>&gt;</operator> <name>b_thr_uid</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_thr_uid</name> <operator>&lt;</operator> <name>b_thr_uid</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_thr_discrim</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_thr_discrim</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>a_thr_discrim</name> <operator>&gt;</operator> <name>b_thr_discrim</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_thr_discrim</name> <operator>&lt;</operator>
		    <name>b_thr_discrim</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_tctx_uid</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>tctx_uid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_tctx_uid</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>tctx_uid</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>a_tctx_uid</name> <operator>&gt;</operator> <name>b_tctx_uid</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_tctx_uid</name> <operator>&lt;</operator>
			    <name>b_tctx_uid</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>rb_gen</name><argument_list>(<argument>static UNUSED</argument>, <argument>tctx_tree_</argument>, <argument>prof_tctx_tree_t</argument>, <argument>prof_tctx_t</argument>,
    <argument>tctx_link</argument>, <argument>prof_tctx_comp</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_gctx_comp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>a_len</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>b_len</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>comp_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>a_len</name> <operator>&lt;</operator> <name>b_len</name><operator>)</operator></expr> ?</condition><then> <expr><name>a_len</name></expr> </then><else>: <expr><name>b_len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name></expr></argument>, <argument><expr><name>comp_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>a_len</name> <operator>&gt;</operator> <name>b_len</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_len</name> <operator>&lt;</operator> <name>b_len</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>rb_gen</name><argument_list>(<argument>static UNUSED</argument>, <argument>gctx_tree_</argument>, <argument>prof_gctx_tree_t</argument>, <argument>prof_gctx_t</argument>, <argument>dump_link</argument>,
    <argument>prof_gctx_comp</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_tdata_comp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_uid</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_uid</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>a_uid</name> <operator>&gt;</operator> <name>b_uid</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_uid</name> <operator>&lt;</operator> <name>b_uid</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_discrim</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_discrim</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>a_discrim</name> <operator>&gt;</operator> <name>b_discrim</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_discrim</name> <operator>&lt;</operator> <name>b_discrim</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>rb_gen</name><argument_list>(<argument>static UNUSED</argument>, <argument>tdata_tree_</argument>, <argument>prof_tdata_tree_t</argument>, <argument>prof_tdata_t</argument>, <argument>tdata_link</argument>,
    <argument>prof_tdata_comp</argument>)</argument_list></macro>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><name>void</name></type>
<name>prof_alloc_rollback</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>updated</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Compute a new sample threshold.  This isn't very important in
		 * practice, because this function is rarely executed, so the
		 * potential for sample bias is minimal except in contrived
		 * programs.
		 */</comment>
		<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_sample_threshold_update</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>prof_tctx_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_tctx_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_malloc_sample_object</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
    <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>prof_tctx_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the current time and set this in the extent_t. We'll read this
	 * when free() is called. */</comment>
	<decl_stmt><decl><type><name>nstime_t</name></type> <name>t</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_alloc_time_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumobjs</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>prof_log_bt_index</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>prof_bt_node_t</name></type> <name>dummy_node</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dummy_node</name><operator>.</operator><name>bt</name></name> <operator>=</operator> <operator>*</operator><name>bt</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<comment type="block">/* See if this backtrace is already cached in the table. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dummy_node</name><operator>)</operator></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>node</name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>prof_bt_node_t</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator>
			        <operator>(</operator><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator>
		    <call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>log_bt_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>log_bt_first</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>log_bt_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>log_bt_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>log_bt_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>log_bt_index</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * Copy the backtrace: bt is inside a tdata or gctx, which
		 * might die before prof_log_stop is called.
		 */</comment>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name> <operator>=</operator> <name><name>new_node</name><operator>-&gt;</operator><name>vec</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>log_bt_index</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>new_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>prof_log_thr_index</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>prof_thr_node_t</name></type> <name>dummy_node</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dummy_node</name><operator>.</operator><name>thr_uid</name></name> <operator>=</operator> <name>thr_uid</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<comment type="block">/* See if this thread is already cached in the table. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dummy_node</name><operator>)</operator></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>node</name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>prof_thr_node_t</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator>
		    <call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>log_thr_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>log_thr_first</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>log_thr_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>log_thr_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>log_thr_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>log_thr_index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>=</operator> <name>thr_uid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>log_thr_index</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>new_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_try_log</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>cons_tdata</name> <init>= <expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cons_tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * We decide not to log these allocations. cons_tdata will be
		 * NULL only when the current thread is in a weird state (e.g.
		 * it's being destroyed).
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>!=</operator> <name>prof_logging_state_started</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_tables_initialized</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>err1</name> <init>= <expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
				<argument><expr><name>prof_bt_node_hash</name></expr></argument>, <argument><expr><name>prof_bt_node_keycomp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>err2</name> <init>= <expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
				<argument><expr><name>prof_thr_node_hash</name></expr></argument>, <argument><expr><name>prof_thr_node_keycomp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>err1</name> <operator>||</operator> <name>err2</name></expr>)</condition> <block>{<block_content>
			<goto>goto <name>label_done</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>log_tables_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>nstime_t</name></type> <name>alloc_time</name> <init>= <expr><call><name>prof_alloc_time_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
			          <argument><expr><operator>(</operator><name>alloc_ctx_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>nstime_t</name></type> <name>free_time</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_alloc_node_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>prof_alloc_node_t</name> <operator>*</operator><operator>)</operator>
	    <call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	    <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prod_thr_name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
				        <expr><literal type="string">""</literal></expr> </then><else>: <expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cons_thr_name</name> <init>= <expr><call><name>prof_thread_name_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>prof_bt_t</name></type> <name>bt</name></decl>;</decl_stmt>
	<comment type="block">/* Initialize the backtrace, using the buffer in tdata to store it. */</comment>
	<expr_stmt><expr><call><name>bt_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt</name></expr></argument>, <argument><expr><name><name>cons_tdata</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_backtrace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>cons_bt</name> <init>= <expr><operator>&amp;</operator><name>bt</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We haven't destroyed tctx yet, so gctx should be good to read. */</comment>
	<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>prod_bt</name> <init>= <expr><operator>&amp;</operator><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>alloc_thr_ind</name></name> <operator>=</operator> <call><name>prof_log_thr_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>,
				      <argument><expr><name>prod_thr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>free_thr_ind</name></name> <operator>=</operator> <call><name>prof_log_thr_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name><name>cons_tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>,
				     <argument><expr><name>cons_thr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>alloc_bt_ind</name></name> <operator>=</operator> <call><name>prof_log_bt_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>prod_bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>free_bt_ind</name></name> <operator>=</operator> <call><name>prof_log_bt_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>cons_bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>alloc_time_ns</name></name> <operator>=</operator> <call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alloc_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>free_time_ns</name></name> <operator>=</operator> <call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>usize</name></name> <operator>=</operator> <name>usize</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_alloc_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>log_alloc_first</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_alloc_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>log_alloc_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_alloc_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<label><name>label_done</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_free_sampled_object</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
    <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>&gt;=</operator> <name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>-=</operator> <name>usize</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>prof_try_log</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_tctx_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_tctx_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>bt_init</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name> <operator>=</operator> <name>vec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_enter</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tdata</name> <operator>==</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_leave</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tdata</name> <operator>==</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>idump</name></decl>, <decl><type ref="prev"/><name>gdump</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>idump</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>gdump</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>idump</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_idump</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>gdump</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_gdump</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF_LIBUNWIND</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nframes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nframes</name> <operator>=</operator> <call><name>unw_backtrace</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name>PROF_BT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nframes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>nframes</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_LIBGCC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>_Unwind_Reason_Code</name></type>
<name>prof_unwind_init_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>_Unwind_Context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>_URC_NO_REASON</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>_Unwind_Reason_Code</name></type>
<name>prof_unwind_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>_Unwind_Context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_unwind_data_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>prof_unwind_data_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>_Unwind_GetIP</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>_URC_END_OF_STACK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>vec</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>_URC_END_OF_STACK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>_URC_NO_REASON</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_unwind_data_t</name></type> <name>data</name> <init>= <expr><block>{<expr><name>bt</name></expr>, <expr><name>PROF_BT_MAX</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_Unwind_Backtrace</name><argument_list>(<argument><expr><name>prof_unwind_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_GCC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_FRAME</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>							\
	<cpp:value>if ((i) &lt; PROF_BT_MAX) {					\
		void *p;						\
		if (__builtin_frame_address(i) == 0) {			\
			return;						\
		}							\
		p = __builtin_return_address(i);			\
		if (p == NULL) {					\
			return;						\
		}							\
		bt-&gt;vec[(i)] = p;					\
		bt-&gt;len = (i) + 1;					\
	} else {							\
		return;							\
	}</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">5</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">6</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">7</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">9</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">10</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">11</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">12</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">13</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">14</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">15</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">16</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">17</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">18</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">19</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">20</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">21</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">22</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">23</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">24</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">25</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">26</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">27</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">28</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">29</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">30</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">31</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">32</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">33</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">34</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">35</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">36</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">37</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">38</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">39</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">40</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">41</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">42</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">43</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">44</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">45</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">46</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">47</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">48</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">49</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">50</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">51</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">52</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">53</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">54</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">55</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">56</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">57</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">58</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">59</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">60</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">61</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">62</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">63</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">64</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">65</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">66</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">67</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">68</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">69</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">70</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">71</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">72</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">73</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">74</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">75</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">76</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">77</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">78</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">79</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">80</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">81</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">82</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">83</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">84</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">85</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">86</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">87</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">88</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">89</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">90</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">91</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">92</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">93</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">94</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">95</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">96</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">97</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">98</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">99</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">100</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">101</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">102</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">103</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">104</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">105</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">106</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">107</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">108</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">109</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">110</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">111</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">112</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">113</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">114</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">115</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">116</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">117</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">118</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">119</literal></argument>)</argument_list></macro>

	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">120</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">121</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">122</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">123</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">124</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">125</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">126</literal></argument>)</argument_list></macro>
	<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">127</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_FRAME</name></cpp:undef>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>malloc_mutex_t</name> <modifier>*</modifier></type>
<name>prof_gctx_mutex_choose</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>ngctxs</name> <init>= <expr><call><name>atomic_fetch_add_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cum_gctxs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><operator>(</operator><name>ngctxs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>PROF_NCTX_LOCKS</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>malloc_mutex_t</name> <modifier>*</modifier></type>
<name>prof_tdata_mutex_choose</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>thr_uid</name> <operator>%</operator> <name>PROF_NTDATA_LOCKS</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type>
<name>prof_gctx_create</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * Create a single allocation that has space for vec of length bt-&gt;len.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>prof_gctx_t</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name> <init>= <expr><operator>(</operator><name>prof_gctx_t</name> <operator>*</operator><operator>)</operator><call><name>iallocztm</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
	    <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
	    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>gctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <call><name>prof_gctx_mutex_choose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Set nlimbo to 1, in order to avoid a race condition with
	 * prof_tctx_destroy()/prof_gctx_try_destroy().
	 */</comment>
	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tctx_tree_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Duplicate bt. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name> <operator>=</operator> <name><name>gctx</name><operator>-&gt;</operator><name>vec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
	<return>return <expr><name>gctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_gctx_try_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata_self</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>,
    <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that gctx is still unused by any thread cache before destroying
	 * it.  prof_lookup() increments gctx-&gt;nlimbo in order to avoid a race
	 * condition with this function, as does prof_tctx_destroy() in order to
	 * avoid a race between the main body of prof_tctx_destroy() and entry
	 * into this function.
	 */</comment>
	<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tctx_tree_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Remove gctx from bt2gctx. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ckh_remove</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Destroy gctx. */</comment>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * Compensate for increment in prof_tctx_destroy() or
		 * prof_lookup().
		 */</comment>
		<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tctx_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>prepared</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_gctx_should_destroy</name><parameter_list>(<parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tctx_tree_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tctx_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name> <init>= <expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>destroy_tdata</name></decl>, <decl><type ref="prev"/><name>destroy_tctx</name></decl>, <decl><type ref="prev"/><name>destroy_gctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>opt_prof_accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ckh_remove</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <call><name>prof_tdata_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
		<expr_stmt><expr><call><name>tctx_tree_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>destroy_tctx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>prof_gctx_should_destroy</name><argument_list>(<argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Increment gctx-&gt;nlimbo in order to keep another
			 * thread from winning the race to destroy gctx while
			 * this one has gctx-&gt;lock dropped.  Without this, it
			 * would be possible for another thread to:
			 *
			 * 1) Sample an allocation associated with gctx.
			 * 2) Deallocate the sampled object.
			 * 3) Successfully prof_gctx_try_destroy(gctx).
			 *
			 * The result would be that gctx no longer exists by the
			 * time this thread accesses it in
			 * prof_gctx_try_destroy().
			 */</comment>
			<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
		<comment type="block">/*
		 * A dumping thread needs tctx to remain valid until dumping
		 * has finished.  Change state such that the dumping thread will
		 * complete destruction during a late dump iteration phase.
		 */</comment>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_purgatory</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>destroy_tctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>destroy_tctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>destroy_gctx</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gctx</name></expr></argument>,
		    <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_assert_not_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>destroy_tdata</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_tdata_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>destroy_tctx</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_lookup_global</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_btkey</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_gctx</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>p_new_gctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<union>union <block>{
		<decl_stmt><decl><type><name>prof_gctx_t</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>		<modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	}</block> <decl><name>gctx</name></decl>, <decl><type ref="prev"/><name>tgctx</name></decl>;</union>
	<union>union <block>{
		<decl_stmt><decl><type><name>prof_bt_t</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>		<modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	}</block> <decl><name>btkey</name></decl>;</union>
	<decl_stmt><decl><type><name>bool</name></type> <name>new_gctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btkey</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* bt has never been seen before.  Insert it. */</comment>
		<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tgctx</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>prof_gctx_create</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tgctx</name><operator>.</operator><name>v</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btkey</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>gctx</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name><name>tgctx</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>btkey</name><operator>.</operator><name>p</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>bt</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name><name>btkey</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="block">/* OOM. */</comment>
				<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>tgctx</name><operator>.</operator><name>v</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_gctx</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Increment nlimbo, in order to avoid a race condition with
		 * prof_tctx_destroy()/prof_gctx_try_destroy().
		 */</comment>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tgctx</name><operator>.</operator><name>v</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Lost race to insert. */</comment>
			<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tgctx</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>p_btkey</name> <operator>=</operator> <name><name>btkey</name><operator>.</operator><name>v</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_gctx</name> <operator>=</operator> <name><name>gctx</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_new_gctx</name> <operator>=</operator> <name>new_gctx</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_lookup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<union>union <block>{
		<decl_stmt><decl><type><name>prof_tctx_t</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>		<modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	}</block> <decl><name>ret</name></decl>;</union>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>not_found</name> <operator>=</operator> <call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>not_found</name></expr>)</condition> <block>{<block_content> <comment type="block">/* Note double negative! */</comment>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>btkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>new_gctx</name></decl>, <decl><type ref="prev"/><name>error</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This thread's cache lacks bt.  Look for it in the global
		 * cache.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>prof_lookup_global</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctx</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>new_gctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Link a prof_tctx_t into gctx for this thread. */</comment>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>v</name></name> <operator>=</operator> <call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		    <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
		    <argument><expr><call><name>arena_ichoose</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>new_gctx</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>tdata</name></name> <operator>=</operator> <name>tdata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>thr_discrim</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>cnts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>gctx</name></name> <operator>=</operator> <name>gctx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>tctx_uid</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tctx_uid_next</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_initializing</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><name>btkey</name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>new_gctx</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_nominal</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tctx_tree_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>ret</name><operator>.</operator><name>p</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The bodies of this function and prof_leakcheck() are compiled out unless heap
 * profiling is enabled, so that it is possible to compile jemalloc with
 * floating point support completely disabled.  Avoiding floating point code is
 * important on memory-constrained systems, but it also enables a workaround for
 * versions of glibc that don't properly save/restore floating point registers
 * during dynamic lazy symbol loading (which internally calls into whatever
 * malloc implementation happens to be integrated into the application).  Note
 * that some compilers (e.g.  gcc 4.8) may use floating point registers for fast
 * memory moves, so jemalloc must be compiled with such optimizations disabled
 * (e.g.
 * -mno-sse) in order for the workaround to be complete.
 */</comment>
<function><type><name>void</name></type>
<name>prof_sample_threshold_update</name><parameter_list>(<parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lg_prof_sample</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_bytes_until_sample_set</name><argument_list>(<argument><expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute sample interval as a geometrically distributed random
	 * variable with mean (2^lg_prof_sample).
	 *
	 *                             __        __
	 *                             |  log(u)  |                     1
	 * tdata-&gt;bytes_until_sample = | -------- |, where p = ---------------
	 *                             | log(1-p) |             lg_prof_sample
	 *                                                     2
	 *
	 * For more information on the math, see:
	 *
	 *   Non-Uniform Random Variate Generation
	 *   Luc Devroye
	 *   Springer-Verlag, New York, 1986
	 *   pp 500
	 *   (http://luc.devroye.org/rnbookindex.html)
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>r</name> <init>= <expr><call><name>prng_lg_range_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>prng_state</name></name></expr></argument>, <argument><expr><literal type="number">53</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>r</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal><operator>/</operator><literal type="number">9007199254740992.0L</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>bytes_until_sample</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><call><name>log</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>/</operator>
	    <call><name>log</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>lg_prof_sample</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator>
	    <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>bytes_until_sample</name> <operator>&gt;</operator> <name>SSIZE_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>bytes_until_sample</name> <operator>=</operator> <name>SSIZE_MAX</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>tsd_bytes_until_sample_set</name><argument_list>(<argument><expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>bytes_until_sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_count_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>tdata_count</name> <init>= <expr><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>tdata_count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_tdata_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>tdata_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tdata_count_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tdata_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tdata_count</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_bt_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bt_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bt_count</name> <operator>=</operator> <call><name>ckh_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bt_count</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_dump_open_impl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>creat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>propagate_err</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: creat(\"%s\"), 0644) failed\n"</literal></expr></argument>,
		    <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><name>prof_dump_open_t</name> <modifier>*</modifier><name>JET_MUTABLE</name></type> <name>prof_dump_open</name> <init>= <expr><name>prof_dump_open_impl</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_flush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>err</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>malloc_write_fd</name><argument_list>(<argument><expr><name>prof_dump_fd</name></expr></argument>, <argument><expr><name>prof_dump_buf</name></expr></argument>, <argument><expr><name>prof_dump_buf_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>propagate_err</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: write() failed during heap "</literal>
			    <literal type="string">"profile flush\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>prof_dump_buf_end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_close</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prof_dump_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>prof_dump_flush</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>prof_dump_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_dump_fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_write</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>slen</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Flush the buffer if it is full. */</comment>
		<if_stmt><if>if <condition>(<expr><name>prof_dump_buf_end</name> <operator>==</operator> <name>PROF_DUMP_BUFSIZE</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>prof_dump_flush</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>propagate_err</name></expr>)</condition> <block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prof_dump_buf_end</name> <operator>+</operator> <name>slen</name> <operator>-</operator> <name>i</name> <operator>&lt;=</operator> <name>PROF_DUMP_BUFSIZE</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Finish writing. */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <name>slen</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* Write as much of s as will fit. */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <name>PROF_DUMP_BUFSIZE</name> <operator>-</operator> <name>prof_dump_buf_end</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_dump_buf</name><index>[<expr><name>prof_dump_buf_end</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prof_dump_buf_end</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">2</literal></argument>, <argument><literal type="number">3</literal></argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_printf</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PROF_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>prof_dump_write</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tctx_merge_tdata</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>prof_tctx_state_initializing</name></expr>:</case>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_dumping</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>+=</operator>
			    <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator>
			    <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
	<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tctx_merge_gctx</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_tctx_merge_iter</name><parameter_list>(<parameter><decl><type><name>prof_tctx_tree_t</name> <modifier>*</modifier></type><name>tctxs</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
		<comment type="block">/* New since dumping started; ignore. */</comment>
		<break>break;</break>
	<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
	<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
		<expr_stmt><expr><call><name>prof_tctx_merge_gctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>prof_tctx_dump_iter_arg_s</name> <block>{
	<decl_stmt><decl><type><name>tsdn_t</name>	<modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>propagate_err</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_tctx_dump_iter</name><parameter_list>(<parameter><decl><type><name>prof_tctx_tree_t</name> <modifier>*</modifier></type><name>tctxs</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_tctx_dump_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
	    <expr><operator>(</operator>struct <name>prof_tctx_dump_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>prof_tctx_state_initializing</name></expr>:</case>
	<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
		<comment type="block">/* Not captured by this dump. */</comment>
		<break>break;</break>
	<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
	<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>propagate_err</name></name></expr></argument>,
		    <argument><expr><literal type="string">"  t%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": "</literal>
		    <literal type="string">"%"</literal><name>FMTu64</name><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curobjs</name></name></expr></argument>,
		    <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curbytes</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumobjs</name></name></expr></argument>,
		    <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>tctx</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_tctx_finish_iter</name><parameter_list>(<parameter><decl><type><name>prof_tctx_tree_t</name> <modifier>*</modifier></type><name>tctxs</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
		<comment type="block">/* New since dumping started; ignore. */</comment>
		<break>break;</break>
	<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_nominal</name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>tctx</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	<default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_dump_gctx_prep</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Increment nlimbo so that gctx won't go away before dump.
	 * Additionally, link gctx into the dump list so that it is included in
	 * prof_dump()'s second pass.
	 */</comment>
	<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gctx_tree_insert</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>prof_gctx_merge_iter_arg_s</name> <block>{
	<decl_stmt><decl><type><name>tsdn_t</name>	<modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>leak_ngctx</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type>
<name>prof_gctx_merge_iter</name><parameter_list>(<parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
	    <expr><operator>(</operator>struct <name>prof_gctx_merge_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tctx_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tctx_merge_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>leak_ngctx</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_gctx_finish</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Standard tree iteration won't work here, because as soon as we
	 * decrement gctx-&gt;nlimbo and unlock gctx, another thread can
	 * concurrently destroy it, which will corrupt the tree.  Therefore,
	 * tear down the tree one node at a time during iteration.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>gctx</name> <operator>=</operator> <call><name>gctx_tree_first</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>gctx_tree_remove</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<do>do <block>{<block_content>
				<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>to_destroy</name> <init>=
				    <expr><call><name>tctx_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
				    <argument><expr><name>prof_tctx_finish_iter</name></expr></argument>,
				    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>to_destroy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>tctx_tree_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>,
					    <argument><expr><name>to_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tctx_tree_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>,
					    <argument><expr><name>to_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>to_destroy</name></expr></argument>,
					    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if> <else>else <block>{<block_content>
					<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block> while <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
		</block_content>}</block>
		<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>prof_gctx_should_destroy</name><argument_list>(<argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<struct>struct <name>prof_tdata_merge_iter_arg_s</name> <block>{
	<decl_stmt><decl><type><name>tsdn_t</name>		<modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_cnt_t</name></type>	<name>cnt_all</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_merge_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
	    <expr><operator>(</operator>struct <name>prof_tdata_merge_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>tabind</name></decl>;</decl_stmt>
		<union>union <block>{
			<decl_stmt><decl><type><name>prof_tctx_t</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name>		<modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		}</block> <decl><name>tctx</name></decl>;</union>

		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>tabind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><call><name>ckh_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>tctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_tctx_merge_tdata</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>curobjs</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>accumobjs</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_dump_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>propagate_err</name> <init>= <expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>,
	    <argument><expr><literal type="string">"  t%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">"]%s%s\n"</literal></expr></argument>,
	    <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name></expr></argument>,
	    <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name></expr></argument>,
	    <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name></expr></argument>,
	    <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
	    <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>tdata</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_header_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>prof_cnt_t</name> <modifier>*</modifier></type><name>cnt_all</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>,
	    <argument><expr><literal type="string">"heap_v2/%"</literal><name>FMTu64</name><literal type="string">"\n"</literal>
	    <literal type="string">"  t*: %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">"]\n"</literal></expr></argument>,
	    <argument><expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>lg_prof_sample</name><operator>)</operator></expr></argument>, <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>curobjs</name></name></expr></argument>,
	    <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name></expr></argument>, <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>accumobjs</name></name></expr></argument>, <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>accumbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tdata_dump_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>propagate_err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><name>prof_dump_header_t</name> <modifier>*</modifier><name>JET_MUTABLE</name></type> <name>prof_dump_header</name> <init>= <expr><name>prof_dump_header_impl</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_gctx</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_tctx_dump_iter_arg_s</name></name></type> <name>prof_tctx_dump_iter_arg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid dumping such gctx's that have no useful data. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>opt_prof_accum</name> <operator>&amp;&amp;</operator> <name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name>opt_prof_accum</name> <operator>&amp;&amp;</operator> <name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><literal type="string">"@"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><literal type="string">" %#"</literal><name>FMTxPTR</name></expr></argument>,
		    <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>bt</name><operator>-&gt;</operator><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>,
	    <argument><expr><literal type="string">"\n"</literal>
	    <literal type="string">"  t*: %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">"]\n"</literal></expr></argument>,
	    <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name></expr></argument>,
	    <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>prof_tctx_dump_iter_arg</name><operator>.</operator><name>tsdn</name></name> <operator>=</operator> <name>tsdn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prof_tctx_dump_iter_arg</name><operator>.</operator><name>propagate_err</name></name> <operator>=</operator> <name>propagate_err</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tctx_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tctx_dump_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>prof_tctx_dump_iter_arg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_open_maps</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>mfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_vsnprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>mfd</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_getpid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<return>return <expr><call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_maps</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mfd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FreeBSD__</name></cpp:ifdef>
	<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>prof_open_maps</name><argument_list>(<argument><expr><literal type="string">"/proc/curproc/map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>mfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// Not implemented</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>prof_open_maps</name><argument_list>(<argument><expr><literal type="string">"/proc/%d/task/%d/maps"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>prof_open_maps</name><argument_list>(<argument><expr><literal type="string">"/proc/%d/maps"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>prof_dump_write</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><literal type="string">"\nMAPPED_LIBRARIES:\n"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		    <name>propagate_err</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>label_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nread</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<do>do <block>{<block_content>
			<expr_stmt><expr><name>prof_dump_buf_end</name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>prof_dump_buf_end</name> <operator>==</operator> <name>PROF_DUMP_BUFSIZE</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* Make space in prof_dump_buf before read(). */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>prof_dump_flush</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				    <name>propagate_err</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>label_return</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>malloc_read_fd</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name><name>prof_dump_buf</name><index>[<expr><name>prof_dump_buf_end</name></expr>]</index></name></expr></argument>, <argument><expr><name>PROF_DUMP_BUFSIZE</name>
			    <operator>-</operator> <name>prof_dump_buf_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * See prof_sample_threshold_update() comment for why the body of this function
 * is conditionally compiled.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_leakcheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_cnt_t</name> <modifier>*</modifier></type><name>cnt_all</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>leak_ngctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF</name></cpp:ifdef>
	<comment type="block">/*
	 * Scaling is equivalent AdjustSamples() in jeprof, but the result may
	 * differ slightly from what jeprof reports, because here we scale the
	 * summary values, whereas jeprof scales each context individually and
	 * reports the sums of the scaled values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>sample_period</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>lg_prof_sample</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>ratio</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name><operator>)</operator> <operator>/</operator>
		    <operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curobjs</name></name><operator>)</operator> <operator>/</operator> <name>sample_period</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>scale_factor</name> <init>= <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <call><name>exp</name><argument_list>(<argument><expr><operator>-</operator><name>ratio</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>curbytes</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>round</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name><operator>)</operator>
		    <operator>*</operator> <name>scale_factor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>curobjs</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>round</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curobjs</name></name><operator>)</operator> <operator>*</operator>
		    <name>scale_factor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Leak approximation summary: ~%"</literal><name>FMTu64</name>
		    <literal type="string">" byte%s, ~%"</literal><name>FMTu64</name><literal type="string">" object%s, &gt;= %zu context%s\n"</literal></expr></argument>,
		    <argument><expr><name>curbytes</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>curbytes</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>curobjs</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>curobjs</name> <operator>!=</operator>
		    <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>leak_ngctx</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>leak_ngctx</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(
		    <argument><expr><literal type="string">"&lt;jemalloc&gt;: Run jeprof on \"%s\" for leak detail\n"</literal></expr></argument>,
		    <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<struct>struct <name>prof_gctx_dump_iter_arg_s</name> <block>{
	<decl_stmt><decl><type><name>tsdn_t</name>	<modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>propagate_err</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type>
<name>prof_gctx_dump_iter</name><parameter_list>(<parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_dump_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
	    <expr><operator>(</operator>struct <name>prof_gctx_dump_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_gctx</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>propagate_err</name></name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></argument>,
	    <argument><expr><name>gctxs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>gctx</name></expr>;</expr_stmt>
		<goto>goto <name>label_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_dump_prep</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_tdata_merge_iter_arg</name></decl></parameter>,
    <parameter><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_gctx_merge_iter_arg</name></decl></parameter>,
    <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>tabind</name></decl>;</decl_stmt>
	<union>union <block>{
		<decl_stmt><decl><type><name>prof_gctx_t</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>		<modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	}</block> <decl><name>gctx</name></decl>;</union>

	<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put gctx's in limbo and clear their counters in preparation for
	 * summing.
	 */</comment>
	<expr_stmt><expr><call><name>gctx_tree_new</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>tabind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><call><name>ckh_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_dump_gctx_prep</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Iterate over tdatas, and for the non-expired ones snapshot their tctx
	 * stats and merge them into the associated gctx's.
	 */</comment>
	<expr_stmt><expr><name><name>prof_tdata_merge_iter_arg</name><operator>-&gt;</operator><name>tsdn</name></name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_tdata_merge_iter_arg</name><operator>-&gt;</operator><name>cnt_all</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tdata_merge_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Merge tctx stats into gctx's. */</comment>
	<expr_stmt><expr><name><name>prof_gctx_merge_iter_arg</name><operator>-&gt;</operator><name>tsdn</name></name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prof_gctx_merge_iter_arg</name><operator>-&gt;</operator><name>leak_ngctx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gctx_tree_iter</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_gctx_merge_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_file</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>leakcheck</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_tdata_merge_iter_arg</name></decl></parameter>,
    <parameter><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_gctx_merge_iter_arg</name></decl></parameter>,
    <parameter><decl><type><name><name>struct</name> <name>prof_gctx_dump_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_gctx_dump_iter_arg</name></decl></parameter>,
    <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Create dump file. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prof_dump_fd</name> <operator>=</operator> <call><name>prof_dump_open</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump profile header. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_header</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>propagate_err</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name><name>prof_tdata_merge_iter_arg</name><operator>-&gt;</operator><name>cnt_all</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_write_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump per gctx profile stats. */</comment>
	<expr_stmt><expr><name><name>prof_gctx_dump_iter_arg</name><operator>-&gt;</operator><name>tsdn</name></name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prof_gctx_dump_iter_arg</name><operator>-&gt;</operator><name>propagate_err</name></name> <operator>=</operator> <name>propagate_err</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>gctx_tree_iter</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_gctx_dump_iter</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prof_gctx_dump_iter_arg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_write_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump /proc/&lt;pid&gt;/maps if possible. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_maps</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<goto>goto <name>label_write_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>prof_dump_close</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
<label><name>label_write_error</name>:</label>
	<expr_stmt><expr><call><name>prof_dump_close</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>leakcheck</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type> <name>tdata</name> <init>= <expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>prof_gctx_tree_t</name></type> <name>gctxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name></type> <name>prof_tdata_merge_iter_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name></type> <name>prof_gctx_merge_iter_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_dump_iter_arg_s</name></name></type> <name>prof_gctx_dump_iter_arg</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>prof_dump_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>prof_dump_file</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>leakcheck</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>prof_gctx_dump_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>prof_gctx_finish</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>leakcheck</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_leakcheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name></name></expr></argument>,
		    <argument><expr><name><name>prof_gctx_merge_iter_arg</name><operator>.</operator><name>leak_ngctx</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>prof_cnt_all</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>curobjs</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>curbytes</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>accumobjs</name></decl></parameter>,
    <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>accumbytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name></type> <name>prof_tdata_merge_iter_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name></type> <name>prof_gctx_merge_iter_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_gctx_tree_t</name></type> <name>gctxs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>curobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>curobjs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>curbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>curbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>accumobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>accumobjs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>accumbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>accumbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>prof_dump_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_gctx_finish</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>curobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>curobjs</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>curbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>curbytes</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>accumobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>accumobjs</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>accumbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>accumbytes</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_FILENAME_BUFSIZE</name></cpp:macro>	<cpp:value>(PATH_MAX + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSEQ_INVALID</name></cpp:macro>		<cpp:value>UINT64_C(0xffffffffffffffff)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_dump_filename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>vseq</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>vseq</name> <operator>!=</operator> <name>VSEQ_INVALID</name></expr>)</condition> <block>{<block_content>
	        <comment type="block">/* "&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.v&lt;vseq&gt;.heap" */</comment>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>DUMP_FILENAME_BUFSIZE</name></expr></argument>,
		    <argument><expr><literal type="string">"%s.%d.%"</literal><name>FMTu64</name><literal type="string">".%c%"</literal><name>FMTu64</name><literal type="string">".heap"</literal></expr></argument>,
		    <argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prof_dump_seq</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	        <comment type="block">/* "&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.&lt;v&gt;.heap" */</comment>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>DUMP_FILENAME_BUFSIZE</name></expr></argument>,
		    <argument><expr><literal type="string">"%s.%d.%"</literal><name>FMTu64</name><literal type="string">".%c.heap"</literal></expr></argument>,
		    <argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prof_dump_seq</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>prof_dump_seq</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_fdump</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>DUMP_FILENAME_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opt_prof_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>VSEQ_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>opt_prof_leak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_accum_init</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_accum_t</name> <modifier>*</modifier></type><name>prof_accum</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JEMALLOC_ATOMIC_U64</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_accum</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>, <argument><expr><literal type="string">"prof_accum"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_PROF_ACCUM</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>prof_accum</name><operator>-&gt;</operator><name>accumbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>atomic_store_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_accum</name><operator>-&gt;</operator><name>accumbytes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_idump</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_booted</name> <operator>||</operator> <call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><name>prof_dump_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prof_dump_iseq</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_mdump</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_prof</name> <operator>||</operator> <operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>filename_buf</name><index>[<expr><name>DUMP_FILENAME_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* No filename specified, so automatically generate one. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename_buf</name></expr></argument>, <argument><expr><literal type="char">'m'</literal></expr></argument>, <argument><expr><name>prof_dump_mseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prof_dump_mseq</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>filename_buf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_gdump</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_booted</name> <operator>||</operator> <call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>DUMP_FILENAME_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'u'</literal></expr></argument>, <argument><expr><name>prof_dump_useq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prof_dump_useq</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_bt_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name> <init>= <expr><operator>(</operator><name>prof_bt_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0x94122f33U</literal></expr></argument>, <argument><expr><name>r_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_bt_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_t</name> <modifier>*</modifier></type><name>bt1</name> <init>= <expr><operator>(</operator><name>prof_bt_t</name> <operator>*</operator><operator>)</operator><name>k1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_t</name> <modifier>*</modifier></type><name>bt2</name> <init>= <expr><operator>(</operator><name>prof_bt_t</name> <operator>*</operator><operator>)</operator><name>k2</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bt1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>bt2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>bt1</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt2</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt1</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_bt_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>prof_bt_hash</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>bt_node</name><operator>-&gt;</operator><name>bt</name></name><operator>)</operator></expr></argument>, <argument><expr><name>r_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_bt_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node1</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator><name>k1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node2</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator><name>k2</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>prof_bt_keycomp</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>bt_node1</name><operator>-&gt;</operator><name>bt</name></name><operator>)</operator></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>bt_node2</name><operator>-&gt;</operator><name>bt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_thr_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thr_node</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0x94122f35U</literal></expr></argument>, <argument><expr><name>r_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_thr_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node1</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator><name>k1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node2</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator><name>k2</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>thr_node1</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>==</operator> <name><name>thr_node2</name><operator>-&gt;</operator><name>thr_uid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>prof_thr_uid_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>thr_uid</name> <operator>=</operator> <name>next_thr_uid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_thr_uid</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>thr_uid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_init_impl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>thr_discrim</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize an empty cache for this thread. */</comment>
	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>(</operator><name>prof_tdata_t</name> <operator>*</operator><operator>)</operator><call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tdata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
	    <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tdata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	    <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <call><name>prof_tdata_mutex_choose</name><argument_list>(<argument><expr><name>thr_uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>=</operator> <name>thr_uid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_discrim</name></name> <operator>=</operator> <name>thr_discrim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>=</operator> <name>thread_name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>tctx_uid_next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>, <argument><expr><name>prof_bt_hash</name></expr></argument>,
	    <argument><expr><name>prof_bt_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>prng_state</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_sample_threshold_update</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tdata_tree_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tdata</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_init</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>prof_tdata_init_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>prof_thr_uid_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
	    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>prof_thread_active_init_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tdata_should_destroy_unlocked</name><parameter_list>(<parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>even_if_attached</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ckh_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tdata_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>prof_tdata_should_destroy_unlocked</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>even_if_attached</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tdata_destroy_locked</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tdata_tree_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>prof_tdata_should_destroy_unlocked</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>even_if_attached</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ckh_delete</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tdata_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_tdata_destroy_locked</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>even_if_attached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tdata_detach</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>destroy_tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <call><name>prof_tdata_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Only detach if !destroy_tdata, because detaching would allow
		 * another thread to win the race to destroy tdata.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroy_tdata</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>tsd_prof_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>destroy_tdata</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_tdata_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_reinit</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_uid</name> <init>= <expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_discrim</name> <init>= <expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_discrim</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>thread_name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
	    <expr><call><name>prof_thread_name_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>active</name> <init>= <expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prof_tdata_detach</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>prof_tdata_init_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>thr_uid</name></expr></argument>, <argument><expr><name>thr_discrim</name></expr></argument>, <argument><expr><name>thread_name</name></expr></argument>,
	    <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tdata_expire</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>destroy_tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <ternary><condition><expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>:
		    <expr><call><name>prof_tdata_should_destroy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>destroy_tdata</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_reset_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>prof_tdata_expire</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>tdata</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_reset</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lg_sample</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lg_sample</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lg_prof_sample</name> <operator>=</operator> <name>lg_sample</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<do>do <block>{<block_content>
		<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>to_destroy</name> <init>= <expr><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
		    <argument><expr><name>prof_tdata_reset_iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>to_destroy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>tdata_tree_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>to_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>prof_tdata_destroy_locked</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>to_destroy</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_tdata_cleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>tsd_prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>prof_tdata_detach</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_active_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_active_current</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_active_current</name> <operator>=</operator> <name>prof_active</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>prof_active_current</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_active_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_active_old</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_active_old</name> <operator>=</operator> <name>prof_active</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>prof_active_old</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
<function><type><name>size_t</name></type>
<name>prof_log_bt_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_bt_first</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_log_alloc_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_alloc_first</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_log_thr_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_thr_first</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_log_is_logging</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_started</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_log_rep_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_stopped</name>
	    <operator>&amp;&amp;</operator> <name>log_tables_initialized</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_bt_last</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>log_bt_last</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>log_thr_last</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>log_thr_last</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>log_alloc_last</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>log_alloc_last</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>bt_count</name> <init>= <expr><call><name>prof_log_bt_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>thr_count</name> <init>= <expr><call><name>prof_log_thr_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_count</name> <init>= <expr><call><name>prof_log_alloc_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_stopped</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>bt_count</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>thr_count</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>alloc_count</name> <operator>||</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_alloc_first</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>alloc_bt_ind</name></name> <operator>&gt;=</operator> <name>bt_count</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>free_bt_ind</name></name> <operator>&gt;=</operator> <name>bt_count</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>alloc_thr_ind</name></name> <operator>&gt;=</operator> <name>thr_count</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>free_thr_ind</name></name> <operator>&gt;=</operator> <name>thr_count</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>alloc_time_ns</name></name> <operator>&gt;</operator> <name><name>node</name><operator>-&gt;</operator><name>free_time_ns</name></name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_log_dummy_set</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>new_value</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>prof_log_dummy</name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name>prof_log_start</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_prof</name> <operator>||</operator> <operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>buf_size</name> <init>= <expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>!=</operator> <name>prof_logging_state_stopped</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Make default name. */</comment>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><literal type="string">"%s.%d.%"</literal><name>FMTu64</name><literal type="string">".json"</literal></expr></argument>,
		    <argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>log_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_seq</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_started</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>buf_size</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_started</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_start_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Used as an atexit function to stop logging on exit. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_stop_final</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>prof_log_stop</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>prof_emitter_cb_arg_s</name> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_emitter_write_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>to_write</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_emitter_cb_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
	    <expr><operator>(</operator>struct <name>prof_emitter_cb_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>to_write</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>prof_log_dummy</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>ret</name></name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>to_write</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * prof_log_emit_{...} goes through the appropriate linked list, emitting each
 * node to the json and deallocating it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_threads</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"threads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node</name> <init>= <expr><name>log_thr_first</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_old_node</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>thr_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"thr_uid"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>thr_node</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>thr_name</name> <init>= <expr><name><name>thr_node</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"thr_name"</literal></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>thr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>thr_old_node</name> <operator>=</operator> <name>thr_node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>thr_node</name> <operator>=</operator> <name><name>thr_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>idalloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>thr_old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_traces</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"stack_traces"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node</name> <init>= <expr><name>log_bt_first</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_old_node</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Calculate how many hex digits we need: twice number of bytes, two for
	 * "0x", and then one more for terminating '\0'.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>intptr_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>buf_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>bt_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bt_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_sz</name></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name><name>bt_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trace_str</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>trace_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>bt_old_node</name> <operator>=</operator> <name>bt_node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bt_node</name> <operator>=</operator> <name><name>bt_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>idalloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>bt_old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_allocs</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>alloc_node</name> <init>= <expr><name>log_alloc_first</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>alloc_old_node</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>alloc_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"alloc_thread"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>alloc_thr_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"free_thread"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>free_thr_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"alloc_trace"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>alloc_bt_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"free_trace"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>free_bt_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"alloc_timestamp"</literal></expr></argument>,
		    <argument><expr><name>emitter_type_uint64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>alloc_time_ns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"free_timestamp"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>free_time_ns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"usize"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>usize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>alloc_old_node</name> <operator>=</operator> <name>alloc_node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>alloc_node</name> <operator>=</operator> <name><name>alloc_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>idalloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>alloc_old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_metadata</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>nstime_t</name></type> <name>now</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>ns</name> <init>= <expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_start_timestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"duration"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vers</name> <init>= <expr><name>JEMALLOC_VERSION</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"lg_sample_rate"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lg_prof_sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"pid"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>prof_log_stop</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_prof</name> <operator>||</operator> <operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>!=</operator> <name>prof_logging_state_started</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set the state to dumping. We'll set it to stopped when we're done.
	 * Since other threads won't be able to start/stop/log when the state is
	 * dumping, we don't have to hold the lock during the whole method.
	 */</comment>
	<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_dumping</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>emitter_t</name></type> <name>emitter</name></decl>;</decl_stmt>

	<comment type="block">/* Create a file. */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>prof_log_dummy</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>creat</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>creat</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: creat() for log file \"%s\" "</literal>
			      <literal type="string">" failed with %d\n"</literal></expr></argument>, <argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Emit to json. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>prof_emitter_cb_arg_s</name></name></type> <name>arg</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><name>emitter_output_json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_emitter_write_cb</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>arg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_log_emit_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_log_emit_threads</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_log_emit_traces</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prof_log_emit_allocs</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset global state. */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_tables_initialized</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ckh_delete</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ckh_delete</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>log_tables_initialized</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_bt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_thr_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_bt_first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_bt_last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_thr_first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_thr_last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_alloc_first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>log_alloc_last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_stopped</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>prof_log_dummy</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>prof_thread_name_get</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>prof_thread_name_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>thread_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>thread_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>iallocztm</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	    <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>thread_name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>prof_thread_name_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>EAGAIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Validate input. */</comment>
	<if_stmt><if>if <condition>(<expr><name>thread_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>EFAULT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>thread_name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>thread_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isgraph</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isblank</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>EFAULT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>prof_thread_name_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>thread_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>EAGAIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
		    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_get</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_init_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>active_init</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>active_init</name> <operator>=</operator> <name>prof_thread_active_init</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>active_init</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_init_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active_init</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>active_init_old</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>active_init_old</name> <operator>=</operator> <name>prof_thread_active_init</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_thread_active_init</name> <operator>=</operator> <name>active_init</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>active_init_old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_gdump_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_gdump_current</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_gdump_current</name> <operator>=</operator> <name>prof_gdump_val</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>prof_gdump_current</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_gdump_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gdump</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>prof_gdump_old</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_gdump_old</name> <operator>=</operator> <name>prof_gdump_val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prof_gdump_val</name> <operator>=</operator> <name>gdump</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>prof_gdump_old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_boot0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><name>PROF_PREFIX_DEFAULT</name></expr></argument>,
	    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROF_PREFIX_DEFAULT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_boot1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * opt_prof must be in its final state before any arenas are
	 * initialized, so this function must be executed early.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>opt_prof_leak</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Enable opt_prof, but in such a way that profiles are never
		 * automatically dumped.
		 */</comment>
		<expr_stmt><expr><name>opt_prof</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opt_prof_gdump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>opt_lg_prof_interval</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>prof_interval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal><operator>)</operator> <operator>&lt;&lt;</operator>
			    <name>opt_lg_prof_interval</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_boot2</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lg_prof_sample</name> <operator>=</operator> <name>opt_lg_prof_sample</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <name>opt_prof_active</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_active"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_ACTIVE</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prof_gdump_val</name> <operator>=</operator> <name>opt_prof_gdump</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_gdump"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_GDUMP</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prof_thread_active_init</name> <operator>=</operator> <name>opt_prof_thread_active_init</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>,
		    <argument><expr><literal type="string">"prof_thread_active_init"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_THREAD_ACTIVE_INIT</name></expr></argument>,
		    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>, <argument><expr><name>prof_bt_hash</name></expr></argument>,
		    <argument><expr><name>prof_bt_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_bt2gctx"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_BT2GCTX</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>tdata_tree_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_tdatas"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_TDATAS</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>next_thr_uid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_next_thr_uid"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_NEXT_THR_UID</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_dump_seq"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_DUMP_SEQ</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_dump"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_DUMP</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>opt_prof_final</name> <operator>&amp;&amp;</operator> <name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		    <call><name>atexit</name><argument_list>(<argument><expr><name>prof_fdump</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in atexit()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>opt_prof_log</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>prof_log_start</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><name>prof_log_stop_final</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in atexit() "</literal>
				     <literal type="string">"for logging\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_log"</literal></expr></argument>,
		    <argument><expr><name>WITNESS_RANK_PROF_LOG</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
		    <argument><expr><name>prof_bt_node_hash</name></expr></argument>, <argument><expr><name>prof_bt_node_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
		    <argument><expr><name>prof_thr_node_hash</name></expr></argument>, <argument><expr><name>prof_thr_node_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>log_tables_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>gctx_locks</name> <operator>=</operator> <operator>(</operator><name>malloc_mutex_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PROF_NCTX_LOCKS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>malloc_mutex_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		    <argument><expr><name>CACHELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>gctx_locks</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prof_gctx"</literal></expr></argument>,
			    <argument><expr><name>WITNESS_RANK_PROF_GCTX</name></expr></argument>,
			    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>tdata_locks</name> <operator>=</operator> <operator>(</operator><name>malloc_mutex_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PROF_NTDATA_LOCKS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>malloc_mutex_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		    <argument><expr><name>CACHELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tdata_locks</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prof_tdata"</literal></expr></argument>,
			    <argument><expr><name>WITNESS_RANK_PROF_TDATA</name></expr></argument>,
			    <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_PROF_LIBGCC</name></cpp:ifdef>
		<comment type="block">/*
		 * Cause the backtracing machinery to allocate its internal
		 * state before enabling profiling.
		 */</comment>
		<expr_stmt><expr><call><name>_Unwind_Backtrace</name><argument_list>(<argument><expr><name>prof_unwind_init_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>prof_booted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_prefork0</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_prefork1</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
</unit>
