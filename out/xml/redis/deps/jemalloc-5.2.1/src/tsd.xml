<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/tsd.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_TSD_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/rtree.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>ncleanups</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_tsd_cleanup_t</name></type> <name><name>cleanups</name><index>[<expr><name>MALLOC_TSD_CLEANUPS_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* TSD_INITIALIZER triggers "-Wmissing-field-initializer" */</comment>
<decl_stmt><decl><type><name>JEMALLOC_DIAGNOSTIC_PUSH</name>
<name>JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS</name></type>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></cpp:ifdef>
<name>JEMALLOC_TSD_TYPE_ATTR</name><argument_list>(<argument><expr><name>tsd_t</name></expr></argument>)</argument_list> <name>tsd_tls</name> <init>= <expr><name>TSD_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<macro><name>JEMALLOC_TSD_TYPE_ATTR</name><argument_list>(<argument>bool</argument>)</argument_list></macro> <decl_stmt><decl><type><name>JEMALLOC_TLS_MODEL</name></type> <name>tsd_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>tsd_booted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<macro><name>JEMALLOC_TSD_TYPE_ATTR</name><argument_list>(<argument>tsd_t</argument>)</argument_list></macro> <expr_stmt><expr><name>tsd_tls</name> <operator>=</operator> <name>TSD_INITIALIZER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>pthread_key_t</name></type> <name>tsd_tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>tsd_booted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<decl_stmt><decl><type><name>DWORD</name></type> <name>tsd_tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tsd_wrapper_t</name></type> <name>tsd_boot_wrapper</name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>TSD_INITIALIZER</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>tsd_booted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/*
 * This contains a mutex, but it's pretty convenient to allow the mutex code to
 * have a dependency on tsd.  So we define the struct here, and only refer to it
 * by pointer in the header.
 */</comment>
<struct>struct <name>tsd_init_head_s</name> <block>{
	<macro><name>ql_head</name><argument_list>(<argument>tsd_init_block_t</argument>)</argument_list></macro> <expr_stmt><expr><name>blocks</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>malloc_mutex_t</name></type> <name>lock</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>pthread_key_t</name></type> <name>tsd_tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tsd_init_head_t</name></type>	<name>tsd_init_head</name> <init>= <expr><block>{
	<expr><call><name>ql_head_initializer</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>,
	<expr><name>MALLOC_MUTEX_INITIALIZER</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tsd_wrapper_t</name></type> <name>tsd_boot_wrapper</name> <init>= <expr><block>{
	<expr><name>false</name></expr>,
	<expr><name>TSD_INITIALIZER</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>tsd_booted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>JEMALLOC_DIAGNOSTIC_POP</name></macro>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<comment type="block">/* A list of all the tsds in the nominal state. */</comment>
<typedef>typedef <macro><name>ql_head</name><argument_list>(<argument>tsd_t</argument>)</argument_list></macro> <expr_stmt><expr><name>tsd_list_t</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>tsd_list_t</name></type> <name>tsd_nominal_tsds</name> <init>= <expr><call><name>ql_head_initializer</name><argument_list>(<argument><expr><name>tsd_nominal_tsds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>tsd_nominal_tsds_lock</name></decl>;</decl_stmt>

<comment type="block">/* How many slow-path-enabling features are turned on. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_u32_t</name></type> <name>tsd_global_slow_count</name> <init>= <expr><call><name>ATOMIC_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tsd_in_nominal_list</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * We don't know that tsd is nominal; it might not be safe to get data
	 * out of it here.
	 */</comment>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ql_foreach</name><argument_list>(<argument>tsd_list</argument>, <argument>&amp;tsd_nominal_tsds</argument>, <argument>TSD_MANGLE(tcache).tsd_link</argument>)</argument_list></macro> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>tsd</name> <operator>==</operator> <name>tsd_list</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tsd_add_nominal</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsd_in_nominal_list</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>tsd_state_nominal_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_elm_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>TSD_MANGLE</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>)</argument_list></call><operator>.</operator><name>tsd_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_tail_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>TSD_MANGLE</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>)</argument_list></call><operator>.</operator><name>tsd_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tsd_remove_nominal</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_in_nominal_list</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>tsd_state_nominal_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds</name></expr></argument>, <argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>TSD_MANGLE</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>)</argument_list></call><operator>.</operator><name>tsd_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tsd_force_recompute</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * The stores to tsd-&gt;state here need to synchronize with the exchange
	 * in tsd_slow_update.
	 */</comment>
	<expr_stmt><expr><call><name>atomic_fence</name><argument_list>(<argument><expr><name>ATOMIC_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>remote_tsd</name></decl>;</decl_stmt>
	<macro><name>ql_foreach</name><argument_list>(<argument>remote_tsd</argument>, <argument>&amp;tsd_nominal_tsds</argument>, <argument>TSD_MANGLE(tcache).tsd_link</argument>)</argument_list></macro> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote_tsd</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call>
		    <operator>&lt;=</operator> <name>tsd_state_nominal_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote_tsd</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>tsd_state_nominal_recompute</name></expr></argument>,
		    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_global_slow_inc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_global_slow_count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * We unconditionally force a recompute, even if the global slow count
	 * was already positive.  If we didn't, then it would be possible for us
	 * to return to the user, have the user synchronize externally with some
	 * other thread, and then have that other thread not have picked up the
	 * update yet (since the original incrementing thread might still be
	 * making its way through the tsd list).
	 */</comment>
	<expr_stmt><expr><call><name>tsd_force_recompute</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tsd_global_slow_dec</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_global_slow_count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* See the note in ..._inc(). */</comment>
	<expr_stmt><expr><call><name>tsd_force_recompute</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tsd_local_slow</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>tsd_tcache_enabled_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call>
	    <operator>||</operator> <call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>tsd_global_slow</name><parameter_list>()</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>atomic_load_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_global_slow_count</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>uint8_t</name></type>
<name>tsd_state_compute</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsd_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* We're in *a* nominal state; but which one? */</comment>
	<if_stmt><if>if <condition>(<expr><name>malloc_slow</name> <operator>||</operator> <call><name>tsd_local_slow</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tsd_global_slow</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>tsd_state_nominal_slow</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><name>tsd_state_nominal</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_slow_update</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name>old_state</name></decl>;</decl_stmt>
	<do>do <block>{<block_content>
		<decl_stmt><decl><type><name>uint8_t</name></type> <name>new_state</name> <init>= <expr><call><name>tsd_state_compute</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>old_state</name> <operator>=</operator> <call><name>tsd_atomic_exchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>new_state</name></expr></argument>,
		    <argument><expr><name>ATOMIC_ACQUIRE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>old_state</name> <operator>==</operator> <name>tsd_state_nominal_recompute</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_state_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>new_state</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Only the tsd module can change the state *to* recompute. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new_state</name> <operator>!=</operator> <name>tsd_state_nominal_recompute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name>old_state</name> <init>= <expr><call><name>tsd_atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>old_state</name> <operator>&gt;</operator> <name>tsd_state_nominal_max</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Not currently in the nominal list, but it might need to be
		 * inserted there.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsd_in_nominal_list</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>new_state</name></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>new_state</name> <operator>&lt;=</operator> <name>tsd_state_nominal_max</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tsd_add_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * We're currently nominal.  If the new state is non-nominal,
		 * great; we take ourselves off the list and just enter the new
		 * state.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_in_nominal_list</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>new_state</name> <operator>&gt;</operator> <name>tsd_state_nominal_max</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tsd_remove_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tsd_atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>new_state</name></expr></argument>,
			    <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/*
			 * This is the tricky case.  We're transitioning from
			 * one nominal state to another.  The caller can't know
			 * about any races that are occuring at the same time,
			 * so we always have to recompute no matter what.
			 */</comment>
			<expr_stmt><expr><call><name>tsd_slow_update</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tsd_data_init</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * We initialize the rtree context first (before the tcache), since the
	 * tcache initialization depends on it.
	 */</comment>
	<expr_stmt><expr><call><name>rtree_ctx_data_init</name><argument_list>(<argument><expr><call><name>tsd_rtree_ctxp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * A nondeterministic seed based on the address of tsd reduces
	 * the likelihood of lockstep non-uniform cache index
	 * utilization among identical concurrent processes, but at the
	 * cost of test repeatability.  For debug builds, instead use a
	 * deterministic seed.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_offset_statep_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <ternary><condition><expr><name>config_debug</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
	    <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tsd</name></expr></else></ternary></expr>;</expr_stmt>

	<return>return <expr><call><name>tsd_tcache_enabled_data_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assert_tsd_data_cleanup_done</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsd_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsd_in_nominal_list</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_arenap_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_iarenap_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_arenas_tdata_bypassp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_arenas_tdatap_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_tcache_enabledp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_prof_tdatap_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tsd_data_init_nocleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_reincarnated</name> <operator>||</operator>
	    <call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_minimal_initialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * During reincarnation, there is no guarantee that the cleanup function
	 * will be called (deallocation may happen after all tsd destructors).
	 * We set up tsd in a way that no cleanup is needed.
	 */</comment>
	<expr_stmt><expr><call><name>rtree_ctx_data_init</name><argument_list>(<argument><expr><call><name>tsd_rtree_ctxp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_arenas_tdata_bypassp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_tcache_enabledp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_reentrancy_levelp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_tsd_data_cleanup_done</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>tsd_t</name> <modifier>*</modifier></type>
<name>tsd_fetch_slow</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>minimal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tsd_fast</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_nominal_slow</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * On slow path but no work needed.  Note that we can't
		 * necessarily *assert* that we're slow, because we might be
		 * slow because of an asynchronous modification to global state,
		 * which might be asynchronously modified *back*.
		 */</comment>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_nominal_recompute</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_slow_update</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_uninitialized</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minimal</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>tsd_booted</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>tsd_state_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tsd_state_nominal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tsd_slow_update</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Trigger cleanup handler registration. */</comment>
				<expr_stmt><expr><call><name>tsd_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tsd_data_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>tsd_state_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tsd_state_minimal_initialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tsd_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tsd_data_init_nocleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_minimal_initialized</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minimal</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Switch to fully initialized. */</comment>
			<expr_stmt><expr><call><name>tsd_state_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tsd_state_nominal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>tsd_reentrancy_levelp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><call><name>tsd_reentrancy_levelp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tsd_slow_update</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tsd_data_init</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert_tsd_data_cleanup_done</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_purgatory</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_state_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tsd_state_reincarnated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_data_init_nocleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsd_state_reincarnated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>tsd</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>malloc_tsd_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>a0malloc</name><argument_list>(<argument><expr><call><name>CACHELINE_CEILING</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>malloc_tsd_dalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>wrapper</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>a0dalloc</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<function><type><name>JEMALLOC_EXPORT</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>void</name></type>
<name>_malloc_thread_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>pending</name><index>[<expr><name>MALLOC_TSD_CLEANUPS_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name>again</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncleanups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>pending</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<do>do <block>{<block_content>
		<expr_stmt><expr><name>again</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncleanups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pending</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>pending</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cleanups</name><index>[<expr><name>i</name></expr>]</index></name><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>pending</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>again</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block> while <condition>(<expr><name>again</name></expr>)</condition>;</do>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>malloc_tsd_cleanup_register</name><parameter_list>(<parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ncleanups</name> <operator>&lt;</operator> <name>MALLOC_TSD_CLEANUPS_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cleanups</name><index>[<expr><name>ncleanups</name></expr>]</index></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ncleanups</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tsd_do_data_cleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>prof_tdata_cleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>iarena_cleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arena_cleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>arenas_tdata_cleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tcache_cleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>witnesses_cleanup</name><argument_list>(<argument><expr><call><name>tsd_witness_tsdp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><operator>(</operator><name>tsd_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>tsd_state_uninitialized</name></expr>:</case>
		<comment type="block">/* Do nothing. */</comment>
		<break>break;</break>
	<case>case <expr><name>tsd_state_minimal_initialized</name></expr>:</case>
		<comment type="block">/* This implies the thread only did free() in its life time. */</comment>
		<comment type="block">/* Fall through. */</comment>
	<case>case <expr><name>tsd_state_reincarnated</name></expr>:</case>
		<comment type="block">/*
		 * Reincarnated means another destructor deallocated memory
		 * after the destructor was called.  Cleanup isn't required but
		 * is still called for testing and completeness.
		 */</comment>
		<expr_stmt><expr><call><name>assert_tsd_data_cleanup_done</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fall through. */</comment>
	<case>case <expr><name>tsd_state_nominal</name></expr>:</case>
	<case>case <expr><name>tsd_state_nominal_slow</name></expr>:</case>
		<expr_stmt><expr><call><name>tsd_do_data_cleanup</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_state_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tsd_state_purgatory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tsd_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>tsd_state_purgatory</name></expr>:</case>
		<comment type="block">/*
		 * The previous time this destructor was called, we set the
		 * state to tsd_state_purgatory so that other destructors
		 * wouldn't cause re-creation of the tsd.  This time, do
		 * nothing, and do not request another callback.
		 */</comment>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_JET</name></cpp:ifdef>
	<decl_stmt><decl><type><name>test_callback_t</name></type> <name>test_callback</name> <init>= <expr><operator>*</operator><call><name>tsd_test_callbackp_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>tsd_test_datap_get_unsafe</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>test_callback</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>test_callback</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>tsd_t</name> <modifier>*</modifier></type>
<name>malloc_tsd_boot0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ncleanups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>, <argument><expr><literal type="string">"tsd_nominal_tsds_lock"</literal></expr></argument>,
	    <argument><expr><name>WITNESS_RANK_OMIT</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tsd_boot0</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_arenas_tdata_bypassp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>tsd</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>malloc_tsd_boot1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>tsd_boot1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* malloc_slow has been set properly.  Update tsd_slow. */</comment>
	<expr_stmt><expr><call><name>tsd_slow_update</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>tsd_arenas_tdata_bypassp_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>_tls_callback</name><parameter_list>(<parameter><decl><type><name>HINSTANCE</name></type> <name>hinstDLL</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>fdwReason</name></decl></parameter>, <parameter><decl><type><name>LPVOID</name></type> <name>lpvReserved</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch <condition>(<expr><name>fdwReason</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JEMALLOC_LAZY_LOCK</name></cpp:ifdef>
	<case>case <expr><name>DLL_THREAD_ATTACH</name></expr>:</case>
		<expr_stmt><expr><name>isthreaded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<case>case <expr><name>DLL_THREAD_DETACH</name></expr>:</case>
		<expr_stmt><expr><call><name>_malloc_thread_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We need to be able to say "read" here (in the "pragma section"), but have
 * hooked "read". We won't read for the rest of the file, so we can get away
 * with unhooking.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>read</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>read</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>_M_IX86</name></cpp:ifdef>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:__tls_used"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:_tls_callback"</cpp:literal><name>)</name></cpp:pragma>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:_tls_used"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:"</cpp:literal> <name>STRINGIFY</name><name>(</name><name>tls_callback</name><name>)</name> <name>)</name></cpp:pragma>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>section</name><name>(</name><cpp:literal>".CRT$XLY"</cpp:literal><name>,</name><name>long</name><name>,</name><name>read</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>JEMALLOC_SECTION</name><argument_list>(<argument><literal type="string">".CRT$XLY"</literal></argument>)</argument_list></macro> <function_decl><type><name>JEMALLOC_ATTR</name></type>(<name>used</name>)
<macro><name>BOOL</name>	<argument_list>(<argument>WINAPI *const tls_callback</argument>)</argument_list></macro><parameter_list>(<parameter><decl><type><name>HINSTANCE</name></type> <name>hinstDLL</name></decl></parameter>,
    <parameter><decl><type><name>DWORD</name></type> <name>fdwReason</name></decl></parameter>, <parameter><decl><type><name>LPVOID</name></type> <name>lpvReserved</name></decl></parameter>)</parameter_list> <init>= <expr><name>_tls_callback</name></expr></init>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>tsd_init_check_recursion</name><parameter_list>(<parameter><decl><type><name>tsd_init_head_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>tsd_init_block_t</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>pthread_t</name></type> <name>self</name> <init>= <expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tsd_init_block_t</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

	<comment type="block">/* Check whether this thread has already inserted into the list. */</comment>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ql_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;head-&gt;blocks</argument>, <argument>link</argument>)</argument_list></macro> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <name>self</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* Insert block into list. */</comment>
	<expr_stmt><expr><call><name>ql_elm_new</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>thread</name></name> <operator>=</operator> <name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_tail_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>blocks</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_init_finish</name><parameter_list>(<parameter><decl><type><name>tsd_init_head_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>tsd_init_block_t</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>blocks</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>tsd_prefork</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tsd_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ql_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsd_nominal_tsds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>tsd_state_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>tsd_state_nominal_max</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tsd_add_nominal</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
