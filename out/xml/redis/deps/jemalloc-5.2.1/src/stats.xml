<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/src/stats.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_STATS_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ctl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/emitter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex_prof.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>global_mutex_names</name><index>[<expr><name>mutex_prof_num_global_mutexes</name></expr>]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#mtx,</cpp:value></cpp:define>
	<expr><name>MUTEX_PROF_GLOBAL_MUTEXES</name></expr>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>arena_mutex_names</name><index>[<expr><name>mutex_prof_num_arena_mutexes</name></expr>]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mtx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#mtx,</cpp:value></cpp:define>
	<expr><name>MUTEX_PROF_ARENA_MUTEXES</name></expr>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_GET</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {						\
	size_t sz = sizeof(t);						\
	xmallctl(n, (void *)v, &amp;sz, NULL, 0);				\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_M2_GET</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {					\
	size_t mib[CTL_MAX_DEPTH];					\
	size_t miblen = sizeof(mib) / sizeof(size_t);			\
	size_t sz = sizeof(t);						\
	xmallctlnametomib(n, mib, &amp;miblen);				\
	mib[2] = (i);							\
	xmallctlbymib(mib, miblen, (void *)v, &amp;sz, NULL, 0);		\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_M2_M4_GET</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>j</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {				\
	size_t mib[CTL_MAX_DEPTH];					\
	size_t miblen = sizeof(mib) / sizeof(size_t);			\
	size_t sz = sizeof(t);						\
	xmallctlnametomib(n, mib, &amp;miblen);				\
	mib[2] = (i);							\
	mib[4] = (j);							\
	xmallctlbymib(mib, miblen, (void *)v, &amp;sz, NULL, 0);		\
} while (0)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block">/* Data. */</comment>

<decl_stmt><decl><type><name>bool</name></type> <name>opt_stats_print</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>opt_stats_print_opts</name><index>[<expr><name>stats_print_tot_num_options</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>rate_per_second</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>uptime_ns</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>billion</name> <init>= <expr><literal type="number">1000000000</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>uptime_ns</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>uptime_ns</name> <operator>&lt;</operator> <name>billion</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>value</name></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>uptime_s</name> <init>= <expr><name>uptime_ns</name> <operator>/</operator> <name>billion</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><name>value</name> <operator>/</operator> <name>uptime_s</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Calculate x.yyy and output a string (takes a fixed sized char array). */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_rate_str</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>dividend</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>divisor</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>divisor</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>dividend</name> <operator>&gt;</operator> <name>divisor</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* The rate is not supposed to be greater than 1. */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dividend</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>UINT64_MAX</name> <operator>/</operator> <name>dividend</name> <operator>&gt;=</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><name>dividend</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator> <operator>/</operator> <name>divisor</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"0.00%u"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"0.0%u"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"0.%u"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_CTL_STR_MAX_LENGTH</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_mutex_ctl_str</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>counter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><literal type="string">"stats.%s.%s.%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mutex_stats_init_cols</name><parameter_list>(<parameter><decl><type><name>emitter_row_t</name> <modifier>*</modifier></type><name>row</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint64_t</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint32_t</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>mutex_prof_uint64_t_counter_ind_t</name></type> <name>k_uint64_t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mutex_prof_uint32_t_counter_ind_t</name></type> <name>k_uint32_t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_col_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>name</name><operator>-&gt;</operator><name>justify</name></name> <operator>=</operator> <name>emitter_justify_left</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>name</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>name</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_title</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>name</name><operator>-&gt;</operator><name>str_val</name></name> <operator>=</operator> <name>table_name</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIDTH_uint32_t</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIDTH_uint64_t</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>counter</name></type></parameter>, <parameter><type><name>counter_type</name></type></parameter>, <parameter><type><name>human</name></type></parameter>, <parameter><type><name>derived</name></type></parameter>, <parameter><type><name>base_counter</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>col = &amp;col_##counter_type[k_##counter_type];			\
	++k_##counter_type;						\
	emitter_col_init(col, row);					\
	col-&gt;justify = emitter_justify_right;				\
	col-&gt;width = derived ? 8 : WIDTH_##counter_type;		\
	col-&gt;type = emitter_type_title;					\
	col-&gt;str_val = human;</cpp:value></cpp:define>
	<expr_stmt><expr><name>MUTEX_PROF_COUNTERS</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WIDTH_uint32_t</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WIDTH_uint64_t</name></cpp:undef>
	<name><name>col_uint64_t</name><index>[<expr><name>mutex_counter_total_wait_time_ps</name></expr>]</index></name><operator>.</operator><name>width</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mutex_stats_read_global</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>col_name</name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint64_t</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint32_t</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>uint64_t</name></type> <name>uptime</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><name>MUTEX_CTL_STR_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>col_name</name><operator>-&gt;</operator><name>str_val</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint32_t</name></cpp:macro> <cpp:value>emitter_type_uint32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint64_t</name></cpp:macro> <cpp:value>emitter_type_uint64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>counter</name></type></parameter>, <parameter><type><name>counter_type</name></type></parameter>, <parameter><type><name>human</name></type></parameter>, <parameter><type><name>derived</name></type></parameter>, <parameter><type><name>base_counter</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>dst = &amp;col_##counter_type[mutex_counter_##counter];		\
	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
	if (!derived) {							\
		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,	\
		    "mutexes", name, #counter);				\
		CTL_GET(cmd, (counter_type *)&amp;dst-&gt;bool_val, counter_type);	\
	} else { \
	    emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter];	\
	    dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
	}</cpp:value></cpp:define>
	<expr_stmt><expr><name>MUTEX_PROF_COUNTERS</name></expr></expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint32_t</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint64_t</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mutex_stats_read_arena</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>, <parameter><decl><type><name>mutex_prof_arena_ind_t</name></type> <name>mutex_ind</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>col_name</name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint64_t</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint32_t</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>uint64_t</name></type> <name>uptime</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><name>MUTEX_CTL_STR_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>col_name</name><operator>-&gt;</operator><name>str_val</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint32_t</name></cpp:macro> <cpp:value>emitter_type_uint32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint64_t</name></cpp:macro> <cpp:value>emitter_type_uint64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>counter</name></type></parameter>, <parameter><type><name>counter_type</name></type></parameter>, <parameter><type><name>human</name></type></parameter>, <parameter><type><name>derived</name></type></parameter>, <parameter><type><name>base_counter</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>dst = &amp;col_##counter_type[mutex_counter_##counter];		\
	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
	if (!derived) {                                   \
		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
		    "arenas.0.mutexes", arena_mutex_names[mutex_ind], #counter);\
		CTL_M2_GET(cmd, arena_ind, (counter_type *)&amp;dst-&gt;bool_val, counter_type); \
	} else {                      \
		emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter];	\
		dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
	}</cpp:value></cpp:define>
	<expr_stmt><expr><name>MUTEX_PROF_COUNTERS</name></expr></expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint32_t</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint64_t</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mutex_stats_read_arena_bin</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>bin_ind</name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint64_t</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint32_t</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>uint64_t</name></type> <name>uptime</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><name>MUTEX_CTL_STR_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint32_t</name></cpp:macro> <cpp:value>emitter_type_uint32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint64_t</name></cpp:macro> <cpp:value>emitter_type_uint64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>counter</name></type></parameter>, <parameter><type><name>counter_type</name></type></parameter>, <parameter><type><name>human</name></type></parameter>, <parameter><type><name>derived</name></type></parameter>, <parameter><type><name>base_counter</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>dst = &amp;col_##counter_type[mutex_counter_##counter];		\
	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
	if (!derived) {                                   \
		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
		    "arenas.0.bins.0","mutex", #counter);            \
		CTL_M2_M4_GET(cmd, arena_ind, bin_ind,                \
		    (counter_type *)&amp;dst-&gt;bool_val, counter_type);  \
	} else {                      \
		emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter]; \
		dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
	}</cpp:value></cpp:define>
	<expr_stmt><expr><name>MUTEX_PROF_COUNTERS</name></expr></expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint32_t</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint64_t</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/* "row" can be NULL to avoid emitting in table mode. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mutex_stats_emit</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>emitter_row_t</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint64_t</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>emitter_col_t</name></type> <name><name>col_uint32_t</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>row</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>mutex_prof_uint64_t_counter_ind_t</name></type> <name>k_uint64_t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mutex_prof_uint32_t_counter_ind_t</name></type> <name>k_uint32_t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint32_t</name></cpp:macro> <cpp:value>emitter_type_uint32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMITTER_TYPE_uint64_t</name></cpp:macro> <cpp:value>emitter_type_uint64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>counter</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>human</name></type></parameter>, <parameter><type><name>derived</name></type></parameter>, <parameter><type><name>base_counter</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>if (!derived) {                    \
		col = &amp;col_##type[k_##type];                        \
		++k_##type;                            \
		emitter_json_kv(emitter, #counter, EMITTER_TYPE_##type,        \
		    (const void *)&amp;col-&gt;bool_val); \
	}</cpp:value></cpp:define>
	<expr_stmt><expr><name>MUTEX_PROF_COUNTERS</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint32_t</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EMITTER_TYPE_uint64_t</name></cpp:undef>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COL</name><parameter_list>(<parameter><type><name>row_name</name></type></parameter>, <parameter><type><name>column_name</name></type></parameter>, <parameter><type><name>left_or_right</name></type></parameter>, <parameter><type><name>col_width</name></type></parameter>, <parameter><type><name>etype</name></type></parameter>)</parameter_list></cpp:macro>      \
	<cpp:value>emitter_col_t col_##column_name;                                     \
	emitter_col_init(&amp;col_##column_name, &amp;row_name);                     \
	col_##column_name.justify = emitter_justify_##left_or_right;         \
	col_##column_name.width = col_width;                                 \
	col_##column_name.type = emitter_type_##etype;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COL_HDR</name><parameter_list>(<parameter><type><name>row_name</name></type></parameter>, <parameter><type><name>column_name</name></type></parameter>, <parameter><type><name>human</name></type></parameter>, <parameter><type><name>left_or_right</name></type></parameter>, <parameter><type><name>col_width</name></type></parameter>, <parameter><type><name>etype</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>COL(row_name, column_name, left_or_right, col_width, etype)	         \
	emitter_col_t header_##column_name;                                  \
	emitter_col_init(&amp;header_##column_name, &amp;header_##row_name);         \
	header_##column_name.justify = emitter_justify_##left_or_right;      \
	header_##column_name.width = col_width;                              \
	header_##column_name.type = emitter_type_title;                      \
	header_##column_name.str_val = human ? human : #column_name;</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_arena_bins_print</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mutex</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>uptime</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>in_gap</name></decl>, <decl><type ref="prev"/><name>in_gap_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>nbins</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.page"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.nbins"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbins</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>header_row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>size</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">20</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ind</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">4</literal></argument>, <argument>unsigned</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>allocated</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nmalloc</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nmalloc_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ndalloc</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ndalloc_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nrequests</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nrequests_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">10</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nshards</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">9</literal></argument>, <argument>unsigned</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>curregs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>curslabs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nonfull_slabs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">15</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>regs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">5</literal></argument>, <argument>unsigned</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>pgs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">4</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<comment type="block">/* To buffer a right- and left-justified column. */</comment>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>justify_spacer</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">1</literal></argument>, <argument>title</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>util</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">6</literal></argument>, <argument>title</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nfills</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nfills_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nflushes</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nflushes_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nslabs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nreslabs</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nreslabs_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>

	<comment type="block">/* Don't want to actually print the name. */</comment>
	<expr_stmt><expr><name><name>header_justify_spacer</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_justify_spacer</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>col_mutex64</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>col_mutex32</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>header_mutex64</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>header_mutex32</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>mutex</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>mutex_stats_init_cols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>col_mutex64</name></expr></argument>,
		    <argument><expr><name>col_mutex32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mutex_stats_init_cols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>header_mutex64</name></expr></argument>,
		    <argument><expr><name>header_mutex32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We print a "bins:" header as part of the table row; we need to adjust
	 * the header size column to compensate.
	 */</comment>
	<expr_stmt><expr><name><name>header_size</name><operator>.</operator><name>width</name></name> <operator>-=</operator><literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"bins:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"bins"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>in_gap</name> <operator>=</operator> <name>false</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nbins</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nslabs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>reg_size</name></decl>, <decl><type ref="prev"/><name>slab_size</name></decl>, <decl><type ref="prev"/><name>curregs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>curslabs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>nonfull_slabs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>nregs</name></decl>, <decl><type ref="prev"/><name>nshards</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nmalloc</name></decl>, <decl><type ref="prev"/><name>ndalloc</name></decl>, <decl><type ref="prev"/><name>nrequests</name></decl>, <decl><type ref="prev"/><name>nfills</name></decl>, <decl><type ref="prev"/><name>nflushes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nreslabs</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nslabs"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nslabs</name></expr></argument>,
		    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_gap_prev</name> <operator>=</operator> <name>in_gap</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_gap</name> <operator>=</operator> <operator>(</operator><name>nslabs</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>in_gap_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_gap</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>,
			    <argument><expr><literal type="string">"                     ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.size"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reg_size</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.nregs"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nregs</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.slab_size"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slab_size</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.nshards"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nshards</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nmalloc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nmalloc</name></expr></argument>,
		    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.ndalloc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndalloc</name></expr></argument>,
		    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.curregs"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curregs</name></expr></argument>,
		    <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nrequests"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nrequests</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nfills"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nfills</name></expr></argument>,
		    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nflushes"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nflushes</name></expr></argument>,
		    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nreslabs"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nreslabs</name></expr></argument>,
		    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.curslabs"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curslabs</name></expr></argument>,
		    <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.bins.0.nonfull_slabs"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nonfull_slabs</name></expr></argument>,
		    <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mutex</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>mutex_stats_read_arena_bin</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>col_mutex64</name></expr></argument>,
			    <argument><expr><name>col_mutex32</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nmalloc"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"ndalloc"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>ndalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"curregs"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>curregs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nrequests"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nrequests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nfills"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nfills</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nflushes"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nflushes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nreslabs"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nreslabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"curslabs"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>curslabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nonfull_slabs"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nonfull_slabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mutex</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mutex_stats_emit</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>col_mutex64</name></expr></argument>,
			    <argument><expr><name>col_mutex32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>size_t</name></type> <name>availregs</name> <init>= <expr><name>nregs</name> <operator>*</operator> <name>curslabs</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>util</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>get_rate_str</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>curregs</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>availregs</name></expr></argument>, <argument><expr><name>util</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>availregs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>util</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curregs</name> <operator>&gt;</operator> <name>availregs</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * Race detected: the counters were read in
				 * separate mallctl calls and concurrent
				 * operations happened in between.  In this case
				 * no meaningful utilization can be computed.
				 */</comment>
				<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>util</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>util</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">" race"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>col_size</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>reg_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ind</name><operator>.</operator><name>unsigned_val</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_allocated</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>curregs</name> <operator>*</operator> <name>reg_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nmalloc</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nmalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nmalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nmalloc</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ndalloc</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>ndalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ndalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>ndalloc</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nrequests</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nrequests</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nrequests_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nrequests</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nshards</name><operator>.</operator><name>unsigned_val</name></name> <operator>=</operator> <name>nshards</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_curregs</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>curregs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_curslabs</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>curslabs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nonfull_slabs</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>nonfull_slabs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_regs</name><operator>.</operator><name>unsigned_val</name></name> <operator>=</operator> <name>nregs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_pgs</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>slab_size</name> <operator>/</operator> <name>page</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_util</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <name>util</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nfills</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nfills</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nfills_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nfills</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nflushes</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nflushes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nflushes_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nflushes</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nslabs</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nslabs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nreslabs</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nreslabs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nreslabs_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nreslabs</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that mutex columns were initialized above, if mutex ==
		 * true.
		 */</comment>

		<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "bins". */</comment>

	<if_stmt><if>if <condition>(<expr><name>in_gap</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"                     ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_arena_lextents_print</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>uptime</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>nbins</name></decl>, <decl><type ref="prev"/><name>nlextents</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>in_gap</name></decl>, <decl><type ref="prev"/><name>in_gap_prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.nbins"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbins</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.nlextents"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlextents</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>header_row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>size</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">20</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ind</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">4</literal></argument>, <argument>unsigned</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>allocated</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nmalloc</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nmalloc_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ndalloc</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ndalloc_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nrequests</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nrequests_ps</argument>, <argument><literal type="string">"(#/sec)"</literal></argument>, <argument>right</argument>, <argument><literal type="number">8</literal></argument>, <argument>uint64</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>curlextents</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>

	<comment type="block">/* As with bins, we label the large extents table. */</comment>
	<expr_stmt><expr><name><name>header_size</name><operator>.</operator><name>width</name></name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"large:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"lextents"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>in_gap</name> <operator>=</operator> <name>false</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nlextents</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>nmalloc</name></decl>, <decl><type ref="prev"/><name>ndalloc</name></decl>, <decl><type ref="prev"/><name>nrequests</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>lextent_size</name></decl>, <decl><type ref="prev"/><name>curlextents</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.lextents.0.nmalloc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nmalloc</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.lextents.0.ndalloc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>ndalloc</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.lextents.0.nrequests"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nrequests</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_gap_prev</name> <operator>=</operator> <name>in_gap</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_gap</name> <operator>=</operator> <operator>(</operator><name>nrequests</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>in_gap_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_gap</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>,
			    <argument><expr><literal type="string">"                     ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.lextent.0.size"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lextent_size</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.lextents.0.curlextents"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>curlextents</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"curlextents"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>curlextents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>col_size</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>lextent_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ind</name><operator>.</operator><name>unsigned_val</name></name> <operator>=</operator> <name>nbins</name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_allocated</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>curlextents</name> <operator>*</operator> <name>lextent_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nmalloc</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nmalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nmalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nmalloc</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ndalloc</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>ndalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ndalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>ndalloc</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nrequests</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>nrequests</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nrequests_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <call><name>rate_per_second</name><argument_list>(<argument><expr><name>nrequests</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_curlextents</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>curlextents</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_gap</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "lextents". */</comment>
	<if_stmt><if>if <condition>(<expr><name>in_gap</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"                     ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_arena_extents_print</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>in_gap</name></decl>, <decl><type ref="prev"/><name>in_gap_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>header_row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>size</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">20</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ind</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">4</literal></argument>, <argument>unsigned</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ndirty</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>dirty</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nmuzzy</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>muzzy</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>nretained</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>retained</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>ntotal</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>COL_HDR</name><argument_list>(<argument>row</argument>, <argument>total</argument>, <argument>NULL</argument>, <argument>right</argument>, <argument><literal type="number">13</literal></argument>, <argument>size</argument>)</argument_list></macro>

	<comment type="block">/* Label this section. */</comment>
	<expr_stmt><expr><name><name>header_size</name><operator>.</operator><name>width</name></name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"extents:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"extents"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>in_gap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>SC_NPSIZES</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>ndirty</name></decl>, <decl><type ref="prev"/><name>nmuzzy</name></decl>, <decl><type ref="prev"/><name>nretained</name></decl>, <decl><type ref="prev"/><name>total</name></decl>, <decl><type ref="prev"/><name>dirty_bytes</name></decl>,
		    <decl><type ref="prev"/><name>muzzy_bytes</name></decl>, <decl><type ref="prev"/><name>retained_bytes</name></decl>, <decl><type ref="prev"/><name>total_bytes</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.extents.0.ndirty"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>ndirty</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.extents.0.nmuzzy"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nmuzzy</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.extents.0.nretained"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nretained</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.extents.0.dirty_bytes"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>dirty_bytes</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.extents.0.muzzy_bytes"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>muzzy_bytes</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_M2_M4_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.extents.0.retained_bytes"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>retained_bytes</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>total</name> <operator>=</operator> <name>ndirty</name> <operator>+</operator> <name>nmuzzy</name> <operator>+</operator> <name>nretained</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_bytes</name> <operator>=</operator> <name>dirty_bytes</name> <operator>+</operator> <name>muzzy_bytes</name> <operator>+</operator> <name>retained_bytes</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>in_gap_prev</name> <operator>=</operator> <name>in_gap</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_gap</name> <operator>=</operator> <operator>(</operator><name>total</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>in_gap_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_gap</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>,
			    <argument><expr><literal type="string">"                     ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"ndirty"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nmuzzy"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nmuzzy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nretained"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>nretained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dirty_bytes"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>dirty_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"muzzy_bytes"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>muzzy_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"retained_bytes"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>retained_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>col_size</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <call><name>sz_pind2sz</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ind</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ndirty</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>ndirty</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_dirty</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>dirty_bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nmuzzy</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>nmuzzy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_muzzy</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>muzzy_bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_nretained</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>nretained</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_retained</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>retained_bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_ntotal</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>total</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_total</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>total_bytes</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_gap</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "extents". */</comment>
	<if_stmt><if>if <condition>(<expr><name>in_gap</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"                     ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_arena_mutexes_print</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>arena_ind</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>uptime</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>col_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>col64</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>col32</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mutex_stats_init_cols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>col_name</name></expr></argument>, <argument><expr><name>col64</name></expr></argument>, <argument><expr><name>col32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"mutexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>mutex_prof_arena_ind_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mutex_prof_num_arena_mutexes</name></expr>;</condition>
	    <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>arena_mutex_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mutex_stats_read_arena</name><argument_list>(<argument><expr><name>arena_ind</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>col_name</name></expr></argument>, <argument><expr><name>col64</name></expr></argument>,
		    <argument><expr><name>col32</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mutex_stats_emit</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>, <argument><expr><name>col64</name></expr></argument>, <argument><expr><name>col32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close the mutex dict. */</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* End "mutexes". */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_arena_print</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bins</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>large</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>mutex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>nthreads</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>dirty_decay_ms</name></decl>, <decl><type ref="prev"/><name>muzzy_decay_ms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>page</name></decl>, <decl><type ref="prev"/><name>pactive</name></decl>, <decl><type ref="prev"/><name>pdirty</name></decl>, <decl><type ref="prev"/><name>pmuzzy</name></decl>, <decl><type ref="prev"/><name>mapped</name></decl>, <decl><type ref="prev"/><name>retained</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>internal</name></decl>, <decl><type ref="prev"/><name>resident</name></decl>, <decl><type ref="prev"/><name>metadata_thp</name></decl>, <decl><type ref="prev"/><name>extent_avail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>dirty_npurge</name></decl>, <decl><type ref="prev"/><name>dirty_nmadvise</name></decl>, <decl><type ref="prev"/><name>dirty_purged</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>muzzy_npurge</name></decl>, <decl><type ref="prev"/><name>muzzy_nmadvise</name></decl>, <decl><type ref="prev"/><name>muzzy_purged</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>small_allocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>small_nmalloc</name></decl>, <decl><type ref="prev"/><name>small_ndalloc</name></decl>, <decl><type ref="prev"/><name>small_nrequests</name></decl>, <decl><type ref="prev"/><name>small_nfills</name></decl>,
	    <decl><type ref="prev"/><name>small_nflushes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>large_allocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>large_nmalloc</name></decl>, <decl><type ref="prev"/><name>large_ndalloc</name></decl>, <decl><type ref="prev"/><name>large_nrequests</name></decl>, <decl><type ref="prev"/><name>large_nfills</name></decl>,
	    <decl><type ref="prev"/><name>large_nflushes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>tcache_bytes</name></decl>, <decl><type ref="prev"/><name>abandoned_vm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>uptime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.page"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.nthreads"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nthreads</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nthreads"</literal></expr></argument>, <argument><expr><literal type="string">"assigned threads"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_unsigned</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.uptime"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uptime</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"uptime_ns"</literal></expr></argument>, <argument><expr><literal type="string">"uptime"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.dss"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dss</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dss"</literal></expr></argument>, <argument><expr><literal type="string">"dss allocation precedence"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.dirty_decay_ms"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirty_decay_ms</name></expr></argument>,
	    <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.muzzy_decay_ms"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>muzzy_decay_ms</name></expr></argument>,
	    <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.pactive"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pactive</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.pdirty"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdirty</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.pmuzzy"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pmuzzy</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.dirty_npurge"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirty_npurge</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.dirty_nmadvise"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirty_nmadvise</name></expr></argument>,
	    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.dirty_purged"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirty_purged</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.muzzy_npurge"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>muzzy_npurge</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.muzzy_nmadvise"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>muzzy_nmadvise</name></expr></argument>,
	    <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.muzzy_purged"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>muzzy_purged</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>decay_row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decay_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* JSON-style emission. */</comment>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>, <argument><expr><name>emitter_type_ssize</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>dirty_decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>, <argument><expr><name>emitter_type_ssize</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>muzzy_decay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"pactive"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pactive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"pdirty"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"pmuzzy"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pmuzzy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dirty_npurge"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>dirty_npurge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dirty_nmadvise"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>dirty_nmadvise</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dirty_purged"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>dirty_purged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"muzzy_npurge"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>muzzy_npurge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"muzzy_nmadvise"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>muzzy_nmadvise</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"muzzy_purged"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>muzzy_purged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Table-style emission. */</comment>
	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>decay_row</name></expr></argument>, <argument><expr><name>decay_type</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_type</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"decaying:"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>decay_row</name></expr></argument>, <argument><expr><name>decay_time</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"time"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>decay_row</name></expr></argument>, <argument><expr><name>decay_npages</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_npages</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"npages"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>decay_row</name></expr></argument>, <argument><expr><name>decay_sweeps</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_sweeps</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"sweeps"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>decay_row</name></expr></argument>, <argument><expr><name>decay_madvises</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_madvises</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"madvises"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>decay_row</name></expr></argument>, <argument><expr><name>decay_purged</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_purged</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"purged"</literal></expr>;</expr_stmt>

	<comment type="block">/* Title row. */</comment>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decay_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dirty row. */</comment>
	<expr_stmt><expr><name><name>col_decay_type</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"dirty:"</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dirty_decay_ms</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_ssize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>ssize_val</name></name> <operator>=</operator> <name>dirty_decay_ms</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_title</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"N/A"</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>col_decay_npages</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_npages</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>pdirty</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_decay_sweeps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_sweeps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>dirty_npurge</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_decay_madvises</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_madvises</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>dirty_nmadvise</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_decay_purged</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_purged</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>dirty_purged</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decay_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Muzzy row. */</comment>
	<expr_stmt><expr><name><name>col_decay_type</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"muzzy:"</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>muzzy_decay_ms</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_ssize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>ssize_val</name></name> <operator>=</operator> <name>muzzy_decay_ms</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_title</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>col_decay_time</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"N/A"</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>col_decay_npages</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_npages</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>pmuzzy</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_decay_sweeps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_sweeps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>muzzy_npurge</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_decay_madvises</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_madvises</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>muzzy_nmadvise</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_decay_purged</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_decay_purged</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>muzzy_purged</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decay_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Small / large / total allocation counts. */</comment>
	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>alloc_count_row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alloc_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_title</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_title</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_allocated</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_allocated</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"allocated"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nmalloc</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nmalloc</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"nmalloc"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nmalloc_ps</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nmalloc_ps</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"(#/sec)"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_ndalloc</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_ndalloc</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"ndalloc"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_ndalloc_ps</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_ndalloc_ps</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"(#/sec)"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nrequests</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nrequests</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"nrequests"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nrequests_ps</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nrequests_ps</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"(#/sec)"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nfills</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nfills</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"nfill"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nfills_ps</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nfills_ps</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"(#/sec)"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nflushes</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nflushes</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"nflush"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COL</name><argument_list>(<argument><expr><name>alloc_count_row</name></expr></argument>, <argument><expr><name>count_nflushes_ps</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nflushes_ps</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"(#/sec)"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col_count_nmalloc_ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_ndalloc_ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nrequests_ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nfills_ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nflushes_ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_uint64</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_AND_EMIT_ALLOC_STAT</name><parameter_list>(<parameter><type><name>small_or_large</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>valtype</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>CTL_M2_GET("stats.arenas.0." #small_or_large "." #name, i,	\
	    &amp;small_or_large##_##name, valtype##_t);			\
	emitter_json_kv(emitter, #name, emitter_type_##valtype,		\
	    &amp;small_or_large##_##name);					\
	col_count_##name.type = emitter_type_##valtype;		\
	col_count_##name.valtype##_val = small_or_large##_##name;</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_title</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"small:"</literal></expr>;</expr_stmt>

	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>small</argument>, <argument>allocated</argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>small</argument>, <argument>nmalloc</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nmalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nmalloc</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>small</argument>, <argument>ndalloc</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_ndalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_ndalloc</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>small</argument>, <argument>nrequests</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nrequests_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nrequests</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>small</argument>, <argument>nfills</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nfills_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nfills</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>small</argument>, <argument>nflushes</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nflushes_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nflushes</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "small". */</comment>

	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"large"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_title</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"large:"</literal></expr>;</expr_stmt>

	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>large</argument>, <argument>allocated</argument>, <argument>size</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>large</argument>, <argument>nmalloc</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nmalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nmalloc</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>large</argument>, <argument>ndalloc</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_ndalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_ndalloc</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>large</argument>, <argument>nrequests</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nrequests_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nrequests</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>large</argument>, <argument>nfills</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nfills_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nfills</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>GET_AND_EMIT_ALLOC_STAT</name><argument_list>(<argument>large</argument>, <argument>nflushes</argument>, <argument>uint64</argument>)</argument_list></macro>
	<expr_stmt><expr><name><name>col_count_nflushes_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nflushes</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "large". */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_AND_EMIT_ALLOC_STAT</name></cpp:undef>

	<comment type="block">/* Aggregated small + large stats are emitter only in table mode. */</comment>
	<expr_stmt><expr><name><name>col_count_title</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"total:"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_allocated</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>small_allocated</name> <operator>+</operator> <name>large_allocated</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nmalloc</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>small_nmalloc</name> <operator>+</operator> <name>large_nmalloc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_ndalloc</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>small_ndalloc</name> <operator>+</operator> <name>large_ndalloc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nrequests</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>small_nrequests</name> <operator>+</operator> <name>large_nrequests</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nfills</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>small_nfills</name> <operator>+</operator> <name>large_nfills</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nflushes</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator> <name>small_nflushes</name> <operator>+</operator> <name>large_nflushes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nmalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nmalloc</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_ndalloc_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_ndalloc</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nrequests_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nrequests</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nfills_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nfills</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>col_count_nflushes_ps</name><operator>.</operator><name>uint64_val</name></name> <operator>=</operator>
	    <call><name>rate_per_second</name><argument_list>(<argument><expr><name><name>col_count_nflushes</name><operator>.</operator><name>uint64_val</name></name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alloc_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>mem_count_row</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>mem_count_title</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_col_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem_count_title</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_title</name><operator>.</operator><name>justify</name></name> <operator>=</operator> <name>emitter_justify_left</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_title</name><operator>.</operator><name>width</name></name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_title</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_title</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_title</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>mem_count_val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_col_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem_count_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_val</name><operator>.</operator><name>justify</name></name> <operator>=</operator> <name>emitter_justify_right</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_val</name><operator>.</operator><name>width</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_title</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_val</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_size</name></expr>;</expr_stmt>

	<comment type="block">/* Active count in bytes is emitted only in table mode. */</comment>
	<expr_stmt><expr><name><name>mem_count_title</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"active:"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_count_val</name><operator>.</operator><name>size_val</name></name> <operator>=</operator> <name>pactive</name> <operator>*</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem_count_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_AND_EMIT_MEM_STAT</name><parameter_list>(<parameter><type><name>stat</name></type></parameter>)</parameter_list></cpp:macro>					\
	<cpp:value>CTL_M2_GET("stats.arenas.0."#stat, i, &amp;stat, size_t);		\
	emitter_json_kv(emitter, #stat, emitter_type_size, &amp;stat);	\
	mem_count_title.str_val = #stat":";				\
	mem_count_val.size_val = stat;					\
	emitter_table_row(emitter, &amp;mem_count_row);</cpp:value></cpp:define>

	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>mapped</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>retained</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>base</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>internal</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>metadata_thp</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>tcache_bytes</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>resident</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>abandoned_vm</argument>)</argument_list></macro>
	<macro><name>GET_AND_EMIT_MEM_STAT</name><argument_list>(<argument>extent_avail</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_AND_EMIT_MEM_STAT</name></cpp:undef>

	<if_stmt><if>if <condition>(<expr><name>mutex</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stats_arena_mutexes_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>bins</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stats_arena_bins_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>large</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stats_arena_lextents_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>extents</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stats_arena_extents_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_general_print</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>bv</name></decl>, <decl><type ref="prev"/><name>bv2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>uv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>u32v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>u64v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>ssv</name></decl>, <decl><type ref="prev"/><name>ssv2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sv</name></decl>, <decl><type ref="prev"/><name>bsz</name></decl>, <decl><type ref="prev"/><name>usz</name></decl>, <decl><type ref="prev"/><name>ssz</name></decl>, <decl><type ref="prev"/><name>sssz</name></decl>, <decl><type ref="prev"/><name>cpsz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bsz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>usz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>ssz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>sssz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ssize_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpsz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpv</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><literal type="string">"Version"</literal></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* config. */</comment>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"config"</literal></expr></argument>, <argument><expr><literal type="string">"Build-time option settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_WRITE_BOOL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>						\
	<cpp:value>do {								\
		CTL_GET("config."#name, &amp;bv, bool);			\
		emitter_kv(emitter, #name, "config."#name,		\
		    emitter_type_bool, &amp;bv);				\
	} while (0)</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>cache_oblivious</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>lazy_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"malloc_conf"</literal></expr></argument>, <argument><expr><literal type="string">"config.malloc_conf"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>config_malloc_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>opt_safety_checks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>prof_libgcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>prof_libunwind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>utrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CONFIG_WRITE_BOOL</name><argument_list>(<argument><expr><name>xmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONFIG_WRITE_BOOL</name></cpp:undef>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "config" dict. */</comment>

	<comment type="block">/* opt. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>var</name></type></parameter>, <parameter><type><name>size</name></type></parameter>, <parameter><type><name>emitter_type</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>if (je_mallctl("opt."name, (void *)&amp;var, &amp;size, NULL, 0) ==	\
	    0) {							\
		emitter_kv(emitter, name, "opt."name, emitter_type,	\
		    &amp;var);						\
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_MUTABLE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>var1</name></type></parameter>, <parameter><type><name>var2</name></type></parameter>, <parameter><type><name>size</name></type></parameter>, <parameter><type><name>emitter_type</name></type></parameter>,		\
    <parameter><type><name>altname</name></type></parameter>)</parameter_list></cpp:macro>								\
	<cpp:value>if (je_mallctl("opt."name, (void *)&amp;var1, &amp;size, NULL, 0) ==	\
	    0 &amp;&amp; je_mallctl(altname, (void *)&amp;var2, &amp;size, NULL, 0)	\
	    == 0) {							\
		emitter_kv_note(emitter, name, "opt."name,		\
		    emitter_type, &amp;var1, altname, emitter_type,		\
		    &amp;var2);						\
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_BOOL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>OPT_WRITE(name, bv, bsz, emitter_type_bool)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_BOOL_MUTABLE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>altname</name></type></parameter>)</parameter_list></cpp:macro>				\
	<cpp:value>OPT_WRITE_MUTABLE(name, bv, bv2, bsz, emitter_type_bool, altname)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_UNSIGNED</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>					\
	<cpp:value>OPT_WRITE(name, uv, usz, emitter_type_unsigned)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_SIZE_T</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>						\
	<cpp:value>OPT_WRITE(name, sv, ssz, emitter_type_size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_SSIZE_T</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>						\
	<cpp:value>OPT_WRITE(name, ssv, sssz, emitter_type_ssize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_SSIZE_T_MUTABLE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>altname</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>OPT_WRITE_MUTABLE(name, ssv, ssv2, sssz, emitter_type_ssize,	\
	    altname)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_WRITE_CHAR_P</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>						\
	<cpp:value>OPT_WRITE(name, cpv, cpsz, emitter_type_string)</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"opt"</literal></expr></argument>, <argument><expr><literal type="string">"Run-time option settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"abort"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"abort_conf"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"confirm_conf"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"retain"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"dss"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_UNSIGNED</name><argument_list>(<argument><literal type="string">"narenas"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"percpu_arena"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SIZE_T</name><argument_list>(<argument><literal type="string">"oversize_threshold"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"metadata_thp"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL_MUTABLE</name><argument_list>(<argument><literal type="string">"background_thread"</literal></argument>, <argument><literal type="string">"background_thread"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SSIZE_T_MUTABLE</name><argument_list>(<argument><literal type="string">"dirty_decay_ms"</literal></argument>, <argument><literal type="string">"arenas.dirty_decay_ms"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SSIZE_T_MUTABLE</name><argument_list>(<argument><literal type="string">"muzzy_decay_ms"</literal></argument>, <argument><literal type="string">"arenas.muzzy_decay_ms"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SIZE_T</name><argument_list>(<argument><literal type="string">"lg_extent_max_active_fit"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"junk"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"zero"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"utrace"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"xmalloc"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"tcache"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SSIZE_T</name><argument_list>(<argument><literal type="string">"lg_tcache_max"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"thp"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"prof"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"prof_prefix"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL_MUTABLE</name><argument_list>(<argument><literal type="string">"prof_active"</literal></argument>, <argument><literal type="string">"prof.active"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL_MUTABLE</name><argument_list>(<argument><literal type="string">"prof_thread_active_init"</literal></argument>,
	    <argument><literal type="string">"prof.thread_active_init"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SSIZE_T_MUTABLE</name><argument_list>(<argument><literal type="string">"lg_prof_sample"</literal></argument>, <argument><literal type="string">"prof.lg_sample"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"prof_accum"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_SSIZE_T</name><argument_list>(<argument><literal type="string">"lg_prof_interval"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"prof_gdump"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"prof_final"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"prof_leak"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_BOOL</name><argument_list>(<argument><literal type="string">"stats_print"</literal></argument>)</argument_list></macro>
	<macro><name>OPT_WRITE_CHAR_P</name><argument_list>(<argument><literal type="string">"stats_print_opts"</literal></argument>)</argument_list></macro>

	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_MUTABLE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_BOOL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_BOOL_MUTABLE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_UNSIGNED</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_SSIZE_T</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_SSIZE_T_MUTABLE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_WRITE_CHAR_P</name></cpp:undef>

	<comment type="block">/* prof. */</comment>
	<if_stmt><if>if <condition>(<expr><name>config_prof</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"prof"</literal></expr></argument>, <argument><expr><literal type="string">"Profiling settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"prof.thread_active_init"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bv</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"thread_active_init"</literal></expr></argument>,
		    <argument><expr><literal type="string">"prof.thread_active_init"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"prof.active"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bv</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"active"</literal></expr></argument>, <argument><expr><literal type="string">"prof.active"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>bv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"prof.gdump"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bv</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"gdump"</literal></expr></argument>, <argument><expr><literal type="string">"prof.gdump"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>bv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"prof.interval"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>u64v</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"interval"</literal></expr></argument>, <argument><expr><literal type="string">"prof.interval"</literal></expr></argument>,
		    <argument><expr><name>emitter_type_uint64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u64v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"prof.lg_sample"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssv</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"lg_sample"</literal></expr></argument>, <argument><expr><literal type="string">"prof.lg_sample"</literal></expr></argument>,
		    <argument><expr><name>emitter_type_ssize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "prof". */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* arenas. */</comment>
	<comment type="block">/*
	 * The json output sticks arena info into an "arenas" dict; the table
	 * output puts them at the top-level.
	 */</comment>
	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"arenas"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.narenas"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>uv</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"narenas"</literal></expr></argument>, <argument><expr><literal type="string">"Arenas"</literal></expr></argument>, <argument><expr><name>emitter_type_unsigned</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decay settings are emitted only in json mode; in table mode, they're
	 * emitted as notes with the opt output, above.
	 */</comment>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.dirty_decay_ms"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssv</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dirty_decay_ms"</literal></expr></argument>, <argument><expr><name>emitter_type_ssize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.muzzy_decay_ms"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssv</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"muzzy_decay_ms"</literal></expr></argument>, <argument><expr><name>emitter_type_ssize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.quantum"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"quantum"</literal></expr></argument>, <argument><expr><literal type="string">"Quantum size"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.page"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"page"</literal></expr></argument>, <argument><expr><literal type="string">"Page size"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"arenas.tcache_max"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"tcache_max"</literal></expr></argument>,
		    <argument><expr><literal type="string">"Maximum thread-cached size class"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>nbins</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.nbins"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbins</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nbins"</literal></expr></argument>, <argument><expr><literal type="string">"Number of bin size classes"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_unsigned</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>nhbins</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.nhbins"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nhbins</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nhbins"</literal></expr></argument>, <argument><expr><literal type="string">"Number of thread-cache bin size classes"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_unsigned</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nhbins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do enough mallctls in a loop that we actually want to omit them
	 * (not just omit the printing).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>emitter</name><operator>-&gt;</operator><name>output</name></name> <operator>==</operator> <name>emitter_output_json</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"bin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbins</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.size"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.nregs"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32v</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nregs"</literal></expr></argument>, <argument><expr><name>emitter_type_uint32</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>u32v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.slab_size"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"slab_size"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.bin.0.nshards"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32v</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nshards"</literal></expr></argument>, <argument><expr><name>emitter_type_uint32</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>u32v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "bin". */</comment>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name></type> <name>nlextents</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.nlextents"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlextents</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"nlextents"</literal></expr></argument>, <argument><expr><literal type="string">"Number of large size classes"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_unsigned</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlextents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>emitter</name><operator>-&gt;</operator><name>output</name></name> <operator>==</operator> <name>emitter_output_json</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"lextent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlextents</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.lextent.0.size"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
			    <argument><expr><operator>&amp;</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "lextent". */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "arenas" */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stats_print_helper</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>merged</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>destroyed</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>unmerged</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bins</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>large</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mutex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>extents</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * These should be deleted.  We keep them around for a while, to aid in
	 * the transition to the emitter code.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>allocated</name></decl>, <decl><type ref="prev"/><name>active</name></decl>, <decl><type ref="prev"/><name>metadata</name></decl>, <decl><type ref="prev"/><name>metadata_thp</name></decl>, <decl><type ref="prev"/><name>resident</name></decl>, <decl><type ref="prev"/><name>mapped</name></decl>,
	    <decl><type ref="prev"/><name>retained</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>num_background_threads</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>background_thread_num_runs</name></decl>, <decl><type ref="prev"/><name>background_thread_run_interval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.allocated"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.active"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>active</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.metadata"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.metadata_thp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>metadata_thp</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.resident"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>resident</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.mapped"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mapped</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.retained"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>retained</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_background_thread</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.background_thread.num_threads"</literal></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>num_background_threads</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.background_thread.num_runs"</literal></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>background_thread_num_runs</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"stats.background_thread.run_interval"</literal></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>background_thread_run_interval</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>num_background_threads</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>background_thread_num_runs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>background_thread_run_interval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Generic global stats. */</comment>
	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"stats"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"allocated"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"active"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"metadata"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"metadata_thp"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>metadata_thp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"resident"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"mapped"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"retained"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"Allocated: %zu, active: %zu, "</literal>
	    <literal type="string">"metadata: %zu (n_thp %zu), resident: %zu, mapped: %zu, "</literal>
	    <literal type="string">"retained: %zu\n"</literal></expr></argument>, <argument><expr><name>allocated</name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>metadata_thp</name></expr></argument>,
	    <argument><expr><name>resident</name></expr></argument>, <argument><expr><name>mapped</name></expr></argument>, <argument><expr><name>retained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Background thread stats. */</comment>
	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"background_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"num_threads"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>num_background_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"num_runs"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>background_thread_num_runs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"run_interval"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>background_thread_run_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "background_thread". */</comment>

	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"Background threads: %zu, "</literal>
	    <literal type="string">"num_runs: %"</literal><name>FMTu64</name><literal type="string">", run_interval: %"</literal><name>FMTu64</name><literal type="string">" ns\n"</literal></expr></argument>,
	    <argument><expr><name>num_background_threads</name></expr></argument>, <argument><expr><name>background_thread_num_runs</name></expr></argument>,
	    <argument><expr><name>background_thread_run_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mutex</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>row</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>col64</name><index>[<expr><name>mutex_prof_num_uint64_t_counters</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>emitter_col_t</name></type> <name><name>col32</name><index>[<expr><name>mutex_prof_num_uint32_t_counters</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>uptime</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mutex_stats_init_cols</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>col64</name></expr></argument>, <argument><expr><name>col32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"mutexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_M2_GET</name><argument_list>(<argument><expr><literal type="string">"stats.arenas.0.uptime"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>uptime</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mutex_prof_num_global_mutexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>mutex_stats_read_global</name><argument_list>(<argument><expr><name><name>global_mutex_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>,
			    <argument><expr><name>col64</name></expr></argument>, <argument><expr><name>col32</name></expr></argument>, <argument><expr><name>uptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name><name>global_mutex_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mutex_stats_emit</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>, <argument><expr><name>col64</name></expr></argument>, <argument><expr><name>col32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "mutexes". */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "stats". */</comment>

	<if_stmt><if>if <condition>(<expr><name>merged</name> <operator>||</operator> <name>destroyed</name> <operator>||</operator> <name>unmerged</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>narenas</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"stats.arenas"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CTL_GET</name><argument_list>(<argument><expr><literal type="string">"arenas.narenas"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>narenas</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name><name>mib</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>miblen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>mib</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>VARIABLE_ARRAY</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>initialized</name></expr></argument>, <argument><expr><name>narenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>destroyed_initialized</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>ninitialized</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>xmallctlnametomib</name><argument_list>(<argument><expr><literal type="string">"arena.0.initialized"</literal></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>miblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ninitialized</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xmallctlbymib</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>initialized</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>,
			    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>initialized</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>ninitialized</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MALLCTL_ARENAS_DESTROYED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xmallctlbymib</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><name>miblen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destroyed_initialized</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>,
		    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Merged stats. */</comment>
		<if_stmt><if>if <condition>(<expr><name>merged</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ninitialized</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><name>unmerged</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Print merged arena stats. */</comment>
			<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"Merged arenas stats:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"merged"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>stats_arena_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>MALLCTL_ARENAS_ALL</name></expr></argument>, <argument><expr><name>bins</name></expr></argument>,
			    <argument><expr><name>large</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "merged". */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Destroyed stats. */</comment>
		<if_stmt><if>if <condition>(<expr><name>destroyed_initialized</name> <operator>&amp;&amp;</operator> <name>destroyed</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Print destroyed arena stats. */</comment>
			<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>,
			    <argument><expr><literal type="string">"Destroyed arenas stats:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"destroyed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>stats_arena_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>MALLCTL_ARENAS_DESTROYED</name></expr></argument>,
			    <argument><expr><name>bins</name></expr></argument>, <argument><expr><name>large</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "destroyed". */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Unmerged stats. */</comment>
		<if_stmt><if>if <condition>(<expr><name>unmerged</name></expr>)</condition> <block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narenas</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>initialized</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type> <name><name>arena_ind_str</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>arena_ind_str</name></expr></argument>,
					    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arena_ind_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>,
					    <argument><expr><name>arena_ind_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>,
					    <argument><expr><literal type="string">"arenas[%s]:\n"</literal></expr></argument>, <argument><expr><name>arena_ind_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>stats_arena_print</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bins</name></expr></argument>,
					    <argument><expr><name>large</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Close "&lt;arena-ind&gt;". */</comment>
					<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close "stats.arenas". */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>stats_print</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>write_cb</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbopaque</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>u64sz</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool v = d;</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>STATS_PRINT_OPTIONS</name></type>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPTION</name></cpp:undef>

	<comment type="block">/*
	 * Refresh stats, in case mallctl() was called by the application.
	 *
	 * Check for OOM here, since refreshing the ctl cache can trigger
	 * allocation.  In practice, none of the subsequent mallctl()-related
	 * calls in this function will cause OOM if this one succeeds.
	 * */</comment>
	<name>epoch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>u64sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>je_mallctl</name><argument_list>(<argument><expr><literal type="string">"epoch"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>epoch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u64sz</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>epoch</name></expr></argument>,
	    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Memory allocation failure in "</literal>
			    <literal type="string">"mallctl(\"epoch\", ...)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Failure in mallctl(\"epoch\", "</literal>
		    <literal type="string">"...)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<switch>switch <condition>(<expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case o: v = s; break;</cpp:value></cpp:define>
				<macro><name>STATS_PRINT_OPTIONS</name></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPTION</name></cpp:undef>
			<default>default:</default><empty_stmt>;</empty_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>emitter_t</name></type> <name>emitter</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>,
	    <argument><expr><ternary><condition><expr><name>json</name></expr> ?</condition><then> <expr><name>emitter_output_json</name></expr> </then><else>: <expr><name>emitter_output_table</name></expr></else></ternary></expr></argument>, <argument><expr><name>write_cb</name></expr></argument>,
	    <argument><expr><name>cbopaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"___ Begin jemalloc statistics ___\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"jemalloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>general</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stats_general_print</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stats_print_helper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><name>merged</name></expr></argument>, <argument><expr><name>destroyed</name></expr></argument>, <argument><expr><name>unmerged</name></expr></argument>,
		    <argument><expr><name>bins</name></expr></argument>, <argument><expr><name>large</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>extents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Closes the "jemalloc" dict. */</comment>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"--- End jemalloc statistics ---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
