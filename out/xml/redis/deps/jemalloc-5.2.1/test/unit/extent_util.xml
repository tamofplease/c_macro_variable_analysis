<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/test/unit/extent_util.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test/jemalloc_test.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_UTIL_EINVAL</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>why_inval</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {		\
	assert_d_eq(mallctl("experimental.utilization." node,		\
	    a, b, c, d), EINVAL, "Should fail when " why_inval);	\
	assert_zu_eq(out_sz, out_sz_ref,				\
	    "Output size touched when given invalid arguments");	\
	assert_d_eq(memcmp(out, out_ref, out_sz_ref), 0,		\
	    "Output content touched when given invalid arguments");	\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_UTIL_QUERY_EINVAL</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>why_inval</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>TEST_UTIL_EINVAL("query", a, b, c, d, why_inval)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_UTIL_BATCH_EINVAL</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>why_inval</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>TEST_UTIL_EINVAL("batch_query", a, b, c, d, why_inval)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_UTIL_VALID</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {					\
        assert_d_eq(mallctl("experimental.utilization." node,		\
	    out, &amp;out_sz, in, in_sz), 0,				\
	    "Should return 0 on correct arguments");			\
        assert_zu_eq(out_sz, out_sz_ref, "incorrect output size");	\
	assert_d_ne(memcmp(out, out_ref, out_sz_ref), 0,		\
	    "Output content should be changed");			\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_UTIL_BATCH_VALID</name></cpp:macro> <cpp:value>TEST_UTIL_VALID("batch_query")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_MAX_SIZE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 20)</cpp:value></cpp:define>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_query</argument>)</argument_list></macro> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Select some sizes that can span both small and large sizes, and are
	 * numerically unrelated to any size boundaries.
	 */</comment>
	<for>for <control>(<init><expr><name>sz</name> <operator>=</operator> <literal type="number">7</literal></expr>;</init> <condition><expr><name>sz</name> <operator>&lt;=</operator> <name>TEST_MAX_SIZE</name> <operator>&amp;&amp;</operator> <name>sz</name> <operator>&lt;=</operator> <name>SC_LARGE_MAXCLASS</name></expr>;</condition>
	    <incr><expr><name>sz</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><name>sz</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr> ?</condition><then> <expr><literal type="number">1009</literal></expr> </then><else>: <expr><literal type="number">99989</literal></expr></else></ternary><operator>)</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>mallocx</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>in</name> <init>= <expr><operator>&amp;</operator><name>p</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>in_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>out_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">5</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>mallocx</name><argument_list>(<argument><expr><name>out_sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>out_ref</name> <init>= <expr><call><name>mallocx</name><argument_list>(<argument><expr><name>out_sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>out_sz_ref</name> <init>= <expr><name>out_sz</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert_ptr_not_null</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
		    <argument><expr><literal type="string">"test pointer allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_ptr_not_null</name><argument_list>(<argument><expr><name>out</name></expr></argument>,
		    <argument><expr><literal type="string">"test output allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_ptr_not_null</name><argument_list>(<argument><expr><name>out_ref</name></expr></argument>,
		    <argument><expr><literal type="string">"test reference output allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLABCUR_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(void **)out)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COUNTS</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t *)((void **)out + 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NFREE_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>COUNTS(out)[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NREGS_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>COUNTS(out)[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>COUNTS(out)[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIN_NFREE_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>COUNTS(out)[3]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIN_NREGS_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>COUNTS(out)[4]</cpp:value></cpp:define>

		<expr_stmt><expr><call><name>SLABCUR_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BIN_NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out_ref</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>out_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Test invalid argument(s) errors */</comment>
		<expr_stmt><expr><call><name>TEST_UTIL_QUERY_EINVAL</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"old is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_QUERY_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"oldlenp is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_QUERY_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"newp is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_QUERY_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		    <argument><expr><literal type="string">"newlen is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_QUERY_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"invalid newlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>out_sz_ref</name> <operator>=</operator> <name>out_sz</name> <operator>-=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_QUERY_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"invalid *oldlenp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>out_sz_ref</name> <operator>=</operator> <name>out_sz</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* Examine output for valid call */</comment>
		<expr_stmt><expr><call><name>TEST_UTIL_VALID</name><argument_list>(<argument><expr><literal type="string">"query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><literal type="string">"Extent size should be at least allocation size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>PAGE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		    <argument><expr><literal type="string">"Extent size should be a multiple of page size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Extent free count exceeded region count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Extent region count exceeded size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_zu_ne</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent region count must be positive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_ptr_not_null</name><argument_list>(<argument><expr><call><name>SLABCUR_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Current slab is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
			    <operator>||</operator> <call><name>SLABCUR_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>p</name></expr></argument>,
			    <argument><expr><literal type="string">"Allocation should follow first fit principle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>BIN_NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><literal type="string">"Bin free count exceeded region count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_ne</name><argument_list>(<argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				    <argument><expr><literal type="string">"Bin region count must be positive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>BIN_NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><literal type="string">"Extent free count exceeded bin free count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><literal type="string">"Extent region count exceeded "</literal>
				    <literal type="string">"bin region count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call>
				    <operator>%</operator> <call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				    <argument><expr><literal type="string">"Bin region count isn't a multiple of "</literal>
				    <literal type="string">"extent region count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(
				    <argument><expr><call><name>BIN_NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><literal type="string">"Free count in other extents in the bin "</literal>
				    <literal type="string">"exceeded region count in other extents "</literal>
				    <literal type="string">"in the bin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BIN_NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><literal type="string">"Extent utilized count exceeded "</literal>
				    <literal type="string">"bin utilized count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent free count should be zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent region count should be one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_ptr_null</name><argument_list>(<argument><expr><call><name>SLABCUR_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Current slab must be null for large size classes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>config_stats</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>BIN_NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				    <argument><expr><literal type="string">"Bin free count must be zero for "</literal>
				    <literal type="string">"large sizes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>BIN_NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				    <argument><expr><literal type="string">"Bin region count must be zero for "</literal>
				    <literal type="string">"large sizes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BIN_NREGS_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BIN_NFREE_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SIZE_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NREGS_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NFREE_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COUNTS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLABCUR_READ</name></cpp:undef>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>out_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block>
<function><type><name>TEST_END</name></type>

<name>TEST_BEGIN</name><parameter_list>(<parameter><decl><type><name>test_batch</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Select some sizes that can span both small and large sizes, and are
	 * numerically unrelated to any size boundaries.
	 */</comment>
	<for>for <control>(<init><expr><name>sz</name> <operator>=</operator> <literal type="number">17</literal></expr>;</init> <condition><expr><name>sz</name> <operator>&lt;=</operator> <name>TEST_MAX_SIZE</name> <operator>&amp;&amp;</operator> <name>sz</name> <operator>&lt;=</operator> <name>SC_LARGE_MAXCLASS</name></expr>;</condition>
	    <incr><expr><name>sz</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><name>sz</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr> ?</condition><then> <expr><literal type="number">1019</literal></expr> </then><else>: <expr><literal type="number">99991</literal></expr></else></ternary><operator>)</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>mallocx</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>mallocx</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>in</name><index>[]</index></name> <init>= <expr><block>{<expr><name>p</name></expr>, <expr><name>q</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>in_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name><name>out</name><index>[]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>out_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name><name>out_ref</name><index>[]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>out_sz_ref</name> <init>= <expr><name>out_sz</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert_ptr_not_null</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"test pointer allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_ptr_not_null</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"test pointer allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Test invalid argument(s) errors */</comment>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"old is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"oldlenp is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"newp is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		    <argument><expr><literal type="string">"newlen is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"newlen is not an exact multiple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>out_sz_ref</name> <operator>=</operator> <name>out_sz</name> <operator>-=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"*oldlenp is not an exact multiple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>out_sz_ref</name> <operator>=</operator> <name>out_sz</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_UTIL_BATCH_EINVAL</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_sz</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_sz</name></expr></argument>,
		    <argument><expr><literal type="string">"*oldlenp and newlen do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Examine output for valid calls */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_EQUAL_REF</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>assert_d_eq(memcmp(out + (i) * 3, out_ref + (i) * 3, 3), 0, message)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NFREE_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>out[(i) * 3]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NREGS_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>out[(i) * 3 + 1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_READ</name><parameter_list>(<parameter><type><name>out</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>out[(i) * 3 + 2]</cpp:value></cpp:define>

		<expr_stmt><expr><name>out_sz_ref</name> <operator>=</operator> <name>out_sz</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>TEST_UTIL_BATCH_VALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><literal type="string">"Extent size should be at least allocation size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>PAGE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		    <argument><expr><literal type="string">"Extent size should be a multiple of page size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Extent free count exceeded region count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Extent region count exceeded size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_zu_ne</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent region count must be positive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent free count should be zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent region count should be one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>TEST_EQUAL_REF</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
		    <argument><expr><literal type="string">"Should not overwrite content beyond what's needed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_sz</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>out_sz_ref</name> <operator>=</operator> <name>out_sz</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out_ref</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>TEST_UTIL_BATCH_VALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEST_EQUAL_REF</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Statistics should be stable across calls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <name>SC_SMALL_MAXCLASS</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>assert_zu_le</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><literal type="string">"Extent free count exceeded region count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>NFREE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			    <argument><expr><literal type="string">"Extent free count should be zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NREGS_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><literal type="string">"Extent region count should be same for same region size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZE_READ</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><literal type="string">"Extent size should be same for same region size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SIZE_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NREGS_READ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NFREE_READ</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TEST_EQUAL_REF</name></cpp:undef>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>TEST_END</name>

<name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_zu_lt</name><argument_list>(<argument><expr><name>SC_SMALL_MAXCLASS</name></expr></argument>, <argument><expr><name>TEST_MAX_SIZE</name></expr></argument>,
	    <argument><expr><literal type="string">"Test case cannot cover large classes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>test_query</name></expr></argument>, <argument><expr><name>test_batch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
