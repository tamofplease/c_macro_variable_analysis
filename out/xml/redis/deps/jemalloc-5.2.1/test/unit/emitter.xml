<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/jemalloc-5.2.1/test/unit/emitter.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test/jemalloc_test.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/emitter.h"</cpp:file></cpp:include>

<comment type="block">/*
 * This is so useful for debugging and feature work, we'll leave printing
 * functionality committed but disabled by default.
 */</comment>
<comment type="block">/* Print the text as it will appear. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>print_raw</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Print the text escaped, so it can be copied back into the test case. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>print_escaped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name><name>struct</name> <name>buf_descriptor_s</name></name></type> <name>buf_descriptor_t</name>;</typedef>
<struct>struct <name>buf_descriptor_s</name> <block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>mid_quote</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Forwards all writes to the passed-in buf_v (which should be cast from a
 * buf_descriptor_t *).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>forwarding_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf_descriptor_v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>buf_descriptor_t</name> <modifier>*</modifier></type><name>buf_descriptor</name> <init>= <expr><operator>(</operator><name>buf_descriptor_t</name> <operator>*</operator><operator>)</operator><name>buf_descriptor_v</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>print_raw</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>print_escaped</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>it</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf_descriptor</name><operator>-&gt;</operator><name>mid_quote</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>mid_quote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<switch>switch <condition>(<expr><operator>*</operator><name>it</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\"'</literal></expr>:</case>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"\\n\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>mid_quote</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<expr_stmt><expr><name>it</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>written</name> <init>= <expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,
	    <argument><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_zu_eq</name><argument_list>(<argument><expr><name>written</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Buffer overflow!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>buf</name></name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>len</name></name> <operator>-=</operator> <name>written</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_zu_gt</name><argument_list>(<argument><expr><name><name>buf_descriptor</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Buffer out of space!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assert_emit_output</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>emit_fn</name>)<parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expected_json_output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expected_table_output</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>emitter_t</name></type> <name>emitter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MALLOC_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buf_descriptor_t</name></type> <name>buf_descriptor</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf_descriptor</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_descriptor</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>MALLOC_PRINTF_BUFSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_descriptor</name><operator>.</operator><name>mid_quote</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><name>emitter_output_json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forwarding_cb</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>buf_descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>emit_fn</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_str_eq</name><argument_list>(<argument><expr><name>expected_json_output</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"json output failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buf_descriptor</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_descriptor</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>MALLOC_PRINTF_BUFSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_descriptor</name><operator>.</operator><name>mid_quote</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><name>emitter_output_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forwarding_cb</name></expr></argument>,
	    <argument><expr><operator>&amp;</operator><name>buf_descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>emit_fn</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_str_eq</name><argument_list>(<argument><expr><name>expected_table_output</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"table output failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>emit_dict</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>b_false</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>b_true</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i_123</name> <init>= <expr><literal type="number">123</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><literal type="string">"a string"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="string">"This is the foo table:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="string">"ABC"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b_false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="string">"DEF"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b_true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv_note</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"ghi"</literal></expr></argument>, <argument><expr><literal type="string">"GHI"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i_123</name></expr></argument>,
	    <argument><expr><literal type="string">"note_key1"</literal></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv_note</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"jkl"</literal></expr></argument>, <argument><expr><literal type="string">"JKL"</literal></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
	    <argument><expr><literal type="string">"note_key2"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b_false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dict_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"\t\"foo\": {\n"</literal>
<literal type="string">"\t\t\"abc\": false,\n"</literal>
<literal type="string">"\t\t\"def\": true,\n"</literal>
<literal type="string">"\t\t\"ghi\": 123,\n"</literal>
<literal type="string">"\t\t\"jkl\": \"a string\"\n"</literal>
<literal type="string">"\t}\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dict_table</name> <init>=
<expr><literal type="string">"This is the foo table:\n"</literal>
<literal type="string">"  ABC: false\n"</literal>
<literal type="string">"  DEF: true\n"</literal>
<literal type="string">"  GHI: 123 (note_key1: \"a string\")\n"</literal>
<literal type="string">"  JKL: \"a string\" (note_key2: false)\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_dict</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_dict</name></expr></argument>, <argument><expr><name>dict_json</name></expr></argument>, <argument><expr><name>dict_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type>
<name>emit_table_printf</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"Table note 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_printf</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"Table note 2 %s\n"</literal></expr></argument>,
	    <argument><expr><literal type="string">"with format string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_printf_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_printf_table</name> <init>=
<expr><literal type="string">"Table note 1\n"</literal>
<literal type="string">"Table note 2 with format string\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_table_printf</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_table_printf</name></expr></argument>, <argument><expr><name>table_printf_json</name></expr></argument>,
	    <argument><expr><name>table_printf_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type> <name>emit_nested_dict</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">123</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"json1"</literal></expr></argument>, <argument><expr><literal type="string">"Dict 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"json2"</literal></expr></argument>, <argument><expr><literal type="string">"Dict 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"primitive"</literal></expr></argument>, <argument><expr><literal type="string">"A primitive"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close 2 */</comment>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"json3"</literal></expr></argument>, <argument><expr><literal type="string">"Dict 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close 3 */</comment>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close 1 */</comment>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"json4"</literal></expr></argument>, <argument><expr><literal type="string">"Dict 4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"primitive"</literal></expr></argument>, <argument><expr><literal type="string">"Another primitive"</literal></expr></argument>,
	    <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close 4 */</comment>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nested_object_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"\t\"json1\": {\n"</literal>
<literal type="string">"\t\t\"json2\": {\n"</literal>
<literal type="string">"\t\t\t\"primitive\": 123\n"</literal>
<literal type="string">"\t\t},\n"</literal>
<literal type="string">"\t\t\"json3\": {\n"</literal>
<literal type="string">"\t\t}\n"</literal>
<literal type="string">"\t},\n"</literal>
<literal type="string">"\t\"json4\": {\n"</literal>
<literal type="string">"\t\t\"primitive\": 123\n"</literal>
<literal type="string">"\t}\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nested_object_table</name> <init>=
<expr><literal type="string">"Dict 1\n"</literal>
<literal type="string">"  Dict 2\n"</literal>
<literal type="string">"    A primitive: 123\n"</literal>
<literal type="string">"  Dict 3\n"</literal>
<literal type="string">"Dict 4\n"</literal>
<literal type="string">"  Another primitive: 123\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_nested_dict</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_nested_dict</name></expr></argument>, <argument><expr><name>nested_object_json</name></expr></argument>,
	    <argument><expr><name>nested_object_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type>
<name>emit_types</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>b</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">123</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>u</name> <init>= <expr><literal type="number">123</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>zd</name> <init>= <expr><operator>-</operator><literal type="number">456</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>zu</name> <init>= <expr><literal type="number">456</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><literal type="string">"string"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>u32</name> <init>= <expr><literal type="number">789</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>u64</name> <init>= <expr><literal type="number">10000000000ULL</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k1"</literal></expr></argument>, <argument><expr><literal type="string">"K1"</literal></expr></argument>, <argument><expr><name>emitter_type_bool</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k2"</literal></expr></argument>, <argument><expr><literal type="string">"K2"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k3"</literal></expr></argument>, <argument><expr><literal type="string">"K3"</literal></expr></argument>, <argument><expr><name>emitter_type_unsigned</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k4"</literal></expr></argument>, <argument><expr><literal type="string">"K4"</literal></expr></argument>, <argument><expr><name>emitter_type_ssize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k5"</literal></expr></argument>, <argument><expr><literal type="string">"K5"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k6"</literal></expr></argument>, <argument><expr><literal type="string">"K6"</literal></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k7"</literal></expr></argument>, <argument><expr><literal type="string">"K7"</literal></expr></argument>, <argument><expr><name>emitter_type_uint32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"k8"</literal></expr></argument>, <argument><expr><literal type="string">"K8"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * We don't test the title type, since it's only used for tables.  It's
	 * tested in the emitter_table_row tests.
	 */</comment>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"\t\"k1\": false,\n"</literal>
<literal type="string">"\t\"k2\": -123,\n"</literal>
<literal type="string">"\t\"k3\": 123,\n"</literal>
<literal type="string">"\t\"k4\": -456,\n"</literal>
<literal type="string">"\t\"k5\": 456,\n"</literal>
<literal type="string">"\t\"k6\": \"string\",\n"</literal>
<literal type="string">"\t\"k7\": 789,\n"</literal>
<literal type="string">"\t\"k8\": 10000000000\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types_table</name> <init>=
<expr><literal type="string">"K1: false\n"</literal>
<literal type="string">"K2: -123\n"</literal>
<literal type="string">"K3: 123\n"</literal>
<literal type="string">"K4: -456\n"</literal>
<literal type="string">"K5: 456\n"</literal>
<literal type="string">"K6: \"string\"\n"</literal>
<literal type="string">"K7: 789\n"</literal>
<literal type="string">"K8: 10000000000\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_types</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_types</name></expr></argument>, <argument><expr><name>types_json</name></expr></argument>, <argument><expr><name>types_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type>
<name>emit_modal</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">123</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"j0"</literal></expr></argument>, <argument><expr><literal type="string">"T0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_key</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"j1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"i1"</literal></expr></argument>, <argument><expr><literal type="string">"I1"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"i2"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"I3"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_dict_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"T1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"i4"</literal></expr></argument>, <argument><expr><literal type="string">"I4"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close j1 */</comment>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"i5"</literal></expr></argument>, <argument><expr><literal type="string">"I5"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close T1 */</comment>
	<expr_stmt><expr><call><name>emitter_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"i6"</literal></expr></argument>, <argument><expr><literal type="string">"I6"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_dict_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close j0 / T0 */</comment>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modal_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"\t\"j0\": {\n"</literal>
<literal type="string">"\t\t\"j1\": {\n"</literal>
<literal type="string">"\t\t\t\"i1\": 123,\n"</literal>
<literal type="string">"\t\t\t\"i2\": 123,\n"</literal>
<literal type="string">"\t\t\t\"i4\": 123\n"</literal>
<literal type="string">"\t\t},\n"</literal>
<literal type="string">"\t\t\"i5\": 123,\n"</literal>
<literal type="string">"\t\t\"i6\": 123\n"</literal>
<literal type="string">"\t}\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modal_table</name> <init>=
<expr><literal type="string">"T0\n"</literal>
<literal type="string">"  I1: 123\n"</literal>
<literal type="string">"  I3: 123\n"</literal>
<literal type="string">"  T1\n"</literal>
<literal type="string">"    I4: 123\n"</literal>
<literal type="string">"    I5: 123\n"</literal>
<literal type="string">"  I6: 123\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_modal</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_modal</name></expr></argument>, <argument><expr><name>modal_json</name></expr></argument>, <argument><expr><name>modal_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type>
<name>emit_json_arr</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ival</name> <init>= <expr><literal type="number">123</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_key</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"dict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_key</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"arr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close arr[0] */</comment>
	<comment type="block">/* arr[1] and arr[2] are primitives. */</comment>
	<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"baz"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close arr[3]. */</comment>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close arr. */</comment>
	<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Close dict. */</comment>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>json_array_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"\t\"dict\": {\n"</literal>
<literal type="string">"\t\t\"arr\": [\n"</literal>
<literal type="string">"\t\t\t{\n"</literal>
<literal type="string">"\t\t\t\t\"foo\": 123\n"</literal>
<literal type="string">"\t\t\t},\n"</literal>
<literal type="string">"\t\t\t123,\n"</literal>
<literal type="string">"\t\t\t123,\n"</literal>
<literal type="string">"\t\t\t{\n"</literal>
<literal type="string">"\t\t\t\t\"bar\": 123,\n"</literal>
<literal type="string">"\t\t\t\t\"baz\": 123\n"</literal>
<literal type="string">"\t\t\t}\n"</literal>
<literal type="string">"\t\t]\n"</literal>
<literal type="string">"\t}\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>json_array_table</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_json_arr</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_json_arr</name></expr></argument>, <argument><expr><name>json_array_json</name></expr></argument>, <argument><expr><name>json_array_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type>
<name>emit_json_nested_array</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ival</name> <init>= <expr><literal type="number">123</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sval</name> <init>= <expr><literal type="string">"foo"</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>json_nested_array_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"\t[\n"</literal>
<literal type="string">"\t\t[\n"</literal>
<literal type="string">"\t\t\t123,\n"</literal>
<literal type="string">"\t\t\t\"foo\",\n"</literal>
<literal type="string">"\t\t\t123,\n"</literal>
<literal type="string">"\t\t\t\"foo\"\n"</literal>
<literal type="string">"\t\t],\n"</literal>
<literal type="string">"\t\t[\n"</literal>
<literal type="string">"\t\t\t123\n"</literal>
<literal type="string">"\t\t],\n"</literal>
<literal type="string">"\t\t[\n"</literal>
<literal type="string">"\t\t\t\"foo\",\n"</literal>
<literal type="string">"\t\t\t123\n"</literal>
<literal type="string">"\t\t],\n"</literal>
<literal type="string">"\t\t[\n"</literal>
<literal type="string">"\t\t]\n"</literal>
<literal type="string">"\t]\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_json_nested_arr</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_json_nested_array</name></expr></argument>, <argument><expr><name>json_nested_array_json</name></expr></argument>,
	    <argument><expr><name>json_array_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<specifier>static</specifier> <name>void</name></type>
<name>emit_table_row</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>emitter_row_t</name></type> <name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>abc</name> <init>= <expr><block>{<expr><name>emitter_justify_left</name></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>emitter_type_title</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>abc</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"ABC title"</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>def</name> <init>= <expr><block>{<expr><name>emitter_justify_right</name></expr>, <expr><literal type="number">15</literal></expr>, <expr><name>emitter_type_title</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>def</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"DEF title"</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>emitter_col_t</name></type> <name>ghi</name> <init>= <expr><block>{<expr><name>emitter_justify_right</name></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>emitter_type_title</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ghi</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"GHI"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_row_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_col_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_col_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>def</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_col_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ghi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>abc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_int</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>def</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_bool</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ghi</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_int</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>abc</name><operator>.</operator><name>int_val</name></name> <operator>=</operator> <literal type="number">123</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>def</name><operator>.</operator><name>bool_val</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ghi</name><operator>.</operator><name>int_val</name></name> <operator>=</operator> <literal type="number">456</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>abc</name><operator>.</operator><name>int_val</name></name> <operator>=</operator> <literal type="number">789</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>def</name><operator>.</operator><name>bool_val</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ghi</name><operator>.</operator><name>int_val</name></name> <operator>=</operator> <literal type="number">1011</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>abc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_string</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>abc</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"a string"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>def</name><operator>.</operator><name>bool_val</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ghi</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>emitter_type_title</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ghi</name><operator>.</operator><name>str_val</name></name> <operator>=</operator> <literal type="string">"ghi"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emitter_table_row</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_row_json</name> <init>=
<expr><literal type="string">"{\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_row_table</name> <init>=
<expr><literal type="string">"ABC title       DEF title  GHI\n"</literal>
<literal type="string">"123                  true  456\n"</literal>
<literal type="string">"789                 false 1011\n"</literal>
<literal type="string">"\"a string\"          false  ghi\n"</literal></expr></init></decl>;</decl_stmt>

<macro><name>TEST_BEGIN</name><argument_list>(<argument>test_table_row</argument>)</argument_list></macro> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_emit_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emit_table_row</name></expr></argument>, <argument><expr><name>table_row_json</name></expr></argument>, <argument><expr><name>table_row_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>TEST_END</name>

<name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>test_no_reentrancy</name><argument_list>(
	    <argument><expr><name>test_dict</name></expr></argument>,
	    <argument><expr><name>test_table_printf</name></expr></argument>,
	    <argument><expr><name>test_nested_dict</name></expr></argument>,
	    <argument><expr><name>test_types</name></expr></argument>,
	    <argument><expr><name>test_modal</name></expr></argument>,
	    <argument><expr><name>test_json_arr</name></expr></argument>,
	    <argument><expr><name>test_json_nested_arr</name></expr></argument>,
	    <argument><expr><name>test_table_row</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
