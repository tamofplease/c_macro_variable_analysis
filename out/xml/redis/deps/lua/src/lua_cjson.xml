<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/lua/src/lua_cjson.c"><comment type="block">/* Lua CJSON - JSON support for Lua
 *
 * Copyright (c) 2010-2012  Mark Pulford &lt;mark@kyne.com.au&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */</comment>

<comment type="block">/* Caveats:
 * - JSON "null" values are represented as lightuserdata since Lua
 *   tables cannot contain "nil". Compare with cjson.null.
 * - Invalid UTF-8 characters are not detected and will be passed
 *   untouched. If required, UTF-8 error checking should be done
 *   outside this library.
 * - Javascript comments are not part of the JSON spec, and are not
 *   currently supported.
 *
 * Note: Decoding is slower than encoding. Lua spends significant
 *       time (30%) managing tables when parsing JSON since it is
 *       difficult to know object/array sizes ahead of time.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strbuf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fpconv.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../../src/solarisfixes.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CJSON_MODNAME</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CJSON_MODNAME</name></cpp:macro>   <cpp:value>"cjson"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CJSON_VERSION</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CJSON_VERSION</name></cpp:macro>   <cpp:value>"2.1.0"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Workaround for Solaris platforms missing isinf() */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>isinf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_INTERNAL_ISINF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MISSING_ISINF</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isinf</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!isnan(x) &amp;&amp; isnan((x) - (x)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SPARSE_CONVERT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SPARSE_RATIO</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SPARSE_SAFE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ENCODE_MAX_DEPTH</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_DECODE_MAX_DEPTH</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ENCODE_INVALID_NUMBERS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_DECODE_INVALID_NUMBERS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ENCODE_KEEP_BUFFER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ENCODE_NUMBER_PRECISION</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DISABLE_INVALID_NUMBERS</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFAULT_DECODE_INVALID_NUMBERS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_DECODE_INVALID_NUMBERS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>T_OBJ_BEGIN</name></decl>,
    <decl><name>T_OBJ_END</name></decl>,
    <decl><name>T_ARR_BEGIN</name></decl>,
    <decl><name>T_ARR_END</name></decl>,
    <decl><name>T_STRING</name></decl>,
    <decl><name>T_NUMBER</name></decl>,
    <decl><name>T_BOOLEAN</name></decl>,
    <decl><name>T_NULL</name></decl>,
    <decl><name>T_COLON</name></decl>,
    <decl><name>T_COMMA</name></decl>,
    <decl><name>T_END</name></decl>,
    <decl><name>T_WHITESPACE</name></decl>,
    <decl><name>T_ERROR</name></decl>,
    <decl><name>T_UNKNOWN</name></decl>
}</block></enum></type> <name>json_token_type_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>json_token_type_name</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"T_OBJ_BEGIN"</literal></expr>,
    <expr><literal type="string">"T_OBJ_END"</literal></expr>,
    <expr><literal type="string">"T_ARR_BEGIN"</literal></expr>,
    <expr><literal type="string">"T_ARR_END"</literal></expr>,
    <expr><literal type="string">"T_STRING"</literal></expr>,
    <expr><literal type="string">"T_NUMBER"</literal></expr>,
    <expr><literal type="string">"T_BOOLEAN"</literal></expr>,
    <expr><literal type="string">"T_NULL"</literal></expr>,
    <expr><literal type="string">"T_COLON"</literal></expr>,
    <expr><literal type="string">"T_COMMA"</literal></expr>,
    <expr><literal type="string">"T_END"</literal></expr>,
    <expr><literal type="string">"T_WHITESPACE"</literal></expr>,
    <expr><literal type="string">"T_ERROR"</literal></expr>,
    <expr><literal type="string">"T_UNKNOWN"</literal></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>json_token_type_t</name></type> <name><name>ch2token</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>escape2char</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Decoding */</comment>

    <comment type="block">/* encode_buf is only allocated and used when
     * encode_keep_buffer is set */</comment>
    <decl_stmt><decl><type><name>strbuf_t</name></type> <name>encode_buf</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>encode_sparse_convert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encode_sparse_ratio</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encode_sparse_safe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encode_max_depth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encode_invalid_numbers</name></decl>;</decl_stmt>     <comment type="block">/* 2 =&gt; Encode as "null" */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>encode_number_precision</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>encode_keep_buffer</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>decode_invalid_numbers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>decode_max_depth</name></decl>;</decl_stmt>
}</block></struct></type> <name>json_config_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>    <comment type="block">/* Temporary storage for strings */</comment>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>current_depth</name></decl>;</decl_stmt>
}</block></struct></type> <name>json_parse_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>json_token_type_t</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
    <union>union <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>number</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>boolean</name></decl>;</decl_stmt>
    }</block> <decl><name>value</name></decl>;</union>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>json_token_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>char2escape</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"\\u0000"</literal></expr>, <expr><literal type="string">"\\u0001"</literal></expr>, <expr><literal type="string">"\\u0002"</literal></expr>, <expr><literal type="string">"\\u0003"</literal></expr>,
    <expr><literal type="string">"\\u0004"</literal></expr>, <expr><literal type="string">"\\u0005"</literal></expr>, <expr><literal type="string">"\\u0006"</literal></expr>, <expr><literal type="string">"\\u0007"</literal></expr>,
    <expr><literal type="string">"\\b"</literal></expr>, <expr><literal type="string">"\\t"</literal></expr>, <expr><literal type="string">"\\n"</literal></expr>, <expr><literal type="string">"\\u000b"</literal></expr>,
    <expr><literal type="string">"\\f"</literal></expr>, <expr><literal type="string">"\\r"</literal></expr>, <expr><literal type="string">"\\u000e"</literal></expr>, <expr><literal type="string">"\\u000f"</literal></expr>,
    <expr><literal type="string">"\\u0010"</literal></expr>, <expr><literal type="string">"\\u0011"</literal></expr>, <expr><literal type="string">"\\u0012"</literal></expr>, <expr><literal type="string">"\\u0013"</literal></expr>,
    <expr><literal type="string">"\\u0014"</literal></expr>, <expr><literal type="string">"\\u0015"</literal></expr>, <expr><literal type="string">"\\u0016"</literal></expr>, <expr><literal type="string">"\\u0017"</literal></expr>,
    <expr><literal type="string">"\\u0018"</literal></expr>, <expr><literal type="string">"\\u0019"</literal></expr>, <expr><literal type="string">"\\u001a"</literal></expr>, <expr><literal type="string">"\\u001b"</literal></expr>,
    <expr><literal type="string">"\\u001c"</literal></expr>, <expr><literal type="string">"\\u001d"</literal></expr>, <expr><literal type="string">"\\u001e"</literal></expr>, <expr><literal type="string">"\\u001f"</literal></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"\\\""</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"\\/"</literal></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"\\\\"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"\\u007f"</literal></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ===== CONFIGURATION ===== */</comment>

<function><type><specifier>static</specifier> <name>json_config_t</name> <modifier>*</modifier></type><name>json_fetch_config</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>lua_touserdata</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"BUG: Unable to fetch CJSON configuration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>cfg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Ensure the correct number of arguments have been provided.
 * Pad with nil to allow other functions to simply check arg[i]
 * to find whether an argument was provided */</comment>
<function><type><specifier>static</specifier> <name>json_config_t</name> <modifier>*</modifier></type><name>json_arg_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>args</name></expr></argument>, <argument><expr><name>args</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                  <argument><expr><literal type="string">"found too many arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>args</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <return>return <expr><call><name>json_fetch_config</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Process integer options for configuration functions */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_integer_option</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optindex</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>setting</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>errmsg</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lua_isnil</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>optindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>optindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errmsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"expected integer between %d and %d"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>min</name> <operator>&lt;=</operator> <name>value</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>max</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>setting</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>*</operator><name>setting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Process enumerated arguments for a configuration function */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_enum_option</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optindex</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>setting</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bool_true</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>bool_options</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"off"</literal></expr>, <expr><literal type="string">"on"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>options</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>options</name> <operator>=</operator> <name>bool_options</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bool_true</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lua_isnil</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>optindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>bool_true</name> <operator>&amp;&amp;</operator> <call><name>lua_isboolean</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>optindex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>setting</name> <operator>=</operator> <call><name>lua_toboolean</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>optindex</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>bool_true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>setting</name> <operator>=</operator> <call><name>luaL_checkoption</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>optindex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>bool_true</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>setting</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>setting</name> <operator>==</operator> <name>bool_true</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>*</operator><name>setting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><operator>*</operator><name>setting</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Configures handling of extremely sparse arrays:
 * convert: Convert extremely sparse arrays into objects? Otherwise error.
 * ratio: 0: always allow sparse; 1: never allow sparse; &gt;1: use ratio
 * safe: Always use an array when the max index &lt;= safe */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_encode_sparse_array</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>json_enum_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_convert</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>json_integer_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_ratio</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>json_integer_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_safe</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Configures the maximum number of nested arrays/objects allowed when
 * encoding */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_encode_max_depth</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>json_integer_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_max_depth</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Configures the maximum number of nested arrays/objects allowed when
 * encoding */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_decode_max_depth</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>json_integer_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>decode_max_depth</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Configures number precision when converting doubles to text */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_encode_number_precision</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>json_integer_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_number_precision</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Configures JSON encoding buffer persistence */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_encode_keep_buffer</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_value</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>old_value</name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>json_enum_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Init / free the buffer if the setting has changed */</comment>
    <if_stmt><if>if <condition>(<expr><name>old_value</name> <operator>^</operator> <name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DISABLE_INVALID_NUMBERS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_INTERNAL_FPCONV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>json_verify_invalid_number_setting</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>setting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>setting</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>setting</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"Infinity, NaN, and/or hexadecimal numbers are not supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>json_verify_invalid_number_setting</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>do { } while(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_encode_invalid_numbers</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>options</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"off"</literal></expr>, <expr><literal type="string">"on"</literal></expr>, <expr><literal type="string">"null"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>json_enum_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_invalid_numbers</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>json_verify_invalid_number_setting</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_invalid_numbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>json_cfg_decode_invalid_numbers</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_arg_init</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>json_enum_option</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>decode_invalid_numbers</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>json_verify_invalid_number_setting</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_invalid_numbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>json_destroy_config</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>lua_touserdata</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cfg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_create_config</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>lua_newuserdata</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cfg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create GC method to clean up strbuf */</comment>
    <expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json_destroy_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"__gc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_convert</name></name> <operator>=</operator> <name>DEFAULT_SPARSE_CONVERT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_ratio</name></name> <operator>=</operator> <name>DEFAULT_SPARSE_RATIO</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_safe</name></name> <operator>=</operator> <name>DEFAULT_SPARSE_SAFE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_max_depth</name></name> <operator>=</operator> <name>DEFAULT_ENCODE_MAX_DEPTH</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>decode_max_depth</name></name> <operator>=</operator> <name>DEFAULT_DECODE_MAX_DEPTH</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_invalid_numbers</name></name> <operator>=</operator> <name>DEFAULT_ENCODE_INVALID_NUMBERS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>decode_invalid_numbers</name></name> <operator>=</operator> <name>DEFAULT_DECODE_INVALID_NUMBERS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name> <operator>=</operator> <name>DEFAULT_ENCODE_KEEP_BUFFER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_number_precision</name></name> <operator>=</operator> <name>DEFAULT_ENCODE_NUMBER_PRECISION</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_ENCODE_KEEP_BUFFER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Decoding init */</comment>

    <comment type="block">/* Tag all characters as an error */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>T_ERROR</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Set tokens that require no further processing */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'{'</literal></expr>]</index></name> <operator>=</operator> <name>T_OBJ_BEGIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'}'</literal></expr>]</index></name> <operator>=</operator> <name>T_OBJ_END</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'['</literal></expr>]</index></name> <operator>=</operator> <name>T_ARR_BEGIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">']'</literal></expr>]</index></name> <operator>=</operator> <name>T_ARR_END</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">','</literal></expr>]</index></name> <operator>=</operator> <name>T_COMMA</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">':'</literal></expr>]</index></name> <operator>=</operator> <name>T_COLON</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'\0'</literal></expr>]</index></name> <operator>=</operator> <name>T_END</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">' '</literal></expr>]</index></name> <operator>=</operator> <name>T_WHITESPACE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'\t'</literal></expr>]</index></name> <operator>=</operator> <name>T_WHITESPACE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'\n'</literal></expr>]</index></name> <operator>=</operator> <name>T_WHITESPACE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'\r'</literal></expr>]</index></name> <operator>=</operator> <name>T_WHITESPACE</name></expr>;</expr_stmt>

    <comment type="block">/* Update characters that require further processing */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'f'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>     <comment type="block">/* false? */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'i'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>     <comment type="block">/* inf, ininity? */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'I'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'n'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>     <comment type="block">/* null, nan? */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'N'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'t'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>     <comment type="block">/* true? */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'"'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>     <comment type="block">/* string? */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'+'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>     <comment type="block">/* number? */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'-'</literal></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>ch2token</name><index>[<expr><literal type="char">'0'</literal> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>T_UNKNOWN</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Lookup table for parsing escape characters */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>          <comment type="block">/* String error */</comment>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'"'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'\\'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'/'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'b'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'t'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'n'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'f'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'r'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>escape2char</name><index>[<expr><literal type="char">'u'</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>          <comment type="block">/* Unicode parsing required */</comment>
</block_content>}</block></function>

<comment type="block">/* ===== ENCODING ===== */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_encode_exception</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lindex</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"Cannot serialise %s: %s"</literal></expr></argument>,
                  <argument><expr><call><name>lua_typename</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_type</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lindex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* json_append_string args:
 * - lua_State
 * - JSON strbuf
 * - String (Lua stack index)
 *
 * Returns nothing. Doesn't remove string from Lua stack */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_append_string</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>escstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>lua_tolstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lindex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Worst case is len * 6 (all unicode escapes).
     * This buffer is reused constantly for small strings
     * If there are any excess pages, they won't be hit anyway.
     * This gains ~5% speedup. */</comment>
    <expr_stmt><expr><call><name>strbuf_ensure_empty_length</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>len</name> <operator>*</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strbuf_append_char_unsafe</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">'\"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>escstr</name> <operator>=</operator> <name><name>char2escape</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>escstr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_append_string</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>escstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_append_char_unsafe</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>strbuf_append_char_unsafe</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">'\"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Find the size of the array on the top of the Lua stack
 * -1   object (not a pure array)
 * &gt;=0  elements in array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_array_length</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>items</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>items</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* table, startkey */</comment>
    <while>while <condition>(<expr><call><name>lua_next</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* table, key, value */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNUMBER</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>k</name> <operator>=</operator> <call><name>lua_tonumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Integer &gt;= 1 ? */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>floor</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>k</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>max</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>items</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Must not be an array (non integer key) */</comment>
        <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></while>

    <comment type="block">/* Encode excessively sparse arrays as objects (if enabled) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_ratio</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name>max</name> <operator>&gt;</operator> <name>items</name> <operator>*</operator> <name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_ratio</name></name> <operator>&amp;&amp;</operator>
        <name>max</name> <operator>&gt;</operator> <name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_safe</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_sparse_convert</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_encode_exception</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"excessively sparse array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>max</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_check_encode_depth</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name></type> <name>current_depth</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Ensure there are enough slots free to traverse a table (key,
     * value) and push a string for a potential error message.
     *
     * Unlike "decode", the key and value are still on the stack when
     * lua_checkstack() is called.  Hence an extra slot for luaL_error()
     * below is required just in case the next check to lua_checkstack()
     * fails.
     *
     * While this won't cause a crash due to the EXTRA_STACK reserve
     * slots, it would still be an improper use of the API. */</comment>
    <if_stmt><if>if <condition>(<expr><name>current_depth</name> <operator>&lt;=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>encode_max_depth</name></name> <operator>&amp;&amp;</operator> <call><name>lua_checkstack</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"Cannot serialise, excessive nesting (%d)"</literal></expr></argument>,
               <argument><expr><name>current_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>json_append_data</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>current_depth</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* json_append_array args:
 * - lua_State
 * - JSON strbuf
 * - Size of passwd Lua array (top of stack) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_append_array</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>current_depth</name></decl></parameter>,
                              <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>array_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>comma</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>comma</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>array_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>comma</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>json_append_data</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>current_depth</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_append_number</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>,
                               <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>num</name> <init>= <expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_invalid_numbers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Prevent encoding invalid numbers */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_encode_exception</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><name>lindex</name></expr></argument>, <argument><expr><literal type="string">"must not be NaN or Inf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_invalid_numbers</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Encode invalid numbers, but handle "nan" separately
         * since some platforms may encode as "-nan". */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"nan"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Encode invalid numbers as "null" */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>strbuf_ensure_empty_length</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>FPCONV_G_FMT_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>fpconv_g_fmt</name><argument_list>(<argument><expr><call><name>strbuf_empty_ptr</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name><name>cfg</name><operator>-&gt;</operator><name>encode_number_precision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strbuf_extend_length</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_append_object</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>current_depth</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>comma</name></decl>, <decl><type ref="prev"/><name>keytype</name></decl>;</decl_stmt>

    <comment type="block">/* Object */</comment>
    <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* table, startkey */</comment>
    <expr_stmt><expr><name>comma</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>lua_next</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>comma</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* table, key, value */</comment>
        <expr_stmt><expr><name>keytype</name> <operator>=</operator> <call><name>lua_type</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>keytype</name> <operator>==</operator> <name>LUA_TNUMBER</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>json_append_number</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"\":"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>keytype</name> <operator>==</operator> <name>LUA_TSTRING</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>json_append_string</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>json_encode_exception</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,
                                  <argument><expr><literal type="string">"table key must be a number or string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* never returns */</comment>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* table, key, value */</comment>
        <expr_stmt><expr><call><name>json_append_data</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>current_depth</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* table, key */</comment>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>strbuf_append_char</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Serialise Lua data into JSON string. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_append_data</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>current_depth</name></decl></parameter>, <parameter><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_TSTRING</name></expr>:</case>
        <expr_stmt><expr><call><name>json_append_string</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>LUA_TNUMBER</name></expr>:</case>
        <expr_stmt><expr><call><name>json_append_number</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>LUA_TBOOLEAN</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <break>break;</break>
    <case>case <expr><name>LUA_TTABLE</name></expr>:</case>
        <expr_stmt><expr><name>current_depth</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>json_check_encode_depth</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>current_depth</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lua_array_length</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_append_array</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>current_depth</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_append_object</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>current_depth</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <break>break;</break>
    <case>case <expr><name>LUA_TNIL</name></expr>:</case>
        <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>LUA_TLIGHTUSERDATA</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>strbuf_append_mem</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    <default>default:</default>
        <comment type="block">/* Remaining types (LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD,
         * and LUA_TLIGHTUSERDATA) cannot be serialised */</comment>
        <expr_stmt><expr><call><name>json_encode_exception</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"type not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* never returns */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>json_encode</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_config_t</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><call><name>json_fetch_config</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>strbuf_t</name></type> <name>local_encode_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>strbuf_t</name> <modifier>*</modifier></type><name>encode_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"expected 1 argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Use private buffer */</comment>
        <expr_stmt><expr><name>encode_buf</name> <operator>=</operator> <operator>&amp;</operator><name>local_encode_buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><name>encode_buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Reuse existing buffer */</comment>
        <expr_stmt><expr><name>encode_buf</name> <operator>=</operator> <operator>&amp;</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_buf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>encode_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>json_append_data</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>encode_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>json</name> <operator>=</operator> <call><name>strbuf_string</name><argument_list>(<argument><expr><name>encode_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cfg</name><operator>-&gt;</operator><name>encode_keep_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><name>encode_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===== DECODING ===== */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>json_process_value</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>,
                               <parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hexdigit2int</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>hex</name>  <operator>&amp;&amp;</operator> <name>hex</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>hex</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Force lowercase */</comment>
    <expr_stmt><expr><name>hex</name> <operator>|=</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="char">'a'</literal> <operator>&lt;=</operator> <name>hex</name> <operator>&amp;&amp;</operator> <name>hex</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">10</literal> <operator>+</operator> <name>hex</name> <operator>-</operator> <literal type="char">'a'</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_hex4</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name><name>digit</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Convert ASCII hex digit to numeric digit
     * Note: this returns an error for invalid hex digits, including
     *       NULL */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>digit</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>hexdigit2int</name><argument_list>(<argument><expr><name><name>hex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>digit</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>(</operator><name><name>digit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>+</operator>
           <operator>(</operator><name><name>digit</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator>
           <operator>(</operator><name><name>digit</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator>
            <name><name>digit</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Converts a Unicode codepoint to UTF-8.
 * Returns UTF-8 string length, and up to 4 bytes in *utf8 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codepoint_to_utf8</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>utf8</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>codepoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* 0xxxxxxx */</comment>
    <if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&lt;=</operator> <literal type="number">0x7F</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>codepoint</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 110xxxxx 10xxxxxx */</comment>
    <if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&lt;=</operator> <literal type="number">0x7FF</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xC0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 1110xxxx 10xxxxxx 10xxxxxx */</comment>
    <if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&lt;=</operator> <literal type="number">0xFFFF</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xE0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>codepoint</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */</comment>
    <if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&lt;=</operator> <literal type="number">0x1FFFFF</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xF0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>codepoint</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>codepoint</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>utf8</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Called when index pointing to beginning of UTF-16 code escape: \uXXXX
 * \u is guaranteed to exist, but the remaining hex characters may be
 * missing.
 * Translate to UTF-8 and append to temporary token string.
 * Must advance index to the next character to be processed.
 * Returns: 0   success
 *          -1  error
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_append_unicode_escape</name><parameter_list>(<parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>utf8</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Surrogate pairs require 4 UTF-8 bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>codepoint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>surrogate_low</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>escape_len</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Fetch UTF-16 code unit */</comment>
    <expr_stmt><expr><name>codepoint</name> <operator>=</operator> <call><name>decode_hex4</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* UTF-16 surrogate pairs take the following 2 byte form:
     *      11011 x yyyyyyyyyy
     * When x = 0: y is the high 10 bits of the codepoint
     *      x = 1: y is the low 10 bits of the codepoint
     *
     * Check for a surrogate pair (high or low) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0xF800</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xD800</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Error if the 1st surrogate is not high */</comment>
        <if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0x400</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Ensure the next code is a unicode escape */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name>escape_len</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>||</operator>
            <operator>*</operator><operator>(</operator><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name>escape_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Fetch the next codepoint */</comment>
        <expr_stmt><expr><name>surrogate_low</name> <operator>=</operator> <call><name>decode_hex4</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>escape_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>surrogate_low</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Error if the 2nd code is not a low surrogate */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>surrogate_low</name> <operator>&amp;</operator> <literal type="number">0xFC00</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xDC00</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Calculate Unicode codepoint */</comment>
        <expr_stmt><expr><name>codepoint</name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0x3FF</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>surrogate_low</name> <operator>&amp;=</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>codepoint</name> <operator>=</operator> <operator>(</operator><name>codepoint</name> <operator>|</operator> <name>surrogate_low</name><operator>)</operator> <operator>+</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>escape_len</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Convert codepoint to UTF-8 */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>codepoint_to_utf8</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>, <argument><expr><name>codepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Append bytes and advance parse index */</comment>
    <expr_stmt><expr><call><name>strbuf_append_mem_unsafe</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <name>escape_len</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_set_token_error</name><parameter_list>(<parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>json</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>string</name></name> <operator>=</operator> <name>errtype</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_next_string_token</name><parameter_list>(<parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escape2char</name> <init>= <expr><name><name>json</name><operator>-&gt;</operator><name>cfg</name><operator>-&gt;</operator><name>escape2char</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

    <comment type="block">/* Caller must ensure a string is next */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Skip " */</comment>
    <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* json-&gt;tmp is the temporary strbuf used to accumulate the
     * decoded string value.
     * json-&gt;tmp is sized to handle JSON containing only a string value.
     */</comment>
    <expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ch</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Premature end of the string */</comment>
            <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Handle escapes */</comment>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Fetch escape character */</comment>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

            <comment type="block">/* Translate escape code and append to tmp string */</comment>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <name><name>escape2char</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>ch</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>json_append_unicode_escape</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>,
                                     <argument><expr><literal type="string">"invalid unicode escape code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ch</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"invalid escape code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Skip '\' */</comment>
            <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Append normal character or translated single character
         * Unicode escapes are handled above */</comment>
        <expr_stmt><expr><call><name>strbuf_append_char_unsafe</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* Eat final quote (") */</comment>

    <expr_stmt><expr><call><name>strbuf_ensure_null</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>strbuf_string</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>token</name><operator>-&gt;</operator><name>string_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* JSON numbers should take the following form:
 *      -?(0|[1-9]|[1-9][0-9]+)(.[0-9]+)?([eE][-+]?[0-9]+)?
 *
 * json_next_number_token() uses strtod() which allows other forms:
 * - numbers starting with '+'
 * - NaN, -NaN, infinity, -infinity
 * - hexadecimal numbers
 * - numbers with leading zeros
 *
 * json_is_invalid_number() detects "numbers" which may pass strtod()'s
 * error checking, but should not be allowed with strict JSON.
 *
 * json_is_invalid_number() may pass numbers which cause strtod()
 * to generate an error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_is_invalid_number</name><parameter_list>(<parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Reject numbers starting with + */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Skip minus sign if it exists */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Reject numbers starting with 0x, or leading zeros */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ch2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch2</name> <operator>|</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator>          <comment type="block">/* Hex */</comment>
            <operator>(</operator><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>ch2</name> <operator>&amp;&amp;</operator> <name>ch2</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>     <comment type="block">/* Leading zero */</comment>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>                           <comment type="block">/* Ordinary number */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Reject inf/nan */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"nan"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Pass all other numbers which may still be invalid, but
     * strtod() will catch them. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_next_number_token</name><parameter_list>(<parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_NUMBER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>number</name></name> <operator>=</operator> <call><name>fpconv_strtod</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"invalid number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>     <comment type="block">/* Skip the processed number */</comment>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Fills in the token struct.
 * T_STRING will return a pointer to the json_parse_t temporary string
 * T_ERROR will leave the json-&gt;ptr pointer at the error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_next_token</name><parameter_list>(<parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>json_token_type_t</name> <modifier>*</modifier></type><name>ch2token</name> <init>= <expr><name><name>json</name><operator>-&gt;</operator><name>cfg</name><operator>-&gt;</operator><name>ch2token</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>

    <comment type="block">/* Eat whitespace. */</comment>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>ch2token</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>T_WHITESPACE</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Store location of new token. Required when throwing errors
     * for unexpected tokens (syntax errors). */</comment>
    <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>json</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

    <comment type="block">/* Don't advance the pointer for an error or the end */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_ERROR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"invalid token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_END</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Found a known single character token, advance index and return */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>T_UNKNOWN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process characters which triggered T_UNKNOWN
     *
     * Must use strncmp() to match the front of the JSON string.
     * JSON identifier must be lowercase.
     * When strict_numbers if disabled, either case is allowed for
     * Infinity/NaN (since we are no longer following the spec..) */</comment>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>json_next_string_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>(</operator><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>json</name><operator>-&gt;</operator><name>cfg</name><operator>-&gt;</operator><name>decode_invalid_numbers</name></name> <operator>&amp;&amp;</operator> <call><name>json_is_invalid_number</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"invalid number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>json_next_number_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_BOOLEAN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_BOOLEAN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>json</name><operator>-&gt;</operator><name>cfg</name><operator>-&gt;</operator><name>decode_invalid_numbers</name></name> <operator>&amp;&amp;</operator>
               <call><name>json_is_invalid_number</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* When decode_invalid_numbers is enabled, only attempt to process
         * numbers we know are invalid JSON (Inf, NaN, hex)
         * This is required to generate an appropriate token error,
         * otherwise all bad tokens will register as "invalid number"
         */</comment>
        <expr_stmt><expr><call><name>json_next_number_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Token starts with t/f/n but isn't recognised above. */</comment>
    <expr_stmt><expr><call><name>json_set_token_error</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"invalid token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function does not return.
 * DO NOT CALL WITH DYNAMIC MEMORY ALLOCATED.
 * The only supported exception is the temporary parser string
 * json-&gt;tmp struct.
 * json and token should exist on the stack somewhere.
 * luaL_error() will long_jmp and release the stack */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_throw_parse_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>, <parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>string</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name><name>json_token_type_name</name><index>[<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Note: token-&gt;index is 0 based, display starting from 1 */</comment>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"Expected %s but found %s at character %d"</literal></expr></argument>,
               <argument><expr><name>exp</name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>index</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>json_decode_ascend</name><parameter_list>(<parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>current_depth</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_decode_descend</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>json</name><operator>-&gt;</operator><name>current_depth</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>json</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>&lt;=</operator> <name><name>json</name><operator>-&gt;</operator><name>cfg</name><operator>-&gt;</operator><name>decode_max_depth</name></name> <operator>&amp;&amp;</operator>
        <call><name>lua_checkstack</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><name><name>json</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"Found too many nested data structures (%d) at character %d"</literal></expr></argument>,
        <argument><expr><name><name>json</name><operator>-&gt;</operator><name>current_depth</name></name></expr></argument>, <argument><expr><name><name>json</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>json</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>json_parse_object_context</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_token_t</name></type> <name>token</name></decl>;</decl_stmt>

    <comment type="block">/* 3 slots required:
     * .., table, key, value */</comment>
    <expr_stmt><expr><call><name>json_decode_descend</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Handle empty objects */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_OBJ_END</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>json_decode_ascend</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>T_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_throw_parse_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"object key string"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Push key */</comment>
        <expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>value</name><operator>.</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>string_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>T_COLON</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_throw_parse_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"colon"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Fetch value */</comment>
        <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>json_process_value</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set key = value */</comment>
        <expr_stmt><expr><call><name>lua_rawset</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_OBJ_END</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>json_decode_ascend</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>T_COMMA</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_throw_parse_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"comma or object end"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Handle the array context */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_parse_array_context</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_token_t</name></type> <name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* 2 slots required:
     * .., table, value */</comment>
    <expr_stmt><expr><call><name>json_decode_descend</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Handle empty arrays */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARR_END</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>json_decode_ascend</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>json_process_value</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* arr[i] = value */</comment>

        <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_ARR_END</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>json_decode_ascend</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>T_COMMA</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>json_throw_parse_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"comma or array end"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Handle the "value" context */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>json_process_value</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>json_parse_t</name> <modifier>*</modifier></type><name>json</name></decl></parameter>,
                               <parameter><decl><type><name>json_token_t</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>T_STRING</name></expr>:</case>
        <expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>string_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break><empty_stmt>;</empty_stmt>
    <case>case <expr><name>T_NUMBER</name></expr>:</case>
        <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break><empty_stmt>;</empty_stmt>
    <case>case <expr><name>T_BOOLEAN</name></expr>:</case>
        <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>boolean</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break><empty_stmt>;</empty_stmt>
    <case>case <expr><name>T_OBJ_BEGIN</name></expr>:</case>
        <expr_stmt><expr><call><name>json_parse_object_context</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break><empty_stmt>;</empty_stmt>
    <case>case <expr><name>T_ARR_BEGIN</name></expr>:</case>
        <expr_stmt><expr><call><name>json_parse_array_context</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break><empty_stmt>;</empty_stmt>
    <case>case <expr><name>T_NULL</name></expr>:</case>
        <comment type="block">/* In Lua, setting "t[k] = nil" will delete k from the table.
         * Hence a NULL pointer lightuserdata object is used instead */</comment>
        <expr_stmt><expr><call><name>lua_pushlightuserdata</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break><empty_stmt>;</empty_stmt>
    <default>default:</default>
        <expr_stmt><expr><call><name>json_throw_parse_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>json_decode</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>json_parse_t</name></type> <name>json</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>json_token_t</name></type> <name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>json_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"expected 1 argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>json</name><operator>.</operator><name>cfg</name></name> <operator>=</operator> <call><name>json_fetch_config</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>json</name><operator>.</operator><name>data</name></name> <operator>=</operator> <call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>json_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>json</name><operator>.</operator><name>current_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>json</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name><name>json</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

    <comment type="block">/* Detect Unicode other than UTF-8 (see RFC 4627, Sec 3)
     *
     * CJSON can support any simple data type, hence only the first
     * character is guaranteed to be ASCII (at worst: '"'). This is
     * still enough to detect whether the wrong encoding is in use. */</comment>
    <if_stmt><if>if <condition>(<expr><name>json_len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>json</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>json</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"JSON parser does not support UTF-16 or UTF-32"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Ensure the temporary buffer can hold the entire string.
     * This means we no longer need to do length checks since the decoded
     * string must be smaller than the entire json string */</comment>
    <expr_stmt><expr><name><name>json</name><operator>.</operator><name>tmp</name></name> <operator>=</operator> <call><name>strbuf_new</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>json_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                       <comment type="block">/* WIN_PORT_FIX cast (int) */</comment>

    <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><operator>&amp;</operator><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>json_process_value</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Ensure there is no more input left */</comment>
    <expr_stmt><expr><call><name>json_next_token</name><argument_list>(<argument><expr><operator>&amp;</operator><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>T_END</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>json_throw_parse_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>json</name></expr></argument>, <argument><expr><literal type="string">"the end"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>strbuf_free</name><argument_list>(<argument><expr><name><name>json</name><operator>.</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ===== INITIALISATION ===== */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_VERSION_NUM</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>LUA_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">502</literal></expr></cpp:if>
<comment type="block">/* Compatibility for Lua 5.1.
 *
 * luaL_setfuncs() is used to create a module table where the functions have
 * json_config_t as their first upvalue. Code borrowed from Lua 5.2 source. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_setfuncs</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>luaL_Reg</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>nup</name></expr></argument>, <argument><expr><literal type="string">"too many upvalues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>reg</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* fill the table with given functions */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nup</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* copy upvalues to the top */</comment>
            <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><name>nup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name>nup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* closure with those upvalues */</comment>
        <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>nup</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>nup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove upvalues */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Call target function in protected mode with all supplied args.
 * Assumes target function only returns a single non-nil value.
 * Convert and return thrown errors as: nil, "error message" */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>json_protect_conversion</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

    <comment type="block">/* Deliberately throw an error for invalid arguments */</comment>
    <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"expected 1 argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pcall() the function stored as upvalue(1) */</comment>
    <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>lua_pcall</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>LUA_ERRRUN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Since we are not using a custom error handler, the only remaining
     * errors are memory related */</comment>
    <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"Memory allocation error in CJSON protected call"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return cjson module table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_cjson_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>luaL_Reg</name></type> <name><name>reg</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><literal type="string">"encode"</literal></expr>, <expr><name>json_encode</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"decode"</literal></expr>, <expr><name>json_decode</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"encode_sparse_array"</literal></expr>, <expr><name>json_cfg_encode_sparse_array</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"encode_max_depth"</literal></expr>, <expr><name>json_cfg_encode_max_depth</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"decode_max_depth"</literal></expr>, <expr><name>json_cfg_decode_max_depth</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"encode_number_precision"</literal></expr>, <expr><name>json_cfg_encode_number_precision</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"encode_keep_buffer"</literal></expr>, <expr><name>json_cfg_encode_keep_buffer</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"encode_invalid_numbers"</literal></expr>, <expr><name>json_cfg_encode_invalid_numbers</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"decode_invalid_numbers"</literal></expr>, <expr><name>json_cfg_decode_invalid_numbers</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"new"</literal></expr>, <expr><name>lua_cjson_new</name></expr> }</block></expr>,
        <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Initialise number conversions */</comment>
    <expr_stmt><expr><call><name>fpconv_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* cjson module table */</comment>
    <expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Register functions with config data as upvalue */</comment>
    <expr_stmt><expr><call><name>json_create_config</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaL_setfuncs</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set cjson.null */</comment>
    <expr_stmt><expr><call><name>lua_pushlightuserdata</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set module name / version fields */</comment>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>CJSON_MODNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"_NAME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>CJSON_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"_VERSION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return cjson.safe module table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_cjson_safe_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>func</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"decode"</literal></expr>, <expr><literal type="string">"encode"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lua_cjson_new</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fix new() method */</comment>
    <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lua_cjson_safe_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>func</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>func</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>json_protect_conversion</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>func</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaopen_cjson</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>lua_cjson_new</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_CJSON_GLOBAL</name></cpp:ifdef>
    <comment type="block">/* Register a global "cjson" table. */</comment>
    <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>CJSON_MODNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Return cjson table */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaopen_cjson_safe</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>lua_cjson_safe_new</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return cjson.safe table */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* vi:ai et sw=4 ts=4:
 */</comment>
</unit>
