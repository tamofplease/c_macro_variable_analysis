<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/deps/lua/src/ldo.c"><comment type="block">/*
** $Id: ldo.c,v 2.38.1.4 2012/01/18 02:27:10 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ldo_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lopcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lundump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lvm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lzio.h"</cpp:file></cpp:include>




<comment type="block">/*
** {======================================================
** Error-recovery functions
** =======================================================
*/</comment>


<comment type="block">/* chain list of long jump buffers */</comment>
<struct>struct <name>lua_longjmp</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name> <modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>luai_jmpbuf</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>status</name></decl>;</decl_stmt>  <comment type="block">/* error code */</comment>
}</block>;</struct>


<function><type><name>void</name></type> <name>luaD_seterrorobj</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>oldtop</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_ERRMEM</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>MEMERRMSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_ERRERR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"error in error handling"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_ERRSYNTAX</name></expr>:</case>
    <case>case <expr><name>LUA_ERRRUN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* error message on current top */</comment>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>oldtop</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>restore_stack_limit</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>-</operator> <name>EXTRA_STACK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&gt;</operator> <name>LUAI_MAXCALLS</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* there was an overflow? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>inuse</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>inuse</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>LUAI_MAXCALLS</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* can `undo' overflow? */</comment>
      <expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUAI_MAXCALLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>resetstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close eventual pending closures */</comment>
  <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>restore_stack_limit</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_throw</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LUAI_THROW</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>resetstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>panic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaD_rawrunprotected</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Pfunc</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name></type> <name>lj</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>lj</name><operator>.</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lj</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>;</expr_stmt>  <comment type="block">/* chain new error handler */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name> <operator>=</operator> <operator>&amp;</operator><name>lj</name></expr>;</expr_stmt>
  <macro><name>LUAI_TRY</name><argument_list>(<argument>L</argument>, <argument>&amp;lj</argument>,
    <argument>(*f)(L, ud);</argument>
  )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name> <operator>=</operator> <name><name>lj</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>  <comment type="block">/* restore old error handler */</comment>
  <return>return <expr><name><name>lj</name><operator>.</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>correctstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>oldstack</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>up</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>up</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr>;</init> <condition><expr><name>up</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>up</name> <operator>=</operator> <name><name>up</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>up</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>v</name> <operator>=</operator> <operator>(</operator><call><name>gco2uv</name><argument_list>(<argument><expr><name>up</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>v</name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</init> <condition><expr><name>ci</name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</condition> <incr><expr><name>ci</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_reallocstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>oldstack</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>realsize</name> <init>= <expr><name>newsize</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>EXTRA_STACK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>-</operator> <name>EXTRA_STACK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>, <argument><expr><name>realsize</name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>=</operator> <name>realsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name><operator>+</operator><name>newsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>correctstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_reallocCI</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>oldci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>CallInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>-</operator> <name>oldci</name><operator>)</operator> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>end_ci</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_growstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* double size is enough? */</comment>
    <expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>CallInfo</name> <modifier>*</modifier></type><name>growCI</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&gt;</operator> <name>LUAI_MAXCALLS</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* overflow while handling overflow? */</comment>
    <expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&gt;</operator> <name>LUAI_MAXCALLS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"stack overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>++</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_callhook</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Hook</name></type> <name>hook</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>hook</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hook</name> <operator>&amp;&amp;</operator> <name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ci_top</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lua_Debug</name></type> <name>ar</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>event</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>currentline</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>LUA_HOOKTAILRET</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>i_ci</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* tail call; no debug information about it */</comment>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>i_ci</name></name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure minimum stack size */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>LUA_MINSTACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* cannot call hooks inside a hook */</comment>
    <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call>(<modifier>*</modifier><name>hook</name>)<argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StkId</name></type> <name>adjust_varargs</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>actual</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nfixargs</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>htab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>fixed</name></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>actual</name> <operator>&lt;</operator> <name>nfixargs</name></expr>;</condition> <incr><expr><operator>++</operator><name>actual</name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_COMPAT_VARARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>&amp;</operator> <name>VARARG_NEEDSARG</name></expr>)</condition> <block>{<block_content> <comment type="block">/* compat. with old-style vararg? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nvar</name> <init>= <expr><name>actual</name> <operator>-</operator> <name>nfixargs</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of extra arguments */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>&amp;</operator> <name>VARARG_HASARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nvar</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create `arg' table */</comment>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nvar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* put extra arguments into `arg' table */</comment>
      <expr_stmt><expr><call><name>setobj2n</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaH_setnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>htab</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>nvar</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <comment type="block">/* store counter in field `n' */</comment>
    <expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><call><name>luaH_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>htab</name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>nvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* move fixed parameters to final position */</comment>
  <expr_stmt><expr><name>fixed</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>actual</name></expr>;</expr_stmt>  <comment type="block">/* first fixed argument */</comment>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>  <comment type="block">/* final position of first argument */</comment>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nfixargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>fixed</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>fixed</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <comment type="block">/* add `arg' parameter */</comment>
  <if_stmt><if>if <condition>(<expr><name>htab</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>iswhite</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>base</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StkId</name></type> <name>tryfuncTM</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name> <init>= <expr><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>TM_CALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>funcr</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttisfunction</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="string">"call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* Open a hole inside the stack at `func' */</comment>
  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&gt;</operator> <name>func</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* previous call may change stack */</comment>
  <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* tag method is the new function to be called */</comment>
  <return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inc_ci</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((L-&gt;ci == L-&gt;end_ci) ? growCI(L) : \
   (condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci)), ++L-&gt;ci))</cpp:value></cpp:define>


<function><type><name>int</name></type> <name>luaD_precall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LClosure</name> <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>funcr</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttisfunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* `func' is not a function? */</comment>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>tryfuncTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* check the `function' tag method */</comment>
  <expr_stmt><expr><name>funcr</name> <operator>=</operator> <call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cl</name> <operator>=</operator> <operator>&amp;</operator><call><name>clvalue</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>l</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cl</name><operator>-&gt;</operator><name>isC</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Lua function? prepare its call */</comment>
    <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StkId</name></type> <name>st</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>cl</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no varargs? */</comment>
      <expr_stmt><expr><name>base</name> <operator>=</operator> <name>func</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&gt;</operator> <name>base</name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* vararg function */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>func</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>adjust_varargs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* previous call may change the stack */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>inc_ci</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* now `enter' new function */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>code</name></name></expr>;</expr_stmt>  <comment type="block">/* starting point */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>tailcalls</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name> <operator>=</operator> <name>nresults</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>st</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</init> <condition><expr><name>st</name> <operator>&lt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition> <incr><expr><name>st</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCALL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* hooks assume 'pc' is already incremented */</comment>
      <expr_stmt><expr><call><name>luaD_callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKCALL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* correct 'pc' */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>PCRLUA</name></expr>;</return>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* if is a C function, call it */</comment>
    <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure minimum stack size */</comment>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>inc_ci</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* now `enter' new function */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>LUA_MINSTACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name> <operator>=</operator> <name>nresults</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCALL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaD_callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKCALL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><operator>*</operator><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>f</name></name><operator>)</operator><operator>(</operator><name>L</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* do the actual call */</comment>
    <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* yielding? */</comment>
      <return>return <expr><name>PCRYIELD</name></expr>;</return></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PCRC</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StkId</name></type> <name>callrethooks</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>firstResult</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>fr</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>firstResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* next call may change stack */</comment>
  <expr_stmt><expr><call><name>luaD_callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKRET</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>f_isLua</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Lua function? */</comment>
    <while>while <condition>(<expr><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKRET</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>tailcalls</name></name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* tail calls */</comment>
      <expr_stmt><expr><call><name>luaD_callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKTAILRET</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaD_poscall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>firstResult</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>StkId</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wanted</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKRET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>firstResult</name> <operator>=</operator> <call><name>callrethooks</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>firstResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>  <comment type="block">/* res == final position of 1st result */</comment>
  <expr_stmt><expr><name>wanted</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <operator>(</operator><name>ci</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>base</name></expr>;</expr_stmt>  <comment type="block">/* restore base */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name> <operator>=</operator> <operator>(</operator><name>ci</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>savedpc</name></expr>;</expr_stmt>  <comment type="block">/* restore savedpc */</comment>
  <comment type="block">/* move results to correct place */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>wanted</name></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>firstResult</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name><operator>++</operator></expr></argument>, <argument><expr><name>firstResult</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>res</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>wanted</name> <operator>-</operator> <name>LUA_MULTRET</name><operator>)</operator></expr>;</return>  <comment type="block">/* 0 iff wanted == LUA_MULTRET */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/</comment> 
<function><type><name>void</name></type> <name>luaD_call</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nResults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>&gt;=</operator> <name>LUAI_MAXCCALLS</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>==</operator> <name>LUAI_MAXCCALLS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"C stack overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>&gt;=</operator> <operator>(</operator><name>LUAI_MAXCCALLS</name> <operator>+</operator> <operator>(</operator><name>LUAI_MAXCCALLS</name><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* error while handing stack error */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>luaD_precall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>nResults</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PCRLUA</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is a Lua function? */</comment>
    <expr_stmt><expr><call><name>luaV_execute</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* call it */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>resume</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>StkId</name></type> <name>firstArg</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr><name>StkId</name></expr></argument>, <argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* start coroutine? */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>ci</name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name> <operator>&amp;&amp;</operator> <name>firstArg</name> <operator>&gt;</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luaD_precall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>firstArg</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PCRLUA</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* resuming from previous yield */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>f_isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* `common' yield? */</comment>
      <comment type="block">/* finish interrupted execution of `OP_CALL' */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ci</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>savedpc</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_CALL</name> <operator>||</operator>
                 <call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ci</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>savedpc</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>firstArg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* complete it... */</comment>
        <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* and correct top if not multiple results */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* yielded inside a hook: just continue its execution */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>luaV_execute</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>resume_error</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>LUA_ERRRUN</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_resume</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>LUA_YIELD</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>!=</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>resume_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot resume non-suspended coroutine"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>&gt;=</operator> <name>LUAI_MAXCCALLS</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>resume_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"C stack overflow"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>luai_userstateresume</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name> <operator>=</operator> <operator>++</operator><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>resume</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* error? */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mark thread as `dead' */</comment>
    <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>--</operator><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_yield</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luai_userstateyield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>&gt;</operator> <name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"attempt to yield across metamethod/C-call boundary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>nresults</name></expr>;</expr_stmt>  <comment type="block">/* protect stack slots below */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>LUA_YIELD</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaD_pcall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Pfunc</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>,
                <parameter><decl><type><name>ptrdiff_t</name></type> <name>old_top</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>ef</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>oldnCcalls</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>old_ci</name> <init>= <expr><call><name>saveci</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>old_allowhooks</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>old_errfunc</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <name>ef</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* an error occurred? */</comment>
    <decl_stmt><decl><type><name>StkId</name></type> <name>oldtop</name> <init>= <expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close eventual pending closures */</comment>
    <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>=</operator> <name>oldnCcalls</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <call><name>restoreci</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>old_ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <name>old_allowhooks</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>restore_stack_limit</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <name>old_errfunc</name></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** Execute a protected parser.
*/</comment>
<struct>struct <name>SParser</name> <block>{  <comment type="block">/* data to `f_parser' */</comment>
  <decl_stmt><decl><type><name>ZIO</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mbuffer</name></type> <name>buff</name></decl>;</decl_stmt>  <comment type="block">/* buffer to be used by the scanner */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>f_parser</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>tf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Closure</name> <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SParser</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr>struct <name>SParser</name> <operator>*</operator></expr></argument>, <argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>luaZ_lookahead</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tf</name> <operator>=</operator> <operator>(</operator><name>luaY_parser</name><operator>)</operator><operator>(</operator><name>L</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>,</operator>
                                                             <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>buff</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>luaF_newLclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>, <argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>tf</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tf</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* initialize eventual upvalues */</comment>
    <expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>luaF_newupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>setclvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaD_protectedparser</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ZIO</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>SParser</name></name></type> <name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaZ_initbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaZ_freebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


</unit>
